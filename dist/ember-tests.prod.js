(function() {
/*!
 * @overview  Ember - JavaScript Application Framework
 * @copyright Copyright 2011-2018 Tilde Inc. and contributors
 *            Portions Copyright 2006-2011 Strobe Inc.
 *            Portions Copyright 2008-2011 Apple Inc. All rights reserved.
 * @license   Licensed under MIT license
 *            See https://raw.github.com/emberjs/ember.js/master/LICENSE
 * @version   3.8.0
 */

/*globals process */
var enifed, requireModule, Ember;

// Used in @ember/-internals/environment/lib/global.js
mainContext = this; // eslint-disable-line no-undef

(function() {
  function missingModule(name, referrerName) {
    if (referrerName) {
      throw new Error('Could not find module ' + name + ' required by: ' + referrerName);
    } else {
      throw new Error('Could not find module ' + name);
    }
  }

  function internalRequire(_name, referrerName) {
    var name = _name;
    var mod = registry[name];

    if (!mod) {
      name = name + '/index';
      mod = registry[name];
    }

    var exports = seen[name];

    if (exports !== undefined) {
      return exports;
    }

    exports = seen[name] = {};

    if (!mod) {
      missingModule(_name, referrerName);
    }

    var deps = mod.deps;
    var callback = mod.callback;
    var reified = new Array(deps.length);

    for (var i = 0; i < deps.length; i++) {
      if (deps[i] === 'exports') {
        reified[i] = exports;
      } else if (deps[i] === 'require') {
        reified[i] = requireModule;
      } else {
        reified[i] = internalRequire(deps[i], name);
      }
    }

    callback.apply(this, reified);

    return exports;
  }

  var isNode =
    typeof window === 'undefined' &&
    typeof process !== 'undefined' &&
    {}.toString.call(process) === '[object process]';

  if (!isNode) {
    Ember = this.Ember = this.Ember || {};
  }

  if (typeof Ember === 'undefined') {
    Ember = {};
  }

  if (typeof Ember.__loader === 'undefined') {
    var registry = Object.create(null);
    var seen = Object.create(null);

    enifed = function(name, deps, callback) {
      var value = {};

      if (!callback) {
        value.deps = [];
        value.callback = deps;
      } else {
        value.deps = deps;
        value.callback = callback;
      }

      registry[name] = value;
    };

    requireModule = function(name) {
      return internalRequire(name, null);
    };

    // setup `require` module
    requireModule['default'] = requireModule;

    requireModule.has = function registryHas(moduleName) {
      return Boolean(registry[moduleName]) || Boolean(registry[moduleName + '/index']);
    };

    requireModule._eak_seen = registry;

    Ember.__loader = {
      define: enifed,
      require: requireModule,
      registry: registry,
    };
  } else {
    enifed = Ember.__loader.define;
    requireModule = Ember.__loader.require;
  }
})();

enifed("@ember/application/tests/application_instance_test", ["ember-babel", "@ember/engine", "@ember/application", "@ember/application/instance", "@ember/runloop", "@ember/-internals/container", "internal-test-helpers", "@ember/-internals/runtime", "@ember/debug"], function (_emberBabel, _engine, _application, _instance, _runloop, _container, _internalTestHelpers, _runtime, _debug) {
  "use strict";

  function _templateObject() {
    var data = (0, _emberBabel.taggedTemplateLiteralLoose)(["-bucket-cache:main"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  var originalDebug = (0, _debug.getDebugFunction)('debug');

  var noop = function () {};

  var application, appInstance;
  (0, _internalTestHelpers.moduleFor)('ApplicationInstance',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      var _this;

      (0, _debug.setDebugFunction)('debug', noop);
      _this = _TestCase.call(this) || this;
      document.getElementById('qunit-fixture').innerHTML = "\n      <div id='one'><div id='one-child'>HI</div></div><div id='two'>HI</div>\n    ";
      application = (0, _runloop.run)(function () {
        return _application.default.create({
          rootElement: '#one',
          router: null
        });
      });
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _debug.setDebugFunction)('debug', originalDebug);

      if (appInstance) {
        (0, _runloop.run)(appInstance, 'destroy');
        appInstance = null;
      }

      if (application) {
        (0, _runloop.run)(application, 'destroy');
        application = null;
      }

      document.getElementById('qunit-fixture').innerHTML = '';
    };

    _proto['@test an application instance can be created based upon an application'] = function testAnApplicationInstanceCanBeCreatedBasedUponAnApplication(assert) {
      appInstance = (0, _runloop.run)(function () {
        return _instance.default.create({
          application: application
        });
      });
      assert.ok(appInstance, 'instance should be created');
      assert.equal(appInstance.application, application, 'application should be set to parent');
    };

    _proto['@test customEvents added to the application before setupEventDispatcher'] = function testCustomEventsAddedToTheApplicationBeforeSetupEventDispatcher(assert) {
      assert.expect(1);
      appInstance = (0, _runloop.run)(function () {
        return _instance.default.create({
          application: application
        });
      });
      appInstance.setupRegistry();
      application.customEvents = {
        awesome: 'sauce'
      };
      var eventDispatcher = appInstance.lookup('event_dispatcher:main');

      eventDispatcher.setup = function (events) {
        assert.equal(events.awesome, 'sauce');
      };

      appInstance.setupEventDispatcher();
    };

    _proto['@test customEvents added to the application before setupEventDispatcher'] = function testCustomEventsAddedToTheApplicationBeforeSetupEventDispatcher(assert) {
      assert.expect(1);
      appInstance = (0, _runloop.run)(function () {
        return _instance.default.create({
          application: application
        });
      });
      appInstance.setupRegistry();
      application.customEvents = {
        awesome: 'sauce'
      };
      var eventDispatcher = appInstance.lookup('event_dispatcher:main');

      eventDispatcher.setup = function (events) {
        assert.equal(events.awesome, 'sauce');
      };

      appInstance.setupEventDispatcher();
    };

    _proto['@test customEvents added to the application instance before setupEventDispatcher'] = function testCustomEventsAddedToTheApplicationInstanceBeforeSetupEventDispatcher(assert) {
      assert.expect(1);
      appInstance = (0, _runloop.run)(function () {
        return _instance.default.create({
          application: application
        });
      });
      appInstance.setupRegistry();
      appInstance.customEvents = {
        awesome: 'sauce'
      };
      var eventDispatcher = appInstance.lookup('event_dispatcher:main');

      eventDispatcher.setup = function (events) {
        assert.equal(events.awesome, 'sauce');
      };

      appInstance.setupEventDispatcher();
    };

    _proto['@test unregistering a factory clears all cached instances of that factory'] = function testUnregisteringAFactoryClearsAllCachedInstancesOfThatFactory(assert) {
      assert.expect(5);
      appInstance = (0, _runloop.run)(function () {
        return _instance.default.create({
          application: application
        });
      });
      var PostController1 = (0, _internalTestHelpers.factory)();
      var PostController2 = (0, _internalTestHelpers.factory)();
      appInstance.register('controller:post', PostController1);
      var postController1 = appInstance.lookup('controller:post');
      var postController1Factory = appInstance.factoryFor('controller:post');
      assert.ok(postController1 instanceof PostController1, 'precond - lookup creates instance');
      assert.equal(PostController1, postController1Factory.class, 'precond - factoryFor().class matches');
      appInstance.unregister('controller:post');
      appInstance.register('controller:post', PostController2);
      var postController2 = appInstance.lookup('controller:post');
      var postController2Factory = appInstance.factoryFor('controller:post');
      assert.ok(postController2 instanceof PostController2, 'lookup creates instance');
      assert.equal(PostController2, postController2Factory.class, 'factoryFor().class matches');
      assert.notStrictEqual(postController1, postController2, 'lookup creates a brand new instance, because the previous one was reset');
    };

    _proto['@skip unregistering a factory clears caches with source of that factory'] = function skipUnregisteringAFactoryClearsCachesWithSourceOfThatFactory(assert) {
      assert.expect(1);
      appInstance = (0, _runloop.run)(function () {
        return _instance.default.create({
          application: application
        });
      });
      var PostController1 = (0, _internalTestHelpers.factory)();
      var PostController2 = (0, _internalTestHelpers.factory)();
      appInstance.register('controller:post', PostController1);
      appInstance.lookup('controller:post');
      var postControllerLookupWithSource = appInstance.lookup('controller:post', {
        source: 'doesnt-even-matter'
      });
      appInstance.unregister('controller:post');
      appInstance.register('controller:post', PostController2); // The cache that is source-specific is not cleared

      assert.ok(postControllerLookupWithSource !== appInstance.lookup('controller:post', {
        source: 'doesnt-even-matter'
      }), 'lookup with source creates a new instance');
    };

    _proto['@test can build and boot a registered engine'] = function testCanBuildAndBootARegisteredEngine(assert) {
      assert.expect(11);

      var ChatEngine = _engine.default.extend();

      var chatEngineInstance;
      application.register('engine:chat', ChatEngine);
      (0, _runloop.run)(function () {
        appInstance = _instance.default.create({
          application: application
        });
        appInstance.setupRegistry();
        chatEngineInstance = appInstance.buildChildEngineInstance('chat');
      });
      return chatEngineInstance.boot().then(function () {
        assert.ok(true, 'boot successful');
        var registrations = ['route:basic', 'service:-routing', 'service:-glimmer-environment'];
        registrations.forEach(function (key) {
          assert.strictEqual(chatEngineInstance.resolveRegistration(key), appInstance.resolveRegistration(key), "Engine and parent app share registrations for '" + key + "'");
        });
        var singletons = ['router:main', (0, _container.privatize)(_templateObject()), '-view-registry:main', '-environment:main', 'service:-document', 'event_dispatcher:main'];
        var env = appInstance.lookup('-environment:main');
        singletons.push(env.isInteractive ? 'renderer:-dom' : 'renderer:-inert');
        singletons.forEach(function (key) {
          assert.strictEqual(chatEngineInstance.lookup(key), appInstance.lookup(key), "Engine and parent app share singleton '" + key + "'");
        });
      });
    };

    _proto['@test can build a registry via ApplicationInstance.setupRegistry() -- simulates ember-test-helpers'] = function testCanBuildARegistryViaApplicationInstanceSetupRegistrySimulatesEmberTestHelpers(assert) {
      var namespace = _runtime.Object.create({
        Resolver: {
          create: function () {}
        }
      });

      var registry = _application.default.buildRegistry(namespace);

      _instance.default.setupRegistry(registry);

      assert.equal(registry.resolve('service:-document'), document);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/application/tests/application_test", ["ember-babel", "ember/version", "@ember/-internals/environment", "@ember/-internals/metal", "@ember/debug", "@ember/application", "@ember/-internals/routing", "@ember/-internals/views", "@ember/controller", "@ember/-internals/runtime", "@ember/-internals/glimmer", "@ember/-internals/container", "@ember/polyfills", "internal-test-helpers", "@ember/runloop"], function (_emberBabel, _version, _environment, _metal, _debug, _application, _routing, _views, _controller, _runtime, _glimmer, _container, _polyfills, _internalTestHelpers, _runloop) {
  "use strict";

  function _templateObject5() {
    var data = (0, _emberBabel.taggedTemplateLiteralLoose)(["template-compiler:main"]);

    _templateObject5 = function () {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    var data = (0, _emberBabel.taggedTemplateLiteralLoose)(["template:components/-default"]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    var data = (0, _emberBabel.taggedTemplateLiteralLoose)(["-bucket-cache:main"]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    var data = (0, _emberBabel.taggedTemplateLiteralLoose)(["-bucket-cache:main"]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    var data = (0, _emberBabel.taggedTemplateLiteralLoose)(["-bucket-cache:main"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }
  /*globals EmberDev */


  (0, _internalTestHelpers.moduleFor)('Application, autobooting multiple apps',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.createSecondApplication = function createSecondApplication(options) {
      var myOptions = (0, _polyfills.assign)(this.applicationOptions, options);
      return this.secondApp = _application.default.create(myOptions);
    };

    _proto.teardown = function teardown() {
      var _this = this;

      _ApplicationTestCase.prototype.teardown.call(this);

      if (this.secondApp) {
        (0, _internalTestHelpers.runTask)(function () {
          return _this.secondApp.destroy();
        });
      }
    };

    _proto["@test you can make a new application in a non-overlapping element"] = function (assert) {
      var _this2 = this;

      var app = (0, _internalTestHelpers.runTask)(function () {
        return _this2.createSecondApplication({
          rootElement: '#two'
        });
      });
      (0, _internalTestHelpers.runTask)(function () {
        return app.destroy();
      });
      assert.ok(true, 'should not raise');
    };

    _proto["@test you cannot make a new application that is a parent of an existing application"] = function () {
      var _this3 = this;

      expectAssertion(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this3.createSecondApplication({
            rootElement: _this3.applicationOptions.rootElement
          });
        });
      });
    };

    _proto["@test you cannot make a new application that is a descendant of an existing application"] = function () {
      var _this4 = this;

      expectAssertion(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this4.createSecondApplication({
            rootElement: '#one-child'
          });
        });
      });
    };

    _proto["@test you cannot make a new application that is a duplicate of an existing application"] = function () {
      var _this5 = this;

      expectAssertion(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this5.createSecondApplication({
            rootElement: '#one'
          });
        });
      });
    };

    _proto["@test you cannot make two default applications without a rootElement error"] = function () {
      var _this6 = this;

      expectAssertion(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this6.createSecondApplication();
        });
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "fixture",
      get: function () {
        return "\n      <div id=\"one\">\n        <div id=\"one-child\">HI</div>\n      </div>\n      <div id=\"two\">HI</div>\n    ";
      }
    }, {
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_ApplicationTestCase.prototype.applicationOptions, {
          rootElement: '#one',
          router: null,
          autoboot: true
        });
      }
    }]);
    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application',
  /*#__PURE__*/
  function (_ApplicationTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase2);

    function _class2() {
      return _ApplicationTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2["@test builds a registry"] = function (assert) {
      var application = this.application;
      assert.strictEqual(application.resolveRegistration('application:main'), application, "application:main is registered");
      assert.deepEqual(application.registeredOptionsForType('component'), {
        singleton: false
      }, "optionsForType 'component'");
      assert.deepEqual(application.registeredOptionsForType('view'), {
        singleton: false
      }, "optionsForType 'view'");
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'controller:basic');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, '-view-registry:main');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'view', '_viewRegistry', '-view-registry:main');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'route', '_topLevelViewTemplate', 'template:-outlet');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'route:basic');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'event_dispatcher:main');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'router:main', 'namespace', 'application:main');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'view:-outlet', 'namespace', 'application:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'location:auto');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'location:hash');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'location:history');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'location:none');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'controller', 'target', 'router:main');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'controller', 'namespace', 'application:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, (0, _container.privatize)(_templateObject()));
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'router', '_bucketCache', (0, _container.privatize)(_templateObject2()));
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'route', '_bucketCache', (0, _container.privatize)(_templateObject3()));
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'route', '_router', 'router:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'component:-text-field');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'component:-text-area');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'component:-checkbox');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'component:link-to');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'service:-routing');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'service:-routing', 'router', 'router:main'); // DEBUGGING

      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'resolver-for-debugging:main');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'container-debug-adapter:main', 'resolver', 'resolver-for-debugging:main');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'data-adapter:main', 'containerDebugAdapter', 'container-debug-adapter:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'container-debug-adapter:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'component-lookup:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'service:-glimmer-environment');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'service:-dom-changes');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'service:-dom-tree-construction');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'service:-glimmer-environment', 'appendOperations', 'service:-dom-tree-construction');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'service:-glimmer-environment', 'updateOperations', 'service:-dom-changes');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'renderer', 'env', 'service:-glimmer-environment');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'view:-outlet');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'renderer:-dom');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'renderer:-inert');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, (0, _container.privatize)(_templateObject4()));
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'template:-outlet');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'view:-outlet', 'template', 'template:-outlet');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'template', 'compiler', (0, _container.privatize)(_templateObject5()));
      assert.deepEqual(application.registeredOptionsForType('helper'), {
        instantiate: false
      }, "optionsForType 'helper'");
    };

    return _class2;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application, default resolver with autoboot',
  /*#__PURE__*/
  function (_DefaultResolverAppli) {
    (0, _emberBabel.inheritsLoose)(_class3, _DefaultResolverAppli);

    function _class3() {
      var _this7;

      _this7 = _DefaultResolverAppli.apply(this, arguments) || this;
      _this7.originalLookup = _environment.context.lookup;
      return _this7;
    }

    var _proto3 = _class3.prototype;

    _proto3.teardown = function teardown() {
      _environment.context.lookup = this.originalLookup;

      _DefaultResolverAppli.prototype.teardown.call(this);

      (0, _glimmer.setTemplates)({});
    };

    _proto3["@test acts like a namespace"] = function (assert) {
      var _this8 = this;

      this.application = (0, _internalTestHelpers.runTask)(function () {
        return _this8.createApplication();
      });

      var Foo = this.application.Foo = _runtime.Object.extend();

      assert.equal(Foo.toString(), 'TestApp.Foo', 'Classes pick up their parent namespace');
    };

    _proto3["@test can specify custom router"] = function (assert) {
      var _this9 = this;

      var MyRouter = _routing.Router.extend();

      (0, _internalTestHelpers.runTask)(function () {
        _this9.createApplication();

        _this9.application.Router = MyRouter;
      });
      assert.ok(this.application.__deprecatedInstance__.lookup('router:main') instanceof MyRouter, 'application resolved the correct router');
    };

    _proto3["@test Minimal Application initialized with just an application template"] = function () {
      var _this10 = this;

      this.setupFixture('<script type="text/x-handlebars">Hello World</script>');
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.createApplication();
      });
      this.assertInnerHTML('Hello World');
    };

    (0, _emberBabel.createClass)(_class3, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_DefaultResolverAppli.prototype.applicationOptions, {
          autoboot: true
        });
      }
    }]);
    return _class3;
  }(_internalTestHelpers.DefaultResolverApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application, autobooting',
  /*#__PURE__*/
  function (_AutobootApplicationT) {
    (0, _emberBabel.inheritsLoose)(_class4, _AutobootApplicationT);

    function _class4() {
      var _this11;

      _this11 = _AutobootApplicationT.apply(this, arguments) || this;
      _this11.originalLogVersion = _environment.ENV.LOG_VERSION;
      _this11.originalDebug = (0, _debug.getDebugFunction)('debug');
      _this11.originalWarn = (0, _debug.getDebugFunction)('warn');
      return _this11;
    }

    var _proto4 = _class4.prototype;

    _proto4.teardown = function teardown() {
      (0, _debug.setDebugFunction)('warn', this.originalWarn);
      (0, _debug.setDebugFunction)('debug', this.originalDebug);
      _environment.ENV.LOG_VERSION = this.originalLogVersion;

      _AutobootApplicationT.prototype.teardown.call(this);
    };

    _proto4["@test initialized application goes to initial route"] = function () {
      var _this12 = this;

      (0, _internalTestHelpers.runTask)(function () {
        _this12.createApplication();

        _this12.addTemplate('application', '{{outlet}}');

        _this12.addTemplate('index', '<h1>Hi from index</h1>');
      });
      this.assertText('Hi from index');
    };

    _proto4["@test ready hook is called before routing begins"] = function (assert) {
      var _this13 = this;

      assert.expect(2);
      (0, _internalTestHelpers.runTask)(function () {
        function registerRoute(application, name, callback) {
          var route = _routing.Route.extend({
            activate: callback
          });

          application.register('route:' + name, route);
        }

        var MyApplication = _application.default.extend({
          ready: function () {
            registerRoute(this, 'index', function () {
              assert.ok(true, 'last-minute route is activated');
            });
          }
        });

        var app = _this13.createApplication({}, MyApplication);

        registerRoute(app, 'application', function () {
          return assert.ok(true, 'normal route is activated');
        });
      });
    };

    _proto4["@test initialize application via initialize call"] = function (assert) {
      var _this14 = this;

      (0, _internalTestHelpers.runTask)(function () {
        return _this14.createApplication();
      }); // This is not a public way to access the container; we just
      // need to make some assertions about the created router

      var router = this.applicationInstance.lookup('router:main');
      assert.equal(router instanceof _routing.Router, true, 'Router was set from initialize call');
      assert.equal(router.location instanceof _routing.NoneLocation, true, 'Location was set from location implementation name');
    };

    _proto4["@test initialize application with stateManager via initialize call from Router class"] = function (assert) {
      var _this15 = this;

      (0, _internalTestHelpers.runTask)(function () {
        _this15.createApplication();

        _this15.addTemplate('application', '<h1>Hello!</h1>');
      }); // This is not a public way to access the container; we just
      // need to make some assertions about the created router

      var router = this.application.__deprecatedInstance__.lookup('router:main');

      assert.equal(router instanceof _routing.Router, true, 'Router was set from initialize call');
      this.assertText('Hello!');
    };

    _proto4["@test Application Controller backs the appplication template"] = function () {
      var _this16 = this;

      (0, _internalTestHelpers.runTask)(function () {
        _this16.createApplication();

        _this16.addTemplate('application', '<h1>{{greeting}}</h1>');

        _this16.add('controller:application', _controller.default.extend({
          greeting: 'Hello!'
        }));
      });
      this.assertText('Hello!');
    };

    _proto4["@test enable log of libraries with an ENV var"] = function (assert) {
      var _this17 = this;

      if (EmberDev && EmberDev.runningProdBuild) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }

      var messages = [];
      _environment.ENV.LOG_VERSION = true;
      (0, _debug.setDebugFunction)('debug', function (message) {
        return messages.push(message);
      });

      _metal.libraries.register('my-lib', '2.0.0a');

      (0, _internalTestHelpers.runTask)(function () {
        return _this17.createApplication();
      });
      assert.equal(messages[1], 'Ember  : ' + _version.default);

      if (_views.jQueryDisabled) {
        assert.equal(messages[2], 'my-lib : ' + '2.0.0a');
      } else {
        assert.equal(messages[2], 'jQuery : ' + (0, _views.jQuery)().jquery);
        assert.equal(messages[3], 'my-lib : ' + '2.0.0a');
      }

      _metal.libraries.deRegister('my-lib');
    };

    _proto4["@test disable log of version of libraries with an ENV var"] = function (assert) {
      var _this18 = this;

      var logged = false;
      _environment.ENV.LOG_VERSION = false;
      (0, _debug.setDebugFunction)('debug', function () {
        return logged = true;
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.createApplication();
      });
      assert.ok(!logged, 'library version logging skipped');
    };

    _proto4["@test can resolve custom router"] = function (assert) {
      var _this19 = this;

      var CustomRouter = _routing.Router.extend();

      (0, _internalTestHelpers.runTask)(function () {
        _this19.createApplication();

        _this19.add('router:main', CustomRouter);
      });
      assert.ok(this.application.__deprecatedInstance__.lookup('router:main') instanceof CustomRouter, 'application resolved the correct router');
    };

    _proto4["@test does not leak itself in onLoad._loaded"] = function (assert) {
      var _this20 = this;

      assert.equal(_application._loaded.application, undefined);
      (0, _internalTestHelpers.runTask)(function () {
        return _this20.createApplication();
      });
      assert.equal(_application._loaded.application, this.application);
      (0, _internalTestHelpers.runTask)(function () {
        return _this20.application.destroy();
      });
      assert.equal(_application._loaded.application, undefined);
    };

    _proto4["@test can build a registry via Application.buildRegistry() --- simulates ember-test-helpers"] = function (assert) {
      var namespace = _runtime.Object.create({
        Resolver: {
          create: function () {}
        }
      });

      var registry = _application.default.buildRegistry(namespace);

      assert.equal(registry.resolve('application:main'), namespace);
    };

    return _class4;
  }(_internalTestHelpers.AutobootApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application#buildRegistry',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class5, _AbstractTestCase);

    function _class5() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto5 = _class5.prototype;

    _proto5["@test can build a registry via Application.buildRegistry() --- simulates ember-test-helpers"] = function (assert) {
      var namespace = _runtime.Object.create({
        Resolver: {
          create: function () {}
        }
      });

      var registry = _application.default.buildRegistry(namespace);

      assert.equal(registry.resolve('application:main'), namespace);
    };

    return _class5;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Application - instance tracking',
  /*#__PURE__*/
  function (_ApplicationTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class6, _ApplicationTestCase3);

    function _class6() {
      return _ApplicationTestCase3.apply(this, arguments) || this;
    }

    var _proto6 = _class6.prototype;

    _proto6['@test tracks built instance'] = function testTracksBuiltInstance(assert) {
      var _this21 = this;

      var instance = this.application.buildInstance();
      (0, _runloop.run)(function () {
        _this21.application.destroy();
      });
      assert.ok(instance.isDestroyed, 'instance was destroyed');
    };

    _proto6['@test tracks built instances'] = function testTracksBuiltInstances(assert) {
      var _this22 = this;

      var instanceA = this.application.buildInstance();
      var instanceB = this.application.buildInstance();
      (0, _runloop.run)(function () {
        _this22.application.destroy();
      });
      assert.ok(instanceA.isDestroyed, 'instanceA was destroyed');
      assert.ok(instanceB.isDestroyed, 'instanceB was destroyed');
    };

    return _class6;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/application/tests/bootstrap-test", ["ember-babel", "@ember/polyfills", "internal-test-helpers"], function (_emberBabel, _polyfills, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application with default resolver and autoboot',
  /*#__PURE__*/
  function (_DefaultResolverAppli) {
    (0, _emberBabel.inheritsLoose)(_class, _DefaultResolverAppli);

    function _class() {
      return _DefaultResolverAppli.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test templates in script tags are extracted at application creation'] = function testTemplatesInScriptTagsAreExtractedAtApplicationCreation(assert) {
      var _this = this;

      (0, _internalTestHelpers.runTask)(function () {
        return _this.createApplication();
      });
      assert.equal(document.getElementById('app').textContent, 'Hello World!');
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "fixture",
      get: function () {
        return "\n      <div id=\"app\"></div>\n\n      <script type=\"text/x-handlebars\">Hello {{outlet}}</script>\n      <script type=\"text/x-handlebars\" id=\"index\">World!</script>\n    ";
      }
    }, {
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_DefaultResolverAppli.prototype.applicationOptions, {
          autoboot: true,
          rootElement: '#app'
        });
      }
    }]);
    return _class;
  }(_internalTestHelpers.DefaultResolverApplicationTestCase));
});
enifed("@ember/application/tests/dependency_injection/custom_resolver_test", ["ember-babel", "@ember/application/globals-resolver", "@ember/polyfills", "internal-test-helpers"], function (_emberBabel, _globalsResolver, _polyfills, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application with extended default resolver and autoboot',
  /*#__PURE__*/
  function (_DefaultResolverAppli) {
    (0, _emberBabel.inheritsLoose)(_class, _DefaultResolverAppli);

    function _class() {
      return _DefaultResolverAppli.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto["@test a resolver can be supplied to application"] = function () {
      var _this = this;

      (0, _internalTestHelpers.runTask)(function () {
        return _this.createApplication();
      });
      this.assertText('Fallback');
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "applicationOptions",
      get: function () {
        var applicationTemplate = this.compile("<h1>Fallback</h1>");

        var Resolver = _globalsResolver.default.extend({
          resolveTemplate: function (resolvable) {
            if (resolvable.fullNameWithoutType === 'application') {
              return applicationTemplate;
            } else {
              return this._super(resolvable);
            }
          }
        });

        return (0, _polyfills.assign)(_DefaultResolverAppli.prototype.applicationOptions, {
          Resolver: Resolver,
          autoboot: true
        });
      }
    }]);
    return _class;
  }(_internalTestHelpers.DefaultResolverApplicationTestCase));
});
enifed("@ember/application/tests/dependency_injection/default_resolver_test", ["ember-babel", "internal-test-helpers", "@ember/-internals/environment", "@ember/controller", "@ember/service", "@ember/-internals/runtime", "@ember/-internals/routing", "@ember/-internals/glimmer", "@ember/debug"], function (_emberBabel, _internalTestHelpers, _environment, _controller, _service, _runtime, _routing, _glimmer, _debug) {
  "use strict";

  /* globals EmberDev */
  (0, _internalTestHelpers.moduleFor)('Application Dependency Injection - Integration - default resolver',
  /*#__PURE__*/
  function (_DefaultResolverAppli) {
    (0, _emberBabel.inheritsLoose)(_class, _DefaultResolverAppli);

    function _class() {
      return _DefaultResolverAppli.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      var _this = this;

      (0, _internalTestHelpers.runTask)(function () {
        return _this.createApplication();
      });
      return this.visit('/');
    };
    /*
     * This first batch of tests are integration tests against the public
     * applicationInstance API.
     */


    _proto["@test the default resolver looks up templates in Ember.TEMPLATES"] = function (assert) {
      var fooTemplate = this.addTemplate('foo', "foo template");
      var fooBarTemplate = this.addTemplate('fooBar', "fooBar template");
      var fooBarBazTemplate = this.addTemplate('fooBar/baz', "fooBar/baz template");
      assert.equal(this.applicationInstance.factoryFor('template:foo').class, fooTemplate, 'resolves template:foo');
      assert.equal(this.applicationInstance.factoryFor('template:fooBar').class, fooBarTemplate, 'resolves template:foo_bar');
      assert.equal(this.applicationInstance.factoryFor('template:fooBar.baz').class, fooBarBazTemplate, 'resolves template:foo_bar.baz');
    };

    _proto["@test the default resolver looks up basic name as no prefix"] = function (assert) {
      var instance = this.applicationInstance.lookup('controller:basic');
      assert.ok(_controller.default.detect(instance), 'locator looks up correct controller');
    };

    _proto["@test the default resolver looks up arbitrary types on the namespace"] = function (assert) {
      var Class = this.application.FooManager = _runtime.Object.extend();

      var resolvedClass = this.application.resolveRegistration('manager:foo');
      assert.equal(Class, resolvedClass, 'looks up FooManager on application');
    };

    _proto["@test the default resolver resolves models on the namespace"] = function (assert) {
      var Class = this.application.Post = _runtime.Object.extend();

      var factoryClass = this.applicationInstance.factoryFor('model:post').class;
      assert.equal(Class, factoryClass, 'looks up Post model on application');
    };

    _proto["@test the default resolver resolves *:main on the namespace"] = function (assert) {
      var Class = this.application.FooBar = _runtime.Object.extend();

      var factoryClass = this.applicationInstance.factoryFor('foo-bar:main').class;
      assert.equal(Class, factoryClass, 'looks up FooBar type without name on application');
    };

    _proto["@test the default resolver resolves container-registered helpers"] = function (assert) {
      var shorthandHelper = (0, _glimmer.helper)(function () {});

      var helper = _glimmer.Helper.extend();

      this.application.register('helper:shorthand', shorthandHelper);
      this.application.register('helper:complete', helper);
      var lookedUpShorthandHelper = this.applicationInstance.factoryFor('helper:shorthand').class;
      assert.ok(lookedUpShorthandHelper.isHelperFactory, 'shorthand helper isHelper');
      var lookedUpHelper = this.applicationInstance.factoryFor('helper:complete').class;
      assert.ok(lookedUpHelper.isHelperFactory, 'complete helper is factory');
      assert.ok(helper.detect(lookedUpHelper), 'looked up complete helper');
    };

    _proto["@test the default resolver resolves container-registered helpers via lookupFor"] = function (assert) {
      var shorthandHelper = (0, _glimmer.helper)(function () {});

      var helper = _glimmer.Helper.extend();

      this.application.register('helper:shorthand', shorthandHelper);
      this.application.register('helper:complete', helper);
      var lookedUpShorthandHelper = this.applicationInstance.factoryFor('helper:shorthand').class;
      assert.ok(lookedUpShorthandHelper.isHelperFactory, 'shorthand helper isHelper');
      var lookedUpHelper = this.applicationInstance.factoryFor('helper:complete').class;
      assert.ok(lookedUpHelper.isHelperFactory, 'complete helper is factory');
      assert.ok(helper.detect(lookedUpHelper), 'looked up complete helper');
    };

    _proto["@test the default resolver resolves helpers on the namespace"] = function (assert) {
      var ShorthandHelper = (0, _glimmer.helper)(function () {});

      var CompleteHelper = _glimmer.Helper.extend();

      this.application.ShorthandHelper = ShorthandHelper;
      this.application.CompleteHelper = CompleteHelper;
      var resolvedShorthand = this.application.resolveRegistration('helper:shorthand');
      var resolvedComplete = this.application.resolveRegistration('helper:complete');
      assert.equal(resolvedShorthand, ShorthandHelper, 'resolve fetches the shorthand helper factory');
      assert.equal(resolvedComplete, CompleteHelper, 'resolve fetches the complete helper factory');
    };

    _proto["@test the default resolver resolves to the same instance, no matter the notation "] = function (assert) {
      this.application.NestedPostController = _controller.default.extend({});
      assert.equal(this.applicationInstance.lookup('controller:nested-post'), this.applicationInstance.lookup('controller:nested_post'), 'looks up NestedPost controller on application');
    };

    _proto["@test the default resolver throws an error if the fullName to resolve is invalid"] = function () {
      var _this2 = this;

      expectAssertion(function () {
        _this2.applicationInstance.resolveRegistration(undefined);
      }, /fullName must be a proper full name/);
      expectAssertion(function () {
        _this2.applicationInstance.resolveRegistration(null);
      }, /fullName must be a proper full name/);
      expectAssertion(function () {
        _this2.applicationInstance.resolveRegistration('');
      }, /fullName must be a proper full name/);
      expectAssertion(function () {
        _this2.applicationInstance.resolveRegistration('');
      }, /fullName must be a proper full name/);
      expectAssertion(function () {
        _this2.applicationInstance.resolveRegistration(':');
      }, /fullName must be a proper full name/);
      expectAssertion(function () {
        _this2.applicationInstance.resolveRegistration('model');
      }, /fullName must be a proper full name/);
      expectAssertion(function () {
        _this2.applicationInstance.resolveRegistration('model:');
      }, /fullName must be a proper full name/);
      expectAssertion(function () {
        _this2.applicationInstance.resolveRegistration(':type');
      }, /fullName must be a proper full name/);
    }
    /*
     * The following are integration tests against the private registry API.
     */
    ;

    _proto["@test lookup description"] = function (assert) {
      this.application.toString = function () {
        return 'App';
      };

      assert.equal(this.privateRegistry.describe('controller:foo'), 'App.FooController', 'Type gets appended at the end');
      assert.equal(this.privateRegistry.describe('controller:foo.bar'), 'App.FooBarController', 'dots are removed');
      assert.equal(this.privateRegistry.describe('model:foo'), 'App.Foo', "models don't get appended at the end");
    };

    _proto["@test assertion for routes without isRouteFactory property"] = function () {
      var _this3 = this;

      this.application.FooRoute = _glimmer.Component.extend();
      expectAssertion(function () {
        _this3.privateRegistry.resolve("route:foo");
      }, /to resolve to an Ember.Route/, 'Should assert');
    };

    _proto["@test no assertion for routes that extend from Route"] = function (assert) {
      assert.expect(0);
      this.application.FooRoute = _routing.Route.extend();
      this.privateRegistry.resolve("route:foo");
    };

    _proto["@test deprecation warning for service factories without isServiceFactory property"] = function () {
      var _this4 = this;

      expectAssertion(function () {
        _this4.application.FooService = _runtime.Object.extend();

        _this4.privateRegistry.resolve('service:foo');
      }, /Expected service:foo to resolve to an Ember.Service but instead it was TestApp\.FooService\./);
    };

    _proto["@test no deprecation warning for service factories that extend from Service"] = function (assert) {
      assert.expect(0);
      this.application.FooService = _service.default.extend();
      this.privateRegistry.resolve('service:foo');
    };

    _proto["@test deprecation warning for component factories without isComponentFactory property"] = function () {
      var _this5 = this;

      expectAssertion(function () {
        _this5.application.FooComponent = _runtime.Object.extend();

        _this5.privateRegistry.resolve('component:foo');
      }, /Expected component:foo to resolve to an Ember\.Component but instead it was TestApp\.FooComponent\./);
    };

    _proto["@test no deprecation warning for component factories that extend from Component"] = function () {
      expectNoDeprecation();
      this.application.FooView = _glimmer.Component.extend();
      this.privateRegistry.resolve('component:foo');
    };

    _proto["@test knownForType returns each item for a given type found"] = function (assert) {
      this.application.FooBarHelper = 'foo';
      this.application.BazQuxHelper = 'bar';
      var found = this.privateRegistry.resolver.knownForType('helper');
      assert.deepEqual(found, {
        'helper:foo-bar': true,
        'helper:baz-qux': true
      });
    };

    _proto["@test knownForType is not required to be present on the resolver"] = function (assert) {
      delete this.privateRegistry.resolver.knownForType;
      this.privateRegistry.resolver.knownForType('helper', function () {});
      assert.ok(true, 'does not error');
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "privateRegistry",
      get: function () {
        return this.application.__registry__;
      }
    }]);
    return _class;
  }(_internalTestHelpers.DefaultResolverApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application Dependency Injection - Integration - default resolver w/ other namespace',
  /*#__PURE__*/
  function (_DefaultResolverAppli2) {
    (0, _emberBabel.inheritsLoose)(_class2, _DefaultResolverAppli2);

    function _class2() {
      return _DefaultResolverAppli2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2.beforeEach = function beforeEach() {
      var _this6 = this;

      this.UserInterface = _environment.context.lookup.UserInterface = _runtime.Namespace.create();
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.createApplication();
      });
      return this.visit('/');
    };

    _proto2.teardown = function teardown() {
      var UserInterfaceNamespace = _runtime.Namespace.NAMESPACES_BY_ID['UserInterface'];

      if (UserInterfaceNamespace) {
        (0, _internalTestHelpers.runTask)(function () {
          UserInterfaceNamespace.destroy();
        });
      }

      _DefaultResolverAppli2.prototype.teardown.call(this);
    };

    _proto2["@test the default resolver can look things up in other namespaces"] = function (assert) {
      this.UserInterface.NavigationController = _controller.default.extend();
      var nav = this.applicationInstance.lookup('controller:userInterface/navigation');
      assert.ok(nav instanceof this.UserInterface.NavigationController, 'the result should be an instance of the specified class');
    };

    return _class2;
  }(_internalTestHelpers.DefaultResolverApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application Dependency Injection - Integration - default resolver',
  /*#__PURE__*/
  function (_DefaultResolverAppli3) {
    (0, _emberBabel.inheritsLoose)(_class3, _DefaultResolverAppli3);

    function _class3() {
      var _this7;

      _this7 = _DefaultResolverAppli3.call(this) || this;
      _this7._originalLookup = _environment.context.lookup;
      _this7._originalInfo = (0, _debug.getDebugFunction)('info');
      return _this7;
    }

    var _proto3 = _class3.prototype;

    _proto3.beforeEach = function beforeEach() {
      var _this8 = this;

      (0, _internalTestHelpers.runTask)(function () {
        return _this8.createApplication();
      });
      return this.visit('/');
    };

    _proto3.teardown = function teardown() {
      (0, _debug.setDebugFunction)('info', this._originalInfo);
      _environment.context.lookup = this._originalLookup;

      _DefaultResolverAppli3.prototype.teardown.call(this);
    };

    _proto3["@test the default resolver logs hits if 'LOG_RESOLVER' is set"] = function (assert) {
      if (EmberDev && EmberDev.runningProdBuild) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }

      assert.expect(3);
      this.application.LOG_RESOLVER = true;
      this.application.ScoobyDoo = _runtime.Object.extend();

      this.application.toString = function () {
        return 'App';
      };

      (0, _debug.setDebugFunction)('info', function (symbol, name, padding, lookupDescription) {
        assert.equal(symbol, '[]', 'proper symbol is printed when a module is found');
        assert.equal(name, 'doo:scooby', 'proper lookup value is logged');
        assert.equal(lookupDescription, 'App.ScoobyDoo');
      });
      this.applicationInstance.resolveRegistration('doo:scooby');
    };

    _proto3["@test the default resolver logs misses if 'LOG_RESOLVER' is set"] = function (assert) {
      if (EmberDev && EmberDev.runningProdBuild) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }

      assert.expect(3);
      this.application.LOG_RESOLVER = true;

      this.application.toString = function () {
        return 'App';
      };

      (0, _debug.setDebugFunction)('info', function (symbol, name, padding, lookupDescription) {
        assert.equal(symbol, '[ ]', 'proper symbol is printed when a module is not found');
        assert.equal(name, 'doo:scooby', 'proper lookup value is logged');
        assert.equal(lookupDescription, 'App.ScoobyDoo');
      });
      this.applicationInstance.resolveRegistration('doo:scooby');
    };

    _proto3["@test doesn't log without LOG_RESOLVER"] = function (assert) {
      if (EmberDev && EmberDev.runningProdBuild) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }

      var infoCount = 0;
      this.application.ScoobyDoo = _runtime.Object.extend();
      (0, _debug.setDebugFunction)('info', function () {
        return infoCount = infoCount + 1;
      });
      this.applicationInstance.resolveRegistration('doo:scooby');
      this.applicationInstance.resolveRegistration('doo:scrappy');
      assert.equal(infoCount, 0, 'console.info should not be called if LOG_RESOLVER is not set');
    };

    return _class3;
  }(_internalTestHelpers.DefaultResolverApplicationTestCase));
});
enifed("@ember/application/tests/dependency_injection/normalization_test", ["ember-babel", "@ember/runloop", "@ember/application", "internal-test-helpers"], function (_emberBabel, _runloop, _application, _internalTestHelpers) {
  "use strict";

  var application, registry;
  (0, _internalTestHelpers.moduleFor)('Application Dependency Injection - normalize',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      var _this;

      _this = _TestCase.call(this) || this;
      application = (0, _runloop.run)(_application.default, 'create');
      registry = application.__registry__;
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _TestCase.prototype.teardown.call(this);

      (0, _runloop.run)(application, 'destroy');
      application = undefined;
      registry = undefined;
    };

    _proto['@test normalization'] = function testNormalization(assert) {
      assert.ok(registry.normalize, 'registry#normalize is present');
      assert.equal(registry.normalize('foo:bar'), 'foo:bar');
      assert.equal(registry.normalize('controller:posts'), 'controller:posts');
      assert.equal(registry.normalize('controller:posts_index'), 'controller:postsIndex');
      assert.equal(registry.normalize('controller:posts.index'), 'controller:postsIndex');
      assert.equal(registry.normalize('controller:posts-index'), 'controller:postsIndex');
      assert.equal(registry.normalize('controller:posts.post.index'), 'controller:postsPostIndex');
      assert.equal(registry.normalize('controller:posts_post.index'), 'controller:postsPostIndex');
      assert.equal(registry.normalize('controller:posts.post_index'), 'controller:postsPostIndex');
      assert.equal(registry.normalize('controller:posts.post-index'), 'controller:postsPostIndex');
      assert.equal(registry.normalize('controller:postsIndex'), 'controller:postsIndex');
      assert.equal(registry.normalize('controller:blogPosts.index'), 'controller:blogPostsIndex');
      assert.equal(registry.normalize('controller:blog/posts.index'), 'controller:blog/postsIndex');
      assert.equal(registry.normalize('controller:blog/posts-index'), 'controller:blog/postsIndex');
      assert.equal(registry.normalize('controller:blog/posts.post.index'), 'controller:blog/postsPostIndex');
      assert.equal(registry.normalize('controller:blog/posts_post.index'), 'controller:blog/postsPostIndex');
      assert.equal(registry.normalize('controller:blog/posts_post-index'), 'controller:blog/postsPostIndex');
      assert.equal(registry.normalize('template:blog/posts_index'), 'template:blog/posts_index');
    };

    _proto['@test normalization is indempotent'] = function testNormalizationIsIndempotent(assert) {
      var examples = ['controller:posts', 'controller:posts.post.index', 'controller:blog/posts.post_index', 'template:foo_bar'];
      examples.forEach(function (example) {
        assert.equal(registry.normalize(registry.normalize(example)), registry.normalize(example));
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/application/tests/dependency_injection/to_string_test", ["ember-babel", "@ember/polyfills", "@ember/-internals/utils", "@ember/-internals/runtime", "internal-test-helpers"], function (_emberBabel, _polyfills, _utils, _runtime, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application Dependency Injection - DefaultResolver#toString',
  /*#__PURE__*/
  function (_DefaultResolverAppli) {
    (0, _emberBabel.inheritsLoose)(_class, _DefaultResolverAppli);

    function _class() {
      var _this;

      _this = _DefaultResolverAppli.call(this) || this;
      (0, _internalTestHelpers.runTask)(function () {
        return _this.createApplication();
      });
      _this.application.Post = _runtime.Object.extend();
      return _this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      return this.visit('/');
    };

    _proto['@test factories'] = function testFactories(assert) {
      var PostFactory = this.applicationInstance.factoryFor('model:post').class;
      assert.equal(PostFactory.toString(), 'TestApp.Post', 'expecting the model to be post');
    };

    _proto['@test instances'] = function testInstances(assert) {
      var post = this.applicationInstance.lookup('model:post');
      var guid = (0, _utils.guidFor)(post);
      assert.equal(post.toString(), '<TestApp.Post:' + guid + '>', 'expecting the model to be post');
    };

    return _class;
  }(_internalTestHelpers.DefaultResolverApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application Dependency Injection - Resolver#toString',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase);

    function _class2() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2.beforeEach = function beforeEach() {
      return this.visit('/');
    };

    _proto2['@test toString called on a resolver'] = function testToStringCalledOnAResolver(assert) {
      this.add('model:peter', _runtime.Object.extend());
      var peter = this.applicationInstance.lookup('model:peter');
      var guid = (0, _utils.guidFor)(peter);
      assert.equal(peter.toString(), "<model:peter:" + guid + ">", 'expecting the supermodel to be peter');
    };

    (0, _emberBabel.createClass)(_class2, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_ApplicationTestCase.prototype.applicationOptions, {
          Resolver:
          /*#__PURE__*/
          function (_ModuleBasedTestResol) {
            (0, _emberBabel.inheritsLoose)(Resolver, _ModuleBasedTestResol);

            function Resolver() {
              return _ModuleBasedTestResol.apply(this, arguments) || this;
            }

            var _proto3 = Resolver.prototype;

            _proto3.makeToString = function makeToString(_, fullName) {
              return fullName;
            };

            return Resolver;
          }(_internalTestHelpers.ModuleBasedTestResolver)
        });
      }
    }]);
    return _class2;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/application/tests/dependency_injection_test", ["ember-babel", "@ember/-internals/environment", "@ember/runloop", "@ember/-internals/runtime", "@ember/application", "internal-test-helpers"], function (_emberBabel, _environment, _runloop, _runtime, _application, _internalTestHelpers) {
  "use strict";

  var originalLookup = _environment.context.lookup;
  var registry, locator, application;
  (0, _internalTestHelpers.moduleFor)('Application Dependency Injection',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      var _this;

      _this = _TestCase.call(this) || this;
      application = (0, _runloop.run)(_application.default, 'create');
      application.Person = _runtime.Object.extend({});
      application.Orange = _runtime.Object.extend({});
      application.Email = _runtime.Object.extend({});
      application.User = _runtime.Object.extend({});
      application.PostIndexController = _runtime.Object.extend({});
      application.register('model:person', application.Person, {
        singleton: false
      });
      application.register('model:user', application.User, {
        singleton: false
      });
      application.register('fruit:favorite', application.Orange);
      application.register('communication:main', application.Email, {
        singleton: false
      });
      application.register('controller:postIndex', application.PostIndexController, {
        singleton: true
      });
      registry = application.__registry__;
      locator = application.__container__;
      _environment.context.lookup = {};
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _TestCase.prototype.teardown.call(this);

      (0, _runloop.run)(application, 'destroy');
      registry = application = locator = null;
      _environment.context.lookup = originalLookup;
    };

    _proto['@test container lookup is normalized'] = function testContainerLookupIsNormalized(assert) {
      var dotNotationController = locator.lookup('controller:post.index');
      var camelCaseController = locator.lookup('controller:postIndex');
      assert.ok(dotNotationController instanceof application.PostIndexController);
      assert.ok(camelCaseController instanceof application.PostIndexController);
      assert.equal(dotNotationController, camelCaseController);
    };

    _proto['@test registered entities can be looked up later'] = function testRegisteredEntitiesCanBeLookedUpLater(assert) {
      assert.equal(registry.resolve('model:person'), application.Person);
      assert.equal(registry.resolve('model:user'), application.User);
      assert.equal(registry.resolve('fruit:favorite'), application.Orange);
      assert.equal(registry.resolve('communication:main'), application.Email);
      assert.equal(registry.resolve('controller:postIndex'), application.PostIndexController);
      assert.equal(locator.lookup('fruit:favorite'), locator.lookup('fruit:favorite'), 'singleton lookup worked');
      assert.ok(locator.lookup('model:user') !== locator.lookup('model:user'), 'non-singleton lookup worked');
    };

    _proto['@test injections'] = function testInjections(assert) {
      application.inject('model', 'fruit', 'fruit:favorite');
      application.inject('model:user', 'communication', 'communication:main');
      var user = locator.lookup('model:user');
      var person = locator.lookup('model:person');
      var fruit = locator.lookup('fruit:favorite');
      assert.equal(user.get('fruit'), fruit);
      assert.equal(person.get('fruit'), fruit);
      assert.ok(application.Email.detectInstance(user.get('communication')));
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/application/tests/initializers_test", ["ember-babel", "@ember/polyfills", "internal-test-helpers", "@ember/application"], function (_emberBabel, _polyfills, _internalTestHelpers, _application) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application initializers',
  /*#__PURE__*/
  function (_AutobootApplicationT) {
    (0, _emberBabel.inheritsLoose)(_class, _AutobootApplicationT);

    function _class() {
      return _AutobootApplicationT.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.createSecondApplication = function createSecondApplication(options) {
      var MyApplication = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _application.default;
      var myOptions = (0, _polyfills.assign)(this.applicationOptions, {
        rootElement: '#two'
      }, options);
      var secondApp = this.secondApp = MyApplication.create(myOptions);
      return secondApp;
    };

    _proto.teardown = function teardown() {
      var _this = this;

      _AutobootApplicationT.prototype.teardown.call(this);

      if (this.secondApp) {
        (0, _internalTestHelpers.runTask)(function () {
          return _this.secondApp.destroy();
        });
      }
    };

    _proto["@test initializers require proper 'name' and 'initialize' properties"] = function () {
      var MyApplication = _application.default.extend();

      expectAssertion(function () {
        MyApplication.initializer({
          name: 'initializer'
        });
      });
      expectAssertion(function () {
        MyApplication.initializer({
          initialize: function () {}
        });
      });
    };

    _proto["@test initializers that throw errors cause the boot promise to reject with the error"] = function (assert) {
      var _this2 = this;

      assert.expect(2);

      var MyApplication = _application.default.extend();

      MyApplication.initializer({
        name: 'initializer',
        initialize: function () {
          throw new Error('boot failure');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        _this2.createApplication({
          autoboot: false
        }, MyApplication);
      });
      var app = this.application;

      try {
        (0, _internalTestHelpers.runTask)(function () {
          app.boot().then(function () {
            assert.ok(false, 'The boot promise should not resolve when there is a boot error');
          }, function (error) {
            assert.ok(error instanceof Error, 'The boot promise should reject with an error');
            assert.equal(error.message, 'boot failure');
          });
        });
      } catch (error) {
        assert.ok(false, 'The boot method should not throw');
        throw error;
      }
    };

    _proto["@test initializers are passed an App"] = function (assert) {
      var _this3 = this;

      var MyApplication = _application.default.extend();

      MyApplication.initializer({
        name: 'initializer',
        initialize: function (App) {
          assert.ok(App instanceof _application.default, 'initialize is passed an Application');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.createApplication({}, MyApplication);
      });
    };

    _proto["@test initializers can be registered in a specified order"] = function (assert) {
      var _this4 = this;

      var order = [];

      var MyApplication = _application.default.extend();

      MyApplication.initializer({
        name: 'fourth',
        after: 'third',
        initialize: function () {
          order.push('fourth');
        }
      });
      MyApplication.initializer({
        name: 'second',
        after: 'first',
        before: 'third',
        initialize: function () {
          order.push('second');
        }
      });
      MyApplication.initializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize: function () {
          order.push('fifth');
        }
      });
      MyApplication.initializer({
        name: 'first',
        before: 'second',
        initialize: function () {
          order.push('first');
        }
      });
      MyApplication.initializer({
        name: 'third',
        initialize: function () {
          order.push('third');
        }
      });
      MyApplication.initializer({
        name: 'sixth',
        initialize: function () {
          order.push('sixth');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.createApplication({}, MyApplication);
      });
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    };

    _proto["@test initializers can be registered in a specified order as an array"] = function (assert) {
      var _this5 = this;

      var order = [];

      var MyApplication = _application.default.extend();

      MyApplication.initializer({
        name: 'third',
        initialize: function () {
          order.push('third');
        }
      });
      MyApplication.initializer({
        name: 'second',
        after: 'first',
        before: ['third', 'fourth'],
        initialize: function () {
          order.push('second');
        }
      });
      MyApplication.initializer({
        name: 'fourth',
        after: ['second', 'third'],
        initialize: function () {
          order.push('fourth');
        }
      });
      MyApplication.initializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize: function () {
          order.push('fifth');
        }
      });
      MyApplication.initializer({
        name: 'first',
        before: ['second'],
        initialize: function () {
          order.push('first');
        }
      });
      MyApplication.initializer({
        name: 'sixth',
        initialize: function () {
          order.push('sixth');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.createApplication({}, MyApplication);
      });
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    };

    _proto["@test initializers can have multiple dependencies"] = function (assert) {
      var _this6 = this;

      var order = [];

      var MyApplication = _application.default.extend();

      var a = {
        name: 'a',
        before: 'b',
        initialize: function () {
          order.push('a');
        }
      };
      var b = {
        name: 'b',
        initialize: function () {
          order.push('b');
        }
      };
      var c = {
        name: 'c',
        after: 'b',
        initialize: function () {
          order.push('c');
        }
      };
      var afterB = {
        name: 'after b',
        after: 'b',
        initialize: function () {
          order.push('after b');
        }
      };
      var afterC = {
        name: 'after c',
        after: 'c',
        initialize: function () {
          order.push('after c');
        }
      };
      MyApplication.initializer(b);
      MyApplication.initializer(a);
      MyApplication.initializer(afterC);
      MyApplication.initializer(afterB);
      MyApplication.initializer(c);
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.createApplication({}, MyApplication);
      });
      assert.ok(order.indexOf(a.name) < order.indexOf(b.name), 'a < b');
      assert.ok(order.indexOf(b.name) < order.indexOf(c.name), 'b < c');
      assert.ok(order.indexOf(b.name) < order.indexOf(afterB.name), 'b < afterB');
      assert.ok(order.indexOf(c.name) < order.indexOf(afterC.name), 'c < afterC');
    };

    _proto["@test initializers set on Application subclasses are not shared between apps"] = function (assert) {
      var _this7 = this;

      var firstInitializerRunCount = 0;
      var secondInitializerRunCount = 0;

      var FirstApp = _application.default.extend();

      FirstApp.initializer({
        name: 'first',
        initialize: function () {
          firstInitializerRunCount++;
        }
      });

      var SecondApp = _application.default.extend();

      SecondApp.initializer({
        name: 'second',
        initialize: function () {
          secondInitializerRunCount++;
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.createApplication({}, FirstApp);
      });
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run');
      assert.equal(secondInitializerRunCount, 0, 'first initializer only was run');
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.createSecondApplication({}, SecondApp);
      });
      assert.equal(firstInitializerRunCount, 1, 'second initializer only was run');
      assert.equal(secondInitializerRunCount, 1, 'second initializer only was run');
    };

    _proto["@test initializers are concatenated"] = function (assert) {
      var _this8 = this;

      var firstInitializerRunCount = 0;
      var secondInitializerRunCount = 0;

      var FirstApp = _application.default.extend();

      FirstApp.initializer({
        name: 'first',
        initialize: function () {
          firstInitializerRunCount++;
        }
      });
      var SecondApp = FirstApp.extend();
      SecondApp.initializer({
        name: 'second',
        initialize: function () {
          secondInitializerRunCount++;
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.createApplication({}, FirstApp);
      });
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run when base class created');
      assert.equal(secondInitializerRunCount, 0, 'first initializer only was run when base class created');
      firstInitializerRunCount = 0;
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.createSecondApplication({}, SecondApp);
      });
      assert.equal(firstInitializerRunCount, 1, 'first initializer was run when subclass created');
      assert.equal(secondInitializerRunCount, 1, 'second initializers was run when subclass created');
    };

    _proto["@test initializers are per-app"] = function (assert) {
      assert.expect(2);

      var FirstApp = _application.default.extend();

      FirstApp.initializer({
        name: 'abc',
        initialize: function () {}
      });
      expectAssertion(function () {
        FirstApp.initializer({
          name: 'abc',
          initialize: function () {}
        });
      });

      var SecondApp = _application.default.extend();

      SecondApp.instanceInitializer({
        name: 'abc',
        initialize: function () {}
      });
      assert.ok(true, 'Two apps can have initializers named the same.');
    };

    _proto["@test initializers are executed in their own context"] = function (assert) {
      var _this9 = this;

      assert.expect(1);

      var MyApplication = _application.default.extend();

      MyApplication.initializer({
        name: 'coolInitializer',
        myProperty: 'cool',
        initialize: function () {
          assert.equal(this.myProperty, 'cool', 'should have access to its own context');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.createApplication({}, MyApplication);
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "fixture",
      get: function () {
        return "<div id=\"one\">ONE</div>\n      <div id=\"two\">TWO</div>\n    ";
      }
    }, {
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_AutobootApplicationT.prototype.applicationOptions, {
          rootElement: '#one'
        });
      }
    }]);
    return _class;
  }(_internalTestHelpers.AutobootApplicationTestCase));
});
enifed("@ember/application/tests/instance_initializers_test", ["ember-babel", "@ember/polyfills", "internal-test-helpers", "@ember/application/instance", "@ember/application"], function (_emberBabel, _polyfills, _internalTestHelpers, _instance, _application) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application instance initializers',
  /*#__PURE__*/
  function (_AutobootApplicationT) {
    (0, _emberBabel.inheritsLoose)(_class, _AutobootApplicationT);

    function _class() {
      return _AutobootApplicationT.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.createSecondApplication = function createSecondApplication(options) {
      var MyApplication = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _application.default;
      var myOptions = (0, _polyfills.assign)(this.applicationOptions, {
        rootElement: '#two'
      }, options);
      var secondApp = this.secondApp = MyApplication.create(myOptions);
      return secondApp;
    };

    _proto.teardown = function teardown() {
      var _this = this;

      _AutobootApplicationT.prototype.teardown.call(this);

      if (this.secondApp) {
        (0, _internalTestHelpers.runTask)(function () {
          return _this.secondApp.destroy();
        });
      }
    };

    _proto["@test initializers require proper 'name' and 'initialize' properties"] = function () {
      var _this2 = this;

      var MyApplication = _application.default.extend();

      expectAssertion(function () {
        MyApplication.instanceInitializer({
          name: 'initializer'
        });
      });
      expectAssertion(function () {
        MyApplication.instanceInitializer({
          initialize: function () {}
        });
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.createApplication({}, MyApplication);
      });
    };

    _proto["@test initializers are passed an app instance"] = function (assert) {
      var _this3 = this;

      var MyApplication = _application.default.extend();

      MyApplication.instanceInitializer({
        name: 'initializer',
        initialize: function (instance) {
          assert.ok(instance instanceof _instance.default, 'initialize is passed an application instance');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.createApplication({}, MyApplication);
      });
    };

    _proto["@test initializers can be registered in a specified order"] = function (assert) {
      var _this4 = this;

      var order = [];

      var MyApplication = _application.default.extend();

      MyApplication.instanceInitializer({
        name: 'fourth',
        after: 'third',
        initialize: function () {
          order.push('fourth');
        }
      });
      MyApplication.instanceInitializer({
        name: 'second',
        after: 'first',
        before: 'third',
        initialize: function () {
          order.push('second');
        }
      });
      MyApplication.instanceInitializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize: function () {
          order.push('fifth');
        }
      });
      MyApplication.instanceInitializer({
        name: 'first',
        before: 'second',
        initialize: function () {
          order.push('first');
        }
      });
      MyApplication.instanceInitializer({
        name: 'third',
        initialize: function () {
          order.push('third');
        }
      });
      MyApplication.instanceInitializer({
        name: 'sixth',
        initialize: function () {
          order.push('sixth');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.createApplication({}, MyApplication);
      });
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    };

    _proto["@test initializers can be registered in a specified order as an array"] = function (assert) {
      var _this5 = this;

      var order = [];

      var MyApplication = _application.default.extend();

      MyApplication.instanceInitializer({
        name: 'third',
        initialize: function () {
          order.push('third');
        }
      });
      MyApplication.instanceInitializer({
        name: 'second',
        after: 'first',
        before: ['third', 'fourth'],
        initialize: function () {
          order.push('second');
        }
      });
      MyApplication.instanceInitializer({
        name: 'fourth',
        after: ['second', 'third'],
        initialize: function () {
          order.push('fourth');
        }
      });
      MyApplication.instanceInitializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize: function () {
          order.push('fifth');
        }
      });
      MyApplication.instanceInitializer({
        name: 'first',
        before: ['second'],
        initialize: function () {
          order.push('first');
        }
      });
      MyApplication.instanceInitializer({
        name: 'sixth',
        initialize: function () {
          order.push('sixth');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.createApplication({}, MyApplication);
      });
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    };

    _proto["@test initializers can have multiple dependencies"] = function (assert) {
      var _this6 = this;

      var order = [];

      var MyApplication = _application.default.extend();

      var a = {
        name: 'a',
        before: 'b',
        initialize: function () {
          order.push('a');
        }
      };
      var b = {
        name: 'b',
        initialize: function () {
          order.push('b');
        }
      };
      var c = {
        name: 'c',
        after: 'b',
        initialize: function () {
          order.push('c');
        }
      };
      var afterB = {
        name: 'after b',
        after: 'b',
        initialize: function () {
          order.push('after b');
        }
      };
      var afterC = {
        name: 'after c',
        after: 'c',
        initialize: function () {
          order.push('after c');
        }
      };
      MyApplication.instanceInitializer(b);
      MyApplication.instanceInitializer(a);
      MyApplication.instanceInitializer(afterC);
      MyApplication.instanceInitializer(afterB);
      MyApplication.instanceInitializer(c);
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.createApplication({}, MyApplication);
      });
      assert.ok(order.indexOf(a.name) < order.indexOf(b.name), 'a < b');
      assert.ok(order.indexOf(b.name) < order.indexOf(c.name), 'b < c');
      assert.ok(order.indexOf(b.name) < order.indexOf(afterB.name), 'b < afterB');
      assert.ok(order.indexOf(c.name) < order.indexOf(afterC.name), 'c < afterC');
    };

    _proto["@test initializers set on Application subclasses should not be shared between apps"] = function (assert) {
      var _this7 = this;

      var firstInitializerRunCount = 0;
      var secondInitializerRunCount = 0;

      var FirstApp = _application.default.extend();

      FirstApp.instanceInitializer({
        name: 'first',
        initialize: function () {
          firstInitializerRunCount++;
        }
      });

      var SecondApp = _application.default.extend();

      SecondApp.instanceInitializer({
        name: 'second',
        initialize: function () {
          secondInitializerRunCount++;
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.createApplication({}, FirstApp);
      });
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run');
      assert.equal(secondInitializerRunCount, 0, 'first initializer only was run');
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.createSecondApplication({}, SecondApp);
      });
      assert.equal(firstInitializerRunCount, 1, 'second initializer only was run');
      assert.equal(secondInitializerRunCount, 1, 'second initializer only was run');
    };

    _proto["@test initializers are concatenated"] = function (assert) {
      var _this8 = this;

      var firstInitializerRunCount = 0;
      var secondInitializerRunCount = 0;

      var FirstApp = _application.default.extend();

      FirstApp.instanceInitializer({
        name: 'first',
        initialize: function () {
          firstInitializerRunCount++;
        }
      });
      var SecondApp = FirstApp.extend();
      SecondApp.instanceInitializer({
        name: 'second',
        initialize: function () {
          secondInitializerRunCount++;
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.createApplication({}, FirstApp);
      });
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run when base class created');
      assert.equal(secondInitializerRunCount, 0, 'first initializer only was run when base class created');
      firstInitializerRunCount = 0;
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.createSecondApplication({}, SecondApp);
      });
      assert.equal(firstInitializerRunCount, 1, 'first initializer was run when subclass created');
      assert.equal(secondInitializerRunCount, 1, 'second initializers was run when subclass created');
    };

    _proto["@test initializers are per-app"] = function (assert) {
      var _this9 = this;

      assert.expect(2);

      var FirstApp = _application.default.extend();

      FirstApp.instanceInitializer({
        name: 'abc',
        initialize: function () {}
      });
      expectAssertion(function () {
        FirstApp.instanceInitializer({
          name: 'abc',
          initialize: function () {}
        });
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.createApplication({}, FirstApp);
      });

      var SecondApp = _application.default.extend();

      SecondApp.instanceInitializer({
        name: 'abc',
        initialize: function () {}
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.createSecondApplication({}, SecondApp);
      });
      assert.ok(true, 'Two apps can have initializers named the same.');
    };

    _proto["@test initializers are run before ready hook"] = function (assert) {
      var _this10 = this;

      assert.expect(2);

      var MyApplication = _application.default.extend({
        ready: function () {
          assert.ok(true, 'ready is called');
          readyWasCalled = false;
        }
      });

      var readyWasCalled = false;
      MyApplication.instanceInitializer({
        name: 'initializer',
        initialize: function () {
          assert.ok(!readyWasCalled, 'ready is not yet called');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.createApplication({}, MyApplication);
      });
    };

    _proto["@test initializers are executed in their own context"] = function (assert) {
      var _this11 = this;

      assert.expect(1);

      var MyApplication = _application.default.extend();

      MyApplication.instanceInitializer({
        name: 'coolInitializer',
        myProperty: 'cool',
        initialize: function () {
          assert.equal(this.myProperty, 'cool', 'should have access to its own context');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this11.createApplication({}, MyApplication);
      });
    };

    _proto["@test initializers get an instance on app reset"] = function (assert) {
      var _this12 = this;

      assert.expect(2);

      var MyApplication = _application.default.extend();

      MyApplication.instanceInitializer({
        name: 'giveMeAnInstance',
        initialize: function (instance) {
          assert.ok(Boolean(instance), 'Initializer got an instance');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.createApplication({}, MyApplication);
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.application.reset();
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "fixture",
      get: function () {
        return "<div id=\"one\">ONE</div>\n      <div id=\"two\">TWO</div>\n    ";
      }
    }, {
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_AutobootApplicationT.prototype.applicationOptions, {
          rootElement: '#one'
        });
      }
    }]);
    return _class;
  }(_internalTestHelpers.AutobootApplicationTestCase));
});
enifed("@ember/application/tests/lazy_load_test", ["ember-babel", "@ember/runloop", "@ember/application", "internal-test-helpers"], function (_emberBabel, _runloop, _application, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Lazy Loading',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.afterEach = function afterEach() {
      var keys = Object.keys(_application._loaded);

      for (var i = 0; i < keys.length; i++) {
        delete _application._loaded[keys[i]];
      }
    };

    _proto['@test if a load hook is registered, it is executed when runLoadHooks are exected'] = function testIfALoadHookIsRegisteredItIsExecutedWhenRunLoadHooksAreExected(assert) {
      var count = 0;
      (0, _runloop.run)(function () {
        (0, _application.onLoad)('__test_hook__', function (object) {
          count += object;
        });
      });
      (0, _runloop.run)(function () {
        (0, _application.runLoadHooks)('__test_hook__', 1);
      });
      assert.equal(count, 1, 'the object was passed into the load hook');
    };

    _proto['@test if runLoadHooks was already run, it executes newly added hooks immediately'] = function testIfRunLoadHooksWasAlreadyRunItExecutesNewlyAddedHooksImmediately(assert) {
      var count = 0;
      (0, _runloop.run)(function () {
        (0, _application.onLoad)('__test_hook__', function (object) {
          return count += object;
        });
      });
      (0, _runloop.run)(function () {
        return (0, _application.runLoadHooks)('__test_hook__', 1);
      });
      count = 0;
      (0, _runloop.run)(function () {
        (0, _application.onLoad)('__test_hook__', function (object) {
          return count += object;
        });
      });
      assert.equal(count, 1, 'the original object was passed into the load hook');
    };

    _proto["@test hooks in ENV.EMBER_LOAD_HOOKS['hookName'] get executed"] = function testHooksInENVEMBER_LOAD_HOOKSHookNameGetExecuted(assert) {
      // Note that the necessary code to perform this test is run before
      // the Ember lib is loaded in tests/index.html
      (0, _runloop.run)(function () {
        (0, _application.runLoadHooks)('__before_ember_test_hook__', 1);
      });
      assert.equal(window.ENV.__test_hook_count__, 1, 'the object was passed into the load hook');
    };

    _proto['@test load hooks trigger a custom event'] = function testLoadHooksTriggerACustomEvent(assert) {
      if (typeof window === 'object' && typeof window.dispatchEvent === 'function' && typeof CustomEvent === 'function') {
        var eventObject = 'super duper awesome events';
        window.addEventListener('__test_hook_for_events__', function (e) {
          assert.ok(true, 'custom event was fired');
          assert.equal(e.detail, eventObject, 'event details are provided properly');
        });
        (0, _runloop.run)(function () {
          (0, _application.runLoadHooks)('__test_hook_for_events__', eventObject);
        });
      } else {
        assert.expect(0);
      }
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/application/tests/logging_test", ["ember-babel", "internal-test-helpers", "@ember/controller", "@ember/-internals/routing", "@ember/polyfills"], function (_emberBabel, _internalTestHelpers, _controller, _routing, _polyfills) {
  "use strict";

  /*globals EmberDev */
  var LoggingApplicationTestCase =
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(LoggingApplicationTestCase, _ApplicationTestCase);

    function LoggingApplicationTestCase() {
      var _this;

      _this = _ApplicationTestCase.call(this) || this;
      _this.logs = {};
      /* eslint-disable no-console */

      _this._originalLogger = console.info;

      console.info = function (_, _ref) {
        var fullName = _ref.fullName;

        if (!_this.logs.hasOwnProperty(fullName)) {
          _this.logs[fullName] = 0;
        }
        /* eslint-ensable no-console */


        _this.logs[fullName]++;
      };

      _this.router.map(function () {
        this.route('posts', {
          resetNamespace: true
        });
      });

      return _this;
    }

    var _proto = LoggingApplicationTestCase.prototype;

    _proto.teardown = function teardown() {
      /* eslint-disable no-console */
      console.info = this._originalLogger;
      /* eslint-enable no-console */

      _ApplicationTestCase.prototype.teardown.call(this);
    };

    return LoggingApplicationTestCase;
  }(_internalTestHelpers.ApplicationTestCase);

  (0, _internalTestHelpers.moduleFor)('Application with LOG_ACTIVE_GENERATION=true',
  /*#__PURE__*/
  function (_LoggingApplicationTe) {
    (0, _emberBabel.inheritsLoose)(_class, _LoggingApplicationTe);

    function _class() {
      return _LoggingApplicationTe.apply(this, arguments) || this;
    }

    var _proto2 = _class.prototype;

    _proto2['@test log class generation if logging enabled'] = function testLogClassGenerationIfLoggingEnabled(assert) {
      var _this2 = this;

      if (EmberDev && EmberDev.runningProdBuild) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }

      return this.visit('/posts').then(function () {
        assert.equal(Object.keys(_this2.logs).length, 4, 'expected logs');
      });
    };

    _proto2['@test actively generated classes get logged'] = function testActivelyGeneratedClassesGetLogged(assert) {
      var _this3 = this;

      if (EmberDev && EmberDev.runningProdBuild) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }

      return this.visit('/posts').then(function () {
        assert.equal(_this3.logs['controller:application'], 1, 'expected: ApplicationController was generated');
        assert.equal(_this3.logs['controller:posts'], 1, 'expected: PostsController was generated');
        assert.equal(_this3.logs['route:application'], 1, 'expected: ApplicationRoute was generated');
        assert.equal(_this3.logs['route:posts'], 1, 'expected: PostsRoute was generated');
      });
    };

    _proto2['@test predefined classes do not get logged'] = function testPredefinedClassesDoNotGetLogged(assert) {
      var _this4 = this;

      this.add('controller:application', _controller.default.extend());
      this.add('controller:posts', _controller.default.extend());
      this.add('route:application', _routing.Route.extend());
      this.add('route:posts', _routing.Route.extend());
      return this.visit('/posts').then(function () {
        assert.ok(!_this4.logs['controller:application'], 'did not expect: ApplicationController was generated');
        assert.ok(!_this4.logs['controller:posts'], 'did not expect: PostsController was generated');
        assert.ok(!_this4.logs['route:application'], 'did not expect: ApplicationRoute was generated');
        assert.ok(!_this4.logs['route:posts'], 'did not expect: PostsRoute was generated');
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_LoggingApplicationTe.prototype.applicationOptions, {
          LOG_ACTIVE_GENERATION: true
        });
      }
    }]);
    return _class;
  }(LoggingApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application when LOG_ACTIVE_GENERATION=false',
  /*#__PURE__*/
  function (_LoggingApplicationTe2) {
    (0, _emberBabel.inheritsLoose)(_class2, _LoggingApplicationTe2);

    function _class2() {
      return _LoggingApplicationTe2.apply(this, arguments) || this;
    }

    var _proto3 = _class2.prototype;

    _proto3["@test do NOT log class generation if logging disabled"] = function (assert) {
      var _this5 = this;

      return this.visit('/posts').then(function () {
        assert.equal(Object.keys(_this5.logs).length, 0, 'expected logs');
      });
    };

    (0, _emberBabel.createClass)(_class2, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_LoggingApplicationTe2.prototype.applicationOptions, {
          LOG_ACTIVE_GENERATION: false
        });
      }
    }]);
    return _class2;
  }(LoggingApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application with LOG_VIEW_LOOKUPS=true',
  /*#__PURE__*/
  function (_LoggingApplicationTe3) {
    (0, _emberBabel.inheritsLoose)(_class3, _LoggingApplicationTe3);

    function _class3() {
      return _LoggingApplicationTe3.apply(this, arguments) || this;
    }

    var _proto4 = _class3.prototype;

    _proto4["@test log when template and view are missing when flag is active"] = function (assert) {
      var _this6 = this;

      if (EmberDev && EmberDev.runningProdBuild) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }

      this.addTemplate('application', '{{outlet}}');
      return this.visit('/').then(function () {
        return _this6.visit('/posts');
      }).then(function () {
        assert.equal(_this6.logs['template:application'], undefined, 'expected: Should not log template:application since it exists.');
        assert.equal(_this6.logs['template:index'], 1, 'expected: Could not find "index" template or view.');
        assert.equal(_this6.logs['template:posts'], 1, 'expected: Could not find "posts" template or view.');
      });
    };

    (0, _emberBabel.createClass)(_class3, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_LoggingApplicationTe3.prototype.applicationOptions, {
          LOG_VIEW_LOOKUPS: true
        });
      }
    }]);
    return _class3;
  }(LoggingApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application with LOG_VIEW_LOOKUPS=false',
  /*#__PURE__*/
  function (_LoggingApplicationTe4) {
    (0, _emberBabel.inheritsLoose)(_class4, _LoggingApplicationTe4);

    function _class4() {
      return _LoggingApplicationTe4.apply(this, arguments) || this;
    }

    var _proto5 = _class4.prototype;

    _proto5["@test do not log when template and view are missing when flag is not true"] = function (assert) {
      var _this7 = this;

      return this.visit('/posts').then(function () {
        assert.equal(Object.keys(_this7.logs).length, 0, 'expected no logs');
      });
    };

    _proto5["@test do not log which views are used with templates when flag is not true"] = function (assert) {
      var _this8 = this;

      return this.visit('/posts').then(function () {
        assert.equal(Object.keys(_this8.logs).length, 0, 'expected no logs');
      });
    };

    (0, _emberBabel.createClass)(_class4, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_LoggingApplicationTe4.prototype.applicationOptions, {
          LOG_VIEW_LOOKUPS: false
        });
      }
    }]);
    return _class4;
  }(LoggingApplicationTestCase));
});
enifed("@ember/application/tests/readiness_test", ["ember-babel", "internal-test-helpers", "@ember/runloop", "@ember/application"], function (_emberBabel, _internalTestHelpers, _runloop, _application) {
  "use strict";

  var jQuery, application, Application;
  var readyWasCalled, domReady, readyCallbacks; // We are using a small mock of jQuery because jQuery is third-party code with
  // very well-defined semantics, and we want to confirm that a jQuery stub run
  // in a more minimal server environment that implements this behavior will be
  // sufficient for Ember's requirements.

  (0, _internalTestHelpers.moduleFor)('Application readiness',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.call(this) || this;
      readyWasCalled = 0;
      readyCallbacks = [];
      var jQueryInstance = {
        ready: function (callback) {
          readyCallbacks.push(callback);

          if (jQuery.isReady) {
            domReady();
          }
        }
      };

      jQuery = function () {
        return jQueryInstance;
      };

      jQuery.isReady = false;
      var domReadyCalled = 0;

      domReady = function () {
        if (domReadyCalled !== 0) {
          return;
        }

        domReadyCalled++;

        for (var i = 0; i < readyCallbacks.length; i++) {
          readyCallbacks[i]();
        }
      };

      Application = _application.default.extend({
        $: jQuery,
        ready: function () {
          readyWasCalled++;
        }
      });
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      if (application) {
        (0, _runloop.run)(function () {
          return application.destroy();
        });
        jQuery = readyCallbacks = domReady = Application = application = undefined;
      }
    } // These tests are confirming that if the callbacks passed into jQuery's ready hook is called
    // synchronously during the application's initialization, we get the same behavior as if
    // it was triggered after initialization.
    ;

    _proto["@test Application's ready event is called right away if jQuery is already ready"] = function testApplicationSReadyEventIsCalledRightAwayIfJQueryIsAlreadyReady(assert) {
      jQuery.isReady = true;
      (0, _runloop.run)(function () {
        application = Application.create({
          router: false
        });
        assert.equal(readyWasCalled, 0, 'ready is not called until later');
      });
      assert.equal(readyWasCalled, 1, 'ready was called');
      domReady();
      assert.equal(readyWasCalled, 1, "application's ready was not called again");
    };

    _proto["@test Application's ready event is called after the document becomes ready"] = function testApplicationSReadyEventIsCalledAfterTheDocumentBecomesReady(assert) {
      (0, _runloop.run)(function () {
        application = Application.create({
          router: false
        });
      });
      assert.equal(readyWasCalled, 0, "ready wasn't called yet");
      domReady();
      assert.equal(readyWasCalled, 1, 'ready was called now that DOM is ready');
    };

    _proto["@test Application's ready event can be deferred by other components"] = function testApplicationSReadyEventCanBeDeferredByOtherComponents(assert) {
      (0, _runloop.run)(function () {
        application = Application.create({
          router: false
        });
        application.deferReadiness();
      });
      assert.equal(readyWasCalled, 0, "ready wasn't called yet");
      domReady();
      assert.equal(readyWasCalled, 0, "ready wasn't called yet");
      (0, _runloop.run)(function () {
        application.advanceReadiness();
        assert.equal(readyWasCalled, 0);
      });
      assert.equal(readyWasCalled, 1, 'ready was called now all readiness deferrals are advanced');
    };

    _proto["@test Application's ready event can be deferred by other components"] = function testApplicationSReadyEventCanBeDeferredByOtherComponents(assert) {
      jQuery.isReady = false;
      (0, _runloop.run)(function () {
        application = Application.create({
          router: false
        });
        application.deferReadiness();
        assert.equal(readyWasCalled, 0, "ready wasn't called yet");
      });
      domReady();
      assert.equal(readyWasCalled, 0, "ready wasn't called yet");
      (0, _runloop.run)(function () {
        application.advanceReadiness();
      });
      assert.equal(readyWasCalled, 1, 'ready was called now all readiness deferrals are advanced');
      expectAssertion(function () {
        application.deferReadiness();
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/application/tests/reset_test", ["ember-babel", "@ember/runloop", "@ember/-internals/metal", "@ember/controller", "@ember/-internals/routing", "internal-test-helpers"], function (_emberBabel, _runloop, _metal, _controller, _routing, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application - resetting',
  /*#__PURE__*/
  function (_AutobootApplicationT) {
    (0, _emberBabel.inheritsLoose)(_class, _AutobootApplicationT);

    function _class() {
      return _AutobootApplicationT.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Brings its own run-loop if not provided'] = function testBringsItsOwnRunLoopIfNotProvided(assert) {
      var _this = this;

      assert.expect(0);
      (0, _runloop.run)(function () {
        return _this.createApplication();
      });
      this.application.reset();
    };

    _proto['@test Does not bring its own run loop if one is already provided'] = function testDoesNotBringItsOwnRunLoopIfOneIsAlreadyProvided(assert) {
      var _this2 = this;

      assert.expect(3);
      var didBecomeReady = false;
      (0, _runloop.run)(function () {
        return _this2.createApplication();
      });
      (0, _runloop.run)(function () {
        _this2.application.ready = function () {
          didBecomeReady = true;
        };

        _this2.application.reset();

        _this2.application.deferReadiness();

        assert.ok(!didBecomeReady, 'app is not ready');
      });
      assert.ok(!didBecomeReady, 'app is not ready');
      (0, _runloop.run)(this.application, 'advanceReadiness');
      assert.ok(didBecomeReady, 'app is ready');
    };

    _proto['@test When an application is reset, new instances of controllers are generated'] = function testWhenAnApplicationIsResetNewInstancesOfControllersAreGenerated(assert) {
      var _this3 = this;

      (0, _runloop.run)(function () {
        _this3.createApplication();

        _this3.add('controller:academic', _controller.default.extend());
      });
      var firstController = this.applicationInstance.lookup('controller:academic');
      var secondController = this.applicationInstance.lookup('controller:academic');
      this.application.reset();
      var thirdController = this.applicationInstance.lookup('controller:academic');
      assert.strictEqual(firstController, secondController, 'controllers looked up in succession should be the same instance');
      assert.ok(firstController.isDestroying, 'controllers are destroyed when their application is reset');
      assert.notStrictEqual(firstController, thirdController, 'controllers looked up after the application is reset should not be the same instance');
    };

    _proto['@test When an application is reset, the eventDispatcher is destroyed and recreated'] = function testWhenAnApplicationIsResetTheEventDispatcherIsDestroyedAndRecreated(assert) {
      var _this4 = this;

      var eventDispatcherWasSetup = 0;
      var eventDispatcherWasDestroyed = 0;
      var mockEventDispatcher = {
        setup: function () {
          eventDispatcherWasSetup++;
        },
        destroy: function () {
          eventDispatcherWasDestroyed++;
        }
      };
      (0, _runloop.run)(function () {
        _this4.createApplication();

        _this4.add('event_dispatcher:main', {
          create: function () {
            return mockEventDispatcher;
          }
        });

        assert.equal(eventDispatcherWasSetup, 0);
        assert.equal(eventDispatcherWasDestroyed, 0);
      });
      assert.equal(eventDispatcherWasSetup, 1);
      assert.equal(eventDispatcherWasDestroyed, 0);
      this.application.reset();
      assert.equal(eventDispatcherWasDestroyed, 1);
      assert.equal(eventDispatcherWasSetup, 2, 'setup called after reset');
    };

    _proto['@test When an application is reset, the router URL is reset to `/`'] = function testWhenAnApplicationIsResetTheRouterURLIsResetTo(assert) {
      var _this5 = this;

      (0, _runloop.run)(function () {
        _this5.createApplication();

        _this5.add('router:main', _routing.Router.extend({
          location: 'none'
        }));

        _this5.router.map(function () {
          this.route('one');
          this.route('two');
        });
      });
      var initialRouter, initialApplicationController;
      return this.visit('/one').then(function () {
        initialApplicationController = _this5.applicationInstance.lookup('controller:application');
        initialRouter = _this5.applicationInstance.lookup('router:main');
        var location = initialRouter.get('location');
        assert.equal(location.getURL(), '/one');
        assert.equal((0, _metal.get)(initialApplicationController, 'currentPath'), 'one');

        _this5.application.reset();

        return _this5.application._bootPromise;
      }).then(function () {
        var applicationController = _this5.applicationInstance.lookup('controller:application');

        assert.strictEqual(applicationController, undefined, 'application controller no longer exists');
        return _this5.visit('/one');
      }).then(function () {
        var applicationController = _this5.applicationInstance.lookup('controller:application');

        var router = _this5.applicationInstance.lookup('router:main');

        var location = router.get('location');
        assert.notEqual(initialRouter, router, 'a different router instance was created');
        assert.notEqual(initialApplicationController, applicationController, 'a different application controller is created');
        assert.equal(location.getURL(), '/one');
        assert.equal((0, _metal.get)(applicationController, 'currentPath'), 'one');
      });
    };

    _proto['@test When an application with advance/deferReadiness is reset, the app does correctly become ready after reset'] = function testWhenAnApplicationWithAdvanceDeferReadinessIsResetTheAppDoesCorrectlyBecomeReadyAfterReset(assert) {
      var _this6 = this;

      var readyCallCount = 0;
      (0, _runloop.run)(function () {
        _this6.createApplication({
          ready: function () {
            readyCallCount++;
          }
        });

        _this6.application.deferReadiness();

        assert.equal(readyCallCount, 0, 'ready has not yet been called');
      });
      (0, _runloop.run)(this.application, 'advanceReadiness');
      assert.equal(readyCallCount, 1, 'ready was called once');
      this.application.reset();
      assert.equal(readyCallCount, 2, 'ready was called twice');
    };

    return _class;
  }(_internalTestHelpers.AutobootApplicationTestCase));
});
enifed("@ember/application/tests/visit_test", ["ember-babel", "internal-test-helpers", "@ember/service", "@ember/-internals/runtime", "@ember/runloop", "@ember/application", "@ember/application/instance", "@ember/engine", "@ember/-internals/routing", "@ember/-internals/glimmer", "ember-template-compiler", "@ember/-internals/environment"], function (_emberBabel, _internalTestHelpers, _service, _runtime, _runloop, _application, _instance, _engine, _routing, _glimmer, _emberTemplateCompiler, _environment) {
  "use strict";

  function expectAsyncError() {
    _runtime.RSVP.off('error');
  }

  (0, _internalTestHelpers.moduleFor)('Application - visit()',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _runtime.RSVP.on('error', _runtime.onerrorDefault);

      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = false;

      _ApplicationTestCase.prototype.teardown.call(this);
    };

    _proto.createApplication = function createApplication(options) {
      return _ApplicationTestCase.prototype.createApplication.call(this, options, _application.default.extend());
    };

    _proto.assertEmptyFixture = function assertEmptyFixture(message) {
      this.assert.strictEqual(document.getElementById('qunit-fixture').children.length, 0, "there are no elements in the fixture element " + (message ? message : ''));
    };

    _proto["@test does not add serialize-mode markers by default"] = function (assert) {
      var templateContent = '<div class="foo">Hi, Mom!</div>';
      this.addTemplate('index', templateContent);
      var rootElement = document.createElement('div');
      var bootOptions = {
        isBrowser: false,
        rootElement: rootElement
      };
      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = false;
      return this.visit('/', bootOptions).then(function () {
        assert.equal(rootElement.innerHTML, templateContent, 'without serialize flag renders as expected');
      });
    };

    _proto["@test _renderMode: rehydration"] = function (assert) {
      var _this = this;

      assert.expect(2);
      var indexTemplate = '<div class="foo">Hi, Mom!</div>';
      this.addTemplate('index', indexTemplate);
      var rootElement = document.createElement('div');
      var bootOptions = {
        isBrowser: false,
        rootElement: rootElement,
        _renderMode: 'serialize'
      };
      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = false;
      return this.visit('/', bootOptions).then(function (instance) {
        assert.ok((0, _glimmer.isSerializationFirstNode)(instance.rootElement.firstChild), 'glimmer-vm comment node was not found');
      }).then(function () {
        return (0, _internalTestHelpers.runTask)(function () {
          _this.applicationInstance.destroy();

          _this.applicationInstance = null;
        });
      }).then(function () {
        bootOptions = {
          isBrowser: false,
          rootElement: rootElement,
          _renderMode: 'rehydrate'
        };

        _this.application.visit('/', bootOptions).then(function (instance) {
          assert.equal(instance.rootElement.innerHTML, indexTemplate, 'was not properly rehydrated');
        });
      });
    } // This tests whether the application is "autobooted" by registering an
    // instance initializer and asserting it never gets run. Since this is
    // inherently testing that async behavior *doesn't* happen, we set a
    // 500ms timeout to verify that when autoboot is set to false, the
    // instance initializer that would normally get called on DOM ready
    // does not fire.
    ;

    _proto["@test Applications with autoboot set to false do not autoboot"] = function (assert) {
      var _this2 = this;

      function delay(time) {
        return new _runtime.RSVP.Promise(function (resolve) {
          return (0, _runloop.later)(resolve, time);
        });
      }

      var appBooted = 0;
      var instanceBooted = 0;
      this.application.initializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          appBooted++;
        }
      });
      this.application.instanceInitializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          instanceBooted++;
        }
      });
      assert.ok(!this.applicationInstance, 'precond - no instance');
      assert.ok(appBooted === 0, 'precond - not booted');
      assert.ok(instanceBooted === 0, 'precond - not booted'); // Continue after 500ms

      return delay(500).then(function () {
        assert.ok(appBooted === 0, '500ms elapsed without app being booted');
        assert.ok(instanceBooted === 0, '500ms elapsed without instances being booted');
        return (0, _internalTestHelpers.runTask)(function () {
          return _this2.application.boot();
        });
      }).then(function () {
        assert.ok(appBooted === 1, 'app should boot when manually calling `app.boot()`');
        assert.ok(instanceBooted === 0, 'no instances should be booted automatically when manually calling `app.boot()');
      });
    };

    _proto["@test calling visit() on an app without first calling boot() should boot the app"] = function (assert) {
      var appBooted = 0;
      var instanceBooted = 0;
      this.application.initializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          appBooted++;
        }
      });
      this.application.instanceInitializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          instanceBooted++;
        }
      });
      return this.visit('/').then(function () {
        assert.ok(appBooted === 1, 'the app should be booted`');
        assert.ok(instanceBooted === 1, 'an instances should be booted');
      });
    };

    _proto["@test calling visit() on an already booted app should not boot it again"] = function (assert) {
      var _this3 = this;

      var appBooted = 0;
      var instanceBooted = 0;
      this.application.initializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          appBooted++;
        }
      });
      this.application.instanceInitializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          instanceBooted++;
        }
      });
      return (0, _internalTestHelpers.runTask)(function () {
        return _this3.application.boot();
      }).then(function () {
        assert.ok(appBooted === 1, 'the app should be booted');
        assert.ok(instanceBooted === 0, 'no instances should be booted');
        return _this3.visit('/');
      }).then(function () {
        assert.ok(appBooted === 1, 'the app should not be booted again');
        assert.ok(instanceBooted === 1, 'an instance should be booted');
        /*
         * Destroy the instance.
         */

        return (0, _internalTestHelpers.runTask)(function () {
          _this3.applicationInstance.destroy();

          _this3.applicationInstance = null;
        });
      }).then(function () {
        /*
         * Visit on the application a second time. The application should remain
         * booted, but a new instance will be created.
         */
        return _this3.application.visit('/').then(function (instance) {
          _this3.applicationInstance = instance;
        });
      }).then(function () {
        assert.ok(appBooted === 1, 'the app should not be booted again');
        assert.ok(instanceBooted === 2, 'another instance should be booted');
      });
    };

    _proto["@test visit() rejects on application boot failure"] = function (assert) {
      this.application.initializer({
        name: 'error',
        initialize: function () {
          throw new Error('boot failure');
        }
      });
      expectAsyncError();
      return this.visit('/').then(function () {
        assert.ok(false, 'It should not resolve the promise');
      }, function (error) {
        assert.ok(error instanceof Error, 'It should reject the promise with the boot error');
        assert.equal(error.message, 'boot failure');
      });
    };

    _proto["@test visit() rejects on instance boot failure"] = function (assert) {
      this.application.instanceInitializer({
        name: 'error',
        initialize: function () {
          throw new Error('boot failure');
        }
      });
      expectAsyncError();
      return this.visit('/').then(function () {
        assert.ok(false, 'It should not resolve the promise');
      }, function (error) {
        assert.ok(error instanceof Error, 'It should reject the promise with the boot error');
        assert.equal(error.message, 'boot failure');
      });
    };

    _proto["@test visit() follows redirects"] = function (assert) {
      this.router.map(function () {
        this.route('a');
        this.route('b', {
          path: '/b/:b'
        });
        this.route('c', {
          path: '/c/:c'
        });
      });
      this.add('route:a', _routing.Route.extend({
        afterModel: function () {
          this.replaceWith('b', 'zomg');
        }
      }));
      this.add('route:b', _routing.Route.extend({
        afterModel: function (params) {
          this.transitionTo('c', params.b);
        }
      }));
      /*
       * First call to `visit` is `this.application.visit` and returns the
       * applicationInstance.
       */

      return this.visit('/a').then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(instance.getURL(), '/c/zomg', 'It should follow all redirects');
      });
    };

    _proto["@test visit() rejects if an error occurred during a transition"] = function (assert) {
      this.router.map(function () {
        this.route('a');
        this.route('b', {
          path: '/b/:b'
        });
        this.route('c', {
          path: '/c/:c'
        });
      });
      this.add('route:a', _routing.Route.extend({
        afterModel: function () {
          this.replaceWith('b', 'zomg');
        }
      }));
      this.add('route:b', _routing.Route.extend({
        afterModel: function (params) {
          this.transitionTo('c', params.b);
        }
      }));
      this.add('route:c', _routing.Route.extend({
        afterModel: function () {
          throw new Error('transition failure');
        }
      }));
      expectAsyncError();
      return this.visit('/a').then(function () {
        assert.ok(false, 'It should not resolve the promise');
      }, function (error) {
        assert.ok(error instanceof Error, 'It should reject the promise with the boot error');
        assert.equal(error.message, 'transition failure');
      });
    };

    _proto["@test visit() chain"] = function (assert) {
      this.router.map(function () {
        this.route('a');
        this.route('b');
        this.route('c');
      });
      return this.visit('/').then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(instance.getURL(), '/');
        return instance.visit('/a');
      }).then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(instance.getURL(), '/a');
        return instance.visit('/b');
      }).then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(instance.getURL(), '/b');
        return instance.visit('/c');
      }).then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(instance.getURL(), '/c');
      });
    };

    _proto["@test visit() returns a promise that resolves when the view has rendered"] = function (assert) {
      var _this4 = this;

      this.addTemplate('application', "<h1>Hello world</h1>");
      this.assertEmptyFixture();
      return this.visit('/').then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(_this4.element.textContent, 'Hello world', 'the application was rendered once the promise resolves');
      });
    };

    _proto["@test visit() returns a promise that resolves without rendering when shouldRender is set to false"] = function (assert) {
      var _this5 = this;

      assert.expect(3);
      this.addTemplate('application', '<h1>Hello world</h1>');
      this.assertEmptyFixture();
      return this.visit('/', {
        shouldRender: false
      }).then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');

        _this5.assertEmptyFixture('after visit');
      });
    };

    _proto["@test visit() renders a template when shouldRender is set to true"] = function (assert) {
      assert.expect(3);
      this.addTemplate('application', '<h1>Hello world</h1>');
      this.assertEmptyFixture();
      return this.visit('/', {
        shouldRender: true
      }).then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.strictEqual(document.querySelector('#qunit-fixture').children.length, 1, 'there is 1 element in the fixture element after visit');
      });
    };

    _proto["@test visit() returns a promise that resolves without rendering when shouldRender is set to false with Engines"] = function (assert) {
      var _this6 = this;

      assert.expect(3);
      this.router.map(function () {
        this.mount('blog');
      });
      this.addTemplate('application', '<h1>Hello world</h1>'); // Register engine

      var BlogEngine = _engine.default.extend();

      this.add('engine:blog', BlogEngine); // Register engine route map

      var BlogMap = function () {};

      this.add('route-map:blog', BlogMap);
      this.assertEmptyFixture();
      return this.visit('/blog', {
        shouldRender: false
      }).then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');

        _this6.assertEmptyFixture('after visit');
      });
    };

    _proto["@test visit() does not setup the event_dispatcher:main if isInteractive is false (with Engines) GH#15615"] = function (assert) {
      var _this7 = this;

      assert.expect(3);
      this.router.map(function () {
        this.mount('blog');
      });
      this.addTemplate('application', '<h1>Hello world</h1>{{outlet}}');
      this.add('event_dispatcher:main', {
        create: function () {
          throw new Error('should not happen!');
        }
      }); // Register engine

      var BlogEngine = _engine.default.extend({
        init: function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          this._super.apply(this, args);

          this.register('template:application', (0, _emberTemplateCompiler.compile)('{{cache-money}}'));
          this.register('template:components/cache-money', (0, _emberTemplateCompiler.compile)("\n          <p>Dis cache money</p>\n        "));
          this.register('component:cache-money', _glimmer.Component.extend({}));
        }
      });

      this.add('engine:blog', BlogEngine); // Register engine route map

      var BlogMap = function () {};

      this.add('route-map:blog', BlogMap);
      this.assertEmptyFixture();
      return this.visit('/blog', {
        isInteractive: false
      }).then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.strictEqual(_this7.element.querySelector('p').textContent, 'Dis cache money', 'Engine component is resolved');
      });
    };

    _proto["@test visit() on engine resolves engine component"] = function (assert) {
      var _this8 = this;

      assert.expect(2);
      this.router.map(function () {
        this.mount('blog');
      }); // Register engine

      var BlogEngine = _engine.default.extend({
        init: function () {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          this._super.apply(this, args);

          this.register('template:application', (0, _emberTemplateCompiler.compile)('{{cache-money}}'));
          this.register('template:components/cache-money', (0, _emberTemplateCompiler.compile)("\n          <p>Dis cache money</p>\n        "));
          this.register('component:cache-money', _glimmer.Component.extend({}));
        }
      });

      this.add('engine:blog', BlogEngine); // Register engine route map

      var BlogMap = function () {};

      this.add('route-map:blog', BlogMap);
      this.assertEmptyFixture();
      return this.visit('/blog', {
        shouldRender: true
      }).then(function () {
        assert.strictEqual(_this8.element.querySelector('p').textContent, 'Dis cache money', 'Engine component is resolved');
      });
    };

    _proto["@test visit() on engine resolves engine helper"] = function (assert) {
      var _this9 = this;

      assert.expect(2);
      this.router.map(function () {
        this.mount('blog');
      }); // Register engine

      var BlogEngine = _engine.default.extend({
        init: function () {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          this._super.apply(this, args);

          this.register('template:application', (0, _emberTemplateCompiler.compile)('{{swag}}'));
          this.register('helper:swag', (0, _glimmer.helper)(function () {
            return 'turnt up';
          }));
        }
      });

      this.add('engine:blog', BlogEngine); // Register engine route map

      var BlogMap = function () {};

      this.add('route-map:blog', BlogMap);
      this.assertEmptyFixture();
      return this.visit('/blog', {
        shouldRender: true
      }).then(function () {
        assert.strictEqual(_this9.element.textContent, 'turnt up', 'Engine component is resolved');
      });
    };

    _proto["@test Ember Islands-style setup"] = function (assert) {
      var _this10 = this;

      var xFooInitCalled = false;
      var xFooDidInsertElementCalled = false;
      var xBarInitCalled = false;
      var xBarDidInsertElementCalled = false;
      this.router.map(function () {
        this.route('show', {
          path: '/:component_name'
        });
      });
      this.add('route:show', _routing.Route.extend({
        queryParams: {
          data: {
            refreshModel: true
          }
        },
        model: function (params) {
          return {
            componentName: params.component_name,
            componentData: params.data ? JSON.parse(params.data) : undefined
          };
        }
      }));

      var Counter = _runtime.Object.extend({
        value: 0,
        increment: function () {
          this.incrementProperty('value');
        }
      });

      this.add('service:isolatedCounter', Counter);
      this.add('service:sharedCounter', Counter.create());
      this.application.registerOptions('service:sharedCounter', {
        instantiate: false
      });
      this.addTemplate('show', '{{component model.componentName model=model.componentData}}');
      this.addTemplate('components/x-foo', "\n      <h1>X-Foo</h1>\n      <p>Hello {{model.name}}, I have been clicked {{isolatedCounter.value}} times ({{sharedCounter.value}} times combined)!</p>\n    ");
      this.add('component:x-foo', _glimmer.Component.extend({
        tagName: 'x-foo',
        isolatedCounter: (0, _service.inject)(),
        sharedCounter: (0, _service.inject)(),
        init: function () {
          this._super();

          xFooInitCalled = true;
        },
        didInsertElement: function () {
          xFooDidInsertElementCalled = true;
        },
        click: function () {
          this.get('isolatedCounter').increment();
          this.get('sharedCounter').increment();
        }
      }));
      this.addTemplate('components/x-bar', "\n      <h1>X-Bar</h1>\n      <button {{action \"incrementCounter\"}}>Join {{counter.value}} others in clicking me!</button>\n    ");
      this.add('component:x-bar', _glimmer.Component.extend({
        counter: (0, _service.inject)('sharedCounter'),
        actions: {
          incrementCounter: function () {
            this.get('counter').increment();
          }
        },
        init: function () {
          this._super();

          xBarInitCalled = true;
        },
        didInsertElement: function () {
          xBarDidInsertElementCalled = true;
        }
      }));
      var fixtureElement = document.querySelector('#qunit-fixture');
      var foo = document.createElement('div');
      var bar = document.createElement('div');
      fixtureElement.appendChild(foo);
      fixtureElement.appendChild(bar);
      var data = encodeURIComponent(JSON.stringify({
        name: 'Godfrey'
      }));
      var instances = [];
      return _runtime.RSVP.all([(0, _internalTestHelpers.runTask)(function () {
        return _this10.application.visit("/x-foo?data=" + data, {
          rootElement: foo
        });
      }), (0, _internalTestHelpers.runTask)(function () {
        return _this10.application.visit('/x-bar', {
          rootElement: bar
        });
      })]).then(function (_instances) {
        instances = _instances;
        assert.ok(xFooInitCalled);
        assert.ok(xFooDidInsertElementCalled);
        assert.ok(xBarInitCalled);
        assert.ok(xBarDidInsertElementCalled);
        assert.equal(foo.querySelector('h1').textContent, 'X-Foo');
        assert.equal(foo.querySelector('p').textContent, 'Hello Godfrey, I have been clicked 0 times (0 times combined)!');
        assert.ok(foo.textContent.indexOf('X-Bar') === -1);
        assert.equal(bar.querySelector('h1').textContent, 'X-Bar');
        assert.equal(bar.querySelector('button').textContent, 'Join 0 others in clicking me!');
        assert.ok(bar.textContent.indexOf('X-Foo') === -1);
        (0, _internalTestHelpers.runTask)(function () {
          _this10.click(foo.querySelector('x-foo'));
        });
        assert.equal(foo.querySelector('p').textContent, 'Hello Godfrey, I have been clicked 1 times (1 times combined)!');
        assert.equal(bar.querySelector('button').textContent, 'Join 1 others in clicking me!');
        (0, _internalTestHelpers.runTask)(function () {
          _this10.click(bar.querySelector('button'));

          _this10.click(bar.querySelector('button'));
        });
        assert.equal(foo.querySelector('p').textContent, 'Hello Godfrey, I have been clicked 1 times (3 times combined)!');
        assert.equal(bar.querySelector('button').textContent, 'Join 3 others in clicking me!');
      }).finally(function () {
        (0, _internalTestHelpers.runTask)(function () {
          instances.forEach(function (instance) {
            instance.destroy();
          });
        });
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/controller/tests/controller_test", ["ember-babel", "@ember/controller", "@ember/service", "@ember/-internals/runtime", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _controller, _service, _runtime, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Controller event handling',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Action can be handled by a function on actions object'] = function testActionCanBeHandledByAFunctionOnActionsObject(assert) {
      assert.expect(1);

      var TestController = _controller.default.extend({
        actions: {
          poke: function () {
            assert.ok(true, 'poked');
          }
        }
      });

      var controller = TestController.create();
      controller.send('poke');
    };

    _proto['@test A handled action can be bubbled to the target for continued processing'] = function testAHandledActionCanBeBubbledToTheTargetForContinuedProcessing(assert) {
      assert.expect(2);

      var TestController = _controller.default.extend({
        actions: {
          poke: function () {
            assert.ok(true, 'poked 1');
            return true;
          }
        }
      });

      var controller = TestController.create({
        target: _controller.default.extend({
          actions: {
            poke: function () {
              assert.ok(true, 'poked 2');
            }
          }
        }).create()
      });
      controller.send('poke');
    };

    _proto["@test Action can be handled by a superclass' actions object"] = function testActionCanBeHandledByASuperclassActionsObject(assert) {
      assert.expect(4);

      var SuperController = _controller.default.extend({
        actions: {
          foo: function () {
            assert.ok(true, 'foo');
          },
          bar: function (msg) {
            assert.equal(msg, 'HELLO');
          }
        }
      });

      var BarControllerMixin = _metal.Mixin.create({
        actions: {
          bar: function (msg) {
            assert.equal(msg, 'HELLO');

            this._super(msg);
          }
        }
      });

      var IndexController = SuperController.extend(BarControllerMixin, {
        actions: {
          baz: function () {
            assert.ok(true, 'baz');
          }
        }
      });
      var controller = IndexController.create({});
      controller.send('foo');
      controller.send('bar', 'HELLO');
      controller.send('baz');
    };

    _proto['@test .send asserts if called on a destroyed controller'] = function testSendAssertsIfCalledOnADestroyedController() {
      var owner = (0, _internalTestHelpers.buildOwner)();
      owner.register('controller:application', _controller.default.extend({
        toString: function () {
          return 'controller:rip-alley';
        }
      }));
      var controller = owner.lookup('controller:application');
      (0, _internalTestHelpers.runDestroy)(owner);
      expectAssertion(function () {
        controller.send('trigger-me-dead');
      }, "Attempted to call .send() with the action 'trigger-me-dead' on the destroyed object 'controller:rip-alley'.");
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Controller deprecations -> Controller Content -> Model Alias',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test `content` is not moved to `model` when `model` is unset'] = function testContentIsNotMovedToModelWhenModelIsUnset(assert) {
      assert.expect(2);
      var controller;
      ignoreDeprecation(function () {
        controller = _controller.default.extend({
          content: 'foo-bar'
        }).create();
      });
      assert.notEqual(controller.get('model'), 'foo-bar', 'model is set properly');
      assert.equal(controller.get('content'), 'foo-bar', 'content is not set properly');
    };

    _proto2['@test specifying `content` (without `model` specified) does not result in deprecation'] = function testSpecifyingContentWithoutModelSpecifiedDoesNotResultInDeprecation(assert) {
      assert.expect(2);
      expectNoDeprecation();

      var controller = _controller.default.extend({
        content: 'foo-bar'
      }).create();

      assert.equal((0, _metal.get)(controller, 'content'), 'foo-bar');
    };

    _proto2['@test specifying `content` (with `model` specified) does not result in deprecation'] = function testSpecifyingContentWithModelSpecifiedDoesNotResultInDeprecation(assert) {
      assert.expect(3);
      expectNoDeprecation();

      var controller = _controller.default.extend({
        content: 'foo-bar',
        model: 'blammo'
      }).create();

      assert.equal((0, _metal.get)(controller, 'content'), 'foo-bar');
      assert.equal((0, _metal.get)(controller, 'model'), 'blammo');
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Controller deprecations -> Controller injected properties',
  /*#__PURE__*/
  function (_AbstractTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class3, _AbstractTestCase3);

    function _class3() {
      return _AbstractTestCase3.apply(this, arguments) || this;
    }

    var _proto3 = _class3.prototype;

    _proto3['@test defining a controller on a non-controller should fail assertion'] = function testDefiningAControllerOnANonControllerShouldFailAssertion() {
      expectAssertion(function () {
        var owner = (0, _internalTestHelpers.buildOwner)();

        var AnObject = _runtime.Object.extend({
          foo: (0, _controller.inject)('bar')
        });

        owner.register('controller:bar', _runtime.Object.extend());
        owner.register('foo:main', AnObject);
        owner.lookup('foo:main');
      }, /Defining `foo` as an injected controller property on a non-controller \(`foo:main`\) is not allowed/);
    };

    _proto3['@test controllers can be injected into controllers'] = function testControllersCanBeInjectedIntoControllers(assert) {
      var owner = (0, _internalTestHelpers.buildOwner)();
      owner.register('controller:post', _controller.default.extend({
        postsController: (0, _controller.inject)('posts')
      }));
      owner.register('controller:posts', _controller.default.extend());
      var postController = owner.lookup('controller:post');
      var postsController = owner.lookup('controller:posts');
      assert.equal(postsController, postController.get('postsController'), 'controller.posts is injected');
    };

    _proto3['@test services can be injected into controllers'] = function testServicesCanBeInjectedIntoControllers(assert) {
      var owner = (0, _internalTestHelpers.buildOwner)();
      owner.register('controller:application', _controller.default.extend({
        authService: (0, _service.inject)('auth')
      }));
      owner.register('service:auth', _service.default.extend());
      var appController = owner.lookup('controller:application');
      var authService = owner.lookup('service:auth');
      assert.equal(authService, appController.get('authService'), 'service.auth is injected');
    };

    return _class3;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/debug/tests/handlers-test", ["ember-babel", "@ember/debug/lib/handlers", "internal-test-helpers"], function (_emberBabel, _handlers, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-debug: registerHandler',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      delete _handlers.HANDLERS.blarz;
    };

    _proto['@test calls handler on `invoke` when `falsey`'] = function testCallsHandlerOnInvokeWhenFalsey(assert) {
      assert.expect(2);

      function handler(message) {
        assert.ok(true, 'called handler');
        assert.equal(message, 'Foo bar');
      }

      (0, _handlers.registerHandler)('blarz', handler);
      (0, _handlers.invoke)('blarz', 'Foo bar', false);
    };

    _proto['@test does not call handler on `invoke` when `truthy`'] = function testDoesNotCallHandlerOnInvokeWhenTruthy(assert) {
      assert.expect(0);

      function handler() {
        assert.ok(false, 'called handler');
      }

      (0, _handlers.registerHandler)('blarz', handler);
      (0, _handlers.invoke)('blarz', 'Foo bar', true);
    };

    _proto['@test calling `invoke` without handlers does not throw an error'] = function testCallingInvokeWithoutHandlersDoesNotThrowAnError(assert) {
      assert.expect(0);
      (0, _handlers.invoke)('blarz', 'Foo bar', false);
    };

    _proto['@test invoking `next` argument calls the next handler'] = function testInvokingNextArgumentCallsTheNextHandler(assert) {
      assert.expect(2);

      function handler1() {
        assert.ok(true, 'called handler1');
      }

      function handler2(message, options, next) {
        assert.ok(true, 'called handler2');
        next(message, options);
      }

      (0, _handlers.registerHandler)('blarz', handler1);
      (0, _handlers.registerHandler)('blarz', handler2);
      (0, _handlers.invoke)('blarz', 'Foo', false);
    };

    _proto['@test invoking `next` when no other handlers exists does not error'] = function testInvokingNextWhenNoOtherHandlersExistsDoesNotError(assert) {
      assert.expect(1);

      function handler(message, options, next) {
        assert.ok(true, 'called handler1');
        next(message, options);
      }

      (0, _handlers.registerHandler)('blarz', handler);
      (0, _handlers.invoke)('blarz', 'Foo', false);
    };

    _proto['@test handlers are called in the proper order'] = function testHandlersAreCalledInTheProperOrder(assert) {
      assert.expect(11);
      var expectedMessage = 'This is the message';
      var expectedOptions = {
        id: 'foo-bar'
      };
      var expected = ['first', 'second', 'third', 'fourth', 'fifth'];
      var actualCalls = [];

      function generateHandler(item) {
        return function (message, options, next) {
          assert.equal(message, expectedMessage, "message supplied to " + item + " handler is correct");
          assert.equal(options, expectedOptions, "options supplied to " + item + " handler is correct");
          actualCalls.push(item);
          next(message, options);
        };
      }

      expected.forEach(function (item) {
        return (0, _handlers.registerHandler)('blarz', generateHandler(item));
      });
      (0, _handlers.invoke)('blarz', expectedMessage, false, expectedOptions);
      assert.deepEqual(actualCalls, expected.reverse(), 'handlers were called in proper order');
    };

    _proto['@test not invoking `next` prevents further handlers from being called'] = function testNotInvokingNextPreventsFurtherHandlersFromBeingCalled(assert) {
      assert.expect(1);

      function handler1() {
        assert.ok(false, 'called handler1');
      }

      function handler2() {
        assert.ok(true, 'called handler2');
      }

      (0, _handlers.registerHandler)('blarz', handler1);
      (0, _handlers.registerHandler)('blarz', handler2);
      (0, _handlers.invoke)('blarz', 'Foo', false);
    };

    _proto['@test handlers can call `next` with custom message and/or options'] = function testHandlersCanCallNextWithCustomMessageAndOrOptions(assert) {
      assert.expect(4);
      var initialMessage = 'initial message';
      var initialOptions = {
        id: 'initial-options'
      };
      var handler2Message = 'Handler2 Message';
      var handler2Options = {
        id: 'handler-2'
      };

      function handler1(message, options) {
        assert.equal(message, handler2Message, 'handler2 message provided to handler1');
        assert.equal(options, handler2Options, 'handler2 options provided to handler1');
      }

      function handler2(message, options, next) {
        assert.equal(message, initialMessage, 'initial message provided to handler2');
        assert.equal(options, initialOptions, 'initial options proivided to handler2');
        next(handler2Message, handler2Options);
      }

      (0, _handlers.registerHandler)('blarz', handler1);
      (0, _handlers.registerHandler)('blarz', handler2);
      (0, _handlers.invoke)('blarz', initialMessage, false, initialOptions);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/debug/tests/main_test", ["ember-babel", "@ember/-internals/environment", "@ember/-internals/runtime", "@ember/debug/lib/handlers", "@ember/debug/lib/deprecate", "@ember/debug/lib/warn", "@ember/debug/index", "internal-test-helpers"], function (_emberBabel, _environment, _runtime, _handlers, _deprecate, _warn, _index, _internalTestHelpers) {
  "use strict";

  var originalEnvValue;
  var originalDeprecateHandler;
  var originalWarnHandler;
  var originalConsoleWarn = console.warn; // eslint-disable-line no-console

  var noop = function () {};

  (0, _internalTestHelpers.moduleFor)('ember-debug',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      var _this;

      _this = _TestCase.call(this) || this;
      originalEnvValue = _environment.ENV.RAISE_ON_DEPRECATION;
      originalDeprecateHandler = _handlers.HANDLERS.deprecate;
      originalWarnHandler = _handlers.HANDLERS.warn;
      _environment.ENV.RAISE_ON_DEPRECATION = true;
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _handlers.HANDLERS.deprecate = originalDeprecateHandler;
      _handlers.HANDLERS.warn = originalWarnHandler;
      _environment.ENV.RAISE_ON_DEPRECATION = originalEnvValue;
    };

    _proto.afterEach = function afterEach() {
      console.warn = originalConsoleWarn; // eslint-disable-line no-console
    };

    _proto['@test deprecate does not throw if RAISE_ON_DEPRECATION is false'] = function testDeprecateDoesNotThrowIfRAISE_ON_DEPRECATIONIsFalse(assert) {
      assert.expect(1);
      console.warn = noop; // eslint-disable-line no-console

      _environment.ENV.RAISE_ON_DEPRECATION = false;

      try {
        (0, _index.deprecate)('Should not throw', false, {
          id: 'test',
          until: 'forever'
        });
        assert.ok(true, 'deprecate did not throw');
      } catch (e) {
        assert.ok(false, "Expected deprecate not to throw but it did: " + e.message);
      }
    };

    _proto['@test deprecate resets deprecation level to RAISE if ENV.RAISE_ON_DEPRECATION is set'] = function testDeprecateResetsDeprecationLevelToRAISEIfENVRAISE_ON_DEPRECATIONIsSet(assert) {
      assert.expect(2);
      console.warn = noop; // eslint-disable-line no-console

      _environment.ENV.RAISE_ON_DEPRECATION = false;

      try {
        (0, _index.deprecate)('Should not throw', false, {
          id: 'test',
          until: 'forever'
        });
        assert.ok(true, 'deprecate did not throw');
      } catch (e) {
        assert.ok(false, "Expected deprecate not to throw but it did: " + e.message);
      }

      _environment.ENV.RAISE_ON_DEPRECATION = true;
      assert.throws(function () {
        (0, _index.deprecate)('Should throw', false, {
          id: 'test',
          until: 'forever'
        });
      }, /Should throw/);
    };

    _proto['@test When ENV.RAISE_ON_DEPRECATION is true, it is still possible to silence a deprecation by id'] = function testWhenENVRAISE_ON_DEPRECATIONIsTrueItIsStillPossibleToSilenceADeprecationById(assert) {
      assert.expect(3);
      _environment.ENV.RAISE_ON_DEPRECATION = true;
      (0, _deprecate.registerHandler)(function (message, options, next) {
        if (!options || options.id !== 'my-deprecation') {
          next.apply(void 0, arguments);
        }
      });

      try {
        (0, _index.deprecate)('should be silenced with matching id', false, {
          id: 'my-deprecation',
          until: 'forever'
        });
        assert.ok(true, 'Did not throw when level is set by id');
      } catch (e) {
        assert.ok(false, "Expected deprecate not to throw but it did: " + e.message);
      }

      assert.throws(function () {
        (0, _index.deprecate)('Should throw with no matching id', false, {
          id: 'test',
          until: 'forever'
        });
      }, /Should throw with no matching id/);
      assert.throws(function () {
        (0, _index.deprecate)('Should throw with non-matching id', false, {
          id: 'other-id',
          until: 'forever'
        });
      }, /Should throw with non-matching id/);
    };

    _proto['@test deprecate throws deprecation if second argument is falsy'] = function testDeprecateThrowsDeprecationIfSecondArgumentIsFalsy(assert) {
      assert.expect(3);
      assert.throws(function () {
        return (0, _index.deprecate)('Deprecation is thrown', false, {
          id: 'test',
          until: 'forever'
        });
      });
      assert.throws(function () {
        return (0, _index.deprecate)('Deprecation is thrown', '', {
          id: 'test',
          until: 'forever'
        });
      });
      assert.throws(function () {
        return (0, _index.deprecate)('Deprecation is thrown', 0, {
          id: 'test',
          until: 'forever'
        });
      });
    };

    _proto['@test deprecate does not invoke a function as the second argument'] = function testDeprecateDoesNotInvokeAFunctionAsTheSecondArgument(assert) {
      assert.expect(1);
      (0, _index.deprecate)('Deprecation is thrown', function () {
        assert.ok(false, 'this function should not be invoked');
      }, {
        id: 'test',
        until: 'forever'
      });
      assert.ok(true, 'deprecations were not thrown');
    };

    _proto['@test deprecate does not throw deprecations if second argument is truthy'] = function testDeprecateDoesNotThrowDeprecationsIfSecondArgumentIsTruthy(assert) {
      assert.expect(1);
      (0, _index.deprecate)('Deprecation is thrown', true, {
        id: 'test',
        until: 'forever'
      });
      (0, _index.deprecate)('Deprecation is thrown', '1', {
        id: 'test',
        until: 'forever'
      });
      (0, _index.deprecate)('Deprecation is thrown', 1, {
        id: 'test',
        until: 'forever'
      });
      assert.ok(true, 'deprecations were not thrown');
    };

    _proto['@test assert throws if second argument is falsy'] = function testAssertThrowsIfSecondArgumentIsFalsy(assert) {
      assert.expect(3);
      assert.throws(function () {
        return (0, _index.assert)('Assertion is thrown', false);
      });
      assert.throws(function () {
        return (0, _index.assert)('Assertion is thrown', '');
      });
      assert.throws(function () {
        return (0, _index.assert)('Assertion is thrown', 0);
      });
    };

    _proto['@test assert does not throw if second argument is a function'] = function testAssertDoesNotThrowIfSecondArgumentIsAFunction(assert) {
      assert.expect(1);
      (0, _index.assert)('Assertion is thrown', function () {
        return true;
      });
      assert.ok(true, 'assertions were not thrown');
    };

    _proto['@test assert does not throw if second argument is falsy'] = function testAssertDoesNotThrowIfSecondArgumentIsFalsy(assert) {
      assert.expect(1);
      (0, _index.assert)('Assertion is thrown', true);
      (0, _index.assert)('Assertion is thrown', '1');
      (0, _index.assert)('Assertion is thrown', 1);
      assert.ok(true, 'assertions were not thrown');
    };

    _proto['@test assert does not throw if second argument is an object'] = function testAssertDoesNotThrowIfSecondArgumentIsAnObject(assert) {
      assert.expect(1);

      var Igor = _runtime.Object.extend();

      (0, _index.assert)('is truthy', Igor);
      (0, _index.assert)('is truthy', Igor.create());
      assert.ok(true, 'assertions were not thrown');
    };

    _proto['@test deprecate does not throw a deprecation at log and silence'] = function testDeprecateDoesNotThrowADeprecationAtLogAndSilence(assert) {
      assert.expect(4);
      var id = 'ABC';
      var until = 'forever';
      var shouldThrow = false;
      (0, _deprecate.registerHandler)(function (message, options) {
        if (options && options.id === id) {
          if (shouldThrow) {
            throw new Error(message);
          }
        }
      });

      try {
        (0, _index.deprecate)('Deprecation for testing purposes', false, {
          id: id,
          until: until
        });
        assert.ok(true, 'Deprecation did not throw');
      } catch (e) {
        assert.ok(false, 'Deprecation was thrown despite being added to blacklist');
      }

      try {
        (0, _index.deprecate)('Deprecation for testing purposes', false, {
          id: id,
          until: until
        });
        assert.ok(true, 'Deprecation did not throw');
      } catch (e) {
        assert.ok(false, 'Deprecation was thrown despite being added to blacklist');
      }

      shouldThrow = true;
      assert.throws(function () {
        (0, _index.deprecate)('Deprecation is thrown', false, {
          id: id,
          until: until
        });
      });
      assert.throws(function () {
        (0, _index.deprecate)('Deprecation is thrown', false, {
          id: id,
          until: until
        });
      });
    };

    _proto['@test deprecate without options triggers an assertion'] = function testDeprecateWithoutOptionsTriggersAnAssertion(assert) {
      assert.expect(2);
      assert.throws(function () {
        return (0, _index.deprecate)('foo');
      }, new RegExp(_deprecate.missingOptionsDeprecation), 'proper assertion is triggered when options is missing');
      assert.throws(function () {
        return (0, _index.deprecate)('foo', false, {});
      }, new RegExp(_deprecate.missingOptionsDeprecation), 'proper assertion is triggered when options is missing');
    };

    _proto['@test deprecate without options.id triggers an assertion'] = function testDeprecateWithoutOptionsIdTriggersAnAssertion(assert) {
      assert.expect(1);
      assert.throws(function () {
        return (0, _index.deprecate)('foo', false, {
          until: 'forever'
        });
      }, new RegExp(_deprecate.missingOptionsIdDeprecation), 'proper assertion is triggered when options.id is missing');
    };

    _proto['@test deprecate without options.until triggers an assertion'] = function testDeprecateWithoutOptionsUntilTriggersAnAssertion(assert) {
      assert.expect(1);
      assert.throws(function () {
        return (0, _index.deprecate)('foo', false, {
          id: 'test'
        });
      }, new RegExp(_deprecate.missingOptionsUntilDeprecation), 'proper assertion is triggered when options.until is missing');
    };

    _proto['@test warn without options triggers an assert'] = function testWarnWithoutOptionsTriggersAnAssert(assert) {
      assert.expect(1);
      assert.throws(function () {
        return (0, _index.warn)('foo');
      }, new RegExp(_warn.missingOptionsDeprecation), 'deprecation is triggered when options is missing');
    };

    _proto['@test warn without options.id triggers an assertion'] = function testWarnWithoutOptionsIdTriggersAnAssertion(assert) {
      assert.expect(1);
      assert.throws(function () {
        return (0, _index.warn)('foo', false, {});
      }, new RegExp(_warn.missingOptionsIdDeprecation), 'deprecation is triggered when options is missing');
    };

    _proto['@test warn without options.id nor test triggers an assertion'] = function testWarnWithoutOptionsIdNorTestTriggersAnAssertion(assert) {
      assert.expect(1);
      assert.throws(function () {
        return (0, _index.warn)('foo', {});
      }, new RegExp(_warn.missingOptionsIdDeprecation), 'deprecation is triggered when options is missing');
    };

    _proto['@test warn without test but with options does not trigger an assertion'] = function testWarnWithoutTestButWithOptionsDoesNotTriggerAnAssertion(assert) {
      assert.expect(1);
      (0, _warn.registerHandler)(function (message) {
        assert.equal(message, 'foo', 'warning was triggered');
      });
      (0, _index.warn)('foo', {
        id: 'ember-debug.do-not-raise'
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/engine/tests/engine_initializers_test", ["ember-babel", "@ember/runloop", "@ember/engine", "internal-test-helpers"], function (_emberBabel, _runloop, _engine, _internalTestHelpers) {
  "use strict";

  var MyEngine, myEngine, myEngineInstance;
  (0, _internalTestHelpers.moduleFor)('Engine initializers',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _runloop.run)(function () {
        if (myEngineInstance) {
          myEngineInstance.destroy();
          myEngineInstance = null;
        }

        if (myEngine) {
          myEngine.destroy();
          myEngine = null;
        }
      });
    };

    _proto["@test initializers require proper 'name' and 'initialize' properties"] = function testInitializersRequireProperNameAndInitializeProperties() {
      MyEngine = _engine.default.extend();
      expectAssertion(function () {
        (0, _runloop.run)(function () {
          MyEngine.initializer({
            name: 'initializer'
          });
        });
      });
      expectAssertion(function () {
        (0, _runloop.run)(function () {
          MyEngine.initializer({
            initialize: function () {}
          });
        });
      });
    };

    _proto['@test initializers are passed an Engine'] = function testInitializersArePassedAnEngine(assert) {
      MyEngine = _engine.default.extend();
      MyEngine.initializer({
        name: 'initializer',
        initialize: function (engine) {
          assert.ok(engine instanceof _engine.default, 'initialize is passed an Engine');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = myEngine.buildInstance();
    };

    _proto['@test initializers can be registered in a specified order'] = function testInitializersCanBeRegisteredInASpecifiedOrder(assert) {
      var order = [];
      MyEngine = _engine.default.extend();
      MyEngine.initializer({
        name: 'fourth',
        after: 'third',
        initialize: function () {
          order.push('fourth');
        }
      });
      MyEngine.initializer({
        name: 'second',
        after: 'first',
        before: 'third',
        initialize: function () {
          order.push('second');
        }
      });
      MyEngine.initializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize: function () {
          order.push('fifth');
        }
      });
      MyEngine.initializer({
        name: 'first',
        before: 'second',
        initialize: function () {
          order.push('first');
        }
      });
      MyEngine.initializer({
        name: 'third',
        initialize: function () {
          order.push('third');
        }
      });
      MyEngine.initializer({
        name: 'sixth',
        initialize: function () {
          order.push('sixth');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = myEngine.buildInstance();
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    };

    _proto['@test initializers can be registered in a specified order as an array'] = function testInitializersCanBeRegisteredInASpecifiedOrderAsAnArray(assert) {
      var order = [];
      MyEngine = _engine.default.extend();
      MyEngine.initializer({
        name: 'third',
        initialize: function () {
          order.push('third');
        }
      });
      MyEngine.initializer({
        name: 'second',
        after: 'first',
        before: ['third', 'fourth'],
        initialize: function () {
          order.push('second');
        }
      });
      MyEngine.initializer({
        name: 'fourth',
        after: ['second', 'third'],
        initialize: function () {
          order.push('fourth');
        }
      });
      MyEngine.initializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize: function () {
          order.push('fifth');
        }
      });
      MyEngine.initializer({
        name: 'first',
        before: ['second'],
        initialize: function () {
          order.push('first');
        }
      });
      MyEngine.initializer({
        name: 'sixth',
        initialize: function () {
          order.push('sixth');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = myEngine.buildInstance();
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    };

    _proto['@test initializers can have multiple dependencies'] = function testInitializersCanHaveMultipleDependencies(assert) {
      var order = [];
      MyEngine = _engine.default.extend();
      var a = {
        name: 'a',
        before: 'b',
        initialize: function () {
          order.push('a');
        }
      };
      var b = {
        name: 'b',
        initialize: function () {
          order.push('b');
        }
      };
      var c = {
        name: 'c',
        after: 'b',
        initialize: function () {
          order.push('c');
        }
      };
      var afterB = {
        name: 'after b',
        after: 'b',
        initialize: function () {
          order.push('after b');
        }
      };
      var afterC = {
        name: 'after c',
        after: 'c',
        initialize: function () {
          order.push('after c');
        }
      };
      MyEngine.initializer(b);
      MyEngine.initializer(a);
      MyEngine.initializer(afterC);
      MyEngine.initializer(afterB);
      MyEngine.initializer(c);
      myEngine = MyEngine.create();
      myEngineInstance = myEngine.buildInstance();
      assert.ok(order.indexOf(a.name) < order.indexOf(b.name), 'a < b');
      assert.ok(order.indexOf(b.name) < order.indexOf(c.name), 'b < c');
      assert.ok(order.indexOf(b.name) < order.indexOf(afterB.name), 'b < afterB');
      assert.ok(order.indexOf(c.name) < order.indexOf(afterC.name), 'c < afterC');
    };

    _proto['@test initializers set on Engine subclasses are not shared between engines'] = function testInitializersSetOnEngineSubclassesAreNotSharedBetweenEngines(assert) {
      var firstInitializerRunCount = 0;
      var secondInitializerRunCount = 0;

      var FirstEngine = _engine.default.extend();

      FirstEngine.initializer({
        name: 'first',
        initialize: function () {
          firstInitializerRunCount++;
        }
      });

      var SecondEngine = _engine.default.extend();

      SecondEngine.initializer({
        name: 'second',
        initialize: function () {
          secondInitializerRunCount++;
        }
      });
      var firstEngine = FirstEngine.create();
      var firstEngineInstance = firstEngine.buildInstance();
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run');
      assert.equal(secondInitializerRunCount, 0, 'first initializer only was run');
      var secondEngine = SecondEngine.create();
      var secondEngineInstance = secondEngine.buildInstance();
      assert.equal(firstInitializerRunCount, 1, 'second initializer only was run');
      assert.equal(secondInitializerRunCount, 1, 'second initializer only was run');
      (0, _runloop.run)(function () {
        firstEngineInstance.destroy();
        secondEngineInstance.destroy();
        firstEngine.destroy();
        secondEngine.destroy();
      });
    };

    _proto['@test initializers are concatenated'] = function testInitializersAreConcatenated(assert) {
      var firstInitializerRunCount = 0;
      var secondInitializerRunCount = 0;

      var FirstEngine = _engine.default.extend();

      FirstEngine.initializer({
        name: 'first',
        initialize: function () {
          firstInitializerRunCount++;
        }
      });
      var SecondEngine = FirstEngine.extend();
      SecondEngine.initializer({
        name: 'second',
        initialize: function () {
          secondInitializerRunCount++;
        }
      });
      var firstEngine = FirstEngine.create();
      var firstEngineInstance = firstEngine.buildInstance();
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run when base class created');
      assert.equal(secondInitializerRunCount, 0, 'second initializer was not run when first base class created');
      firstInitializerRunCount = 0;
      var secondEngine = SecondEngine.create();
      var secondEngineInstance = secondEngine.buildInstance();
      assert.equal(firstInitializerRunCount, 1, 'first initializer was run when subclass created');
      assert.equal(secondInitializerRunCount, 1, 'second initializers was run when subclass created');
      (0, _runloop.run)(function () {
        firstEngineInstance.destroy();
        secondEngineInstance.destroy();
        firstEngine.destroy();
        secondEngine.destroy();
      });
    };

    _proto['@test initializers are per-engine'] = function testInitializersArePerEngine(assert) {
      assert.expect(2);

      var FirstEngine = _engine.default.extend();

      FirstEngine.initializer({
        name: 'abc',
        initialize: function () {}
      });
      expectAssertion(function () {
        FirstEngine.initializer({
          name: 'abc',
          initialize: function () {}
        });
      });

      var SecondEngine = _engine.default.extend();

      SecondEngine.instanceInitializer({
        name: 'abc',
        initialize: function () {}
      });
      assert.ok(true, 'Two engines can have initializers named the same.');
    };

    _proto['@test initializers are executed in their own context'] = function testInitializersAreExecutedInTheirOwnContext(assert) {
      assert.expect(1);
      MyEngine = _engine.default.extend();
      MyEngine.initializer({
        name: 'coolInitializer',
        myProperty: 'cool',
        initialize: function () {
          assert.equal(this.myProperty, 'cool', 'should have access to its own context');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = myEngine.buildInstance();
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/engine/tests/engine_instance_initializers_test", ["ember-babel", "@ember/runloop", "@ember/engine", "@ember/engine/instance", "internal-test-helpers"], function (_emberBabel, _runloop, _engine, _instance, _internalTestHelpers) {
  "use strict";

  var MyEngine, myEngine, myEngineInstance;

  function buildEngineInstance(EngineClass) {
    var engineInstance = EngineClass.buildInstance();
    (0, _engine.setEngineParent)(engineInstance, {
      lookup: function () {
        return {};
      },
      resolveRegistration: function () {
        return {};
      }
    });
    return engineInstance;
  }

  (0, _internalTestHelpers.moduleFor)('Engine instance initializers',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _TestCase.prototype.teardown.call(this);

      (0, _runloop.run)(function () {
        if (myEngineInstance) {
          myEngineInstance.destroy();
        }

        if (myEngine) {
          myEngine.destroy();
        }
      });
      MyEngine = myEngine = myEngineInstance = undefined;
    };

    _proto["@test initializers require proper 'name' and 'initialize' properties"] = function testInitializersRequireProperNameAndInitializeProperties() {
      MyEngine = _engine.default.extend();
      expectAssertion(function () {
        (0, _runloop.run)(function () {
          MyEngine.instanceInitializer({
            name: 'initializer'
          });
        });
      });
      expectAssertion(function () {
        (0, _runloop.run)(function () {
          MyEngine.instanceInitializer({
            initialize: function () {}
          });
        });
      });
    };

    _proto['@test initializers are passed an engine instance'] = function testInitializersArePassedAnEngineInstance(assert) {
      MyEngine = _engine.default.extend();
      MyEngine.instanceInitializer({
        name: 'initializer',
        initialize: function (instance) {
          assert.ok(instance instanceof _instance.default, 'initialize is passed an engine instance');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = buildEngineInstance(myEngine);
      return myEngineInstance.boot();
    };

    _proto['@test initializers can be registered in a specified order'] = function testInitializersCanBeRegisteredInASpecifiedOrder(assert) {
      var order = [];
      MyEngine = _engine.default.extend();
      MyEngine.instanceInitializer({
        name: 'fourth',
        after: 'third',
        initialize: function () {
          order.push('fourth');
        }
      });
      MyEngine.instanceInitializer({
        name: 'second',
        after: 'first',
        before: 'third',
        initialize: function () {
          order.push('second');
        }
      });
      MyEngine.instanceInitializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize: function () {
          order.push('fifth');
        }
      });
      MyEngine.instanceInitializer({
        name: 'first',
        before: 'second',
        initialize: function () {
          order.push('first');
        }
      });
      MyEngine.instanceInitializer({
        name: 'third',
        initialize: function () {
          order.push('third');
        }
      });
      MyEngine.instanceInitializer({
        name: 'sixth',
        initialize: function () {
          order.push('sixth');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = buildEngineInstance(myEngine);
      return myEngineInstance.boot().then(function () {
        assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
      });
    };

    _proto['@test initializers can be registered in a specified order as an array'] = function testInitializersCanBeRegisteredInASpecifiedOrderAsAnArray(assert) {
      var order = [];
      MyEngine = _engine.default.extend();
      MyEngine.instanceInitializer({
        name: 'third',
        initialize: function () {
          order.push('third');
        }
      });
      MyEngine.instanceInitializer({
        name: 'second',
        after: 'first',
        before: ['third', 'fourth'],
        initialize: function () {
          order.push('second');
        }
      });
      MyEngine.instanceInitializer({
        name: 'fourth',
        after: ['second', 'third'],
        initialize: function () {
          order.push('fourth');
        }
      });
      MyEngine.instanceInitializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize: function () {
          order.push('fifth');
        }
      });
      MyEngine.instanceInitializer({
        name: 'first',
        before: ['second'],
        initialize: function () {
          order.push('first');
        }
      });
      MyEngine.instanceInitializer({
        name: 'sixth',
        initialize: function () {
          order.push('sixth');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = buildEngineInstance(myEngine);
      return myEngineInstance.boot().then(function () {
        assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
      });
    };

    _proto['@test initializers can have multiple dependencies'] = function testInitializersCanHaveMultipleDependencies(assert) {
      var order = [];
      MyEngine = _engine.default.extend();
      var a = {
        name: 'a',
        before: 'b',
        initialize: function () {
          order.push('a');
        }
      };
      var b = {
        name: 'b',
        initialize: function () {
          order.push('b');
        }
      };
      var c = {
        name: 'c',
        after: 'b',
        initialize: function () {
          order.push('c');
        }
      };
      var afterB = {
        name: 'after b',
        after: 'b',
        initialize: function () {
          order.push('after b');
        }
      };
      var afterC = {
        name: 'after c',
        after: 'c',
        initialize: function () {
          order.push('after c');
        }
      };
      MyEngine.instanceInitializer(b);
      MyEngine.instanceInitializer(a);
      MyEngine.instanceInitializer(afterC);
      MyEngine.instanceInitializer(afterB);
      MyEngine.instanceInitializer(c);
      myEngine = MyEngine.create();
      myEngineInstance = buildEngineInstance(myEngine);
      return myEngineInstance.boot().then(function () {
        assert.ok(order.indexOf(a.name) < order.indexOf(b.name), 'a < b');
        assert.ok(order.indexOf(b.name) < order.indexOf(c.name), 'b < c');
        assert.ok(order.indexOf(b.name) < order.indexOf(afterB.name), 'b < afterB');
        assert.ok(order.indexOf(c.name) < order.indexOf(afterC.name), 'c < afterC');
      });
    };

    _proto['@test initializers set on Engine subclasses should not be shared between engines'] = function testInitializersSetOnEngineSubclassesShouldNotBeSharedBetweenEngines(assert) {
      var firstInitializerRunCount = 0;
      var secondInitializerRunCount = 0;

      var FirstEngine = _engine.default.extend();

      var firstEngine, firstEngineInstance;
      FirstEngine.instanceInitializer({
        name: 'first',
        initialize: function () {
          firstInitializerRunCount++;
        }
      });

      var SecondEngine = _engine.default.extend();

      var secondEngine, secondEngineInstance;
      SecondEngine.instanceInitializer({
        name: 'second',
        initialize: function () {
          secondInitializerRunCount++;
        }
      });
      firstEngine = FirstEngine.create();
      firstEngineInstance = buildEngineInstance(firstEngine);
      return firstEngineInstance.boot().then(function () {
        assert.equal(firstInitializerRunCount, 1, 'first initializer only was run');
        assert.equal(secondInitializerRunCount, 0, 'first initializer only was run');
        secondEngine = SecondEngine.create();
        secondEngineInstance = buildEngineInstance(secondEngine);
        return secondEngineInstance.boot();
      }).then(function () {
        assert.equal(firstInitializerRunCount, 1, 'second initializer only was run');
        assert.equal(secondInitializerRunCount, 1, 'second initializer only was run');
        (0, _runloop.run)(function () {
          firstEngineInstance.destroy();
          secondEngineInstance.destroy();
          firstEngine.destroy();
          secondEngine.destroy();
        });
      });
    };

    _proto['@test initializers are concatenated'] = function testInitializersAreConcatenated(assert) {
      var firstInitializerRunCount = 0;
      var secondInitializerRunCount = 0;

      var FirstEngine = _engine.default.extend();

      FirstEngine.instanceInitializer({
        name: 'first',
        initialize: function () {
          firstInitializerRunCount++;
        }
      });
      var SecondEngine = FirstEngine.extend();
      SecondEngine.instanceInitializer({
        name: 'second',
        initialize: function () {
          secondInitializerRunCount++;
        }
      });
      var firstEngine = FirstEngine.create();
      var firstEngineInstance = buildEngineInstance(firstEngine);
      var secondEngine, secondEngineInstance;
      return firstEngineInstance.boot().then(function () {
        assert.equal(firstInitializerRunCount, 1, 'first initializer only was run when base class created');
        assert.equal(secondInitializerRunCount, 0, 'second initializer was not run when first base class created');
        firstInitializerRunCount = 0;
        secondEngine = SecondEngine.create();
        secondEngineInstance = buildEngineInstance(secondEngine);
        return secondEngineInstance.boot();
      }).then(function () {
        assert.equal(firstInitializerRunCount, 1, 'first initializer was run when subclass created');
        assert.equal(secondInitializerRunCount, 1, 'second initializers was run when subclass created');
        (0, _runloop.run)(function () {
          firstEngineInstance.destroy();
          secondEngineInstance.destroy();
          firstEngine.destroy();
          secondEngine.destroy();
        });
      });
    };

    _proto['@test initializers are per-engine'] = function testInitializersArePerEngine(assert) {
      assert.expect(2);

      var FirstEngine = _engine.default.extend();

      FirstEngine.instanceInitializer({
        name: 'abc',
        initialize: function () {}
      });
      expectAssertion(function () {
        FirstEngine.instanceInitializer({
          name: 'abc',
          initialize: function () {}
        });
      });

      var SecondEngine = _engine.default.extend();

      SecondEngine.instanceInitializer({
        name: 'abc',
        initialize: function () {}
      });
      assert.ok(true, 'Two engines can have initializers named the same.');
    };

    _proto['@test initializers are executed in their own context'] = function testInitializersAreExecutedInTheirOwnContext(assert) {
      assert.expect(1);

      var MyEngine = _engine.default.extend();

      MyEngine.instanceInitializer({
        name: 'coolInitializer',
        myProperty: 'cool',
        initialize: function () {
          assert.equal(this.myProperty, 'cool', 'should have access to its own context');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = buildEngineInstance(myEngine);
      return myEngineInstance.boot();
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/engine/tests/engine_instance_test", ["ember-babel", "@ember/engine", "@ember/engine/instance", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _engine, _instance, _runloop, _internalTestHelpers) {
  "use strict";

  var engine, engineInstance;
  (0, _internalTestHelpers.moduleFor)('EngineInstance',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      var _this;

      _this = _TestCase.call(this) || this;
      (0, _runloop.run)(function () {
        engine = _engine.default.create({
          router: null
        });
      });
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      if (engineInstance) {
        (0, _runloop.run)(engineInstance, 'destroy');
        engineInstance = undefined;
      }

      if (engine) {
        (0, _runloop.run)(engine, 'destroy');
        engine = undefined;
      }
    };

    _proto['@test an engine instance can be created based upon a base engine'] = function testAnEngineInstanceCanBeCreatedBasedUponABaseEngine(assert) {
      (0, _runloop.run)(function () {
        engineInstance = _instance.default.create({
          base: engine
        });
      });
      assert.ok(engineInstance, 'instance should be created');
      assert.equal(engineInstance.base, engine, 'base should be set to engine');
    };

    _proto['@test unregistering a factory clears all cached instances of that factory'] = function testUnregisteringAFactoryClearsAllCachedInstancesOfThatFactory(assert) {
      assert.expect(3);
      engineInstance = (0, _runloop.run)(function () {
        return _instance.default.create({
          base: engine
        });
      });
      var PostComponent = (0, _internalTestHelpers.factory)();
      engineInstance.register('component:post', PostComponent);
      var postComponent1 = engineInstance.lookup('component:post');
      assert.ok(postComponent1, 'lookup creates instance');
      engineInstance.unregister('component:post');
      engineInstance.register('component:post', PostComponent);
      var postComponent2 = engineInstance.lookup('component:post');
      assert.ok(postComponent2, 'lookup creates instance');
      assert.notStrictEqual(postComponent1, postComponent2, 'lookup creates a brand new instance because previous one was reset');
    };

    _proto['@test can be booted when its parent has been set'] = function testCanBeBootedWhenItsParentHasBeenSet(assert) {
      assert.expect(3);
      engineInstance = (0, _runloop.run)(function () {
        return _instance.default.create({
          base: engine
        });
      });
      expectAssertion(function () {
        engineInstance._bootSync();
      }, "An engine instance's parent must be set via `setEngineParent(engine, parent)` prior to calling `engine.boot()`.");
      (0, _engine.setEngineParent)(engineInstance, {}); // Stub `cloneParentDependencies`, the internals of which are tested along
      // with application instances.

      engineInstance.cloneParentDependencies = function () {
        assert.ok(true, 'parent dependencies are cloned');
      };

      return engineInstance.boot().then(function () {
        assert.ok(true, 'boot successful');
      });
    };

    _proto['@test can build a child instance of a registered engine'] = function testCanBuildAChildInstanceOfARegisteredEngine(assert) {
      var ChatEngine = _engine.default.extend();

      var chatEngineInstance;
      engine.register('engine:chat', ChatEngine);
      (0, _runloop.run)(function () {
        engineInstance = _instance.default.create({
          base: engine
        }); // Try to build an unregistered engine.

        assert.throws(function () {
          engineInstance.buildChildEngineInstance('fake');
        }, "You attempted to mount the engine 'fake', but it is not registered with its parent."); // Build the `chat` engine, registered above.

        chatEngineInstance = engineInstance.buildChildEngineInstance('chat');
      });
      assert.ok(chatEngineInstance, 'child engine instance successfully created');
      assert.strictEqual((0, _engine.getEngineParent)(chatEngineInstance), engineInstance, 'child engine instance is assigned the correct parent');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/engine/tests/engine_parent_test", ["ember-babel", "@ember/engine", "internal-test-helpers"], function (_emberBabel, _engine, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('EngineParent',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto["@test An engine's parent can be set with `setEngineParent` and retrieved with `getEngineParent`"] = function testAnEngineSParentCanBeSetWithSetEngineParentAndRetrievedWithGetEngineParent(assert) {
      var engine = {};
      var parent = {};
      assert.strictEqual((0, _engine.getEngineParent)(engine), undefined, 'parent has not been set');
      (0, _engine.setEngineParent)(engine, parent);
      assert.strictEqual((0, _engine.getEngineParent)(engine), parent, 'parent has been set');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/engine/tests/engine_test", ["ember-babel", "@ember/-internals/environment", "@ember/runloop", "@ember/engine", "@ember/-internals/runtime", "@ember/-internals/container", "internal-test-helpers"], function (_emberBabel, _environment, _runloop, _engine, _runtime, _container, _internalTestHelpers) {
  "use strict";

  function _templateObject4() {
    var data = (0, _emberBabel.taggedTemplateLiteralLoose)(["template-compiler:main"]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    var data = (0, _emberBabel.taggedTemplateLiteralLoose)(["template:components/-default"]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    var data = (0, _emberBabel.taggedTemplateLiteralLoose)(["-bucket-cache:main"]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    var data = (0, _emberBabel.taggedTemplateLiteralLoose)(["-bucket-cache:main"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  var engine;
  var originalLookup = _environment.context.lookup;
  (0, _internalTestHelpers.moduleFor)('Engine',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      var _this;

      _this = _TestCase.call(this) || this;
      (0, _runloop.run)(function () {
        engine = _engine.default.create();
        _environment.context.lookup = {
          TestEngine: engine
        };
      });
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _environment.context.lookup = originalLookup;

      if (engine) {
        (0, _runloop.run)(engine, 'destroy');
        engine = null;
      }
    };

    _proto['@test acts like a namespace'] = function testActsLikeANamespace(assert) {
      engine.Foo = _runtime.Object.extend();
      assert.equal(engine.Foo.toString(), 'TestEngine.Foo', 'Classes pick up their parent namespace');
    };

    _proto['@test builds a registry'] = function testBuildsARegistry(assert) {
      assert.strictEqual(engine.resolveRegistration('application:main'), engine, "application:main is registered");
      assert.deepEqual(engine.registeredOptionsForType('component'), {
        singleton: false
      }, "optionsForType 'component'");
      assert.deepEqual(engine.registeredOptionsForType('view'), {
        singleton: false
      }, "optionsForType 'view'");
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'controller:basic');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'view', '_viewRegistry', '-view-registry:main');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'route', '_topLevelViewTemplate', 'template:-outlet');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'view:-outlet', 'namespace', 'application:main');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'controller', 'target', 'router:main');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'controller', 'namespace', 'application:main');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'router', '_bucketCache', (0, _container.privatize)(_templateObject()));
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'route', '_bucketCache', (0, _container.privatize)(_templateObject2()));
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'route', '_router', 'router:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'component:-text-field');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'component:-text-area');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'component:-checkbox');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'component:link-to');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'service:-routing');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'service:-routing', 'router', 'router:main'); // DEBUGGING

      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'resolver-for-debugging:main');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'container-debug-adapter:main', 'resolver', 'resolver-for-debugging:main');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'data-adapter:main', 'containerDebugAdapter', 'container-debug-adapter:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'container-debug-adapter:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'component-lookup:main');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'service:-dom-changes', 'document', 'service:-document');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'service:-dom-tree-construction', 'document', 'service:-document');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'view:-outlet');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, (0, _container.privatize)(_templateObject3()));
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'template:-outlet');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'view:-outlet', 'template', 'template:-outlet');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'template', 'compiler', (0, _container.privatize)(_templateObject4()));
      assert.deepEqual(engine.registeredOptionsForType('helper'), {
        instantiate: false
      }, "optionsForType 'helper'");
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/error/tests/index_test", ["ember-babel", "@ember/error", "internal-test-helpers"], function (_emberBabel, _error, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember Error Throwing',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test new EmberError displays provided message'] = function testNewEmberErrorDisplaysProvidedMessage(assert) {
      assert.throws(function () {
        throw new _error.default('A Message');
      }, function (e) {
        return e.message === 'A Message';
      }, 'the assigned message was displayed');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/instrumentation/tests/index-test", ["ember-babel", "@ember/instrumentation", "internal-test-helpers"], function (_emberBabel, _instrumentation, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember Instrumentation',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.afterEach = function afterEach() {
      (0, _instrumentation.reset)();
    };

    _proto['@test execute block even if no listeners'] = function testExecuteBlockEvenIfNoListeners(assert) {
      var result = (0, _instrumentation.instrument)('render', {}, function () {
        return 'hello';
      });
      assert.equal(result, 'hello', 'called block');
    };

    _proto['@test subscribing to a simple path receives the listener'] = function testSubscribingToASimplePathReceivesTheListener(assert) {
      assert.expect(12);
      var sentPayload = {};
      var count = 0;
      (0, _instrumentation.subscribe)('render', {
        before: function (name, timestamp, payload) {
          if (count === 0) {
            assert.strictEqual(name, 'render');
          } else {
            assert.strictEqual(name, 'render.handlebars');
          }

          assert.ok(typeof timestamp === 'number');
          assert.strictEqual(payload, sentPayload);
        },
        after: function (name, timestamp, payload) {
          if (count === 0) {
            assert.strictEqual(name, 'render');
          } else {
            assert.strictEqual(name, 'render.handlebars');
          }

          assert.ok(typeof timestamp === 'number');
          assert.strictEqual(payload, sentPayload);
          count++;
        }
      });
      (0, _instrumentation.instrument)('render', sentPayload, function () {});
      (0, _instrumentation.instrument)('render.handlebars', sentPayload, function () {});
    };

    _proto['@test returning a value from the before callback passes it to the after callback'] = function testReturningAValueFromTheBeforeCallbackPassesItToTheAfterCallback(assert) {
      assert.expect(2);
      var passthru1 = {};
      var passthru2 = {};
      (0, _instrumentation.subscribe)('render', {
        before: function () {
          return passthru1;
        },
        after: function (name, timestamp, payload, beforeValue) {
          assert.strictEqual(beforeValue, passthru1);
        }
      });
      (0, _instrumentation.subscribe)('render', {
        before: function () {
          return passthru2;
        },
        after: function (name, timestamp, payload, beforeValue) {
          assert.strictEqual(beforeValue, passthru2);
        }
      });
      (0, _instrumentation.instrument)('render', null, function () {});
    };

    _proto['@test instrument with 2 args (name, callback) no payload'] = function testInstrumentWith2ArgsNameCallbackNoPayload(assert) {
      assert.expect(1);
      (0, _instrumentation.subscribe)('render', {
        before: function (name, timestamp, payload) {
          assert.deepEqual(payload, {});
        },
        after: function () {}
      });
      (0, _instrumentation.instrument)('render', function () {});
    };

    _proto['@test instrument with 3 args (name, callback, binding) no payload'] = function testInstrumentWith3ArgsNameCallbackBindingNoPayload(assert) {
      assert.expect(2);
      var binding = {};
      (0, _instrumentation.subscribe)('render', {
        before: function (name, timestamp, payload) {
          assert.deepEqual(payload, {});
        },
        after: function () {}
      });
      (0, _instrumentation.instrument)('render', function () {
        assert.deepEqual(this, binding);
      }, binding);
    };

    _proto['@test instrument with 3 args (name, payload, callback) with payload'] = function testInstrumentWith3ArgsNamePayloadCallbackWithPayload(assert) {
      assert.expect(1);
      var expectedPayload = {
        hi: 1
      };
      (0, _instrumentation.subscribe)('render', {
        before: function (name, timestamp, payload) {
          assert.deepEqual(payload, expectedPayload);
        },
        after: function () {}
      });
      (0, _instrumentation.instrument)('render', expectedPayload, function () {});
    };

    _proto['@test instrument with 4 args (name, payload, callback, binding) with payload'] = function testInstrumentWith4ArgsNamePayloadCallbackBindingWithPayload(assert) {
      assert.expect(2);
      var expectedPayload = {
        hi: 1
      };
      var binding = {};
      (0, _instrumentation.subscribe)('render', {
        before: function (name, timestamp, payload) {
          assert.deepEqual(payload, expectedPayload);
        },
        after: function () {}
      });
      (0, _instrumentation.instrument)('render', expectedPayload, function () {
        assert.deepEqual(this, binding);
      }, binding);
    };

    _proto['@test raising an exception in the instrumentation attaches it to the payload'] = function testRaisingAnExceptionInTheInstrumentationAttachesItToThePayload(assert) {
      assert.expect(2);
      var error = new Error('Instrumentation');
      (0, _instrumentation.subscribe)('render', {
        before: function () {},
        after: function (name, timestamp, payload) {
          assert.strictEqual(payload.exception, error);
        }
      });
      (0, _instrumentation.subscribe)('render', {
        before: function () {},
        after: function (name, timestamp, payload) {
          assert.strictEqual(payload.exception, error);
        }
      });
      (0, _instrumentation.instrument)('render.handlebars', null, function () {
        throw error;
      });
    };

    _proto['@test it is possible to add a new subscriber after the first instrument'] = function testItIsPossibleToAddANewSubscriberAfterTheFirstInstrument(assert) {
      (0, _instrumentation.instrument)('render.handlebars', null, function () {});
      (0, _instrumentation.subscribe)('render', {
        before: function () {
          assert.ok(true, 'Before callback was called');
        },
        after: function () {
          assert.ok(true, 'After callback was called');
        }
      });
      (0, _instrumentation.instrument)('render.handlebars', null, function () {});
    };

    _proto['@test it is possible to remove a subscriber'] = function testItIsPossibleToRemoveASubscriber(assert) {
      assert.expect(4);
      var count = 0;
      var subscriber = (0, _instrumentation.subscribe)('render', {
        before: function () {
          assert.equal(count, 0);
          assert.ok(true, 'Before callback was called');
        },
        after: function () {
          assert.equal(count, 0);
          assert.ok(true, 'After callback was called');
          count++;
        }
      });
      (0, _instrumentation.instrument)('render.handlebars', null, function () {});
      (0, _instrumentation.unsubscribe)(subscriber);
      (0, _instrumentation.instrument)('render.handlebars', null, function () {});
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/object/tests/computed/computed_macros_test", ["ember-babel", "@ember/-internals/metal", "@ember/object/computed", "@ember/-internals/runtime", "internal-test-helpers"], function (_emberBabel, _metal, _computed, _runtime, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('CP macros',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Ember.computed.empty'] = function testEmberComputedEmpty(assert) {
      var obj = _runtime.Object.extend({
        bestLannister: null,
        lannisters: null,
        bestLannisterUnspecified: (0, _computed.empty)('bestLannister'),
        noLannistersKnown: (0, _computed.empty)('lannisters')
      }).create({
        lannisters: (0, _runtime.A)()
      });

      assert.equal((0, _metal.get)(obj, 'bestLannisterUnspecified'), true, 'bestLannister initially empty');
      assert.equal((0, _metal.get)(obj, 'noLannistersKnown'), true, 'lannisters initially empty');
      (0, _metal.get)(obj, 'lannisters').pushObject('Tyrion');
      (0, _metal.set)(obj, 'bestLannister', 'Tyrion');
      assert.equal((0, _metal.get)(obj, 'bestLannisterUnspecified'), false, 'empty respects strings');
      assert.equal((0, _metal.get)(obj, 'noLannistersKnown'), false, 'empty respects array mutations');
    };

    _proto['@test Ember.computed.notEmpty'] = function testEmberComputedNotEmpty(assert) {
      var obj = _runtime.Object.extend({
        bestLannister: null,
        lannisters: null,
        bestLannisterSpecified: (0, _computed.notEmpty)('bestLannister'),
        LannistersKnown: (0, _computed.notEmpty)('lannisters')
      }).create({
        lannisters: (0, _runtime.A)()
      });

      assert.equal((0, _metal.get)(obj, 'bestLannisterSpecified'), false, 'bestLannister initially empty');
      assert.equal((0, _metal.get)(obj, 'LannistersKnown'), false, 'lannisters initially empty');
      (0, _metal.get)(obj, 'lannisters').pushObject('Tyrion');
      (0, _metal.set)(obj, 'bestLannister', 'Tyrion');
      assert.equal((0, _metal.get)(obj, 'bestLannisterSpecified'), true, 'empty respects strings');
      assert.equal((0, _metal.get)(obj, 'LannistersKnown'), true, 'empty respects array mutations');
    };

    _proto['@test computed.not'] = function testComputedNot(assert) {
      var obj = {
        foo: true
      };
      (0, _metal.defineProperty)(obj, 'notFoo', (0, _computed.not)('foo'));
      assert.equal((0, _metal.get)(obj, 'notFoo'), false);
      obj = {
        foo: {
          bar: true
        }
      };
      (0, _metal.defineProperty)(obj, 'notFoo', (0, _computed.not)('foo.bar'));
      assert.equal((0, _metal.get)(obj, 'notFoo'), false);
    };

    _proto['@test computed.empty'] = function testComputedEmpty(assert) {
      var obj = {
        foo: [],
        bar: undefined,
        baz: null,
        quz: ''
      };
      (0, _metal.defineProperty)(obj, 'fooEmpty', (0, _computed.empty)('foo'));
      (0, _metal.defineProperty)(obj, 'barEmpty', (0, _computed.empty)('bar'));
      (0, _metal.defineProperty)(obj, 'bazEmpty', (0, _computed.empty)('baz'));
      (0, _metal.defineProperty)(obj, 'quzEmpty', (0, _computed.empty)('quz'));
      assert.equal((0, _metal.get)(obj, 'fooEmpty'), true);
      (0, _metal.set)(obj, 'foo', [1]);
      assert.equal((0, _metal.get)(obj, 'fooEmpty'), false);
      assert.equal((0, _metal.get)(obj, 'barEmpty'), true);
      assert.equal((0, _metal.get)(obj, 'bazEmpty'), true);
      assert.equal((0, _metal.get)(obj, 'quzEmpty'), true);
      (0, _metal.set)(obj, 'quz', 'asdf');
      assert.equal((0, _metal.get)(obj, 'quzEmpty'), false);
    };

    _proto['@test computed.bool'] = function testComputedBool(assert) {
      var obj = {
        foo: function () {},
        bar: 'asdf',
        baz: null,
        quz: false
      };
      (0, _metal.defineProperty)(obj, 'fooBool', (0, _computed.bool)('foo'));
      (0, _metal.defineProperty)(obj, 'barBool', (0, _computed.bool)('bar'));
      (0, _metal.defineProperty)(obj, 'bazBool', (0, _computed.bool)('baz'));
      (0, _metal.defineProperty)(obj, 'quzBool', (0, _computed.bool)('quz'));
      assert.equal((0, _metal.get)(obj, 'fooBool'), true);
      assert.equal((0, _metal.get)(obj, 'barBool'), true);
      assert.equal((0, _metal.get)(obj, 'bazBool'), false);
      assert.equal((0, _metal.get)(obj, 'quzBool'), false);
    };

    _proto['@test computed.alias'] = function testComputedAlias(assert) {
      var obj = {
        bar: 'asdf',
        baz: null,
        quz: false
      };
      (0, _metal.defineProperty)(obj, 'bay', (0, _metal.computed)(function () {
        return 'apple';
      }));
      (0, _metal.defineProperty)(obj, 'barAlias', (0, _metal.alias)('bar'));
      (0, _metal.defineProperty)(obj, 'bazAlias', (0, _metal.alias)('baz'));
      (0, _metal.defineProperty)(obj, 'quzAlias', (0, _metal.alias)('quz'));
      (0, _metal.defineProperty)(obj, 'bayAlias', (0, _metal.alias)('bay'));
      assert.equal((0, _metal.get)(obj, 'barAlias'), 'asdf');
      assert.equal((0, _metal.get)(obj, 'bazAlias'), null);
      assert.equal((0, _metal.get)(obj, 'quzAlias'), false);
      assert.equal((0, _metal.get)(obj, 'bayAlias'), 'apple');
      (0, _metal.set)(obj, 'barAlias', 'newBar');
      (0, _metal.set)(obj, 'bazAlias', 'newBaz');
      (0, _metal.set)(obj, 'quzAlias', null);
      assert.equal((0, _metal.get)(obj, 'barAlias'), 'newBar');
      assert.equal((0, _metal.get)(obj, 'bazAlias'), 'newBaz');
      assert.equal((0, _metal.get)(obj, 'quzAlias'), null);
      assert.equal((0, _metal.get)(obj, 'bar'), 'newBar');
      assert.equal((0, _metal.get)(obj, 'baz'), 'newBaz');
      assert.equal((0, _metal.get)(obj, 'quz'), null);
    };

    _proto['@test computed.alias set'] = function testComputedAliasSet(assert) {
      var obj = {};
      var constantValue = 'always `a`';
      (0, _metal.defineProperty)(obj, 'original', (0, _metal.computed)({
        get: function () {
          return constantValue;
        },
        set: function () {
          return constantValue;
        }
      }));
      (0, _metal.defineProperty)(obj, 'aliased', (0, _metal.alias)('original'));
      assert.equal((0, _metal.get)(obj, 'original'), constantValue);
      assert.equal((0, _metal.get)(obj, 'aliased'), constantValue);
      (0, _metal.set)(obj, 'aliased', 'should not set to this value');
      assert.equal((0, _metal.get)(obj, 'original'), constantValue);
      assert.equal((0, _metal.get)(obj, 'aliased'), constantValue);
    };

    _proto['@test computed.match'] = function testComputedMatch(assert) {
      var obj = {
        name: 'Paul'
      };
      (0, _metal.defineProperty)(obj, 'isPaul', (0, _computed.match)('name', /Paul/));
      assert.equal((0, _metal.get)(obj, 'isPaul'), true, 'is Paul');
      (0, _metal.set)(obj, 'name', 'Pierre');
      assert.equal((0, _metal.get)(obj, 'isPaul'), false, 'is not Paul anymore');
    };

    _proto['@test computed.notEmpty'] = function testComputedNotEmpty(assert) {
      var obj = {
        items: [1]
      };
      (0, _metal.defineProperty)(obj, 'hasItems', (0, _computed.notEmpty)('items'));
      assert.equal((0, _metal.get)(obj, 'hasItems'), true, 'is not empty');
      (0, _metal.set)(obj, 'items', []);
      assert.equal((0, _metal.get)(obj, 'hasItems'), false, 'is empty');
    };

    _proto['@test computed.equal'] = function testComputedEqual(assert) {
      var obj = {
        name: 'Paul'
      };
      (0, _metal.defineProperty)(obj, 'isPaul', (0, _computed.equal)('name', 'Paul'));
      assert.equal((0, _metal.get)(obj, 'isPaul'), true, 'is Paul');
      (0, _metal.set)(obj, 'name', 'Pierre');
      assert.equal((0, _metal.get)(obj, 'isPaul'), false, 'is not Paul anymore');
    };

    _proto['@test computed.gt'] = function testComputedGt(assert) {
      var obj = {
        number: 2
      };
      (0, _metal.defineProperty)(obj, 'isGreaterThenOne', (0, _computed.gt)('number', 1));
      assert.equal((0, _metal.get)(obj, 'isGreaterThenOne'), true, 'is gt');
      (0, _metal.set)(obj, 'number', 1);
      assert.equal((0, _metal.get)(obj, 'isGreaterThenOne'), false, 'is not gt');
      (0, _metal.set)(obj, 'number', 0);
      assert.equal((0, _metal.get)(obj, 'isGreaterThenOne'), false, 'is not gt');
    };

    _proto['@test computed.gte'] = function testComputedGte(assert) {
      var obj = {
        number: 2
      };
      (0, _metal.defineProperty)(obj, 'isGreaterOrEqualThenOne', (0, _computed.gte)('number', 1));
      assert.equal((0, _metal.get)(obj, 'isGreaterOrEqualThenOne'), true, 'is gte');
      (0, _metal.set)(obj, 'number', 1);
      assert.equal((0, _metal.get)(obj, 'isGreaterOrEqualThenOne'), true, 'is gte');
      (0, _metal.set)(obj, 'number', 0);
      assert.equal((0, _metal.get)(obj, 'isGreaterOrEqualThenOne'), false, 'is not gte');
    };

    _proto['@test computed.lt'] = function testComputedLt(assert) {
      var obj = {
        number: 0
      };
      (0, _metal.defineProperty)(obj, 'isLesserThenOne', (0, _computed.lt)('number', 1));
      assert.equal((0, _metal.get)(obj, 'isLesserThenOne'), true, 'is lt');
      (0, _metal.set)(obj, 'number', 1);
      assert.equal((0, _metal.get)(obj, 'isLesserThenOne'), false, 'is not lt');
      (0, _metal.set)(obj, 'number', 2);
      assert.equal((0, _metal.get)(obj, 'isLesserThenOne'), false, 'is not lt');
    };

    _proto['@test computed.lte'] = function testComputedLte(assert) {
      var obj = {
        number: 0
      };
      (0, _metal.defineProperty)(obj, 'isLesserOrEqualThenOne', (0, _computed.lte)('number', 1));
      assert.equal((0, _metal.get)(obj, 'isLesserOrEqualThenOne'), true, 'is lte');
      (0, _metal.set)(obj, 'number', 1);
      assert.equal((0, _metal.get)(obj, 'isLesserOrEqualThenOne'), true, 'is lte');
      (0, _metal.set)(obj, 'number', 2);
      assert.equal((0, _metal.get)(obj, 'isLesserOrEqualThenOne'), false, 'is not lte');
    };

    _proto['@test computed.and two properties'] = function testComputedAndTwoProperties(assert) {
      var obj = {
        one: true,
        two: true
      };
      (0, _metal.defineProperty)(obj, 'oneAndTwo', (0, _computed.and)('one', 'two'));
      assert.equal((0, _metal.get)(obj, 'oneAndTwo'), true, 'one and two');
      (0, _metal.set)(obj, 'one', false);
      assert.equal((0, _metal.get)(obj, 'oneAndTwo'), false, 'one and not two');
      (0, _metal.set)(obj, 'one', null);
      (0, _metal.set)(obj, 'two', 'Yes');
      assert.equal((0, _metal.get)(obj, 'oneAndTwo'), null, 'returns falsy value as in &&');
      (0, _metal.set)(obj, 'one', true);
      (0, _metal.set)(obj, 'two', 2);
      assert.equal((0, _metal.get)(obj, 'oneAndTwo'), 2, 'returns truthy value as in &&');
    };

    _proto['@test computed.and three properties'] = function testComputedAndThreeProperties(assert) {
      var obj = {
        one: true,
        two: true,
        three: true
      };
      (0, _metal.defineProperty)(obj, 'oneTwoThree', (0, _computed.and)('one', 'two', 'three'));
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one and two and three');
      (0, _metal.set)(obj, 'one', false);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), false, 'one and not two and not three');
      (0, _metal.set)(obj, 'one', true);
      (0, _metal.set)(obj, 'two', 2);
      (0, _metal.set)(obj, 'three', 3);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), 3, 'returns truthy value as in &&');
    };

    _proto['@test computed.and expand properties'] = function testComputedAndExpandProperties(assert) {
      var obj = {
        one: true,
        two: true,
        three: true
      };
      (0, _metal.defineProperty)(obj, 'oneTwoThree', (0, _computed.and)('{one,two,three}'));
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one and two and three');
      (0, _metal.set)(obj, 'one', false);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), false, 'one and not two and not three');
      (0, _metal.set)(obj, 'one', true);
      (0, _metal.set)(obj, 'two', 2);
      (0, _metal.set)(obj, 'three', 3);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), 3, 'returns truthy value as in &&');
    };

    _proto['@test computed.or two properties'] = function testComputedOrTwoProperties(assert) {
      var obj = {
        one: true,
        two: true
      };
      (0, _metal.defineProperty)(obj, 'oneOrTwo', (0, _computed.or)('one', 'two'));
      assert.equal((0, _metal.get)(obj, 'oneOrTwo'), true, 'one or two');
      (0, _metal.set)(obj, 'one', false);
      assert.equal((0, _metal.get)(obj, 'oneOrTwo'), true, 'one or two');
      (0, _metal.set)(obj, 'two', false);
      assert.equal((0, _metal.get)(obj, 'oneOrTwo'), false, 'nor one nor two');
      (0, _metal.set)(obj, 'two', null);
      assert.equal((0, _metal.get)(obj, 'oneOrTwo'), null, 'returns last falsy value as in ||');
      (0, _metal.set)(obj, 'two', true);
      assert.equal((0, _metal.get)(obj, 'oneOrTwo'), true, 'one or two');
      (0, _metal.set)(obj, 'one', 1);
      assert.equal((0, _metal.get)(obj, 'oneOrTwo'), 1, 'returns truthy value as in ||');
    };

    _proto['@test computed.or three properties'] = function testComputedOrThreeProperties(assert) {
      var obj = {
        one: true,
        two: true,
        three: true
      };
      (0, _metal.defineProperty)(obj, 'oneTwoThree', (0, _computed.or)('one', 'two', 'three'));
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _metal.set)(obj, 'one', false);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _metal.set)(obj, 'two', false);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _metal.set)(obj, 'three', false);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), false, 'one or two or three');
      (0, _metal.set)(obj, 'three', null);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), null, 'returns last falsy value as in ||');
      (0, _metal.set)(obj, 'two', true);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _metal.set)(obj, 'one', 1);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), 1, 'returns truthy value as in ||');
    };

    _proto['@test computed.or expand properties'] = function testComputedOrExpandProperties(assert) {
      var obj = {
        one: true,
        two: true,
        three: true
      };
      (0, _metal.defineProperty)(obj, 'oneTwoThree', (0, _computed.or)('{one,two,three}'));
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _metal.set)(obj, 'one', false);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _metal.set)(obj, 'two', false);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _metal.set)(obj, 'three', false);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), false, 'one or two or three');
      (0, _metal.set)(obj, 'three', null);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), null, 'returns last falsy value as in ||');
      (0, _metal.set)(obj, 'two', true);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _metal.set)(obj, 'one', 1);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), 1, 'returns truthy value as in ||');
    };

    _proto['@test computed.or and computed.and warn about dependent keys with spaces'] = function testComputedOrAndComputedAndWarnAboutDependentKeysWithSpaces() {
      var obj = {
        one: true,
        two: true
      };
      expectAssertion(function () {
        (0, _metal.defineProperty)(obj, 'oneOrTwo', (0, _computed.or)('one', 'two three'));
      }, /Dependent keys passed to computed\.or\(\) can't have spaces\./);
      expectAssertion(function () {
        (0, _metal.defineProperty)(obj, 'oneAndTwo', (0, _computed.and)('one', 'two three'));
      }, /Dependent keys passed to computed\.and\(\) can't have spaces\./);
    };

    _proto['@test computed.oneWay'] = function testComputedOneWay(assert) {
      var obj = {
        firstName: 'Teddy',
        lastName: 'Zeenny'
      };
      (0, _metal.defineProperty)(obj, 'nickName', (0, _computed.oneWay)('firstName'));
      assert.equal((0, _metal.get)(obj, 'firstName'), 'Teddy');
      assert.equal((0, _metal.get)(obj, 'lastName'), 'Zeenny');
      assert.equal((0, _metal.get)(obj, 'nickName'), 'Teddy');
      (0, _metal.set)(obj, 'nickName', 'TeddyBear');
      assert.equal((0, _metal.get)(obj, 'firstName'), 'Teddy');
      assert.equal((0, _metal.get)(obj, 'lastName'), 'Zeenny');
      assert.equal((0, _metal.get)(obj, 'nickName'), 'TeddyBear');
      (0, _metal.set)(obj, 'firstName', 'TEDDDDDDDDYYY');
      assert.equal((0, _metal.get)(obj, 'nickName'), 'TeddyBear');
    };

    _proto['@test computed.readOnly'] = function testComputedReadOnly(assert) {
      var obj = {
        firstName: 'Teddy',
        lastName: 'Zeenny'
      };
      (0, _metal.defineProperty)(obj, 'nickName', (0, _computed.readOnly)('firstName'));
      assert.equal((0, _metal.get)(obj, 'firstName'), 'Teddy');
      assert.equal((0, _metal.get)(obj, 'lastName'), 'Zeenny');
      assert.equal((0, _metal.get)(obj, 'nickName'), 'Teddy');
      assert.throws(function () {
        (0, _metal.set)(obj, 'nickName', 'TeddyBear');
      }, / /);
      assert.equal((0, _metal.get)(obj, 'firstName'), 'Teddy');
      assert.equal((0, _metal.get)(obj, 'lastName'), 'Zeenny');
      assert.equal((0, _metal.get)(obj, 'nickName'), 'Teddy');
      (0, _metal.set)(obj, 'firstName', 'TEDDDDDDDDYYY');
      assert.equal((0, _metal.get)(obj, 'nickName'), 'TEDDDDDDDDYYY');
    };

    _proto['@test computed.deprecatingAlias'] = function testComputedDeprecatingAlias(assert) {
      var obj = {
        bar: 'asdf',
        baz: null,
        quz: false
      };
      (0, _metal.defineProperty)(obj, 'bay', (0, _metal.computed)(function () {
        return 'apple';
      }));
      (0, _metal.defineProperty)(obj, 'barAlias', (0, _computed.deprecatingAlias)('bar', {
        id: 'bar-deprecation',
        until: 'some.version'
      }));
      (0, _metal.defineProperty)(obj, 'bazAlias', (0, _computed.deprecatingAlias)('baz', {
        id: 'baz-deprecation',
        until: 'some.version'
      }));
      (0, _metal.defineProperty)(obj, 'quzAlias', (0, _computed.deprecatingAlias)('quz', {
        id: 'quz-deprecation',
        until: 'some.version'
      }));
      (0, _metal.defineProperty)(obj, 'bayAlias', (0, _computed.deprecatingAlias)('bay', {
        id: 'bay-deprecation',
        until: 'some.version'
      }));
      expectDeprecation(function () {
        assert.equal((0, _metal.get)(obj, 'barAlias'), 'asdf');
      }, 'Usage of `barAlias` is deprecated, use `bar` instead.');
      expectDeprecation(function () {
        assert.equal((0, _metal.get)(obj, 'bazAlias'), null);
      }, 'Usage of `bazAlias` is deprecated, use `baz` instead.');
      expectDeprecation(function () {
        assert.equal((0, _metal.get)(obj, 'quzAlias'), false);
      }, 'Usage of `quzAlias` is deprecated, use `quz` instead.');
      expectDeprecation(function () {
        assert.equal((0, _metal.get)(obj, 'bayAlias'), 'apple');
      }, 'Usage of `bayAlias` is deprecated, use `bay` instead.');
      expectDeprecation(function () {
        (0, _metal.set)(obj, 'barAlias', 'newBar');
      }, 'Usage of `barAlias` is deprecated, use `bar` instead.');
      expectDeprecation(function () {
        (0, _metal.set)(obj, 'bazAlias', 'newBaz');
      }, 'Usage of `bazAlias` is deprecated, use `baz` instead.');
      expectDeprecation(function () {
        (0, _metal.set)(obj, 'quzAlias', null);
      }, 'Usage of `quzAlias` is deprecated, use `quz` instead.');
      assert.equal((0, _metal.get)(obj, 'barAlias'), 'newBar');
      assert.equal((0, _metal.get)(obj, 'bazAlias'), 'newBaz');
      assert.equal((0, _metal.get)(obj, 'quzAlias'), null);
      assert.equal((0, _metal.get)(obj, 'bar'), 'newBar');
      assert.equal((0, _metal.get)(obj, 'baz'), 'newBaz');
      assert.equal((0, _metal.get)(obj, 'quz'), null);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/object/tests/computed/reduce_computed_macros_test", ["ember-babel", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/runtime", "@ember/object/computed", "internal-test-helpers"], function (_emberBabel, _runloop, _metal, _runtime, _computed, _internalTestHelpers) {
  "use strict";

  var obj;
  (0, _internalTestHelpers.moduleFor)('map',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        mapped: (0, _computed.map)('array.@each.v', function (item) {
          return item.v;
        }),
        mappedObjects: (0, _computed.map)('arrayObjects.@each.v', function (item) {
          return {
            name: item.v.name
          };
        })
      }).create({
        arrayObjects: (0, _runtime.A)([{
          v: {
            name: 'Robert'
          }
        }, {
          v: {
            name: 'Leanna'
          }
        }]),
        array: (0, _runtime.A)([{
          v: 1
        }, {
          v: 3
        }, {
          v: 2
        }, {
          v: 1
        }])
      });
    };

    _proto.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto['@test map is readOnly'] = function testMapIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('mapped', 1);
      }, /Cannot set read-only property "mapped" on object:/);
    };

    _proto['@test it maps simple properties'] = function testItMapsSimpleProperties(assert) {
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 1]);
      obj.get('array').pushObject({
        v: 5
      });
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 1, 5]);
      (0, _runtime.removeAt)(obj.get('array'), 3);
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 5]);
    };

    _proto['@test it maps simple unshifted properties'] = function testItMapsSimpleUnshiftedProperties(assert) {
      var array = (0, _runtime.A)();
      obj = _runtime.Object.extend({
        mapped: (0, _computed.map)('array', function (item) {
          return item.toUpperCase();
        })
      }).create({
        array: array
      });
      array.unshiftObject('c');
      array.unshiftObject('b');
      array.unshiftObject('a');
      array.popObject();
      assert.deepEqual(obj.get('mapped'), ['A', 'B'], 'properties unshifted in sequence are mapped correctly');
    };

    _proto['@test it has the correct `this`'] = function testItHasTheCorrectThis(assert) {
      obj = _runtime.Object.extend({
        mapped: (0, _computed.map)('array', function (item) {
          assert.equal(this, obj, 'should have correct context');
          return this.upperCase(item);
        }),
        upperCase: function (string) {
          return string.toUpperCase();
        }
      }).create({
        array: ['a', 'b', 'c']
      });
      assert.deepEqual(obj.get('mapped'), ['A', 'B', 'C'], 'properties unshifted in sequence are mapped correctly');
    };

    _proto['@test it passes the index to the callback'] = function testItPassesTheIndexToTheCallback(assert) {
      var array = ['a', 'b', 'c'];
      obj = _runtime.Object.extend({
        mapped: (0, _computed.map)('array', function (item, index) {
          return index;
        })
      }).create({
        array: array
      });
      assert.deepEqual(obj.get('mapped'), [0, 1, 2], 'index is passed to callback correctly');
    };

    _proto['@test it maps objects'] = function testItMapsObjects(assert) {
      assert.deepEqual(obj.get('mappedObjects'), [{
        name: 'Robert'
      }, {
        name: 'Leanna'
      }]);
      obj.get('arrayObjects').pushObject({
        v: {
          name: 'Eddard'
        }
      });
      assert.deepEqual(obj.get('mappedObjects'), [{
        name: 'Robert'
      }, {
        name: 'Leanna'
      }, {
        name: 'Eddard'
      }]);
      (0, _runtime.removeAt)(obj.get('arrayObjects'), 1);
      assert.deepEqual(obj.get('mappedObjects'), [{
        name: 'Robert'
      }, {
        name: 'Eddard'
      }]);
      (0, _metal.set)(obj.get('arrayObjects')[0], 'v', {
        name: 'Stannis'
      });
      assert.deepEqual(obj.get('mappedObjects'), [{
        name: 'Stannis'
      }, {
        name: 'Eddard'
      }]);
    };

    _proto['@test it maps unshifted objects with property observers'] = function testItMapsUnshiftedObjectsWithPropertyObservers(assert) {
      var array = (0, _runtime.A)();
      var cObj = {
        v: 'c'
      };
      obj = _runtime.Object.extend({
        mapped: (0, _computed.map)('array.@each.v', function (item) {
          return (0, _metal.get)(item, 'v').toUpperCase();
        })
      }).create({
        array: array
      });
      array.unshiftObject(cObj);
      array.unshiftObject({
        v: 'b'
      });
      array.unshiftObject({
        v: 'a'
      });
      (0, _metal.set)(cObj, 'v', 'd');
      assert.deepEqual(array.mapBy('v'), ['a', 'b', 'd'], 'precond - unmapped array is correct');
      assert.deepEqual(obj.get('mapped'), ['A', 'B', 'D'], 'properties unshifted in sequence are mapped correctly');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('mapBy',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        mapped: (0, _computed.mapBy)('array', 'v')
      }).create({
        array: (0, _runtime.A)([{
          v: 1
        }, {
          v: 3
        }, {
          v: 2
        }, {
          v: 1
        }])
      });
    };

    _proto2.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto2['@test mapBy is readOnly'] = function testMapByIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('mapped', 1);
      }, /Cannot set read-only property "mapped" on object:/);
    };

    _proto2['@test it maps properties'] = function testItMapsProperties(assert) {
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 1]);
      obj.get('array').pushObject({
        v: 5
      });
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 1, 5]);
      (0, _runtime.removeAt)(obj.get('array'), 3);
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 5]);
    };

    _proto2['@test it is observable'] = function testItIsObservable(assert) {
      var calls = 0;
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 1]);
      (0, _metal.addObserver)(obj, 'mapped.@each', function () {
        return calls++;
      });
      obj.get('array').pushObject({
        v: 5
      });
      assert.equal(calls, 1, 'mapBy is observable');
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('filter',
  /*#__PURE__*/
  function (_AbstractTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class3, _AbstractTestCase3);

    function _class3() {
      return _AbstractTestCase3.apply(this, arguments) || this;
    }

    var _proto3 = _class3.prototype;

    _proto3.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        filtered: (0, _computed.filter)('array', function (item) {
          return item % 2 === 0;
        })
      }).create({
        array: (0, _runtime.A)([1, 2, 3, 4, 5, 6, 7, 8])
      });
    };

    _proto3.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto3['@test filter is readOnly'] = function testFilterIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('filtered', 1);
      }, /Cannot set read-only property "filtered" on object:/);
    };

    _proto3['@test it filters according to the specified filter function'] = function testItFiltersAccordingToTheSpecifiedFilterFunction(assert) {
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'filter filters by the specified function');
    };

    _proto3['@test it passes the index to the callback'] = function testItPassesTheIndexToTheCallback(assert) {
      obj = _runtime.Object.extend({
        filtered: (0, _computed.filter)('array', function (item, index) {
          return index === 1;
        })
      }).create({
        array: ['a', 'b', 'c']
      });
      assert.deepEqual((0, _metal.get)(obj, 'filtered'), ['b'], 'index is passed to callback correctly');
    };

    _proto3['@test it has the correct `this`'] = function testItHasTheCorrectThis(assert) {
      obj = _runtime.Object.extend({
        filtered: (0, _computed.filter)('array', function (item, index) {
          assert.equal(this, obj);
          return this.isOne(index);
        }),
        isOne: function (value) {
          return value === 1;
        }
      }).create({
        array: ['a', 'b', 'c']
      });
      assert.deepEqual((0, _metal.get)(obj, 'filtered'), ['b'], 'index is passed to callback correctly');
    };

    _proto3['@test it passes the array to the callback'] = function testItPassesTheArrayToTheCallback(assert) {
      obj = _runtime.Object.extend({
        filtered: (0, _computed.filter)('array', function (item, index, array) {
          return index === (0, _metal.get)(array, 'length') - 2;
        })
      }).create({
        array: (0, _runtime.A)(['a', 'b', 'c'])
      });
      assert.deepEqual(obj.get('filtered'), ['b'], 'array is passed to callback correctly');
    };

    _proto3['@test it caches properly'] = function testItCachesProperly(assert) {
      var array = obj.get('array');
      var filtered = obj.get('filtered');
      assert.ok(filtered === obj.get('filtered'));
      array.addObject(11);
      var newFiltered = obj.get('filtered');
      assert.ok(filtered !== newFiltered);
      assert.ok(obj.get('filtered') === newFiltered);
    };

    _proto3['@test it updates as the array is modified'] = function testItUpdatesAsTheArrayIsModified(assert) {
      var array = obj.get('array');
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct');
      array.addObject(11);
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'objects not passing the filter are not added');
      array.addObject(12);
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8, 12], 'objects passing the filter are added');
      array.removeObject(3);
      array.removeObject(4);
      assert.deepEqual(obj.get('filtered'), [2, 6, 8, 12], 'objects removed from the dependent array are removed from the computed array');
    };

    _proto3['@test the dependent array can be cleared one at a time'] = function testTheDependentArrayCanBeClearedOneAtATime(assert) {
      var array = (0, _metal.get)(obj, 'array');
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct'); // clear 1-8 but in a random order

      array.removeObject(3);
      array.removeObject(1);
      array.removeObject(2);
      array.removeObject(4);
      array.removeObject(8);
      array.removeObject(6);
      array.removeObject(5);
      array.removeObject(7);
      assert.deepEqual(obj.get('filtered'), [], 'filtered array cleared correctly');
    };

    _proto3['@test the dependent array can be `clear`ed directly (#3272)'] = function testTheDependentArrayCanBeClearEdDirectly3272(assert) {
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct');
      obj.get('array').clear();
      assert.deepEqual(obj.get('filtered'), [], 'filtered array cleared correctly');
    };

    _proto3['@test it updates as the array is replaced'] = function testItUpdatesAsTheArrayIsReplaced(assert) {
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct');
      obj.set('array', [20, 21, 22, 23, 24]);
      assert.deepEqual(obj.get('filtered'), [20, 22, 24], 'computed array is updated when array is changed');
    };

    _proto3['@test it updates properly on @each with {} dependencies'] = function testItUpdatesProperlyOnEachWithDependencies(assert) {
      var item = _runtime.Object.create({
        prop: true
      });

      obj = _runtime.Object.extend({
        filtered: (0, _computed.filter)('items.@each.{prop}', function (item) {
          return item.get('prop') === true;
        })
      }).create({
        items: (0, _runtime.A)([item])
      });
      assert.deepEqual(obj.get('filtered'), [item]);
      item.set('prop', false);
      assert.deepEqual(obj.get('filtered'), []);
    };

    return _class3;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('filterBy',
  /*#__PURE__*/
  function (_AbstractTestCase4) {
    (0, _emberBabel.inheritsLoose)(_class4, _AbstractTestCase4);

    function _class4() {
      return _AbstractTestCase4.apply(this, arguments) || this;
    }

    var _proto4 = _class4.prototype;

    _proto4.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        a1s: (0, _computed.filterBy)('array', 'a', 1),
        as: (0, _computed.filterBy)('array', 'a'),
        bs: (0, _computed.filterBy)('array', 'b')
      }).create({
        array: (0, _runtime.A)([{
          name: 'one',
          a: 1,
          b: false
        }, {
          name: 'two',
          a: 2,
          b: false
        }, {
          name: 'three',
          a: 1,
          b: true
        }, {
          name: 'four',
          b: true
        }])
      });
    };

    _proto4.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto4['@test filterBy is readOnly'] = function testFilterByIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('as', 1);
      }, /Cannot set read-only property "as" on object:/);
    };

    _proto4['@test properties can be filtered by truthiness'] = function testPropertiesCanBeFilteredByTruthiness(assert) {
      assert.deepEqual(obj.get('as').mapBy('name'), ['one', 'two', 'three'], 'properties can be filtered by existence');
      assert.deepEqual(obj.get('bs').mapBy('name'), ['three', 'four'], 'booleans can be filtered');
      (0, _metal.set)(obj.get('array')[0], 'a', undefined);
      (0, _metal.set)(obj.get('array')[3], 'a', true);
      (0, _metal.set)(obj.get('array')[0], 'b', true);
      (0, _metal.set)(obj.get('array')[3], 'b', false);
      assert.deepEqual(obj.get('as').mapBy('name'), ['two', 'three', 'four'], 'arrays computed by filter property respond to property changes');
      assert.deepEqual(obj.get('bs').mapBy('name'), ['one', 'three'], 'arrays computed by filtered property respond to property changes');
      obj.get('array').pushObject({
        name: 'five',
        a: 6,
        b: true
      });
      assert.deepEqual(obj.get('as').mapBy('name'), ['two', 'three', 'four', 'five'], 'arrays computed by filter property respond to added objects');
      assert.deepEqual(obj.get('bs').mapBy('name'), ['one', 'three', 'five'], 'arrays computed by filtered property respond to added objects');
      obj.get('array').popObject();
      assert.deepEqual(obj.get('as').mapBy('name'), ['two', 'three', 'four'], 'arrays computed by filter property respond to removed objects');
      assert.deepEqual(obj.get('bs').mapBy('name'), ['one', 'three'], 'arrays computed by filtered property respond to removed objects');
      obj.set('array', [{
        name: 'six',
        a: 12,
        b: true
      }]);
      assert.deepEqual(obj.get('as').mapBy('name'), ['six'], 'arrays computed by filter property respond to array changes');
      assert.deepEqual(obj.get('bs').mapBy('name'), ['six'], 'arrays computed by filtered property respond to array changes');
    };

    _proto4['@test properties can be filtered by values'] = function testPropertiesCanBeFilteredByValues(assert) {
      assert.deepEqual(obj.get('a1s').mapBy('name'), ['one', 'three'], 'properties can be filtered by matching value');
      obj.get('array').pushObject({
        name: 'five',
        a: 1
      });
      assert.deepEqual(obj.get('a1s').mapBy('name'), ['one', 'three', 'five'], 'arrays computed by matching value respond to added objects');
      obj.get('array').popObject();
      assert.deepEqual(obj.get('a1s').mapBy('name'), ['one', 'three'], 'arrays computed by matching value respond to removed objects');
      (0, _metal.set)(obj.get('array')[1], 'a', 1);
      (0, _metal.set)(obj.get('array')[2], 'a', 2);
      assert.deepEqual(obj.get('a1s').mapBy('name'), ['one', 'two'], 'arrays computed by matching value respond to modified properties');
    };

    _proto4['@test properties values can be replaced'] = function testPropertiesValuesCanBeReplaced(assert) {
      obj = _runtime.Object.extend({
        a1s: (0, _computed.filterBy)('array', 'a', 1),
        a1bs: (0, _computed.filterBy)('a1s', 'b')
      }).create({
        array: []
      });
      assert.deepEqual(obj.get('a1bs').mapBy('name'), [], 'properties can be filtered by matching value');
      (0, _metal.set)(obj, 'array', [{
        name: 'item1',
        a: 1,
        b: true
      }]);
      assert.deepEqual(obj.get('a1bs').mapBy('name'), ['item1'], 'properties can be filtered by matching value');
    };

    return _class4;
  }(_internalTestHelpers.AbstractTestCase));
  [['uniq', _computed.uniq], ['union', _computed.union]].forEach(function (tuple) {
    var name = tuple[0],
        macro = tuple[1];
    (0, _internalTestHelpers.moduleFor)("computed." + name,
    /*#__PURE__*/
    function (_AbstractTestCase5) {
      (0, _emberBabel.inheritsLoose)(_class5, _AbstractTestCase5);

      function _class5() {
        return _AbstractTestCase5.apply(this, arguments) || this;
      }

      var _proto5 = _class5.prototype;

      _proto5.beforeEach = function beforeEach() {
        obj = _runtime.Object.extend({
          union: macro('array', 'array2', 'array3')
        }).create({
          array: (0, _runtime.A)([1, 2, 3, 4, 5, 6]),
          array2: (0, _runtime.A)([4, 5, 6, 7, 8, 9, 4, 5, 6, 7, 8, 9]),
          array3: (0, _runtime.A)([1, 8, 10])
        });
      };

      _proto5.afterEach = function afterEach() {
        (0, _runloop.run)(obj, 'destroy');
      };

      _proto5["@test " + name + " is readOnly"] = function (assert) {
        assert.throws(function () {
          obj.set('union', 1);
        }, /Cannot set read-only property "union" on object:/);
      };

      _proto5['@test does not include duplicates'] = function testDoesNotIncludeDuplicates(assert) {
        var array = obj.get('array');
        var array2 = obj.get('array2');
        assert.deepEqual(obj.get('union').sort(function (x, y) {
          return x - y;
        }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], name + ' does not include duplicates');
        array.pushObject(8);
        assert.deepEqual(obj.get('union').sort(function (x, y) {
          return x - y;
        }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], name + ' does not add existing items');
        array.pushObject(11);
        assert.deepEqual(obj.get('union').sort(function (x, y) {
          return x - y;
        }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], name + ' adds new items');
        (0, _runtime.removeAt)(array2, 6); // remove 7

        assert.deepEqual(obj.get('union').sort(function (x, y) {
          return x - y;
        }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], name + ' does not remove items that are still in the dependent array');
        array2.removeObject(7);
        assert.deepEqual(obj.get('union').sort(function (x, y) {
          return x - y;
        }), [1, 2, 3, 4, 5, 6, 8, 9, 10, 11], name + ' removes items when their last instance is gone');
      };

      _proto5['@test has set-union semantics'] = function testHasSetUnionSemantics(assert) {
        var array = obj.get('array');
        assert.deepEqual(obj.get('union').sort(function (x, y) {
          return x - y;
        }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], name + ' is initially correct');
        array.removeObject(6);
        assert.deepEqual(obj.get('union').sort(function (x, y) {
          return x - y;
        }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 'objects are not removed if they exist in other dependent arrays');
        array.clear();
        assert.deepEqual(obj.get('union').sort(function (x, y) {
          return x - y;
        }), [1, 4, 5, 6, 7, 8, 9, 10], 'objects are removed when they are no longer in any dependent array');
      };

      return _class5;
    }(_internalTestHelpers.AbstractTestCase));
  });
  (0, _internalTestHelpers.moduleFor)('computed.uniqBy',
  /*#__PURE__*/
  function (_AbstractTestCase6) {
    (0, _emberBabel.inheritsLoose)(_class6, _AbstractTestCase6);

    function _class6() {
      return _AbstractTestCase6.apply(this, arguments) || this;
    }

    var _proto6 = _class6.prototype;

    _proto6.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        list: null,
        uniqueById: (0, _computed.uniqBy)('list', 'id')
      }).create({
        list: (0, _runtime.A)([{
          id: 1,
          value: 'one'
        }, {
          id: 2,
          value: 'two'
        }, {
          id: 1,
          value: 'one'
        }])
      });
    };

    _proto6.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto6['@test uniqBy is readOnly'] = function testUniqByIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('uniqueById', 1);
      }, /Cannot set read-only property "uniqueById" on object:/);
    };

    _proto6['@test does not include duplicates'] = function testDoesNotIncludeDuplicates(assert) {
      assert.deepEqual(obj.get('uniqueById'), [{
        id: 1,
        value: 'one'
      }, {
        id: 2,
        value: 'two'
      }]);
    };

    _proto6['@test it does not share state among instances'] = function testItDoesNotShareStateAmongInstances(assert) {
      var MyObject = _runtime.Object.extend({
        list: [],
        uniqueByName: (0, _computed.uniqBy)('list', 'name')
      });

      var a = MyObject.create({
        list: [{
          name: 'bob'
        }, {
          name: 'mitch'
        }, {
          name: 'mitch'
        }]
      });
      var b = MyObject.create({
        list: [{
          name: 'warren'
        }, {
          name: 'mitch'
        }]
      });
      assert.deepEqual(a.get('uniqueByName'), [{
        name: 'bob'
      }, {
        name: 'mitch'
      }]); // Making sure that 'mitch' appears

      assert.deepEqual(b.get('uniqueByName'), [{
        name: 'warren'
      }, {
        name: 'mitch'
      }]);
    };

    _proto6['@test it handles changes to the dependent array'] = function testItHandlesChangesToTheDependentArray(assert) {
      obj.get('list').pushObject({
        id: 3,
        value: 'three'
      });
      assert.deepEqual(obj.get('uniqueById'), [{
        id: 1,
        value: 'one'
      }, {
        id: 2,
        value: 'two'
      }, {
        id: 3,
        value: 'three'
      }], 'The list includes three');
      obj.get('list').pushObject({
        id: 3,
        value: 'three'
      });
      assert.deepEqual(obj.get('uniqueById'), [{
        id: 1,
        value: 'one'
      }, {
        id: 2,
        value: 'two'
      }, {
        id: 3,
        value: 'three'
      }], 'The list does not include a duplicate three');
    };

    _proto6['@test it returns an empty array when computed on a non-array'] = function testItReturnsAnEmptyArrayWhenComputedOnANonArray(assert) {
      var MyObject = _runtime.Object.extend({
        list: null,
        uniq: (0, _computed.uniqBy)('list', 'name')
      });

      var a = MyObject.create({
        list: 'not an array'
      });
      assert.deepEqual(a.get('uniq'), []);
    };

    return _class6;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('computed.intersect',
  /*#__PURE__*/
  function (_AbstractTestCase7) {
    (0, _emberBabel.inheritsLoose)(_class7, _AbstractTestCase7);

    function _class7() {
      return _AbstractTestCase7.apply(this, arguments) || this;
    }

    var _proto7 = _class7.prototype;

    _proto7.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        intersection: (0, _computed.intersect)('array', 'array2', 'array3')
      }).create({
        array: (0, _runtime.A)([1, 2, 3, 4, 5, 6]),
        array2: (0, _runtime.A)([3, 3, 3, 4, 5]),
        array3: (0, _runtime.A)([3, 5, 6, 7, 8])
      });
    };

    _proto7.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto7['@test intersect is readOnly'] = function testIntersectIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('intersection', 1);
      }, /Cannot set read-only property "intersection" on object:/);
    };

    _proto7['@test it has set-intersection semantics'] = function testItHasSetIntersectionSemantics(assert) {
      var array2 = obj.get('array2');
      var array3 = obj.get('array3');
      assert.deepEqual(obj.get('intersection').sort(function (x, y) {
        return x - y;
      }), [3, 5], 'intersection is initially correct');
      array2.shiftObject();
      assert.deepEqual(obj.get('intersection').sort(function (x, y) {
        return x - y;
      }), [3, 5], 'objects are not removed when they are still in all dependent arrays');
      array2.shiftObject();
      assert.deepEqual(obj.get('intersection').sort(function (x, y) {
        return x - y;
      }), [3, 5], 'objects are not removed when they are still in all dependent arrays');
      array2.shiftObject();
      assert.deepEqual(obj.get('intersection'), [5], 'objects are removed once they are gone from all dependent arrays');
      array2.pushObject(1);
      assert.deepEqual(obj.get('intersection'), [5], 'objects are not added as long as they are missing from any dependent array');
      array3.pushObject(1);
      assert.deepEqual(obj.get('intersection').sort(function (x, y) {
        return x - y;
      }), [1, 5], 'objects added once they belong to all dependent arrays');
    };

    return _class7;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('setDiff',
  /*#__PURE__*/
  function (_AbstractTestCase8) {
    (0, _emberBabel.inheritsLoose)(_class8, _AbstractTestCase8);

    function _class8() {
      return _AbstractTestCase8.apply(this, arguments) || this;
    }

    var _proto8 = _class8.prototype;

    _proto8.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        diff: (0, _computed.setDiff)('array', 'array2')
      }).create({
        array: (0, _runtime.A)([1, 2, 3, 4, 5, 6, 7]),
        array2: (0, _runtime.A)([3, 4, 5, 10])
      });
    };

    _proto8.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto8['@test setDiff is readOnly'] = function testSetDiffIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('diff', 1);
      }, /Cannot set read-only property "diff" on object:/);
    };

    _proto8['@test it asserts if given fewer or more than two dependent properties'] = function testItAssertsIfGivenFewerOrMoreThanTwoDependentProperties() {
      expectAssertion(function () {
        _runtime.Object.extend({
          diff: (0, _computed.setDiff)('array')
        }).create({
          array: (0, _runtime.A)([1, 2, 3, 4, 5, 6, 7]),
          array2: (0, _runtime.A)([3, 4, 5])
        });
      }, /\`computed\.setDiff\` requires exactly two dependent arrays/, 'setDiff requires two dependent arrays');
      expectAssertion(function () {
        _runtime.Object.extend({
          diff: (0, _computed.setDiff)('array', 'array2', 'array3')
        }).create({
          array: (0, _runtime.A)([1, 2, 3, 4, 5, 6, 7]),
          array2: (0, _runtime.A)([3, 4, 5]),
          array3: (0, _runtime.A)([7])
        });
      }, /\`computed\.setDiff\` requires exactly two dependent arrays/, 'setDiff requires two dependent arrays');
    };

    _proto8['@test it has set-diff semantics'] = function testItHasSetDiffSemantics(assert) {
      var array1 = obj.get('array');
      var array2 = obj.get('array2');
      assert.deepEqual(obj.get('diff').sort(function (x, y) {
        return x - y;
      }), [1, 2, 6, 7], 'set-diff is initially correct');
      array2.popObject();
      assert.deepEqual(obj.get('diff').sort(function (x, y) {
        return x - y;
      }), [1, 2, 6, 7], 'removing objects from the remove set has no effect if the object is not in the keep set');
      array2.shiftObject();
      assert.deepEqual(obj.get('diff').sort(function (x, y) {
        return x - y;
      }), [1, 2, 3, 6, 7], "removing objects from the remove set adds them if they're in the keep set");
      array1.removeObject(3);
      assert.deepEqual(obj.get('diff').sort(function (x, y) {
        return x - y;
      }), [1, 2, 6, 7], 'removing objects from the keep array removes them from the computed array');
      array1.pushObject(5);
      assert.deepEqual(obj.get('diff').sort(function (x, y) {
        return x - y;
      }), [1, 2, 6, 7], 'objects added to the keep array that are in the remove array are not added to the computed array');
      array1.pushObject(22);
      assert.deepEqual(obj.get('diff').sort(function (x, y) {
        return x - y;
      }), [1, 2, 6, 7, 22], 'objects added to the keep array not in the remove array are added to the computed array');
    };

    return _class8;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('sort - sortProperties',
  /*#__PURE__*/
  function (_AbstractTestCase9) {
    (0, _emberBabel.inheritsLoose)(_class9, _AbstractTestCase9);

    function _class9() {
      return _AbstractTestCase9.apply(this, arguments) || this;
    }

    var _proto9 = _class9.prototype;

    _proto9.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        sortedItems: (0, _computed.sort)('items', 'itemSorting')
      }).create({
        itemSorting: (0, _runtime.A)(['lname', 'fname']),
        items: (0, _runtime.A)([{
          fname: 'Jaime',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Cersei',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Robb',
          lname: 'Stark',
          age: 16
        }, {
          fname: 'Bran',
          lname: 'Stark',
          age: 8
        }])
      });
    };

    _proto9.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto9['@test sort is readOnly'] = function testSortIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('sortedItems', 1);
      }, /Cannot set read-only property "sortedItems" on object:/);
    };

    _proto9['@test arrays are initially sorted'] = function testArraysAreInitiallySorted(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'array is initially sorted');
    };

    _proto9['@test default sort order is correct'] = function testDefaultSortOrderIsCorrect(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'array is initially sorted');
    };

    _proto9['@test changing the dependent array updates the sorted array'] = function testChangingTheDependentArrayUpdatesTheSortedArray(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      obj.set('items', [{
        fname: 'Roose',
        lname: 'Bolton'
      }, {
        fname: 'Theon',
        lname: 'Greyjoy'
      }, {
        fname: 'Ramsey',
        lname: 'Bolton'
      }, {
        fname: 'Stannis',
        lname: 'Baratheon'
      }]);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Stannis', 'Ramsey', 'Roose', 'Theon'], 'changing dependent array updates sorted array');
    };

    _proto9['@test adding to the dependent array updates the sorted array'] = function testAddingToTheDependentArrayUpdatesTheSortedArray(assert) {
      var items = obj.get('items');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      items.pushObject({
        fname: 'Tyrion',
        lname: 'Lannister'
      });
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb'], 'Adding to the dependent array updates the sorted array');
    };

    _proto9['@test removing from the dependent array updates the sorted array'] = function testRemovingFromTheDependentArrayUpdatesTheSortedArray(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      obj.get('items').popObject();
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Robb'], 'Removing from the dependent array updates the sorted array');
    };

    _proto9['@test distinct items may be sort-equal, although their relative order will not be guaranteed'] = function testDistinctItemsMayBeSortEqualAlthoughTheirRelativeOrderWillNotBeGuaranteed(assert) {
      // We recreate jaime and "Cersei" here only for test stability: we want
      // their guid-ordering to be deterministic
      var jaimeInDisguise = {
        fname: 'Cersei',
        lname: 'Lannister',
        age: 34
      };
      var jaime = {
        fname: 'Jaime',
        lname: 'Lannister',
        age: 34
      };
      var items = obj.get('items');
      items.replace(0, 1, [jaime]);
      items.replace(1, 1, [jaimeInDisguise]);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _metal.set)(jaimeInDisguise, 'fname', 'Jaime');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Jaime', 'Bran', 'Robb'], 'sorted array is updated');
      (0, _metal.set)(jaimeInDisguise, 'fname', 'Cersei');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'sorted array is updated');
    };

    _proto9['@test guid sort-order fallback with a search proxy is not confused by non-search ObjectProxys'] = function testGuidSortOrderFallbackWithASearchProxyIsNotConfusedByNonSearchObjectProxys(assert) {
      var tyrion = {
        fname: 'Tyrion',
        lname: 'Lannister'
      };

      var tyrionInDisguise = _runtime.ObjectProxy.create({
        fname: 'Yollo',
        lname: '',
        content: tyrion
      });

      var items = obj.get('items');
      items.pushObject(tyrion);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb']);
      items.pushObject(tyrionInDisguise);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Yollo', 'Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb']);
    };

    _proto9['@test updating sort properties detaches observers for old sort properties'] = function testUpdatingSortPropertiesDetachesObserversForOldSortProperties(assert) {
      var objectToRemove = obj.get('items')[3];
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      obj.set('itemSorting', (0, _runtime.A)(['fname:desc']));
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Robb', 'Jaime', 'Cersei', 'Bran'], 'after updating sort properties array is updated');
      obj.get('items').removeObject(objectToRemove);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Robb', 'Jaime', 'Cersei'], 'after removing item array is updated');
      (0, _metal.set)(objectToRemove, 'lname', 'Updated-Stark');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Robb', 'Jaime', 'Cersei'], 'after changing removed item array is not updated');
    };

    _proto9['@test sort works if array property is null (non array value) on first evaluation of computed prop'] = function testSortWorksIfArrayPropertyIsNullNonArrayValueOnFirstEvaluationOfComputedProp(assert) {
      obj.set('items', null);
      assert.deepEqual(obj.get('sortedItems'), []);
      obj.set('items', (0, _runtime.A)([{
        fname: 'Cersei',
        lname: 'Lanister'
      }]));
      assert.deepEqual(obj.get('sortedItems'), [{
        fname: 'Cersei',
        lname: 'Lanister'
      }]);
    };

    _proto9['@test updating sort properties updates the sorted array'] = function testUpdatingSortPropertiesUpdatesTheSortedArray(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      obj.set('itemSorting', (0, _runtime.A)(['fname:desc']));
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Robb', 'Jaime', 'Cersei', 'Bran'], 'after updating sort properties array is updated');
    };

    _proto9['@test updating sort properties invalidates the sorted array'] = function testUpdatingSortPropertiesInvalidatesTheSortedArray(assert) {
      var sortProps = obj.get('itemSorting');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      sortProps.clear();
      sortProps.pushObject('fname');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Bran', 'Cersei', 'Jaime', 'Robb'], 'after updating sort properties array is updated');
    };

    _proto9['@test updating new sort properties invalidates the sorted array'] = function testUpdatingNewSortPropertiesInvalidatesTheSortedArray(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      obj.set('itemSorting', (0, _runtime.A)(['age:desc', 'fname:asc']));
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Robb', 'Bran'], 'precond - array is correct after item sorting is changed');
      (0, _metal.set)(obj.get('items')[1], 'age', 29);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Cersei', 'Robb', 'Bran'], 'after updating sort properties array is updated');
    };

    _proto9['@test sort direction defaults to ascending'] = function testSortDirectionDefaultsToAscending(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb']);
    };

    _proto9['@test sort direction defaults to ascending (with sort property change)'] = function testSortDirectionDefaultsToAscendingWithSortPropertyChange(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      obj.set('itemSorting', (0, _runtime.A)(['fname']));
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Bran', 'Cersei', 'Jaime', 'Robb'], 'sort direction defaults to ascending');
    };

    _proto9["@test updating an item's sort properties updates the sorted array"] = function testUpdatingAnItemSSortPropertiesUpdatesTheSortedArray(assert) {
      var tyrionInDisguise = obj.get('items')[1];
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _metal.set)(tyrionInDisguise, 'fname', 'Tyrion');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Tyrion', 'Bran', 'Robb'], "updating an item's sort properties updates the sorted array");
    };

    _proto9["@test updating several of an item's sort properties updated the sorted array"] = function testUpdatingSeveralOfAnItemSSortPropertiesUpdatedTheSortedArray(assert) {
      var sansaInDisguise = obj.get('items')[1];
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _metal.setProperties)(sansaInDisguise, {
        fname: 'Sansa',
        lname: 'Stark'
      });
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Bran', 'Robb', 'Sansa'], "updating an item's sort properties updates the sorted array");
    };

    _proto9["@test updating an item's sort properties does not error when binary search does a self compare (#3273)"] = function testUpdatingAnItemSSortPropertiesDoesNotErrorWhenBinarySearchDoesASelfCompare3273(assert) {
      var jaime = {
        name: 'Jaime',
        status: 1
      };
      var cersei = {
        name: 'Cersei',
        status: 2
      };

      var obj = _runtime.Object.extend({
        sortProps: ['status'],
        sortedPeople: (0, _computed.sort)('people', 'sortProps')
      }).create({
        people: [jaime, cersei]
      });

      assert.deepEqual(obj.get('sortedPeople'), [jaime, cersei], 'precond - array is initially sorted');
      (0, _metal.set)(cersei, 'status', 3);
      assert.deepEqual(obj.get('sortedPeople'), [jaime, cersei], 'array is sorted correctly');
      (0, _metal.set)(cersei, 'status', 2);
      assert.deepEqual(obj.get('sortedPeople'), [jaime, cersei], 'array is sorted correctly');
    };

    _proto9['@test array should not be sorted if sort properties array is empty'] = function testArrayShouldNotBeSortedIfSortPropertiesArrayIsEmpty(assert) {
      var o = _runtime.Object.extend({
        sortedItems: (0, _computed.sort)('items', 'itemSorting')
      }).create({
        itemSorting: (0, _runtime.A)([]),
        // This bug only manifests when array.sort(() => 0) is not equal to array.
        // In order for this to happen, the browser must use an unstable sort and the
        // array must be sufficient large. On Chrome, 12 items is currently sufficient.
        items: (0, _runtime.A)([6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5])
      });

      assert.deepEqual(o.get('sortedItems'), [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5], 'array is not changed');
    };

    _proto9['@test array should update if items to be sorted is replaced when sort properties array is empty'] = function testArrayShouldUpdateIfItemsToBeSortedIsReplacedWhenSortPropertiesArrayIsEmpty(assert) {
      var o = _runtime.Object.extend({
        sortedItems: (0, _computed.sort)('items', 'itemSorting')
      }).create({
        itemSorting: (0, _runtime.A)([]),
        items: (0, _runtime.A)([6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5])
      });

      assert.deepEqual(o.get('sortedItems'), [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5], 'array is not changed');
      (0, _metal.set)(o, 'items', (0, _runtime.A)([5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4]));
      assert.deepEqual(o.get('sortedItems'), [5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4], 'array was updated');
    };

    _proto9['@test array should update if items to be sorted is mutated when sort properties array is empty'] = function testArrayShouldUpdateIfItemsToBeSortedIsMutatedWhenSortPropertiesArrayIsEmpty(assert) {
      var o = _runtime.Object.extend({
        sortedItems: (0, _computed.sort)('items', 'itemSorting')
      }).create({
        itemSorting: (0, _runtime.A)([]),
        items: (0, _runtime.A)([6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5])
      });

      assert.deepEqual(o.get('sortedItems'), [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5], 'array is not changed');
      o.get('items').pushObject(12);
      assert.deepEqual(o.get('sortedItems'), [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5, 12], 'array was updated');
    };

    _proto9['@test array observers do not leak'] = function testArrayObserversDoNotLeak(assert) {
      var daria = {
        name: 'Daria'
      };
      var jane = {
        name: 'Jane'
      };
      var sisters = [jane, daria];
      var sortProps = (0, _runtime.A)(['name']);

      var jaime = _runtime.Object.extend({
        sortedPeople: (0, _computed.sort)('sisters', 'sortProps'),
        sortProps: sortProps
      }).create({
        sisters: sisters
      });

      jaime.get('sortedPeople');
      (0, _runloop.run)(jaime, 'destroy');

      try {
        sortProps.pushObject({
          name: 'Anna'
        });
        assert.ok(true);
      } catch (e) {
        assert.ok(false, e);
      }
    };

    _proto9['@test property paths in sort properties update the sorted array'] = function testPropertyPathsInSortPropertiesUpdateTheSortedArray(assert) {
      var jaime = {
        relatedObj: {
          status: 1,
          firstName: 'Jaime',
          lastName: 'Lannister'
        }
      };
      var cersei = {
        relatedObj: {
          status: 2,
          firstName: 'Cersei',
          lastName: 'Lannister'
        }
      };

      var sansa = _runtime.Object.create({
        relatedObj: {
          status: 3,
          firstName: 'Sansa',
          lastName: 'Stark'
        }
      });

      var obj = _runtime.Object.extend({
        sortProps: ['relatedObj.status'],
        sortedPeople: (0, _computed.sort)('people', 'sortProps')
      }).create({
        people: [jaime, cersei, sansa]
      });

      assert.deepEqual(obj.get('sortedPeople'), [jaime, cersei, sansa], 'precond - array is initially sorted');
      (0, _metal.set)(cersei, 'status', 3);
      assert.deepEqual(obj.get('sortedPeople'), [jaime, cersei, sansa], 'array is sorted correctly');
      (0, _metal.set)(cersei, 'status', 1);
      assert.deepEqual(obj.get('sortedPeople'), [jaime, cersei, sansa], 'array is sorted correctly');
      sansa.set('status', 1);
      assert.deepEqual(obj.get('sortedPeople'), [jaime, cersei, sansa], 'array is sorted correctly');
      obj.set('sortProps', ['relatedObj.firstName']);
      assert.deepEqual(obj.get('sortedPeople'), [cersei, jaime, sansa], 'array is sorted correctly');
    };

    _proto9['@test if the dependentKey is neither an array nor object, it will return an empty array'] = function testIfTheDependentKeyIsNeitherAnArrayNorObjectItWillReturnAnEmptyArray(assert) {
      (0, _metal.set)(obj, 'items', null);
      assert.ok((0, _runtime.isArray)(obj.get('sortedItems')), 'returns an empty arrays');
      (0, _metal.set)(obj, 'array', undefined);
      assert.ok((0, _runtime.isArray)(obj.get('sortedItems')), 'returns an empty arrays');
      (0, _metal.set)(obj, 'array', 'not an array');
      assert.ok((0, _runtime.isArray)(obj.get('sortedItems')), 'returns an empty arrays');
    };

    return _class9;
  }(_internalTestHelpers.AbstractTestCase));

  function sortByLnameFname(a, b) {
    var lna = (0, _metal.get)(a, 'lname');
    var lnb = (0, _metal.get)(b, 'lname');

    if (lna !== lnb) {
      return lna > lnb ? 1 : -1;
    }

    return sortByFnameAsc(a, b);
  }

  function sortByFnameAsc(a, b) {
    var fna = (0, _metal.get)(a, 'fname');
    var fnb = (0, _metal.get)(b, 'fname');

    if (fna === fnb) {
      return 0;
    }

    return fna > fnb ? 1 : -1;
  }

  (0, _internalTestHelpers.moduleFor)('sort - sort function',
  /*#__PURE__*/
  function (_AbstractTestCase10) {
    (0, _emberBabel.inheritsLoose)(_class10, _AbstractTestCase10);

    function _class10() {
      return _AbstractTestCase10.apply(this, arguments) || this;
    }

    var _proto10 = _class10.prototype;

    _proto10.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        sortedItems: (0, _computed.sort)('items.@each.fname', sortByLnameFname)
      }).create({
        items: (0, _runtime.A)([{
          fname: 'Jaime',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Cersei',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Robb',
          lname: 'Stark',
          age: 16
        }, {
          fname: 'Bran',
          lname: 'Stark',
          age: 8
        }])
      });
    };

    _proto10.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto10['@test sort has correct `this`'] = function testSortHasCorrectThis(assert) {
      var obj = _runtime.Object.extend({
        sortedItems: (0, _computed.sort)('items.@each.fname', function (a, b) {
          assert.equal(this, obj, 'expected the object to be `this`');
          return this.sortByLastName(a, b);
        }),
        sortByLastName: function (a, b) {
          return sortByFnameAsc(a, b);
        }
      }).create({
        items: (0, _runtime.A)([{
          fname: 'Jaime',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Cersei',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Robb',
          lname: 'Stark',
          age: 16
        }, {
          fname: 'Bran',
          lname: 'Stark',
          age: 8
        }])
      });

      obj.get('sortedItems');
    };

    _proto10['@test sort (with function) is readOnly'] = function testSortWithFunctionIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('sortedItems', 1);
      }, /Cannot set read-only property "sortedItems" on object:/);
    };

    _proto10['@test arrays are initially sorted'] = function testArraysAreInitiallySorted(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'array is initially sorted');
    };

    _proto10['@test default sort order is correct'] = function testDefaultSortOrderIsCorrect(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'array is initially sorted');
    };

    _proto10['@test changing the dependent array updates the sorted array'] = function testChangingTheDependentArrayUpdatesTheSortedArray(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      obj.set('items', [{
        fname: 'Roose',
        lname: 'Bolton'
      }, {
        fname: 'Theon',
        lname: 'Greyjoy'
      }, {
        fname: 'Ramsey',
        lname: 'Bolton'
      }, {
        fname: 'Stannis',
        lname: 'Baratheon'
      }]);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Stannis', 'Ramsey', 'Roose', 'Theon'], 'changing dependent array updates sorted array');
    };

    _proto10['@test adding to the dependent array updates the sorted array'] = function testAddingToTheDependentArrayUpdatesTheSortedArray(assert) {
      var items = obj.get('items');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      items.pushObject({
        fname: 'Tyrion',
        lname: 'Lannister'
      });
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb'], 'Adding to the dependent array updates the sorted array');
    };

    _proto10['@test removing from the dependent array updates the sorted array'] = function testRemovingFromTheDependentArrayUpdatesTheSortedArray(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      obj.get('items').popObject();
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Robb'], 'Removing from the dependent array updates the sorted array');
    };

    _proto10['@test distinct items may be sort-equal, although their relative order will not be guaranteed'] = function testDistinctItemsMayBeSortEqualAlthoughTheirRelativeOrderWillNotBeGuaranteed(assert) {
      // We recreate jaime and "Cersei" here only for test stability: we want
      // their guid-ordering to be deterministic
      var jaimeInDisguise = {
        fname: 'Cersei',
        lname: 'Lannister',
        age: 34
      };
      var jaime = {
        fname: 'Jaime',
        lname: 'Lannister',
        age: 34
      };
      var items = obj.get('items');
      items.replace(0, 1, [jaime]);
      items.replace(1, 1, [jaimeInDisguise]);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _metal.set)(jaimeInDisguise, 'fname', 'Jaime');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Jaime', 'Bran', 'Robb'], 'sorted array is updated');
      (0, _metal.set)(jaimeInDisguise, 'fname', 'Cersei');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'sorted array is updated');
    };

    _proto10['@test guid sort-order fallback with a search proxy is not confused by non-search ObjectProxys'] = function testGuidSortOrderFallbackWithASearchProxyIsNotConfusedByNonSearchObjectProxys(assert) {
      var tyrion = {
        fname: 'Tyrion',
        lname: 'Lannister'
      };

      var tyrionInDisguise = _runtime.ObjectProxy.create({
        fname: 'Yollo',
        lname: '',
        content: tyrion
      });

      var items = obj.get('items');
      items.pushObject(tyrion);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb']);
      items.pushObject(tyrionInDisguise);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Yollo', 'Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb']);
    };

    _proto10['@test changing item properties specified via @each triggers a resort of the modified item'] = function testChangingItemPropertiesSpecifiedViaEachTriggersAResortOfTheModifiedItem(assert) {
      var items = (0, _metal.get)(obj, 'items');
      var tyrionInDisguise = items[1];
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _metal.set)(tyrionInDisguise, 'fname', 'Tyrion');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Tyrion', 'Bran', 'Robb'], 'updating a specified property on an item resorts it');
    };

    _proto10['@test changing item properties not specified via @each does not trigger a resort'] = function testChangingItemPropertiesNotSpecifiedViaEachDoesNotTriggerAResort(assert) {
      if (!false
      /* EMBER_METAL_TRACKED_PROPERTIES */
      ) {
          var items = obj.get('items');
          var cersei = items[1];
          assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
          (0, _metal.set)(cersei, 'lname', 'Stark'); // plot twist! (possibly not canon)
          // The array has become unsorted.  If your sort function is sensitive to
          // properties, they *must* be specified as dependent item property keys or
          // we'll be doing binary searches on unsorted arrays.

          assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'updating an unspecified property on an item does not resort it');
        } else {
        assert.expect(0);
      }
    };

    return _class10;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('sort - stability',
  /*#__PURE__*/
  function (_AbstractTestCase11) {
    (0, _emberBabel.inheritsLoose)(_class11, _AbstractTestCase11);

    function _class11() {
      return _AbstractTestCase11.apply(this, arguments) || this;
    }

    var _proto11 = _class11.prototype;

    _proto11.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        sortProps: ['count', 'name'],
        sortedItems: (0, _computed.sort)('items', 'sortProps')
      }).create({
        items: [{
          name: 'A',
          count: 1,
          thing: 4
        }, {
          name: 'B',
          count: 1,
          thing: 3
        }, {
          name: 'C',
          count: 1,
          thing: 2
        }, {
          name: 'D',
          count: 1,
          thing: 4
        }]
      });
    };

    _proto11.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto11['@test sorts correctly as only one property changes'] = function testSortsCorrectlyAsOnlyOnePropertyChanges(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'initial');
      (0, _metal.set)(obj.get('items')[3], 'count', 2);
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'final');
    };

    return _class11;
  }(_internalTestHelpers.AbstractTestCase));
  var klass;
  (0, _internalTestHelpers.moduleFor)('sort - concurrency',
  /*#__PURE__*/
  function (_AbstractTestCase12) {
    (0, _emberBabel.inheritsLoose)(_class12, _AbstractTestCase12);

    function _class12() {
      return _AbstractTestCase12.apply(this, arguments) || this;
    }

    var _proto12 = _class12.prototype;

    _proto12.beforeEach = function beforeEach() {
      klass = _runtime.Object.extend({
        sortProps: ['count'],
        sortedItems: (0, _computed.sort)('items', 'sortProps'),
        customSortedItems: (0, _computed.sort)('items.@each.count', function (a, b) {
          return a.count - b.count;
        })
      });
      obj = klass.create({
        items: (0, _runtime.A)([{
          name: 'A',
          count: 1,
          thing: 4,
          id: 1
        }, {
          name: 'B',
          count: 2,
          thing: 3,
          id: 2
        }, {
          name: 'C',
          count: 3,
          thing: 2,
          id: 3
        }, {
          name: 'D',
          count: 4,
          thing: 1,
          id: 4
        }])
      });
    };

    _proto12.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto12['@test sorts correctly after mutation to the sort properties'] = function testSortsCorrectlyAfterMutationToTheSortProperties(assert) {
      var sorted = obj.get('sortedItems');
      assert.deepEqual(sorted.mapBy('name'), ['A', 'B', 'C', 'D'], 'initial');
      (0, _metal.set)(obj.get('items')[1], 'count', 5);
      (0, _metal.set)(obj.get('items')[2], 'count', 6);
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'final');
    };

    _proto12['@test sort correctly after mutation to the sort'] = function testSortCorrectlyAfterMutationToTheSort(assert) {
      assert.deepEqual(obj.get('customSortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'initial');
      (0, _metal.set)(obj.get('items')[1], 'count', 5);
      (0, _metal.set)(obj.get('items')[2], 'count', 6);
      assert.deepEqual(obj.get('customSortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'final');
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'final');
    };

    _proto12['@test sort correctly on multiple instances of the same class'] = function testSortCorrectlyOnMultipleInstancesOfTheSameClass(assert) {
      var obj2 = klass.create({
        items: (0, _runtime.A)([{
          name: 'W',
          count: 23,
          thing: 4
        }, {
          name: 'X',
          count: 24,
          thing: 3
        }, {
          name: 'Y',
          count: 25,
          thing: 2
        }, {
          name: 'Z',
          count: 26,
          thing: 1
        }])
      });
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['W', 'X', 'Y', 'Z'], 'initial');
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'initial');
      (0, _metal.set)(obj.get('items')[1], 'count', 5);
      (0, _metal.set)(obj.get('items')[2], 'count', 6);
      (0, _metal.set)(obj2.get('items')[1], 'count', 27);
      (0, _metal.set)(obj2.get('items')[2], 'count', 28);
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'final');
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['W', 'Z', 'X', 'Y'], 'final');
      obj.set('sortProps', ['thing']);
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['D', 'C', 'B', 'A'], 'final');
      obj2.notifyPropertyChange('sortedItems'); // invalidate to flush, to get DK refreshed

      obj2.get('sortedItems'); // flush to get updated DK

      obj2.set('items.firstObject.count', 9999);
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['Z', 'X', 'Y', 'W'], 'final');
    };

    _proto12['@test sort correctly when multiple sorts are chained on the same instance of a class'] = function testSortCorrectlyWhenMultipleSortsAreChainedOnTheSameInstanceOfAClass(assert) {
      var obj2 = klass.extend({
        items: (0, _metal.computed)('sibling.sortedItems.[]', function () {
          return this.get('sibling.sortedItems');
        }),
        asdf: (0, _metal.observer)('sibling.sortedItems.[]', function () {
          this.get('sibling.sortedItems');
        })
      }).create({
        sibling: obj
      });
      /*
                                                                           
                                             sortedProps                              sortedProps2
                                                                           
                                                                                              
                                                                                 
                                                           CP (sort)        
                                                                                 
                                                                                              
                                                                
                                                                            
         items     items.@each.count  sortedItems  items.@each.count  sortedItems2
                                                                            
                                                                
      */

      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'obj.sortedItems.name should be sorted alpha');
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'obj2.sortedItems.name should be sorted alpha');
      (0, _metal.set)(obj.get('items')[1], 'count', 5);
      (0, _metal.set)(obj.get('items')[2], 'count', 6);
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'obj.sortedItems.name should now have changed');
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'obj2.sortedItems.name should still mirror sortedItems2');
      obj.set('sortProps', ['thing']);
      obj2.set('sortProps', ['id']);
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'we now sort obj2 by id, so we expect a b c d');
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['D', 'C', 'B', 'A'], 'we now sort obj by thing');
    };

    return _class12;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('max',
  /*#__PURE__*/
  function (_AbstractTestCase13) {
    (0, _emberBabel.inheritsLoose)(_class13, _AbstractTestCase13);

    function _class13() {
      return _AbstractTestCase13.apply(this, arguments) || this;
    }

    var _proto13 = _class13.prototype;

    _proto13.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        max: (0, _computed.max)('items')
      }).create({
        items: (0, _runtime.A)([1, 2, 3])
      });
    };

    _proto13.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto13['@test max is readOnly'] = function testMaxIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('max', 1);
      }, /Cannot set read-only property "max" on object:/);
    };

    _proto13['@test max tracks the max number as objects are added'] = function testMaxTracksTheMaxNumberAsObjectsAreAdded(assert) {
      assert.equal(obj.get('max'), 3, 'precond - max is initially correct');
      var items = obj.get('items');
      items.pushObject(5);
      assert.equal(obj.get('max'), 5, 'max updates when a larger number is added');
      items.pushObject(2);
      assert.equal(obj.get('max'), 5, 'max does not update when a smaller number is added');
    };

    _proto13['@test max recomputes when the current max is removed'] = function testMaxRecomputesWhenTheCurrentMaxIsRemoved(assert) {
      assert.equal(obj.get('max'), 3, 'precond - max is initially correct');
      obj.get('items').removeObject(2);
      assert.equal(obj.get('max'), 3, 'max is unchanged when a non-max item is removed');
      obj.get('items').removeObject(3);
      assert.equal(obj.get('max'), 1, 'max is recomputed when the current max is removed');
    };

    return _class13;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('min',
  /*#__PURE__*/
  function (_AbstractTestCase14) {
    (0, _emberBabel.inheritsLoose)(_class14, _AbstractTestCase14);

    function _class14() {
      return _AbstractTestCase14.apply(this, arguments) || this;
    }

    var _proto14 = _class14.prototype;

    _proto14.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        min: (0, _computed.min)('items')
      }).create({
        items: (0, _runtime.A)([1, 2, 3])
      });
    };

    _proto14.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto14['@test min is readOnly'] = function testMinIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('min', 1);
      }, /Cannot set read-only property "min" on object:/);
    };

    _proto14['@test min tracks the min number as objects are added'] = function testMinTracksTheMinNumberAsObjectsAreAdded(assert) {
      assert.equal(obj.get('min'), 1, 'precond - min is initially correct');
      obj.get('items').pushObject(-2);
      assert.equal(obj.get('min'), -2, 'min updates when a smaller number is added');
      obj.get('items').pushObject(2);
      assert.equal(obj.get('min'), -2, 'min does not update when a larger number is added');
    };

    _proto14['@test min recomputes when the current min is removed'] = function testMinRecomputesWhenTheCurrentMinIsRemoved(assert) {
      var items = obj.get('items');
      assert.equal(obj.get('min'), 1, 'precond - min is initially correct');
      items.removeObject(2);
      assert.equal(obj.get('min'), 1, 'min is unchanged when a non-min item is removed');
      items.removeObject(1);
      assert.equal(obj.get('min'), 3, 'min is recomputed when the current min is removed');
    };

    return _class14;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Ember.arrayComputed - mixed sugar',
  /*#__PURE__*/
  function (_AbstractTestCase15) {
    (0, _emberBabel.inheritsLoose)(_class15, _AbstractTestCase15);

    function _class15() {
      return _AbstractTestCase15.apply(this, arguments) || this;
    }

    var _proto15 = _class15.prototype;

    _proto15.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        lannisters: (0, _computed.filterBy)('items', 'lname', 'Lannister'),
        lannisterSorting: (0, _runtime.A)(['fname']),
        sortedLannisters: (0, _computed.sort)('lannisters', 'lannisterSorting'),
        starks: (0, _computed.filterBy)('items', 'lname', 'Stark'),
        starkAges: (0, _computed.mapBy)('starks', 'age'),
        oldestStarkAge: (0, _computed.max)('starkAges')
      }).create({
        items: (0, _runtime.A)([{
          fname: 'Jaime',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Cersei',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Robb',
          lname: 'Stark',
          age: 16
        }, {
          fname: 'Bran',
          lname: 'Stark',
          age: 8
        }])
      });
    };

    _proto15.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto15['@test filtering and sorting can be combined'] = function testFilteringAndSortingCanBeCombined(assert) {
      var items = obj.get('items');
      assert.deepEqual(obj.get('sortedLannisters').mapBy('fname'), ['Cersei', 'Jaime'], 'precond - array is initially filtered and sorted');
      items.pushObject({
        fname: 'Tywin',
        lname: 'Lannister'
      });
      items.pushObject({
        fname: 'Lyanna',
        lname: 'Stark'
      });
      items.pushObject({
        fname: 'Gerion',
        lname: 'Lannister'
      });
      assert.deepEqual(obj.get('sortedLannisters').mapBy('fname'), ['Cersei', 'Gerion', 'Jaime', 'Tywin'], 'updates propagate to array');
    };

    _proto15['@test filtering, sorting and reduce (max) can be combined'] = function testFilteringSortingAndReduceMaxCanBeCombined(assert) {
      var items = obj.get('items');
      assert.equal(16, obj.get('oldestStarkAge'), 'precond - end of chain is initially correct');
      items.pushObject({
        fname: 'Rickon',
        lname: 'Stark',
        age: 5
      });
      assert.equal(16, obj.get('oldestStarkAge'), 'chain is updated correctly');
      items.pushObject({
        fname: 'Eddard',
        lname: 'Stark',
        age: 35
      });
      assert.equal(35, obj.get('oldestStarkAge'), 'chain is updated correctly');
    };

    return _class15;
  }(_internalTestHelpers.AbstractTestCase));

  function todo(name, priority) {
    return _runtime.Object.create({
      name: name,
      priority: priority
    });
  }

  function priorityComparator(todoA, todoB) {
    var pa = parseInt((0, _metal.get)(todoA, 'priority'), 10);
    var pb = parseInt((0, _metal.get)(todoB, 'priority'), 10);
    return pa - pb;
  }

  function evenPriorities(todo) {
    var p = parseInt((0, _metal.get)(todo, 'priority'), 10);
    return p % 2 === 0;
  }

  (0, _internalTestHelpers.moduleFor)('Ember.arrayComputed - chains',
  /*#__PURE__*/
  function (_AbstractTestCase16) {
    (0, _emberBabel.inheritsLoose)(_class16, _AbstractTestCase16);

    function _class16() {
      return _AbstractTestCase16.apply(this, arguments) || this;
    }

    var _proto16 = _class16.prototype;

    _proto16.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        sorted: (0, _computed.sort)('todos.@each.priority', priorityComparator),
        filtered: (0, _computed.filter)('sorted.@each.priority', evenPriorities)
      }).create({
        todos: (0, _runtime.A)([todo('E', 4), todo('D', 3), todo('C', 2), todo('B', 1), todo('A', 0)])
      });
    };

    _proto16.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto16['@test it can filter and sort when both depend on the same item property'] = function testItCanFilterAndSortWhenBothDependOnTheSameItemProperty(assert) {
      assert.deepEqual(obj.get('todos').mapBy('name'), ['E', 'D', 'C', 'B', 'A'], 'precond - todos initially correct');
      assert.deepEqual(obj.get('sorted').mapBy('name'), ['A', 'B', 'C', 'D', 'E'], 'precond - sorted initially correct');
      assert.deepEqual(obj.get('filtered').mapBy('name'), ['A', 'C', 'E'], 'precond - filtered initially correct');
      (0, _metal.set)(obj.get('todos')[1], 'priority', 6);
      assert.deepEqual(obj.get('todos').mapBy('name'), ['E', 'D', 'C', 'B', 'A'], 'precond - todos remain correct');
      assert.deepEqual(obj.get('sorted').mapBy('name'), ['A', 'B', 'C', 'E', 'D'], 'precond - sorted updated correctly');
      assert.deepEqual(obj.get('filtered').mapBy('name'), ['A', 'C', 'E', 'D'], 'filtered updated correctly');
    };

    return _class16;
  }(_internalTestHelpers.AbstractTestCase));
  var userFnCalls;
  (0, _internalTestHelpers.moduleFor)('Chaining array and reduced CPs',
  /*#__PURE__*/
  function (_AbstractTestCase17) {
    (0, _emberBabel.inheritsLoose)(_class17, _AbstractTestCase17);

    function _class17() {
      return _AbstractTestCase17.apply(this, arguments) || this;
    }

    var _proto17 = _class17.prototype;

    _proto17.beforeEach = function beforeEach() {
      userFnCalls = 0;
      obj = _runtime.Object.extend({
        mapped: (0, _computed.mapBy)('array', 'v'),
        max: (0, _computed.max)('mapped'),
        maxDidChange: (0, _metal.observer)('max', function () {
          return userFnCalls++;
        })
      }).create({
        array: (0, _runtime.A)([{
          v: 1
        }, {
          v: 3
        }, {
          v: 2
        }, {
          v: 1
        }])
      });
    };

    _proto17.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto17['@test it computes interdependent array computed properties'] = function testItComputesInterdependentArrayComputedProperties(assert) {
      assert.equal(obj.get('max'), 3, 'sanity - it properly computes the maximum value');
      var calls = 0;
      (0, _metal.addObserver)(obj, 'max', function () {
        return calls++;
      });
      obj.get('array').pushObject({
        v: 5
      });
      assert.equal(obj.get('max'), 5, 'maximum value is updated correctly');
      assert.equal(userFnCalls, 1, 'object defined observers fire');
      assert.equal(calls, 1, 'runtime created observers fire');
    };

    return _class17;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('sum',
  /*#__PURE__*/
  function (_AbstractTestCase18) {
    (0, _emberBabel.inheritsLoose)(_class18, _AbstractTestCase18);

    function _class18() {
      return _AbstractTestCase18.apply(this, arguments) || this;
    }

    var _proto18 = _class18.prototype;

    _proto18.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        total: (0, _computed.sum)('array')
      }).create({
        array: (0, _runtime.A)([1, 2, 3])
      });
    };

    _proto18.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto18['@test sum is readOnly'] = function testSumIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('total', 1);
      }, /Cannot set read-only property "total" on object:/);
    };

    _proto18['@test sums the values in the dependentKey'] = function testSumsTheValuesInTheDependentKey(assert) {
      assert.equal(obj.get('total'), 6, 'sums the values');
    };

    _proto18['@test if the dependentKey is neither an array nor object, it will return `0`'] = function testIfTheDependentKeyIsNeitherAnArrayNorObjectItWillReturn0(assert) {
      (0, _metal.set)(obj, 'array', null);
      assert.equal((0, _metal.get)(obj, 'total'), 0, 'returns 0');
      (0, _metal.set)(obj, 'array', undefined);
      assert.equal((0, _metal.get)(obj, 'total'), 0, 'returns 0');
      (0, _metal.set)(obj, 'array', 'not an array');
      assert.equal((0, _metal.get)(obj, 'total'), 0, 'returns 0');
    };

    _proto18['@test updates when array is modified'] = function testUpdatesWhenArrayIsModified(assert) {
      obj.get('array').pushObject(1);
      assert.equal(obj.get('total'), 7, 'recomputed when elements are added');
      obj.get('array').popObject();
      assert.equal(obj.get('total'), 6, 'recomputes when elements are removed');
    };

    return _class18;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('collect',
  /*#__PURE__*/
  function (_AbstractTestCase19) {
    (0, _emberBabel.inheritsLoose)(_class19, _AbstractTestCase19);

    function _class19() {
      return _AbstractTestCase19.apply(this, arguments) || this;
    }

    var _proto19 = _class19.prototype;

    _proto19['@test works'] = function testWorks(assert) {
      var obj = {
        one: 'foo',
        two: 'bar',
        three: null
      };
      (0, _metal.defineProperty)(obj, 'all', (0, _computed.collect)('one', 'two', 'three', 'four'));
      assert.deepEqual((0, _metal.get)(obj, 'all'), ['foo', 'bar', null, null], 'have all of them');
      (0, _metal.set)(obj, 'four', true);
      assert.deepEqual((0, _metal.get)(obj, 'all'), ['foo', 'bar', null, true], 'have all of them');
      var a = [];
      (0, _metal.set)(obj, 'one', 0);
      (0, _metal.set)(obj, 'three', a);
      assert.deepEqual((0, _metal.get)(obj, 'all'), [0, 'bar', a, true], 'have all of them');
    };

    return _class19;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/polyfills/tests/assign_test", ["ember-babel", "@ember/polyfills", "internal-test-helpers"], function (_emberBabel, _polyfills, _internalTestHelpers) {
  "use strict";

  var AssignTests =
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(AssignTests, _TestCase);

    function AssignTests() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = AssignTests.prototype;

    _proto['@test merging objects'] = function testMergingObjects(assert) {
      var trgt = {
        a: 1
      };
      var src1 = {
        b: 2
      };
      var src2 = {
        c: 3
      };
      this.assign(trgt, src1, src2);
      assert.deepEqual(trgt, {
        a: 1,
        b: 2,
        c: 3
      }, 'assign copies values from one or more source objects to a target object');
      assert.deepEqual(src1, {
        b: 2
      }, 'assign does not change source object 1');
      assert.deepEqual(src2, {
        c: 3
      }, 'assign does not change source object 2');
    };

    _proto['@test merging objects with same property'] = function testMergingObjectsWithSameProperty(assert) {
      var trgt = {
        a: 1,
        b: 1
      };
      var src1 = {
        a: 2,
        b: 2
      };
      var src2 = {
        a: 3
      };
      this.assign(trgt, src1, src2);
      assert.deepEqual(trgt, {
        a: 3,
        b: 2
      }, 'properties are overwritten by other objects that have the same properties later in the parameters order');
    };

    _proto['@test null'] = function testNull(assert) {
      var trgt = {
        a: 1
      };
      this.assign(trgt, null);
      assert.deepEqual(trgt, {
        a: 1
      }, 'null as a source parameter is ignored');
    };

    _proto['@test undefined'] = function testUndefined(assert) {
      var trgt = {
        a: 1
      };
      this.assign(trgt, null);
      assert.deepEqual(trgt, {
        a: 1
      }, 'undefined as a source parameter is ignored');
    };

    return AssignTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _internalTestHelpers.moduleFor)('Ember.assign (polyfill)',
  /*#__PURE__*/
  function (_AssignTests) {
    (0, _emberBabel.inheritsLoose)(_class, _AssignTests);

    function _class() {
      return _AssignTests.apply(this, arguments) || this;
    }

    var _proto2 = _class.prototype;

    _proto2.assign = function assign() {
      return _polyfills.assignPolyfill.apply(void 0, arguments);
    };

    return _class;
  }(AssignTests));
  (0, _internalTestHelpers.moduleFor)('Ember.assign (maybe not-polyfill ;) )',
  /*#__PURE__*/
  function (_AssignTests2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AssignTests2);

    function _class2() {
      return _AssignTests2.apply(this, arguments) || this;
    }

    var _proto3 = _class2.prototype;

    _proto3.assign = function assign() {
      return _polyfills.assign.apply(void 0, arguments);
    };

    return _class2;
  }(AssignTests));
});
enifed("@ember/polyfills/tests/merge_test", ["ember-babel", "@ember/polyfills", "internal-test-helpers"], function (_emberBabel, _polyfills, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.merge',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test merging objects'] = function testMergingObjects(assert) {
      var src1 = {
        a: 1
      };
      var src2 = {
        b: 2
      };
      expectDeprecation(function () {
        (0, _polyfills.merge)(src1, src2);
      }, 'Use of `merge` has been deprecated. Please use `assign` instead.');
      assert.deepEqual(src1, {
        a: 1,
        b: 2
      }, 'merge copies values from second source object to first object');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/debounce_test", ["ember-babel", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('debounce',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test debounce - with target, with method, without args'] = function testDebounceWithTargetWithMethodWithoutArgs(assert) {
      var done = assert.async();
      var calledWith = [];
      var target = {
        someFunc: function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          calledWith.push(args);
        }
      };
      (0, _runloop.debounce)(target, target.someFunc, 10);
      (0, _runloop.debounce)(target, target.someFunc, 10);
      (0, _runloop.debounce)(target, target.someFunc, 10);
      setTimeout(function () {
        assert.deepEqual(calledWith, [[]], 'someFunc called once with correct arguments');
        done();
      }, 20);
    };

    _proto['@test debounce - with target, with method name, without args'] = function testDebounceWithTargetWithMethodNameWithoutArgs(assert) {
      var done = assert.async();
      var calledWith = [];
      var target = {
        someFunc: function () {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          calledWith.push(args);
        }
      };
      (0, _runloop.debounce)(target, 'someFunc', 10);
      (0, _runloop.debounce)(target, 'someFunc', 10);
      (0, _runloop.debounce)(target, 'someFunc', 10);
      setTimeout(function () {
        assert.deepEqual(calledWith, [[]], 'someFunc called once with correct arguments');
        done();
      }, 20);
    };

    _proto['@test debounce - without target, without args'] = function testDebounceWithoutTargetWithoutArgs(assert) {
      var done = assert.async();
      var calledWith = [];

      function someFunc() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        calledWith.push(args);
      }

      (0, _runloop.debounce)(someFunc, 10);
      (0, _runloop.debounce)(someFunc, 10);
      (0, _runloop.debounce)(someFunc, 10);
      setTimeout(function () {
        assert.deepEqual(calledWith, [[]], 'someFunc called once with correct arguments');
        done();
      }, 20);
    };

    _proto['@test debounce - without target, with args'] = function testDebounceWithoutTargetWithArgs(assert) {
      var done = assert.async();
      var calledWith = [];

      function someFunc() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        calledWith.push(args);
      }

      (0, _runloop.debounce)(someFunc, {
        isFoo: true
      }, 10);
      (0, _runloop.debounce)(someFunc, {
        isBar: true
      }, 10);
      (0, _runloop.debounce)(someFunc, {
        isBaz: true
      }, 10);
      setTimeout(function () {
        assert.deepEqual(calledWith, [[{
          isBaz: true
        }]], 'someFunc called once with correct arguments');
        done();
      }, 20);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/later_test", ["ember-babel", "internal-test-helpers", "@ember/polyfills", "@ember/runloop"], function (_emberBabel, _internalTestHelpers, _polyfills, _runloop) {
  "use strict";

  var originalSetTimeout = window.setTimeout;
  var originalDateValueOf = Date.prototype.valueOf;
  var originalPlatform = _runloop.backburner._platform;

  function wait(callback) {
    var maxWaitCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    originalSetTimeout(function () {
      if (maxWaitCount > 0 && ((0, _runloop.hasScheduledTimers)() || (0, _runloop.getCurrentRunLoop)())) {
        wait(callback, maxWaitCount - 1);
        return;
      }

      callback();
    }, 10);
  } // Synchronous "sleep". This simulates work being done
  // after later was called but before the run loop
  // has flushed. In previous versions, this would have
  // caused the later callback to have run from
  // within the run loop flush, since by the time the
  // run loop has to flush, it would have considered
  // the timer already expired.


  function pauseUntil(time) {
    while (Number(new Date()) < time) {
      /* do nothing - sleeping */
    }
  }

  (0, _internalTestHelpers.moduleFor)('run.later',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _runloop.backburner._platform = originalPlatform;
      window.setTimeout = originalSetTimeout;
      Date.prototype.valueOf = originalDateValueOf;
    };

    _proto['@test should invoke after specified period of time - function only'] = function testShouldInvokeAfterSpecifiedPeriodOfTimeFunctionOnly(assert) {
      var done = assert.async();
      var invoked = false;
      (0, _runloop.run)(function () {
        (0, _runloop.later)(function () {
          return invoked = true;
        }, 100);
      });
      wait(function () {
        assert.equal(invoked, true, 'should have invoked later item');
        done();
      });
    };

    _proto['@test should invoke after specified period of time - target/method'] = function testShouldInvokeAfterSpecifiedPeriodOfTimeTargetMethod(assert) {
      var done = assert.async();
      var obj = {
        invoked: false
      };
      (0, _runloop.run)(function () {
        (0, _runloop.later)(obj, function () {
          this.invoked = true;
        }, 100);
      });
      wait(function () {
        assert.equal(obj.invoked, true, 'should have invoked later item');
        done();
      });
    };

    _proto['@test should invoke after specified period of time - target/method/args'] = function testShouldInvokeAfterSpecifiedPeriodOfTimeTargetMethodArgs(assert) {
      var done = assert.async();
      var obj = {
        invoked: 0
      };
      (0, _runloop.run)(function () {
        (0, _runloop.later)(obj, function (amt) {
          this.invoked += amt;
        }, 10, 100);
      });
      wait(function () {
        assert.equal(obj.invoked, 10, 'should have invoked later item');
        done();
      });
    };

    _proto['@test should always invoke within a separate runloop'] = function testShouldAlwaysInvokeWithinASeparateRunloop(assert) {
      var done = assert.async();
      var obj = {
        invoked: 0
      };
      var firstRunLoop, secondRunLoop;
      (0, _runloop.run)(function () {
        firstRunLoop = (0, _runloop.getCurrentRunLoop)();
        (0, _runloop.later)(obj, function (amt) {
          this.invoked += amt;
          secondRunLoop = (0, _runloop.getCurrentRunLoop)();
        }, 10, 1);
        pauseUntil(Number(new Date()) + 100);
      });
      assert.ok(firstRunLoop, 'first run loop captured');
      assert.ok(!(0, _runloop.getCurrentRunLoop)(), "shouldn't be in a run loop after flush");
      assert.equal(obj.invoked, 0, "shouldn't have invoked later item yet");
      wait(function () {
        assert.equal(obj.invoked, 10, 'should have invoked later item');
        assert.ok(secondRunLoop, 'second run loop took place');
        assert.ok(secondRunLoop !== firstRunLoop, 'two different run loops took place');
        done();
      });
    } // Our current implementation doesn't allow us to correctly enforce this ordering.
    // We should probably implement a queue to provide this guarantee.
    // See https://github.com/emberjs/ember.js/issues/3526 for more information.
    // asyncTest('callback order', function() {
    //   let array = [];
    //   function fn(val) { array.push(val); }
    //   run(function() {
    //     later(this, fn, 4, 5);
    //     later(this, fn, 1, 1);
    //     later(this, fn, 5, 10);
    //     later(this, fn, 2, 3);
    //     later(this, fn, 3, 3);
    //   });
    //   deepEqual(array, []);
    //   wait(function() {
    //     QUnit.start();
    //     deepEqual(array, [1,2,3,4,5], 'callbacks were called in expected order');
    //   });
    // });
    // Out current implementation doesn't allow us to properly enforce what is tested here.
    // We should probably fix it, but it's not technically a bug right now.
    // See https://github.com/emberjs/ember.js/issues/3522 for more information.
    // asyncTest('callbacks coalesce into same run loop if expiring at the same time', function() {
    //   let array = [];
    //   function fn(val) { array.push(getCurrentRunLoop()); }
    //   run(function() {
    //     // Force +new Date to return the same result while scheduling
    //     // later timers. Otherwise: non-determinism!
    //     let now = +new Date();
    //     Date.prototype.valueOf = function() { return now; };
    //     later(this, fn, 10);
    //     later(this, fn, 200);
    //     later(this, fn, 200);
    //     Date.prototype.valueOf = originalDateValueOf;
    //   });
    //   deepEqual(array, []);
    //   wait(function() {
    //     QUnit.start();
    //     equal(array.length, 3, 'all callbacks called');
    //     ok(array[0] !== array[1], 'first two callbacks have different run loops');
    //     ok(array[0], 'first runloop present');
    //     ok(array[1], 'second runloop present');
    //     equal(array[1], array[2], 'last two callbacks got the same run loop');
    //   });
    // });
    ;

    _proto['@test inception calls to later should run callbacks in separate run loops'] = function testInceptionCallsToLaterShouldRunCallbacksInSeparateRunLoops(assert) {
      var done = assert.async();
      var runLoop, finished;
      (0, _runloop.run)(function () {
        runLoop = (0, _runloop.getCurrentRunLoop)();
        assert.ok(runLoop);
        (0, _runloop.later)(function () {
          assert.ok((0, _runloop.getCurrentRunLoop)() && (0, _runloop.getCurrentRunLoop)() !== runLoop, 'first later callback has own run loop');
          runLoop = (0, _runloop.getCurrentRunLoop)();
          (0, _runloop.later)(function () {
            assert.ok((0, _runloop.getCurrentRunLoop)() && (0, _runloop.getCurrentRunLoop)() !== runLoop, 'second later callback has own run loop');
            finished = true;
          }, 40);
        }, 40);
      });
      wait(function () {
        assert.ok(finished, 'all .later callbacks run');
        done();
      });
    };

    _proto['@test setTimeout should never run with a negative wait'] = function testSetTimeoutShouldNeverRunWithANegativeWait(assert) {
      var done = assert.async(); // Rationale: The old run loop code was susceptible to an occasional
      // bug where invokeLaterTimers would be scheduled with a setTimeout
      // with a negative wait. Modern browsers normalize this to 0, but
      // older browsers (IE <= 8) break with a negative wait, which
      // happens when an expired timer callback takes a while to run,
      // which is what we simulate here.

      var newSetTimeoutUsed;
      _runloop.backburner._platform = (0, _polyfills.assign)({}, originalPlatform, {
        setTimeout: function () {
          var wait = arguments[arguments.length - 1];
          newSetTimeoutUsed = true;
          assert.ok(!isNaN(wait) && wait >= 0, 'wait is a non-negative number');
          return originalPlatform.setTimeout.apply(originalPlatform, arguments);
        }
      });
      var count = 0;
      (0, _runloop.run)(function () {
        (0, _runloop.later)(function () {
          count++; // This will get run first. Waste some time.
          // This is intended to break invokeLaterTimers code by taking a
          // long enough time that other timers should technically expire. It's
          // fine that they're not called in this run loop; just need to
          // make sure that invokeLaterTimers doesn't end up scheduling
          // a negative setTimeout.

          pauseUntil(Number(new Date()) + 60);
        }, 1);
        (0, _runloop.later)(function () {
          assert.equal(count, 1, 'callbacks called in order');
        }, 50);
      });
      wait(function () {
        assert.ok(newSetTimeoutUsed, 'stub setTimeout was used');
        done();
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/next_test", ["ember-babel", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('run.next',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test should invoke immediately on next timeout'] = function testShouldInvokeImmediatelyOnNextTimeout(assert) {
      var done = assert.async();
      var invoked = false;
      (0, _runloop.run)(function () {
        return (0, _runloop.next)(function () {
          return invoked = true;
        });
      });
      assert.equal(invoked, false, 'should not have invoked yet');
      setTimeout(function () {
        assert.equal(invoked, true, 'should have invoked later item');
        done();
      }, 20);
    };

    _proto['@test callback should be called from within separate loop'] = function testCallbackShouldBeCalledFromWithinSeparateLoop(assert) {
      var done = assert.async();
      var firstRunLoop, secondRunLoop;
      (0, _runloop.run)(function () {
        firstRunLoop = (0, _runloop.getCurrentRunLoop)();
        (0, _runloop.next)(function () {
          return secondRunLoop = (0, _runloop.getCurrentRunLoop)();
        });
      });
      setTimeout(function () {
        assert.ok(secondRunLoop, 'callback was called from within run loop');
        assert.ok(firstRunLoop && secondRunLoop !== firstRunLoop, 'two separate run loops were invoked');
        done();
      }, 20);
    };

    _proto['@test multiple calls to next share coalesce callbacks into same run loop'] = function testMultipleCallsToNextShareCoalesceCallbacksIntoSameRunLoop(assert) {
      var done = assert.async();
      var secondRunLoop, thirdRunLoop;
      (0, _runloop.run)(function () {
        (0, _runloop.next)(function () {
          return secondRunLoop = (0, _runloop.getCurrentRunLoop)();
        });
        (0, _runloop.next)(function () {
          return thirdRunLoop = (0, _runloop.getCurrentRunLoop)();
        });
      });
      setTimeout(function () {
        assert.ok(secondRunLoop && secondRunLoop === thirdRunLoop, 'callbacks coalesced into same run loop');
        done();
      }, 20);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/once_test", ["ember-babel", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/once_test',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test calling invokeOnce more than once invokes only once'] = function testCallingInvokeOnceMoreThanOnceInvokesOnlyOnce(assert) {
      var count = 0;
      (0, _runloop.run)(function () {
        function F() {
          count++;
        }

        (0, _runloop.once)(F);
        (0, _runloop.once)(F);
        (0, _runloop.once)(F);
      });
      assert.equal(count, 1, 'should have invoked once');
    };

    _proto['@test should differentiate based on target'] = function testShouldDifferentiateBasedOnTarget(assert) {
      var A = {
        count: 0
      };
      var B = {
        count: 0
      };
      (0, _runloop.run)(function () {
        function F() {
          this.count++;
        }

        (0, _runloop.once)(A, F);
        (0, _runloop.once)(B, F);
        (0, _runloop.once)(A, F);
        (0, _runloop.once)(B, F);
      });
      assert.equal(A.count, 1, 'should have invoked once on A');
      assert.equal(B.count, 1, 'should have invoked once on B');
    };

    _proto['@test should ignore other arguments - replacing previous ones'] = function testShouldIgnoreOtherArgumentsReplacingPreviousOnes(assert) {
      var A = {
        count: 0
      };
      var B = {
        count: 0
      };
      (0, _runloop.run)(function () {
        function F(amt) {
          this.count += amt;
        }

        (0, _runloop.once)(A, F, 10);
        (0, _runloop.once)(B, F, 20);
        (0, _runloop.once)(A, F, 30);
        (0, _runloop.once)(B, F, 40);
      });
      assert.equal(A.count, 30, 'should have invoked once on A');
      assert.equal(B.count, 40, 'should have invoked once on B');
    };

    _proto['@test should be inside of a runloop when running'] = function testShouldBeInsideOfARunloopWhenRunning(assert) {
      (0, _runloop.run)(function () {
        (0, _runloop.once)(function () {
          return assert.ok(Boolean((0, _runloop.getCurrentRunLoop)()), 'should have a runloop');
        });
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/onerror_test", ["ember-babel", "@ember/runloop", "@ember/-internals/error-handling", "@ember/debug", "internal-test-helpers"], function (_emberBabel, _runloop, _errorHandling, _debug, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/onerror_test',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test With Ember.onerror undefined, errors in run are thrown'] = function testWithEmberOnerrorUndefinedErrorsInRunAreThrown(assert) {
      var thrown = new Error('Boom!');
      var original = (0, _errorHandling.getOnerror)();
      var caught;
      (0, _errorHandling.setOnerror)(undefined);

      try {
        (0, _runloop.run)(function () {
          throw thrown;
        });
      } catch (error) {
        caught = error;
      } finally {
        (0, _errorHandling.setOnerror)(original);
      }

      assert.deepEqual(caught, thrown);
    };

    _proto['@test With Ember.onerror set, errors in run are caught'] = function testWithEmberOnerrorSetErrorsInRunAreCaught(assert) {
      var thrown = new Error('Boom!');
      var original = (0, _errorHandling.getOnerror)();
      var originalDispatchOverride = (0, _errorHandling.getDispatchOverride)();
      var originalIsTesting = (0, _debug.isTesting)();
      var caught;
      (0, _errorHandling.setOnerror)(function (error) {
        caught = error;
      });
      (0, _errorHandling.setDispatchOverride)(null);
      (0, _debug.setTesting)(false);

      try {
        (0, _runloop.run)(function () {
          throw thrown;
        });
      } finally {
        (0, _errorHandling.setOnerror)(original);
        (0, _errorHandling.setDispatchOverride)(originalDispatchOverride);
        (0, _debug.setTesting)(originalIsTesting);
      }

      assert.deepEqual(caught, thrown);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/run_bind_test", ["ember-babel", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/run_bind_test',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test bind builds a run-loop wrapped callback handler'] = function testBindBuildsARunLoopWrappedCallbackHandler(assert) {
      assert.expect(3);
      var obj = {
        value: 0,
        increment: function (increment) {
          assert.ok((0, _runloop.getCurrentRunLoop)(), 'expected a run-loop');
          return this.value += increment;
        }
      };
      var proxiedFunction = (0, _runloop.bind)(obj, obj.increment, 1);
      assert.equal(proxiedFunction(), 1);
      assert.equal(obj.value, 1);
    };

    _proto['@test bind keeps the async callback arguments'] = function testBindKeepsTheAsyncCallbackArguments(assert) {
      assert.expect(4);

      function asyncCallback(increment, increment2, increment3) {
        assert.ok((0, _runloop.getCurrentRunLoop)(), 'expected a run-loop');
        assert.equal(increment, 1);
        assert.equal(increment2, 2);
        assert.equal(increment3, 3);
      }

      function asyncFunction(fn) {
        fn(2, 3);
      }

      asyncFunction((0, _runloop.bind)(asyncCallback, asyncCallback, 1));
    };

    _proto['@test [GH#16652] bind throws an error if callback is undefined'] = function testGH16652BindThrowsAnErrorIfCallbackIsUndefined() {
      var assertBindThrows = function (msg) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        expectAssertion(function () {
          _runloop.bind.apply(void 0, args);
        }, /could not find a suitable method to bind/, msg);
      };

      assertBindThrows('without arguments');
      assertBindThrows('with one arguments that is not a function', 'myMethod');
      assertBindThrows('if second parameter is not a function and not a property in first parameter', Object.create(null), 'myMethod');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/run_test", ["ember-babel", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/run_test',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test run invokes passed function, returning value'] = function testRunInvokesPassedFunctionReturningValue(assert) {
      var obj = {
        foo: function () {
          return [this.bar, 'FOO'];
        },
        bar: 'BAR',
        checkArgs: function (arg1, arg2) {
          return [arg1, this.bar, arg2];
        }
      };
      assert.equal((0, _runloop.run)(function () {
        return 'FOO';
      }), 'FOO', 'pass function only');
      assert.deepEqual((0, _runloop.run)(obj, obj.foo), ['BAR', 'FOO'], 'pass obj and obj.method');
      assert.deepEqual((0, _runloop.run)(obj, 'foo'), ['BAR', 'FOO'], 'pass obj and "method"');
      assert.deepEqual((0, _runloop.run)(obj, obj.checkArgs, 'hello', 'world'), ['hello', 'BAR', 'world'], 'pass obj, obj.method, and extra arguments');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/schedule_test", ["ember-babel", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/schedule_test',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test scheduling item in queue should defer until finished'] = function testSchedulingItemInQueueShouldDeferUntilFinished(assert) {
      var cnt = 0;
      (0, _runloop.run)(function () {
        (0, _runloop.schedule)('actions', function () {
          return cnt++;
        });
        (0, _runloop.schedule)('actions', function () {
          return cnt++;
        });
        assert.equal(cnt, 0, 'should not run action yet');
      });
      assert.equal(cnt, 2, 'should flush actions now');
    };

    _proto['@test a scheduled item can be canceled'] = function testAScheduledItemCanBeCanceled(assert) {
      var hasRan = false;
      (0, _runloop.run)(function () {
        var cancelId = (0, _runloop.schedule)('actions', function () {
          return hasRan = true;
        });
        (0, _runloop.cancel)(cancelId);
      });
      assert.notOk(hasRan, 'should not have ran callback run');
    };

    _proto['@test nested runs should queue each phase independently'] = function testNestedRunsShouldQueueEachPhaseIndependently(assert) {
      var cnt = 0;
      (0, _runloop.run)(function () {
        (0, _runloop.schedule)('actions', function () {
          return cnt++;
        });
        assert.equal(cnt, 0, 'should not run action yet');
        (0, _runloop.run)(function () {
          (0, _runloop.schedule)('actions', function () {
            return cnt++;
          });
        });
        assert.equal(cnt, 1, 'should not run action yet');
      });
      assert.equal(cnt, 2, 'should flush actions now');
    };

    _proto['@test prior queues should be flushed before moving on to next queue'] = function testPriorQueuesShouldBeFlushedBeforeMovingOnToNextQueue(assert) {
      var order = [];
      (0, _runloop.run)(function () {
        var runLoop = (0, _runloop.getCurrentRunLoop)();
        assert.ok(runLoop, 'run loop present');
        expectDeprecation(function () {
          (0, _runloop.schedule)('sync', function () {
            order.push('sync');
            assert.equal(runLoop, (0, _runloop.getCurrentRunLoop)(), 'same run loop used');
          });
        }, "Scheduling into the 'sync' run loop queue is deprecated.");
        (0, _runloop.schedule)('actions', function () {
          order.push('actions');
          assert.equal(runLoop, (0, _runloop.getCurrentRunLoop)(), 'same run loop used');
          (0, _runloop.schedule)('actions', function () {
            order.push('actions');
            assert.equal(runLoop, (0, _runloop.getCurrentRunLoop)(), 'same run loop used');
          });
          expectDeprecation(function () {
            (0, _runloop.schedule)('sync', function () {
              order.push('sync');
              assert.equal(runLoop, (0, _runloop.getCurrentRunLoop)(), 'same run loop used');
            });
          }, "Scheduling into the 'sync' run loop queue is deprecated.");
        });
        (0, _runloop.schedule)('destroy', function () {
          order.push('destroy');
          assert.equal(runLoop, (0, _runloop.getCurrentRunLoop)(), 'same run loop used');
        });
      });
      assert.deepEqual(order, ['sync', 'actions', 'sync', 'actions', 'destroy']);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/sync_test", ["ember-babel", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/sync_test',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test sync() will immediately flush the sync queue only'] = function testSyncWillImmediatelyFlushTheSyncQueueOnly(assert) {
      var cnt = 0;
      (0, _runloop.run)(function () {
        function cntup() {
          cnt++;
        }

        function syncfunc() {
          if (++cnt < 5) {
            expectDeprecation(function () {
              (0, _runloop.schedule)('sync', syncfunc);
            }, "Scheduling into the 'sync' run loop queue is deprecated.");
          }

          (0, _runloop.schedule)('actions', cntup);
        }

        syncfunc();
        assert.equal(cnt, 1, 'should not run action yet');
      });
      assert.equal(cnt, 10, 'should flush actions now too');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/unwind_test", ["ember-babel", "@ember/runloop", "@ember/error", "internal-test-helpers"], function (_emberBabel, _runloop, _error, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/unwind_test',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test RunLoop unwinds despite unhandled exception'] = function testRunLoopUnwindsDespiteUnhandledException(assert) {
      var initialRunLoop = (0, _runloop.getCurrentRunLoop)();
      assert.throws(function () {
        (0, _runloop.run)(function () {
          (0, _runloop.schedule)('actions', function () {
            throw new _error.default('boom!');
          });
        });
      }, Error, 'boom!'); // The real danger at this point is that calls to autorun will stick
      // tasks into the already-dead runloop, which will never get
      // flushed. I can't easily demonstrate this in a unit test because
      // autorun explicitly doesn't work in test mode. - ef4

      assert.equal((0, _runloop.getCurrentRunLoop)(), initialRunLoop, 'Previous run loop should be cleaned up despite exception');
    };

    _proto['@test run unwinds despite unhandled exception'] = function testRunUnwindsDespiteUnhandledException(assert) {
      var initialRunLoop = (0, _runloop.getCurrentRunLoop)();
      assert.throws(function () {
        (0, _runloop.run)(function () {
          throw new _error.default('boom!');
        });
      }, _error.default, 'boom!');
      assert.equal((0, _runloop.getCurrentRunLoop)(), initialRunLoop, 'Previous run loop should be cleaned up despite exception');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/string/tests/camelize_test", ["ember-babel", "@ember/-internals/environment", "@ember/string", "internal-test-helpers"], function (_emberBabel, _environment, _string, _internalTestHelpers) {
  "use strict";

  function test(assert, given, expected, description) {
    assert.deepEqual((0, _string.camelize)(given), expected, description);

    if (_environment.ENV.EXTEND_PROTOTYPES.String) {
      assert.deepEqual(given.camelize(), expected, description);
    }
  }

  (0, _internalTestHelpers.moduleFor)('EmberStringUtils.camelize',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test String.prototype.camelize is not modified without EXTEND_PROTOTYPES'] = function testStringPrototypeCamelizeIsNotModifiedWithoutEXTEND_PROTOTYPES(assert) {
      if (!_environment.ENV.EXTEND_PROTOTYPES.String) {
        assert.ok('undefined' === typeof String.prototype.camelize, 'String.prototype helper disabled');
      } else {
        assert.expect(0);
      }
    };

    _proto['@test String camelize tests'] = function testStringCamelizeTests(assert) {
      test(assert, 'my favorite items', 'myFavoriteItems', 'camelize normal string');
      test(assert, 'I Love Ramen', 'iLoveRamen', 'camelize capitalized string');
      test(assert, 'css-class-name', 'cssClassName', 'camelize dasherized string');
      test(assert, 'action_name', 'actionName', 'camelize underscored string');
      test(assert, 'action.name', 'actionName', 'camelize dot notation string');
      test(assert, 'innerHTML', 'innerHTML', 'does nothing with camelcased string');
      test(assert, 'PrivateDocs/OwnerInvoice', 'privateDocs/ownerInvoice', 'camelize namespaced classified string');
      test(assert, 'private_docs/owner_invoice', 'privateDocs/ownerInvoice', 'camelize namespaced underscored string');
      test(assert, 'private-docs/owner-invoice', 'privateDocs/ownerInvoice', 'camelize namespaced dasherized string');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/string/tests/capitalize_test", ["ember-babel", "@ember/-internals/environment", "@ember/string", "internal-test-helpers"], function (_emberBabel, _environment, _string, _internalTestHelpers) {
  "use strict";

  function test(assert, given, expected, description) {
    assert.deepEqual((0, _string.capitalize)(given), expected, description);

    if (_environment.ENV.EXTEND_PROTOTYPES.String) {
      assert.deepEqual(given.capitalize(), expected, description);
    }
  }

  (0, _internalTestHelpers.moduleFor)('EmberStringUtils.capitalize',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test String.prototype.capitalize is not modified without EXTEND_PROTOTYPES'] = function testStringPrototypeCapitalizeIsNotModifiedWithoutEXTEND_PROTOTYPES(assert) {
      if (!_environment.ENV.EXTEND_PROTOTYPES.String) {
        assert.ok('undefined' === typeof String.prototype.capitalize, 'String.prototype helper disabled');
      } else {
        assert.expect(0);
      }
    };

    _proto['@test String capitalize tests'] = function testStringCapitalizeTests(assert) {
      test(assert, 'my favorite items', 'My favorite items', 'capitalize normal string');
      test(assert, 'css-class-name', 'Css-class-name', 'capitalize dasherized string');
      test(assert, 'action_name', 'Action_name', 'capitalize underscored string');
      test(assert, 'innerHTML', 'InnerHTML', 'capitalize camelcased string');
      test(assert, 'Capitalized string', 'Capitalized string', 'does nothing with capitalized string');
      test(assert, 'privateDocs/ownerInvoice', 'PrivateDocs/OwnerInvoice', 'capitalize namespaced camelized string');
      test(assert, 'private_docs/owner_invoice', 'Private_docs/Owner_invoice', 'capitalize namespaced underscored string');
      test(assert, 'private-docs/owner-invoice', 'Private-docs/Owner-invoice', 'capitalize namespaced dasherized string');
      test(assert, 'abc', 'abc', 'capitalize string with accent character');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/string/tests/classify_test", ["ember-babel", "@ember/-internals/environment", "@ember/string", "internal-test-helpers"], function (_emberBabel, _environment, _string, _internalTestHelpers) {
  "use strict";

  function test(assert, given, expected, description) {
    assert.deepEqual((0, _string.classify)(given), expected, description);

    if (_environment.ENV.EXTEND_PROTOTYPES.String) {
      assert.deepEqual(given.classify(), expected, description);
    }
  }

  (0, _internalTestHelpers.moduleFor)('EmberStringUtils.classify',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test String.prototype.classify is not modified without EXTEND_PROTOTYPES'] = function testStringPrototypeClassifyIsNotModifiedWithoutEXTEND_PROTOTYPES(assert) {
      if (!_environment.ENV.EXTEND_PROTOTYPES.String) {
        assert.ok('undefined' === typeof String.prototype.classify, 'String.prototype helper disabled');
      } else {
        assert.expect(0);
      }
    };

    _proto['@test String classify tests'] = function testStringClassifyTests(assert) {
      test(assert, 'my favorite items', 'MyFavoriteItems', 'classify normal string');
      test(assert, 'css-class-name', 'CssClassName', 'classify dasherized string');
      test(assert, 'action_name', 'ActionName', 'classify underscored string');
      test(assert, 'privateDocs/ownerInvoice', 'PrivateDocs/OwnerInvoice', 'classify namespaced camelized string');
      test(assert, 'private_docs/owner_invoice', 'PrivateDocs/OwnerInvoice', 'classify namespaced underscored string');
      test(assert, 'private-docs/owner-invoice', 'PrivateDocs/OwnerInvoice', 'classify namespaced dasherized string');
      test(assert, '-view-registry', '_ViewRegistry', 'classify prefixed dasherized string');
      test(assert, 'components/-text-field', 'Components/_TextField', 'classify namespaced prefixed dasherized string');
      test(assert, '_Foo_Bar', '_FooBar', 'classify underscore-prefixed underscored string');
      test(assert, '_Foo-Bar', '_FooBar', 'classify underscore-prefixed dasherized string');
      test(assert, '_foo/_bar', '_Foo/_Bar', 'classify underscore-prefixed-namespaced underscore-prefixed string');
      test(assert, '-foo/_bar', '_Foo/_Bar', 'classify dash-prefixed-namespaced underscore-prefixed string');
      test(assert, '-foo/-bar', '_Foo/_Bar', 'classify dash-prefixed-namespaced dash-prefixed string');
      test(assert, 'InnerHTML', 'InnerHTML', 'does nothing with classified string');
      test(assert, '_FooBar', '_FooBar', 'does nothing with classified prefixed string');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/string/tests/dasherize_test", ["ember-babel", "@ember/-internals/environment", "@ember/string", "internal-test-helpers"], function (_emberBabel, _environment, _string, _internalTestHelpers) {
  "use strict";

  function test(assert, given, expected, description) {
    assert.deepEqual((0, _string.dasherize)(given), expected, description);

    if (_environment.ENV.EXTEND_PROTOTYPES.String) {
      assert.deepEqual(given.dasherize(), expected, description);
    }
  }

  (0, _internalTestHelpers.moduleFor)('EmberStringUtils.dasherize',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test String.prototype.dasherize is not modified without EXTEND_PROTOTYPES'] = function testStringPrototypeDasherizeIsNotModifiedWithoutEXTEND_PROTOTYPES(assert) {
      if (!_environment.ENV.EXTEND_PROTOTYPES.String) {
        assert.ok('undefined' === typeof String.prototype.dasherize, 'String.prototype helper disabled');
      } else {
        assert.expect(0);
      }
    };

    _proto['@test String dasherize tests'] = function testStringDasherizeTests(assert) {
      test(assert, 'my favorite items', 'my-favorite-items', 'dasherize normal string');
      test(assert, 'css-class-name', 'css-class-name', 'does nothing with dasherized string');
      test(assert, 'action_name', 'action-name', 'dasherize underscored string');
      test(assert, 'innerHTML', 'inner-html', 'dasherize camelcased string');
      test(assert, 'toString', 'to-string', 'dasherize string that is the property name of Object.prototype');
      test(assert, 'PrivateDocs/OwnerInvoice', 'private-docs/owner-invoice', 'dasherize namespaced classified string');
      test(assert, 'privateDocs/ownerInvoice', 'private-docs/owner-invoice', 'dasherize namespaced camelized string');
      test(assert, 'private_docs/owner_invoice', 'private-docs/owner-invoice', 'dasherize namespaced underscored string');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/string/tests/decamelize_test", ["ember-babel", "@ember/-internals/environment", "@ember/string", "internal-test-helpers"], function (_emberBabel, _environment, _string, _internalTestHelpers) {
  "use strict";

  function test(assert, given, expected, description) {
    assert.deepEqual((0, _string.decamelize)(given), expected, description);

    if (_environment.ENV.EXTEND_PROTOTYPES.String) {
      assert.deepEqual(given.decamelize(), expected, description);
    }
  }

  (0, _internalTestHelpers.moduleFor)('EmberStringUtils.decamelize',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test String.prototype.decamelize is not modified without EXTEND_PROTOTYPES'] = function testStringPrototypeDecamelizeIsNotModifiedWithoutEXTEND_PROTOTYPES(assert) {
      if (!_environment.ENV.EXTEND_PROTOTYPES.String) {
        assert.ok('undefined' === typeof String.prototype.decamelize, 'String.prototype helper disabled');
      } else {
        assert.expect(0);
      }
    };

    _proto['@test String decamelize tests'] = function testStringDecamelizeTests(assert) {
      test(assert, 'my favorite items', 'my favorite items', 'does nothing with normal string');
      test(assert, 'css-class-name', 'css-class-name', 'does nothing with dasherized string');
      test(assert, 'action_name', 'action_name', 'does nothing with underscored string');
      test(assert, 'innerHTML', 'inner_html', 'converts a camelized string into all lower case separated by underscores.');
      test(assert, 'size160Url', 'size160_url', 'decamelizes strings with numbers');
      test(assert, 'PrivateDocs/OwnerInvoice', 'private_docs/owner_invoice', 'decamelize namespaced classified string');
      test(assert, 'privateDocs/ownerInvoice', 'private_docs/owner_invoice', 'decamelize namespaced camelized string');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/string/tests/loc_test", ["ember-babel", "@ember/-internals/environment", "@ember/string", "@ember/string/lib/string_registry", "internal-test-helpers"], function (_emberBabel, _environment, _string, _string_registry, _internalTestHelpers) {
  "use strict";

  var oldString;

  function test(assert, given, args, expected, description) {
    assert.equal((0, _string.loc)(given, args), expected, description);

    if (_environment.ENV.EXTEND_PROTOTYPES.String) {
      assert.deepEqual(given.loc.apply(given, args), expected, description);
    }
  }

  (0, _internalTestHelpers.moduleFor)('EmberStringUtils.loc',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      oldString = (0, _string_registry.getStrings)();
      (0, _string_registry.setStrings)({
        '_Hello World': 'Bonjour le monde',
        '_Hello %@': 'Bonjour %@',
        '_Hello %@ %@': 'Bonjour %@ %@',
        '_Hello %@# %@#': 'Bonjour %@2 %@1'
      });
    };

    _proto.afterEach = function afterEach() {
      (0, _string_registry.setStrings)(oldString);
    };

    _proto['@test String.prototype.loc is not available without EXTEND_PROTOTYPES'] = function testStringPrototypeLocIsNotAvailableWithoutEXTEND_PROTOTYPES(assert) {
      if (!_environment.ENV.EXTEND_PROTOTYPES.String) {
        assert.ok('undefined' === typeof String.prototype.loc, 'String.prototype helper disabled');
      } else {
        assert.expect(0);
      }
    };

    _proto['@test String loc tests'] = function testStringLocTests(assert) {
      test(assert, '_Hello World', [], 'Bonjour le monde', "loc('_Hello World') => 'Bonjour le monde'");
      test(assert, '_Hello %@ %@', ['John', 'Doe'], 'Bonjour John Doe', "loc('_Hello %@ %@', ['John', 'Doe']) => 'Bonjour John Doe'");
      test(assert, '_Hello %@# %@#', ['John', 'Doe'], 'Bonjour Doe John', "loc('_Hello %@# %@#', ['John', 'Doe']) => 'Bonjour Doe John'");
      test(assert, '_Not In Strings', [], '_Not In Strings', "loc('_Not In Strings') => '_Not In Strings'");
    };

    _proto['@test works with argument form'] = function testWorksWithArgumentForm(assert) {
      assert.equal((0, _string.loc)('_Hello %@', 'John'), 'Bonjour John');
      assert.equal((0, _string.loc)('_Hello %@ %@', ['John'], 'Doe'), 'Bonjour John Doe');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/string/tests/underscore_test", ["ember-babel", "@ember/-internals/environment", "@ember/string", "internal-test-helpers"], function (_emberBabel, _environment, _string, _internalTestHelpers) {
  "use strict";

  function test(assert, given, expected, description) {
    assert.deepEqual((0, _string.underscore)(given), expected, description);

    if (_environment.ENV.EXTEND_PROTOTYPES.String) {
      assert.deepEqual(given.underscore(), expected, description);
    }
  }

  (0, _internalTestHelpers.moduleFor)('EmberStringUtils.underscore',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test String.prototype.underscore is not available without EXTEND_PROTOTYPES'] = function testStringPrototypeUnderscoreIsNotAvailableWithoutEXTEND_PROTOTYPES(assert) {
      if (!_environment.ENV.EXTEND_PROTOTYPES.String) {
        assert.ok('undefined' === typeof String.prototype.underscore, 'String.prototype helper disabled');
      } else {
        assert.expect(0);
      }
    };

    _proto['@test String underscore tests'] = function testStringUnderscoreTests(assert) {
      test(assert, 'my favorite items', 'my_favorite_items', 'with normal string');
      test(assert, 'css-class-name', 'css_class_name', 'with dasherized string');
      test(assert, 'action_name', 'action_name', 'does nothing with underscored string');
      test(assert, 'innerHTML', 'inner_html', 'with camelcased string');
      test(assert, 'PrivateDocs/OwnerInvoice', 'private_docs/owner_invoice', 'underscore namespaced classified string');
      test(assert, 'privateDocs/ownerInvoice', 'private_docs/owner_invoice', 'underscore namespaced camelized string');
      test(assert, 'private-docs/owner-invoice', 'private_docs/owner_invoice', 'underscore namespaced dasherized string');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/string/tests/w_test", ["ember-babel", "@ember/-internals/environment", "@ember/string", "internal-test-helpers"], function (_emberBabel, _environment, _string, _internalTestHelpers) {
  "use strict";

  function test(assert, given, expected, description) {
    assert.deepEqual((0, _string.w)(given), expected, description);

    if (_environment.ENV.EXTEND_PROTOTYPES.String) {
      assert.deepEqual(given.w(), expected, description);
    }
  }

  (0, _internalTestHelpers.moduleFor)('EmberStringUtils.w',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test String.prototype.w is not available without EXTEND_PROTOTYPES'] = function testStringPrototypeWIsNotAvailableWithoutEXTEND_PROTOTYPES(assert) {
      if (!_environment.ENV.EXTEND_PROTOTYPES.String) {
        assert.ok('undefined' === typeof String.prototype.w, 'String.prototype helper disabled');
      } else {
        assert.expect(0);
      }
    };

    _proto['@test String w tests'] = function testStringWTests(assert) {
      test(assert, 'one two three', ['one', 'two', 'three'], "w('one two three') => ['one','two','three']");
      test(assert, 'one   two  three', ['one', 'two', 'three'], "w('one    two    three') with extra spaces between words => ['one','two','three']");
      test(assert, 'one\ttwo  three', ['one', 'two', 'three'], "w('one two three') with tabs");
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/plugins/assert-if-helper-without-arguments-test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert-if-helper-without-argument',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto["@test block if helper expects one argument"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("{{#if}}aVal{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "#if requires a single argument. ('baz/foo-bar' @ L1:C0) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if val1 val2}}aVal{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "#if requires a single argument. ('baz/foo-bar' @ L1:C0) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if}}aVal{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "#if requires a single argument. ('baz/foo-bar' @ L1:C0) ");
    };

    _proto["@test inline if helper expects between one and three arguments"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("{{if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "The inline form of the 'if' helper expects two or three arguments. ('baz/foo-bar' @ L1:C0) ");
      (0, _index.compile)("{{if foo bar baz}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto['@test subexpression if helper expects between one and three arguments'] = function testSubexpressionIfHelperExpectsBetweenOneAndThreeArguments() {
      expectAssertion(function () {
        (0, _index.compile)("{{input foo=(if)}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "The inline form of the 'if' helper expects two or three arguments. ('baz/foo-bar' @ L1:C12) ");
      (0, _index.compile)("{{some-thing foo=(if foo bar baz)}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/plugins/assert-input-helper-without-block-test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert-input-helper-without-block',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Using {{#input}}{{/input}} is not valid'] = function testUsingInputInputIsNotValid() {
      var expectedMessage = "The {{input}} helper cannot be used in block form. ('baz/foo-bar' @ L1:C0) ";
      expectAssertion(function () {
        (0, _index.compile)('{{#input value="123"}}Completely invalid{{/input}}', {
          moduleName: 'baz/foo-bar'
        });
      }, expectedMessage);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/plugins/assert-local-variable-shadowing-helper-invocation-test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert-local-variable-shadowing-helper-invocation',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto["@test block statements shadowing sub-expression invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            {{concat (foo)}}\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C21) ");
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            {{concat (foo bar baz)}}\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C21) "); // Not shadowed

      (0, _index.compile)("\n        {{#let foo as |foo|}}{{/let}}\n        {{concat (foo)}}\n        {{concat (foo bar baz)}}", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          {{concat foo}}\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        {{#let (concat foo) as |concat|}}\n          {{input value=concat}}\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test element nodes shadowing sub-expression invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          <Foo as |foo|>\n            {{concat (foo)}}\n          </Foo>", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C21) ");
      expectAssertion(function () {
        (0, _index.compile)("\n          <Foo as |foo|>\n            {{concat (foo bar baz)}}\n          </Foo>", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C21) "); // Not shadowed

      (0, _index.compile)("\n        <Foo as |foo|></Foo>\n        {{concat (foo)}}\n        {{concat (foo bar baz)}}", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        <Foo as |foo|>\n          {{concat foo}}\n        </Foo>", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        <Foo foo={{concat foo}} as |concat|>\n          {{input value=concat}}\n        </Foo>", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test deeply nested sub-expression invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <FooBar as |bar|>\n              {{#each items as |baz|}}\n                {{concat (foo)}}\n              {{/each}}\n            </FooBar>\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L5:C25) ");
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <FooBar as |bar|>\n              {{#each items as |baz|}}\n                {{concat (foo bar baz)}}\n              {{/each}}\n            </FooBar>\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L5:C25) "); // Not shadowed

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n            {{/each}}\n            {{concat (baz)}}\n            {{concat (baz bat)}}\n          </FooBar>\n          {{concat (bar)}}\n          {{concat (bar baz bat)}}\n        {{/let}}\n        {{concat (foo)}}\n        {{concat (foo bar baz bat)}}", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n              {{concat foo}}\n            {{/each}}\n          </FooBar>\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        {{#let (foo foo) as |foo|}}\n          <FooBar bar=(bar bar) as |bar|>\n            {{#each (baz baz) as |baz|}}\n              {{concat foo bar baz}}\n            {{/each}}\n          </FooBar>\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test block statements shadowing attribute sub-expression invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <div class={{concat (foo bar baz)}} />\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C32) "); // Not shadowed

      (0, _index.compile)("\n        {{#let foo as |foo|}}{{/let}}\n        <div class={{concat (foo)}} />\n        <div class={{concat (foo bar baz)}} />", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <div class={{concat foo}} />\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        {{#let (foo foo) as |foo|}}\n          <div class={{concat foo}} />\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test element nodes shadowing attribute sub-expression invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          <Foo as |foo|>\n            <div class={{concat (foo bar baz)}} />\n          </Foo>", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C32) "); // Not shadowed

      (0, _index.compile)("\n        <Foo as |foo|></Foo>\n        <div class={{concat (foo)}} />\n        <div class={{concat (foo bar baz)}} />", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        <Foo as |foo|>\n          <div class={{concat foo}} />\n        </Foo>", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        <Foo foo={{foo foo}} as |foo|>\n          <div class={{concat foo}} />\n        </Foo>", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test deeply nested attribute sub-expression invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <FooBar as |bar|>\n              {{#each items as |baz|}}\n                <div class={{concat (foo bar baz)}} />\n              {{/each}}\n            </FooBar>\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L5:C36) "); // Not shadowed

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n            {{/each}}\n            <div class={{concat (baz)}} />\n            <div class={{concat (baz bat)}} />\n          </FooBar>\n          <div class={{concat (bar)}} />\n          <div class={{concat (bar baz bat)}} />\n        {{/let}}\n        <div class={{concat (foo)}} />\n        <div class={{concat (foo bar baz bat)}} />", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n              <div class={{concat foo}} />\n            {{/each}}\n          </FooBar>\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        {{#let (foo foo) as |foo|}}\n          <FooBar bar=(bar bar) as |bar|>\n            {{#each (baz baz) as |baz|}}\n              <div class={{concat foo bar baz}} />\n            {{/each}}\n          </FooBar>\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test block statements shadowing attribute mustache invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <div class={{foo bar baz}} />\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C23) "); // Not shadowed

      (0, _index.compile)("\n        {{#let foo as |foo|}}{{/let}}\n        <div class={{foo}} />\n        <div class={{foo bar baz}} />", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <div class={{foo}} />\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        {{#let (concat foo) as |concat|}}\n          <div class={{concat}} />\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test element nodes shadowing attribute mustache invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          <Foo as |foo|>\n            <div class={{foo bar baz}} />\n          </Foo>", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C23) "); // Not shadowed

      (0, _index.compile)("\n        <Foo as |foo|></Foo>\n        <div class={{foo}} />\n        <div class={{foo bar baz}} />", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        <Foo as |foo|>\n          <div class={{foo}} />\n        </Foo>", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        <Foo foo={{concat foo}} as |concat|>\n          <div class={{concat}} />\n        </Foo>", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test deeply nested attribute mustache invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <FooBar as |bar|>\n              {{#each items as |baz|}}\n                <div class={{foo bar baz}} />\n              {{/each}}\n            </FooBar>\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L5:C27) "); // Not shadowed

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n            {{/each}}\n            <div class={{baz}} />\n            <div class={{baz bat}} />\n          </FooBar>\n          <div class={{bar}} />\n          <div class={{bar baz bat}} />\n        {{/let}}\n        <div class={{foo}} />\n        <div class={{foo bar baz bat}} />", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n              <div class={{foo}} />\n            {{/each}}\n          </FooBar>\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        {{#let (foo foo) as |foo|}}\n          <FooBar bar=(bar bar) as |bar|>\n            {{#each (baz baz) as |baz|}}\n              <div foo={{foo}} bar={{bar}} baz={{baz}} />\n            {{/each}}\n          </FooBar>\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test block statements shadowing mustache invocations"] = function (assert) {
      // These are fine, because they should already be considered contextual
      // component invocations, not helper invocations
      assert.expect(0);
      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          {{foo}}\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          {{foo bar baz}}\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test element nodes shadowing mustache invocations"] = function (assert) {
      // These are fine, because they should already be considered contextual
      // component invocations, not helper invocations
      assert.expect(0);
      (0, _index.compile)("\n        <Foo as |foo|>\n          {{foo}}\n        </Foo>", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        <Foo as |foo|>\n          {{foo bar baz}}\n        </Foo>", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test deeply nested mustache invocations"] = function (assert) {
      // These are fine, because they should already be considered contextual
      // component invocations, not helper invocations
      assert.expect(0);
      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n              {{foo}}\n            {{/each}}\n          </FooBar>\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n              {{foo bar baz}}\n            {{/each}}\n          </FooBar>\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test block statements shadowing modifier invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <div {{foo}} />\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` modifier because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C17) ");
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <div {{foo bar baz}} />\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` modifier because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C17) "); // Not shadowed

      (0, _index.compile)("\n        {{#let foo as |foo|}}{{/let}}\n        <div {{foo}} />\n        <div {{foo bar baz}} />", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test element nodes shadowing modifier invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          <Foo as |foo|>\n            <div {{foo}} />\n          </Foo>", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` modifier because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C17) ");
      expectAssertion(function () {
        (0, _index.compile)("\n          <Foo as |foo|>\n            <div {{foo bar baz}} />\n          </Foo>", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` modifier because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C17) "); // Not shadowed

      (0, _index.compile)("\n        <Foo as |foo|></Foo>\n        <div {{foo}} />\n        <div {{foo bar baz}} />", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test deeply nested modifier invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <FooBar as |bar|>\n              {{#each items as |baz|}}\n                <div {{foo}} />\n              {{/each}}\n            </FooBar>\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` modifier because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L5:C21) ");
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <FooBar as |bar|>\n              {{#each items as |baz|}}\n                <div {{foo bar baz}} />\n              {{/each}}\n            </FooBar>\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` modifier because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L5:C21) "); // Not shadowed

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n            {{/each}}\n            <div {{baz}} />\n            <div {{baz bat}} />\n          </FooBar>\n          <div {{bar}} />\n          <div {{bar baz bat}} />\n        {{/let}}\n        <div {{foo}} />\n        <div {{foo bar baz bat}} />", {
        moduleName: 'baz/foo-bar'
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/plugins/assert-reserved-named-arguments-test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  if (true
  /* EMBER_GLIMMER_NAMED_ARGUMENTS */
  ) {
      (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert-reserved-named-arguments (EMBER_GLIMMER_NAMED_ARGUMENTS) ',
      /*#__PURE__*/
      function (_AbstractTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

        function _class() {
          return _AbstractTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto["@test '@arguments' is reserved"] = function () {
          expectAssertion(function () {
            (0, _index.compile)("{{@arguments}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@arguments' is reserved. ('baz/foo-bar' @ L1:C2) ");
          expectAssertion(function () {
            (0, _index.compile)("{{#if @arguments}}Yup{{/if}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@arguments' is reserved. ('baz/foo-bar' @ L1:C6) ");
          expectAssertion(function () {
            (0, _index.compile)("{{input type=(if @arguments \"bar\" \"baz\")}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@arguments' is reserved. ('baz/foo-bar' @ L1:C17) ");
        };

        _proto["@test '@args' is reserved"] = function () {
          expectAssertion(function () {
            (0, _index.compile)("{{@args}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@args' is reserved. ('baz/foo-bar' @ L1:C2) ");
          expectAssertion(function () {
            (0, _index.compile)("{{#if @args}}Yup{{/if}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@args' is reserved. ('baz/foo-bar' @ L1:C6) ");
          expectAssertion(function () {
            (0, _index.compile)("{{input type=(if @args \"bar\" \"baz\")}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@args' is reserved. ('baz/foo-bar' @ L1:C17) ");
        };

        _proto["@test '@block' is reserved"] = function () {
          expectAssertion(function () {
            (0, _index.compile)("{{@block}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@block' is reserved. ('baz/foo-bar' @ L1:C2) ");
          expectAssertion(function () {
            (0, _index.compile)("{{#if @block}}Yup{{/if}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@block' is reserved. ('baz/foo-bar' @ L1:C6) ");
          expectAssertion(function () {
            (0, _index.compile)("{{input type=(if @block \"bar\" \"baz\")}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@block' is reserved. ('baz/foo-bar' @ L1:C17) ");
        };

        _proto["@test '@else' is reserved"] = function () {
          expectAssertion(function () {
            (0, _index.compile)("{{@else}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@else' is reserved. ('baz/foo-bar' @ L1:C2) ");
          expectAssertion(function () {
            (0, _index.compile)("{{#if @else}}Yup{{/if}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@else' is reserved. ('baz/foo-bar' @ L1:C6) ");
          expectAssertion(function () {
            (0, _index.compile)("{{input type=(if @else \"bar\" \"baz\")}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@else' is reserved. ('baz/foo-bar' @ L1:C17) ");
        } // anything else that doesn't start with a lower case letter
        ;

        _proto["@test '@Arguments' is reserved"] = function () {
          expectAssertion(function () {
            (0, _index.compile)("{{@Arguments}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@Arguments' is reserved. ('baz/foo-bar' @ L1:C2) ");
          expectAssertion(function () {
            (0, _index.compile)("{{#if @Arguments}}Yup{{/if}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@Arguments' is reserved. ('baz/foo-bar' @ L1:C6) ");
          expectAssertion(function () {
            (0, _index.compile)("{{input type=(if @Arguments \"bar\" \"baz\")}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@Arguments' is reserved. ('baz/foo-bar' @ L1:C17) ");
        };

        _proto["@test '@Args' is reserved"] = function () {
          expectAssertion(function () {
            (0, _index.compile)("{{@Args}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@Args' is reserved. ('baz/foo-bar' @ L1:C2) ");
          expectAssertion(function () {
            (0, _index.compile)("{{#if @Args}}Yup{{/if}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@Args' is reserved. ('baz/foo-bar' @ L1:C6) ");
          expectAssertion(function () {
            (0, _index.compile)("{{input type=(if @Args \"bar\" \"baz\")}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@Args' is reserved. ('baz/foo-bar' @ L1:C17) ");
        };

        _proto["@test '@FOO' is reserved"] = function () {
          expectAssertion(function () {
            (0, _index.compile)("{{@FOO}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@FOO' is reserved. ('baz/foo-bar' @ L1:C2) ");
          expectAssertion(function () {
            (0, _index.compile)("{{#if @FOO}}Yup{{/if}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@FOO' is reserved. ('baz/foo-bar' @ L1:C6) ");
          expectAssertion(function () {
            (0, _index.compile)("{{input type=(if @FOO \"bar\" \"baz\")}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@FOO' is reserved. ('baz/foo-bar' @ L1:C17) ");
        };

        _proto["@test '@Foo' is reserved"] = function () {
          expectAssertion(function () {
            (0, _index.compile)("{{@Foo}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@Foo' is reserved. ('baz/foo-bar' @ L1:C2) ");
          expectAssertion(function () {
            (0, _index.compile)("{{#if @Foo}}Yup{{/if}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@Foo' is reserved. ('baz/foo-bar' @ L1:C6) ");
          expectAssertion(function () {
            (0, _index.compile)("{{input type=(if @Foo \"bar\" \"baz\")}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@Foo' is reserved. ('baz/foo-bar' @ L1:C17) ");
        };

        _proto["@test '@.' is reserved"] = function () {
          expectAssertion(function () {
            (0, _index.compile)("{{@.}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@.' is reserved. ('baz/foo-bar' @ L1:C2) ");
          expectAssertion(function () {
            (0, _index.compile)("{{#if @.}}Yup{{/if}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@.' is reserved. ('baz/foo-bar' @ L1:C6) ");
          expectAssertion(function () {
            (0, _index.compile)("{{input type=(if @. \"bar\" \"baz\")}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@.' is reserved. ('baz/foo-bar' @ L1:C17) ");
        };

        _proto["@test '@_' is reserved"] = function () {
          expectAssertion(function () {
            (0, _index.compile)("{{@_}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@_' is reserved. ('baz/foo-bar' @ L1:C2) ");
          expectAssertion(function () {
            (0, _index.compile)("{{#if @_}}Yup{{/if}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@_' is reserved. ('baz/foo-bar' @ L1:C6) ");
          expectAssertion(function () {
            (0, _index.compile)("{{input type=(if @_ \"bar\" \"baz\")}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@_' is reserved. ('baz/foo-bar' @ L1:C17) ");
        };

        _proto["@test '@-' is reserved"] = function () {
          expectAssertion(function () {
            (0, _index.compile)("{{@-}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@-' is reserved. ('baz/foo-bar' @ L1:C2) ");
          expectAssertion(function () {
            (0, _index.compile)("{{#if @-}}Yup{{/if}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@-' is reserved. ('baz/foo-bar' @ L1:C6) ");
          expectAssertion(function () {
            (0, _index.compile)("{{input type=(if @- \"bar\" \"baz\")}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@-' is reserved. ('baz/foo-bar' @ L1:C17) ");
        };

        _proto["@test '@$' is reserved"] = function () {
          expectAssertion(function () {
            (0, _index.compile)("{{@$}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@$' is reserved. ('baz/foo-bar' @ L1:C2) ");
          expectAssertion(function () {
            (0, _index.compile)("{{#if @$}}Yup{{/if}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@$' is reserved. ('baz/foo-bar' @ L1:C6) ");
          expectAssertion(function () {
            (0, _index.compile)("{{input type=(if @$ \"bar\" \"baz\")}}", {
              moduleName: 'baz/foo-bar'
            });
          }, "'@$' is reserved. ('baz/foo-bar' @ L1:C17) ");
        };

        _proto["@test '@' is de facto reserved (parse error)"] = function (assert) {
          assert.throws(function () {
            (0, _index.compile)('{{@}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
          assert.throws(function () {
            (0, _index.compile)('{{#if @}}Yup{{/if}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
          assert.throws(function () {
            (0, _index.compile)('{{input type=(if @ "bar" "baz")}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
        };

        _proto["@test '@0' is de facto reserved (parse error)"] = function (assert) {
          assert.throws(function () {
            (0, _index.compile)('{{@0}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
          assert.throws(function () {
            (0, _index.compile)('{{#if @0}}Yup{{/if}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
          assert.throws(function () {
            (0, _index.compile)('{{input type=(if @0 "bar" "baz")}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
        };

        _proto["@test '@1' is de facto reserved (parse error)"] = function (assert) {
          assert.throws(function () {
            (0, _index.compile)('{{@1}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
          assert.throws(function () {
            (0, _index.compile)('{{#if @1}}Yup{{/if}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
          assert.throws(function () {
            (0, _index.compile)('{{input type=(if @1 "bar" "baz")}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
        };

        _proto["@test '@2' is de facto reserved (parse error)"] = function (assert) {
          assert.throws(function () {
            (0, _index.compile)('{{@2}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
          assert.throws(function () {
            (0, _index.compile)('{{#if @2}}Yup{{/if}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
          assert.throws(function () {
            (0, _index.compile)('{{input type=(if @2 "bar" "baz")}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
        };

        _proto["@test '@@' is de facto reserved (parse error)"] = function (assert) {
          assert.throws(function () {
            (0, _index.compile)('{{@@}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
          assert.throws(function () {
            (0, _index.compile)('{{#if @@}}Yup{{/if}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
          assert.throws(function () {
            (0, _index.compile)('{{input type=(if @@ "bar" "baz")}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
        };

        _proto["@test '@=' is de facto reserved (parse error)"] = function (assert) {
          assert.throws(function () {
            (0, _index.compile)('{{@=}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
          assert.throws(function () {
            (0, _index.compile)('{{#if @=}}Yup{{/if}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
          assert.throws(function () {
            (0, _index.compile)('{{input type=(if @= "bar" "baz")}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
        };

        _proto["@test '@!' is de facto reserved (parse error)"] = function (assert) {
          assert.throws(function () {
            (0, _index.compile)('{{@!}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
          assert.throws(function () {
            (0, _index.compile)('{{#if @!}}Yup{{/if}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
          assert.throws(function () {
            (0, _index.compile)('{{input type=(if @! "bar" "baz")}}', {
              moduleName: 'baz/foo-bar'
            });
          }, /Expecting 'ID'/);
        };

        return _class;
      }(_internalTestHelpers.AbstractTestCase));
    } else {
    (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert-reserved-named-arguments',
    /*#__PURE__*/
    function (_AbstractTestCase2) {
      (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

      function _class2() {
        return _AbstractTestCase2.apply(this, arguments) || this;
      }

      var _proto2 = _class2.prototype;

      _proto2['@test Paths beginning with @ are not valid'] = function testPathsBeginningWithAreNotValid() {
        expectAssertion(function () {
          (0, _index.compile)('{{@foo}}', {
            moduleName: 'baz/foo-bar'
          });
        }, "'@foo' is not a valid path. ('baz/foo-bar' @ L1:C2) ");
        expectAssertion(function () {
          (0, _index.compile)('{{#if @foo}}Yup{{/if}}', {
            moduleName: 'baz/foo-bar'
          });
        }, "'@foo' is not a valid path. ('baz/foo-bar' @ L1:C6) ");
        expectAssertion(function () {
          (0, _index.compile)('{{input type=(if @foo "bar" "baz")}}', {
            moduleName: 'baz/foo-bar'
          });
        }, "'@foo' is not a valid path. ('baz/foo-bar' @ L1:C17) ");
      };

      return _class2;
    }(_internalTestHelpers.AbstractTestCase));
  }
});
enifed("ember-template-compiler/tests/plugins/assert-splattribute-expression-test", ["ember-babel", "internal-test-helpers", "ember-template-compiler/index"], function (_emberBabel, _internalTestHelpers, _index) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert-splattribute-expression',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.expectedMessage = function expectedMessage(locInfo) {
      return true
      /* EMBER_GLIMMER_ANGLE_BRACKET_INVOCATION */
      ? "Using \"...attributes\" can only be used in the element position e.g. <div ...attributes />. It cannot be used as a path. (" + locInfo + ") " : "...attributes is an invalid path (" + locInfo + ") ";
    };

    _proto['@test ...attributes is in element space'] = function testAttributesIsInElementSpace(assert) {
      if (true
      /* EMBER_GLIMMER_ANGLE_BRACKET_INVOCATION */
      ) {
          assert.expect(0);
          (0, _index.compile)('<div ...attributes>Foo</div>');
        } else {
        expectAssertion(function () {
          (0, _index.compile)('<div ...attributes>Foo</div>');
        }, this.expectedMessage('L1:C5'));
      }
    };

    _proto['@test {{...attributes}} is not valid'] = function testAttributesIsNotValid() {
      expectAssertion(function () {
        (0, _index.compile)('<div>{{...attributes}}</div>', {
          moduleName: 'foo-bar'
        });
      }, this.expectedMessage("'foo-bar' @ L1:C7"));
    };

    _proto['@test {{...attributes}} is not valid path expression'] = function testAttributesIsNotValidPathExpression() {
      expectAssertion(function () {
        (0, _index.compile)('<div>{{...attributes}}</div>', {
          moduleName: 'foo-bar'
        });
      }, this.expectedMessage("'foo-bar' @ L1:C7"));
    };

    _proto['@test {{...attributes}} is not valid modifier'] = function testAttributesIsNotValidModifier() {
      expectAssertion(function () {
        (0, _index.compile)('<div {{...attributes}}>Wat</div>', {
          moduleName: 'foo-bar'
        });
      }, this.expectedMessage("'foo-bar' @ L1:C7"));
    };

    _proto['@test {{...attributes}} is not valid attribute'] = function testAttributesIsNotValidAttribute() {
      expectAssertion(function () {
        (0, _index.compile)('<div class={{...attributes}}>Wat</div>', {
          moduleName: 'foo-bar'
        });
      }, this.expectedMessage("'foo-bar' @ L1:C13"));
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/plugins/deprecate-send-action-test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  var EVENTS = ['insert-newline', 'enter', 'escape-press', 'focus-in', 'focus-out', 'key-press', 'key-up', 'key-down'];

  var DeprecateSendActionTest =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(DeprecateSendActionTest, _AbstractTestCase);

    function DeprecateSendActionTest() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    return DeprecateSendActionTest;
  }(_internalTestHelpers.AbstractTestCase);

  EVENTS.forEach(function (e) {
    DeprecateSendActionTest.prototype["@test Using `{{input " + e + "=\"actionName\"}}` provides a deprecation"] = function () {
      var expectedMessage = "Please refactor `{{input " + e + "=\"foo-bar\"}}` to `{{input " + e + "=(action \"foo-bar\")}}. ('baz/foo-bar' @ L1:C0) ";
      expectDeprecation(function () {
        (0, _index.compile)("{{input " + e + "=\"foo-bar\"}}", {
          moduleName: 'baz/foo-bar'
        });
      }, expectedMessage);
    };
  });
  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: deprecate-send-action', DeprecateSendActionTest);
});
enifed("ember-template-compiler/tests/plugins/transform-component-invocation-test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: transforms component invocation',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Does not throw a compiler error for component invocations'] = function testDoesNotThrowACompilerErrorForComponentInvocations(assert) {
      assert.expect(0);
      ['{{this.modal open}}', '{{this.modal isOpen=true}}', '{{#this.modal}}Woot{{/this.modal}}', '{{@modal open}}', // RFC#311
      '{{@modal isOpen=true}}', // RFC#311
      '{{#@modal}}Woot{{/@modal}}', // RFC#311
      '{{c.modal open}}', '{{c.modal isOpen=true}}', '{{#c.modal}}Woot{{/c.modal}}', '{{#my-component as |c|}}{{c name="Chad"}}{{/my-component}}', // RFC#311
      '{{#my-component as |c|}}{{c "Chad"}}{{/my-component}}', // RFC#311
      '{{#my-component as |c|}}{{#c}}{{/c}}{{/my-component}}', // RFC#311
      '<input disabled={{true}}>', // GH#15740
      '<td colspan={{3}}></td>'].forEach(function (layout, i) {
        (0, _index.compile)(layout, {
          moduleName: "example-" + i
        });
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/plugins/transform-inline-link-to-test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: inline-link-to',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Can transform an inline {{link-to}} without error'] = function testCanTransformAnInlineLinkToWithoutError(assert) {
      assert.expect(0);
      (0, _index.compile)("{{link-to 'foo' 'index'}}", {
        moduleName: 'foo/bar/baz'
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/plugins/transform-input-type-syntax-test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: input type syntax',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Can compile an {{input}} helper that has a sub-expression value as its type'] = function testCanCompileAnInputHelperThatHasASubExpressionValueAsItsType(assert) {
      assert.expect(0);
      (0, _index.compile)("{{input type=(if true 'password' 'text')}}");
    };

    _proto['@test Can compile an {{input}} helper with a string literal type'] = function testCanCompileAnInputHelperWithAStringLiteralType(assert) {
      assert.expect(0);
      (0, _index.compile)("{{input type='text'}}");
    };

    _proto['@test Can compile an {{input}} helper with a type stored in a var'] = function testCanCompileAnInputHelperWithATypeStoredInAVar(assert) {
      assert.expect(0);
      (0, _index.compile)("{{input type=_type}}");
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/system/bootstrap-test", ["ember-babel", "@ember/runloop", "@ember/-internals/glimmer", "ember-template-compiler/lib/system/bootstrap", "internal-test-helpers"], function (_emberBabel, _runloop, _glimmer, _bootstrap, _internalTestHelpers) {
  "use strict";

  var component, fixture;

  function checkTemplate(templateName, assert) {
    (0, _runloop.run)(function () {
      return (0, _bootstrap.default)({
        context: fixture,
        hasTemplate: _glimmer.hasTemplate,
        setTemplate: _glimmer.setTemplate
      });
    });
    var template = (0, _glimmer.getTemplate)(templateName);
    var qunitFixture = document.querySelector('#qunit-fixture');
    assert.ok(template, 'template is available on Ember.TEMPLATES');
    assert.notOk(qunitFixture.querySelector('script'), 'script removed');
    var owner = (0, _internalTestHelpers.buildOwner)();
    owner.register('template:-top-level', template);
    owner.register('component:-top-level', _glimmer.Component.extend({
      layoutName: '-top-level',
      firstName: 'Tobias',
      drug: 'teamocil'
    }));
    component = owner.lookup('component:-top-level');
    (0, _internalTestHelpers.runAppend)(component);
    assert.equal(qunitFixture.textContent.trim(), 'Tobias takes teamocil', 'template works');
    (0, _internalTestHelpers.runDestroy)(owner);
  }

  (0, _internalTestHelpers.moduleFor)('ember-templates: bootstrap',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      fixture = document.getElementById('qunit-fixture');
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _glimmer.setTemplates)({});
      fixture = component = null;
    };

    _proto['@test template with data-template-name should add a new template to Ember.TEMPLATES'] = function testTemplateWithDataTemplateNameShouldAddANewTemplateToEmberTEMPLATES(assert) {
      fixture.innerHTML = '<script type="text/x-handlebars" data-template-name="funkyTemplate">{{firstName}} takes {{drug}}</script>';
      checkTemplate('funkyTemplate', assert);
    };

    _proto['@test template with id instead of data-template-name should add a new template to Ember.TEMPLATES'] = function testTemplateWithIdInsteadOfDataTemplateNameShouldAddANewTemplateToEmberTEMPLATES(assert) {
      fixture.innerHTML = '<script type="text/x-handlebars" id="funkyTemplate" >{{firstName}} takes {{drug}}</script>';
      checkTemplate('funkyTemplate', assert);
    };

    _proto['@test template without data-template-name or id should default to application'] = function testTemplateWithoutDataTemplateNameOrIdShouldDefaultToApplication(assert) {
      fixture.innerHTML = '<script type="text/x-handlebars">{{firstName}} takes {{drug}}</script>';
      checkTemplate('application', assert);
    } // Add this test case, only for typeof Handlebars === 'object';
    ;

    _proto[(typeof Handlebars === 'object' ? '@test' : '@skip') + " template with type text/x-raw-handlebars should be parsed"] = function (assert) {
      fixture.innerHTML = '<script type="text/x-raw-handlebars" data-template-name="funkyTemplate">{{name}}</script>';
      (0, _runloop.run)(function () {
        return (0, _bootstrap.default)({
          context: fixture,
          hasTemplate: _glimmer.hasTemplate,
          setTemplate: _glimmer.setTemplate
        });
      });
      var template = (0, _glimmer.getTemplate)('funkyTemplate');
      assert.ok(template, 'template with name funkyTemplate available'); // This won't even work with Ember templates

      assert.equal(template({
        name: 'Tobias'
      }).trim(), 'Tobias');
    };

    _proto['@test duplicated default application templates should throw exception'] = function testDuplicatedDefaultApplicationTemplatesShouldThrowException(assert) {
      fixture.innerHTML = '<script type="text/x-handlebars">first</script><script type="text/x-handlebars">second</script>';
      assert.throws(function () {
        return (0, _bootstrap.default)({
          context: fixture,
          hasTemplate: _glimmer.hasTemplate,
          setTemplate: _glimmer.setTemplate
        });
      }, /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
    };

    _proto['@test default default application template and id application template present should throw exception'] = function testDefaultDefaultApplicationTemplateAndIdApplicationTemplatePresentShouldThrowException(assert) {
      fixture.innerHTML = '<script type="text/x-handlebars">first</script><script type="text/x-handlebars" id="application">second</script>';
      assert.throws(function () {
        return (0, _bootstrap.default)({
          context: fixture,
          hasTemplate: _glimmer.hasTemplate,
          setTemplate: _glimmer.setTemplate
        });
      }, /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
    };

    _proto['@test default application template and data-template-name application template present should throw exception'] = function testDefaultApplicationTemplateAndDataTemplateNameApplicationTemplatePresentShouldThrowException(assert) {
      fixture.innerHTML = '<script type="text/x-handlebars">first</script><script type="text/x-handlebars" data-template-name="application">second</script>';
      assert.throws(function () {
        return (0, _bootstrap.default)({
          context: fixture,
          hasTemplate: _glimmer.hasTemplate,
          setTemplate: _glimmer.setTemplate
        });
      }, /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
    };

    _proto['@test duplicated template id should throw exception'] = function testDuplicatedTemplateIdShouldThrowException(assert) {
      fixture.innerHTML = '<script type="text/x-handlebars" id="funkyTemplate">first</script><script type="text/x-handlebars" id="funkyTemplate">second</script>';
      assert.throws(function () {
        return (0, _bootstrap.default)({
          context: fixture,
          hasTemplate: _glimmer.hasTemplate,
          setTemplate: _glimmer.setTemplate
        });
      }, /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
    };

    _proto['@test duplicated template data-template-name should throw exception'] = function testDuplicatedTemplateDataTemplateNameShouldThrowException(assert) {
      fixture.innerHTML = '<script type="text/x-handlebars" data-template-name="funkyTemplate">first</script><script type="text/x-handlebars" data-template-name="funkyTemplate">second</script>';
      assert.throws(function () {
        return (0, _bootstrap.default)({
          context: fixture,
          hasTemplate: _glimmer.hasTemplate,
          setTemplate: _glimmer.setTemplate
        });
      }, /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/system/compile_options_test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: default compile options',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test default options are a new copy'] = function testDefaultOptionsAreANewCopy(assert) {
      assert.notEqual((0, _index.compileOptions)(), (0, _index.compileOptions)());
    };

    _proto['@test has default AST plugins'] = function testHasDefaultASTPlugins(assert) {
      assert.expect(_index.defaultPlugins.length);
      var plugins = (0, _index.compileOptions)().plugins.ast;

      for (var i = 0; i < _index.defaultPlugins.length; i++) {
        var plugin = _index.defaultPlugins[i];
        assert.ok(plugins.indexOf(plugin) > -1, "includes " + plugin);
      }
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  var customTransformCounter = 0;

  var LegacyCustomTransform =
  /*#__PURE__*/
  function () {
    function LegacyCustomTransform(options) {
      customTransformCounter++;
      this.options = options;
      this.syntax = null;
    }

    var _proto2 = LegacyCustomTransform.prototype;

    _proto2.transform = function transform(ast) {
      var walker = new this.syntax.Walker();
      walker.visit(ast, function (node) {
        if (node.type !== 'ElementNode') {
          return;
        }

        for (var i = 0; i < node.attributes.length; i++) {
          var attribute = node.attributes[i];

          if (attribute.name === 'data-test') {
            node.attributes.splice(i, 1);
          }
        }
      });
      return ast;
    };

    return LegacyCustomTransform;
  }();

  function customTransform() {
    customTransformCounter++;
    return {
      name: 'remove-data-test',
      visitor: {
        ElementNode: function (node) {
          for (var i = 0; i < node.attributes.length; i++) {
            var attribute = node.attributes[i];

            if (attribute.name === 'data-test') {
              node.attributes.splice(i, 1);
            }
          }
        }
      }
    };
  }

  var CustomPluginsTests =
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(CustomPluginsTests, _RenderingTestCase);

    function CustomPluginsTests() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto3 = CustomPluginsTests.prototype;

    _proto3.afterEach = function afterEach() {
      customTransformCounter = 0;
      return _RenderingTestCase.prototype.afterEach.call(this);
    };

    _proto3['@test custom plugins can be used'] = function testCustomPluginsCanBeUsed() {
      this.render('<div data-test="foo" data-blah="derp" class="hahaha"></div>');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: 'hahaha',
          'data-blah': 'derp'
        },
        content: ''
      });
    };

    _proto3['@test wrapped plugins are only invoked once per template'] = function testWrappedPluginsAreOnlyInvokedOncePerTemplate(assert) {
      this.render('<div>{{#if falsey}}nope{{/if}}</div>');
      assert.equal(customTransformCounter, 1, 'transform should only be instantiated once');
    };

    return CustomPluginsTests;
  }(_internalTestHelpers.RenderingTestCase);

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: registerPlugin with a custom plugins in legacy format',
  /*#__PURE__*/
  function (_CustomPluginsTests) {
    (0, _emberBabel.inheritsLoose)(_class2, _CustomPluginsTests);

    function _class2() {
      return _CustomPluginsTests.apply(this, arguments) || this;
    }

    var _proto4 = _class2.prototype;

    _proto4.beforeEach = function beforeEach() {
      (0, _index.registerPlugin)('ast', LegacyCustomTransform);
    };

    _proto4.afterEach = function afterEach() {
      (0, _index.unregisterPlugin)('ast', LegacyCustomTransform);
      return _CustomPluginsTests.prototype.afterEach.call(this);
    };

    _proto4['@test custom registered plugins are deduplicated'] = function testCustomRegisteredPluginsAreDeduplicated(assert) {
      (0, _index.registerPlugin)('ast', LegacyCustomTransform);
      this.registerTemplate('application', '<div data-test="foo" data-blah="derp" class="hahaha"></div>');
      assert.equal(customTransformCounter, 1, 'transform should only be instantiated once');
    };

    return _class2;
  }(CustomPluginsTests));
  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: registerPlugin with a custom plugins',
  /*#__PURE__*/
  function (_CustomPluginsTests2) {
    (0, _emberBabel.inheritsLoose)(_class3, _CustomPluginsTests2);

    function _class3() {
      return _CustomPluginsTests2.apply(this, arguments) || this;
    }

    var _proto5 = _class3.prototype;

    _proto5.beforeEach = function beforeEach() {
      (0, _index.registerPlugin)('ast', customTransform);
    };

    _proto5.afterEach = function afterEach() {
      (0, _index.unregisterPlugin)('ast', customTransform);
      return _CustomPluginsTests2.prototype.afterEach.call(this);
    };

    _proto5['@test custom registered plugins are deduplicated'] = function testCustomRegisteredPluginsAreDeduplicated(assert) {
      (0, _index.registerPlugin)('ast', customTransform);
      this.registerTemplate('application', '<div data-test="foo" data-blah="derp" class="hahaha"></div>');
      assert.equal(customTransformCounter, 1, 'transform should only be instantiated once');
    };

    return _class3;
  }(CustomPluginsTests));
  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: custom plugins in legacy format passed to compile',
  /*#__PURE__*/
  function (_RenderingTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class4, _RenderingTestCase2);

    function _class4() {
      return _RenderingTestCase2.apply(this, arguments) || this;
    }

    var _proto6 = _class4.prototype; // override so that we can provide custom AST plugins to compile

    _proto6.compile = function compile(templateString) {
      return (0, _index.compile)(templateString, {
        plugins: {
          ast: [LegacyCustomTransform]
        }
      });
    };

    return _class4;
  }(_internalTestHelpers.RenderingTestCase));
  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: custom plugins passed to compile',
  /*#__PURE__*/
  function (_RenderingTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class5, _RenderingTestCase3);

    function _class5() {
      return _RenderingTestCase3.apply(this, arguments) || this;
    }

    var _proto7 = _class5.prototype; // override so that we can provide custom AST plugins to compile

    _proto7.compile = function compile(templateString) {
      return (0, _index.compile)(templateString, {
        plugins: {
          ast: [customTransform]
        }
      });
    };

    return _class5;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("ember-template-compiler/tests/system/dasherize-component-name-test", ["ember-babel", "ember-template-compiler/lib/system/dasherize-component-name", "internal-test-helpers"], function (_emberBabel, _dasherizeComponentName, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('dasherize-component-name',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test names are correctly dasherized'] = function testNamesAreCorrectlyDasherized(assert) {
      assert.equal(_dasherizeComponentName.default.get('Foo'), 'foo');
      assert.equal(_dasherizeComponentName.default.get('foo-bar'), 'foo-bar');
      assert.equal(_dasherizeComponentName.default.get('FooBar'), 'foo-bar');
      assert.equal(_dasherizeComponentName.default.get('F3Bar'), 'f3-bar');
      assert.equal(_dasherizeComponentName.default.get('Foo3Bar'), 'foo3-bar');
      assert.equal(_dasherizeComponentName.default.get('Foo3barBaz'), 'foo3bar-baz');
      assert.equal(_dasherizeComponentName.default.get('FooB3ar'), 'foo-b3ar');
      assert.equal(_dasherizeComponentName.default.get('XBlah'), 'x-blah');
      assert.equal(_dasherizeComponentName.default.get('X-Blah'), 'x-blah');
      assert.equal(_dasherizeComponentName.default.get('Foo::BarBaz'), 'foo::bar-baz');
      assert.equal(_dasherizeComponentName.default.get('Foo::Bar-Baz'), 'foo::bar-baz');
      assert.equal(_dasherizeComponentName.default.get('Foo@BarBaz'), 'foo@bar-baz');
      assert.equal(_dasherizeComponentName.default.get('Foo@Bar-Baz'), 'foo@bar-baz');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-testing/tests/acceptance_test", ["ember-babel", "internal-test-helpers", "@ember/runloop", "ember-testing/lib/test", "ember-testing/lib/adapters/qunit", "@ember/-internals/routing", "@ember/-internals/runtime", "@ember/-internals/views", "@ember/debug"], function (_emberBabel, _internalTestHelpers, _runloop, _test, _qunit, _routing, _runtime, _views, _debug) {
  "use strict";

  var originalDebug = (0, _debug.getDebugFunction)('debug');
  var originalConsoleError = console.error; // eslint-disable-line no-console

  var testContext;

  if (!_views.jQueryDisabled) {
    (0, _internalTestHelpers.moduleFor)('ember-testing Acceptance',
    /*#__PURE__*/
    function (_AutobootApplicationT) {
      (0, _emberBabel.inheritsLoose)(_class, _AutobootApplicationT);

      function _class() {
        var _this;

        (0, _debug.setDebugFunction)('debug', function () {});
        _this = _AutobootApplicationT.call(this) || this;
        _this._originalAdapter = _test.default.adapter;
        testContext = (0, _emberBabel.assertThisInitialized)((0, _emberBabel.assertThisInitialized)(_this));
        (0, _internalTestHelpers.runTask)(function () {
          _this.createApplication();

          _this.router.map(function () {
            this.route('posts');
            this.route('comments');
            this.route('abort_transition');
            this.route('redirect');
          });

          _this.indexHitCount = 0;
          _this.currentRoute = 'index';

          _this.add('route:index', _routing.Route.extend({
            model: function () {
              testContext.indexHitCount += 1;
            }
          }));

          _this.add('route:posts', _routing.Route.extend({
            renderTemplate: function () {
              testContext.currentRoute = 'posts';

              this._super.apply(this, arguments);
            }
          }));

          _this.addTemplate('posts', "\n          <div class=\"posts-view\">\n            <a class=\"dummy-link\"></a>\n            <div id=\"comments-link\">\n              {{#link-to 'comments'}}Comments{{/link-to}}\n            </div>\n          </div>\n        ");

          _this.add('route:comments', _routing.Route.extend({
            renderTemplate: function () {
              testContext.currentRoute = 'comments';

              this._super.apply(this, arguments);
            }
          }));

          _this.addTemplate('comments', "<div>{{input type=\"text\"}}</div>");

          _this.add('route:abort_transition', _routing.Route.extend({
            beforeModel: function (transition) {
              transition.abort();
            }
          }));

          _this.add('route:redirect', _routing.Route.extend({
            beforeModel: function () {
              this.transitionTo('comments');
            }
          }));

          _this.application.setupForTesting();

          _test.default.registerAsyncHelper('slowHelper', function () {
            return new _runtime.RSVP.Promise(function (resolve) {
              return (0, _runloop.later)(resolve, 10);
            });
          });

          _this.application.injectTestHelpers();
        });
        return _this;
      }

      var _proto = _class.prototype;

      _proto.afterEach = function afterEach() {
        console.error = originalConsoleError; // eslint-disable-line no-console

        _AutobootApplicationT.prototype.afterEach.call(this);
      };

      _proto.teardown = function teardown() {
        (0, _debug.setDebugFunction)('debug', originalDebug);
        _test.default.adapter = this._originalAdapter;

        _test.default.unregisterHelper('slowHelper');

        window.slowHelper = undefined;
        testContext = undefined;

        _AutobootApplicationT.prototype.teardown.call(this);
      };

      _proto["@test helpers can be chained with then"] = function (assert) {
        var _this2 = this;

        assert.expect(6);
        window.visit('/posts').then(function () {
          assert.equal(_this2.currentRoute, 'posts', 'Successfully visited posts route');
          assert.equal(window.currentURL(), '/posts', 'posts URL is correct');
          return window.click('a:contains("Comments")');
        }).then(function () {
          assert.equal(_this2.currentRoute, 'comments', 'visit chained with click');
          return window.fillIn('.ember-text-field', 'yeah');
        }).then(function () {
          assert.equal(document.querySelector('.ember-text-field').value, 'yeah', 'chained with fillIn');
          return window.fillIn('.ember-text-field', '#qunit-fixture', 'context working');
        }).then(function () {
          assert.equal(document.querySelector('.ember-text-field').value, 'context working', 'chained with fillIn');
          return window.click('.does-not-exist');
        }).catch(function (e) {
          assert.equal(e.message, 'Element .does-not-exist not found.', 'Non-existent click exception caught');
        });
      };

      _proto["@test helpers can be chained to each other (legacy)"] = function (assert) {
        var _this3 = this;

        assert.expect(7);
        window.visit('/posts').click('a:first', '#comments-link').fillIn('.ember-text-field', 'hello').then(function () {
          assert.equal(_this3.currentRoute, 'comments', 'Successfully visited comments route');
          assert.equal(window.currentURL(), '/comments', 'Comments URL is correct');
          assert.equal(document.querySelector('.ember-text-field').value, 'hello', 'Fillin successfully works');
          window.find('.ember-text-field').one('keypress', function (e) {
            assert.equal(e.keyCode, 13, 'keyevent chained with correct keyCode.');
            assert.equal(e.which, 13, 'keyevent chained with correct which.');
          });
        }).keyEvent('.ember-text-field', 'keypress', 13).visit('/posts').then(function () {
          assert.equal(_this3.currentRoute, 'posts', 'Thens can also be chained to helpers');
          assert.equal(window.currentURL(), '/posts', 'URL is set correct on chained helpers');
        });
      };

      _proto["@test helpers don't need to be chained"] = function (assert) {
        var _this4 = this;

        assert.expect(5);
        window.visit('/posts');
        window.click('a:first', '#comments-link');
        window.fillIn('.ember-text-field', 'hello');
        window.andThen(function () {
          assert.equal(_this4.currentRoute, 'comments', 'Successfully visited comments route');
          assert.equal(window.currentURL(), '/comments', 'Comments URL is correct');
          assert.equal(window.find('.ember-text-field').val(), 'hello', 'Fillin successfully works');
        });
        window.visit('/posts');
        window.andThen(function () {
          assert.equal(_this4.currentRoute, 'posts');
          assert.equal(window.currentURL(), '/posts');
        });
      };

      _proto["@test Nested async helpers"] = function (assert) {
        var _this5 = this;

        assert.expect(5);
        window.visit('/posts');
        window.andThen(function () {
          window.click('a:first', '#comments-link');
          window.fillIn('.ember-text-field', 'hello');
        });
        window.andThen(function () {
          assert.equal(_this5.currentRoute, 'comments', 'Successfully visited comments route');
          assert.equal(window.currentURL(), '/comments', 'Comments URL is correct');
          assert.equal(window.find('.ember-text-field').val(), 'hello', 'Fillin successfully works');
        });
        window.visit('/posts');
        window.andThen(function () {
          assert.equal(_this5.currentRoute, 'posts');
          assert.equal(window.currentURL(), '/posts');
        });
      };

      _proto["@test Multiple nested async helpers"] = function (assert) {
        var _this6 = this;

        assert.expect(3);
        window.visit('/posts');
        window.andThen(function () {
          window.click('a:first', '#comments-link');
          window.fillIn('.ember-text-field', 'hello');
          window.fillIn('.ember-text-field', 'goodbye');
        });
        window.andThen(function () {
          assert.equal(window.find('.ember-text-field').val(), 'goodbye', 'Fillin successfully works');
          assert.equal(_this6.currentRoute, 'comments', 'Successfully visited comments route');
          assert.equal(window.currentURL(), '/comments', 'Comments URL is correct');
        });
      };

      _proto["@test Helpers nested in thens"] = function (assert) {
        var _this7 = this;

        assert.expect(5);
        window.visit('/posts').then(function () {
          window.click('a:first', '#comments-link');
        });
        window.andThen(function () {
          window.fillIn('.ember-text-field', 'hello');
        });
        window.andThen(function () {
          assert.equal(_this7.currentRoute, 'comments', 'Successfully visited comments route');
          assert.equal(window.currentURL(), '/comments', 'Comments URL is correct');
          assert.equal(window.find('.ember-text-field').val(), 'hello', 'Fillin successfully works');
        });
        window.visit('/posts');
        window.andThen(function () {
          assert.equal(_this7.currentRoute, 'posts');
          assert.equal(window.currentURL(), '/posts', 'Posts URL is correct');
        });
      };

      _proto["@test Aborted transitions are not logged via Ember.Test.adapter#exception"] = function (assert) {
        assert.expect(0);
        _test.default.adapter = _qunit.default.create({
          exception: function () {
            assert.ok(false, 'aborted transitions are not logged');
          }
        });
        window.visit('/abort_transition');
      };

      _proto["@test Unhandled exceptions are logged via Ember.Test.adapter#exception"] = function (assert) {
        assert.expect(2);

        console.error = function () {}; // eslint-disable-line no-console


        var asyncHandled;
        _test.default.adapter = _qunit.default.create({
          exception: function (error) {
            assert.equal(error.message, 'Element .does-not-exist not found.', 'Exception successfully caught and passed to Ember.Test.adapter.exception'); // handle the rejection so it doesn't leak later.

            asyncHandled.catch(function () {});
          }
        });
        window.visit('/posts');
        window.click('.invalid-element').catch(function (error) {
          assert.equal(error.message, 'Element .invalid-element not found.', 'Exception successfully handled in the rejection handler');
        });
        asyncHandled = window.click('.does-not-exist');
      };

      _proto["@test Unhandled exceptions in 'andThen' are logged via Ember.Test.adapter#exception"] = function (assert) {
        assert.expect(1);

        console.error = function () {}; // eslint-disable-line no-console


        _test.default.adapter = _qunit.default.create({
          exception: function (error) {
            assert.equal(error.message, 'Catch me', 'Exception successfully caught and passed to Ember.Test.adapter.exception');
          }
        });
        window.visit('/posts');
        window.andThen(function () {
          throw new Error('Catch me');
        });
      };

      _proto["@test should not start routing on the root URL when visiting another"] = function (assert) {
        var _this8 = this;

        assert.expect(4);
        window.visit('/posts');
        window.andThen(function () {
          assert.ok(window.find('#comments-link'), 'found comments-link');
          assert.equal(_this8.currentRoute, 'posts', 'Successfully visited posts route');
          assert.equal(window.currentURL(), '/posts', 'Posts URL is correct');
          assert.equal(_this8.indexHitCount, 0, 'should not hit index route when visiting another route');
        });
      };

      _proto["@test only enters the index route once when visiting "] = function (assert) {
        var _this9 = this;

        assert.expect(1);
        window.visit('/');
        window.andThen(function () {
          assert.equal(_this9.indexHitCount, 1, 'should hit index once when visiting /');
        });
      };

      _proto["@test test must not finish while asyncHelpers are pending"] = function (assert) {
        assert.expect(2);
        var async = 0;
        var innerRan = false;
        _test.default.adapter = _qunit.default.extend({
          asyncStart: function () {
            async++;

            this._super();
          },
          asyncEnd: function () {
            async--;

            this._super();
          }
        }).create();
        this.application.testHelpers.slowHelper();
        window.andThen(function () {
          innerRan = true;
        });
        assert.equal(innerRan, false, 'should not have run yet');
        assert.ok(async > 0, 'should have told the adapter to pause');

        if (async === 0) {
          // If we failed the test, prevent zalgo from escaping and breaking
          // our other tests.
          _test.default.adapter.asyncStart();

          _test.default.resolve().then(function () {
            _test.default.adapter.asyncEnd();
          });
        }
      };

      _proto["@test visiting a URL that causes another transition should yield the correct URL"] = function (assert) {
        assert.expect(1);
        window.visit('/redirect');
        window.andThen(function () {
          assert.equal(window.currentURL(), '/comments', 'Redirected to Comments URL');
        });
      };

      _proto["@test visiting a URL and then visiting a second URL with a transition should yield the correct URL"] = function (assert) {
        assert.expect(2);
        window.visit('/posts');
        window.andThen(function () {
          assert.equal(window.currentURL(), '/posts', 'First visited URL is correct');
        });
        window.visit('/redirect');
        window.andThen(function () {
          assert.equal(window.currentURL(), '/comments', 'Redirected to Comments URL');
        });
      };

      return _class;
    }(_internalTestHelpers.AutobootApplicationTestCase));
    (0, _internalTestHelpers.moduleFor)('ember-testing Acceptance - teardown',
    /*#__PURE__*/
    function (_AutobootApplicationT2) {
      (0, _emberBabel.inheritsLoose)(_class2, _AutobootApplicationT2);

      function _class2() {
        return _AutobootApplicationT2.apply(this, arguments) || this;
      }

      var _proto2 = _class2.prototype;

      _proto2["@test that the setup/teardown happens correctly"] = function (assert) {
        var _this10 = this;

        assert.expect(2);
        (0, _internalTestHelpers.runTask)(function () {
          _this10.createApplication();
        });
        this.application.injectTestHelpers();
        assert.ok(typeof _test.default.Promise.prototype.click === 'function');
        (0, _internalTestHelpers.runTask)(function () {
          _this10.application.destroy();
        });
        assert.equal(_test.default.Promise.prototype.click, undefined);
      };

      return _class2;
    }(_internalTestHelpers.AutobootApplicationTestCase));
  }
});
enifed("ember-testing/tests/adapters/adapter_test", ["ember-babel", "@ember/runloop", "ember-testing/lib/adapters/adapter", "internal-test-helpers"], function (_emberBabel, _runloop, _adapter, _internalTestHelpers) {
  "use strict";

  var adapter;
  (0, _internalTestHelpers.moduleFor)('ember-testing Adapter',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      adapter = _adapter.default.create();
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _runloop.run)(adapter, adapter.destroy);
    };

    _proto['@test exception throws'] = function testExceptionThrows(assert) {
      var error = 'Hai';
      var thrown;

      try {
        adapter.exception(error);
      } catch (e) {
        thrown = e;
      }

      assert.equal(thrown, error);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-testing/tests/adapters/qunit_test", ["ember-babel", "@ember/runloop", "ember-testing/lib/adapters/qunit", "internal-test-helpers"], function (_emberBabel, _runloop, _qunit, _internalTestHelpers) {
  "use strict";

  var adapter;
  (0, _internalTestHelpers.moduleFor)('ember-testing QUnitAdapter: QUnit 2.x',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      _this.originalStart = QUnit.start;
      _this.originalStop = QUnit.stop;
      delete QUnit.start;
      delete QUnit.stop;
      adapter = _qunit.default.create();
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _runloop.run)(adapter, adapter.destroy);
      QUnit.start = this.originalStart;
      QUnit.stop = this.originalStop;
    };

    _proto['@test asyncStart waits for asyncEnd to finish a test'] = function testAsyncStartWaitsForAsyncEndToFinishATest(assert) {
      adapter.asyncStart();
      setTimeout(function () {
        assert.ok(true);
        adapter.asyncEnd();
      }, 50);
    };

    _proto['@test asyncStart waits for equal numbers of asyncEnd to finish a test'] = function testAsyncStartWaitsForEqualNumbersOfAsyncEndToFinishATest(assert) {
      var adapter = _qunit.default.create();

      adapter.asyncStart();
      adapter.asyncStart();
      adapter.asyncEnd();
      setTimeout(function () {
        assert.ok(true);
        adapter.asyncEnd();
      }, 50);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-testing/tests/adapters_test", ["ember-babel", "@ember/runloop", "@ember/-internals/error-handling", "ember-testing/lib/test", "ember-testing/lib/adapters/adapter", "ember-testing/lib/adapters/qunit", "@ember/application", "internal-test-helpers", "@ember/-internals/runtime", "@ember/debug"], function (_emberBabel, _runloop, _errorHandling, _test, _adapter, _qunit, _application, _internalTestHelpers, _runtime, _debug) {
  "use strict";

  var originalDebug = (0, _debug.getDebugFunction)('debug');

  var noop = function () {};

  var App, originalAdapter, originalQUnit, originalWindowOnerror;
  var originalConsoleError = console.error; // eslint-disable-line no-console

  function runThatThrowsSync() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Error for testing error handling';
    return (0, _runloop.run)(function () {
      throw new Error(message);
    });
  }

  function runThatThrowsAsync() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Error for testing error handling';
    return (0, _runloop.next)(function () {
      throw new Error(message);
    });
  }

  var AdapterSetupAndTearDown =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(AdapterSetupAndTearDown, _AbstractTestCase);

    function AdapterSetupAndTearDown() {
      var _this;

      (0, _debug.setDebugFunction)('debug', noop);
      _this = _AbstractTestCase.call(this) || this;
      originalAdapter = _test.default.adapter;
      originalQUnit = window.QUnit;
      originalWindowOnerror = window.onerror;
      return _this;
    }

    var _proto = AdapterSetupAndTearDown.prototype;

    _proto.afterEach = function afterEach() {
      console.error = originalConsoleError; // eslint-disable-line no-console
    };

    _proto.teardown = function teardown() {
      (0, _debug.setDebugFunction)('debug', originalDebug);

      if (App) {
        (0, _runloop.run)(App, App.destroy);
        App.removeTestHelpers();
        App = null;
      }

      _test.default.adapter = originalAdapter;
      window.QUnit = originalQUnit;
      window.onerror = originalWindowOnerror;
      (0, _errorHandling.setOnerror)(undefined);
    };

    return AdapterSetupAndTearDown;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _internalTestHelpers.moduleFor)('ember-testing Adapters',
  /*#__PURE__*/
  function (_AdapterSetupAndTearD) {
    (0, _emberBabel.inheritsLoose)(_class, _AdapterSetupAndTearD);

    function _class() {
      return _AdapterSetupAndTearD.apply(this, arguments) || this;
    }

    var _proto2 = _class.prototype;

    _proto2['@test Setting a test adapter manually'] = function testSettingATestAdapterManually(assert) {
      assert.expect(1);
      var CustomAdapter;
      CustomAdapter = _adapter.default.extend({
        asyncStart: function () {
          assert.ok(true, 'Correct adapter was used');
        }
      });
      (0, _runloop.run)(function () {
        App = _application.default.create();
        _test.default.adapter = CustomAdapter.create();
        App.setupForTesting();
      });

      _test.default.adapter.asyncStart();
    };

    _proto2['@test QUnitAdapter is used by default (if QUnit is available)'] = function testQUnitAdapterIsUsedByDefaultIfQUnitIsAvailable(assert) {
      assert.expect(1);
      _test.default.adapter = null;
      (0, _runloop.run)(function () {
        App = _application.default.create();
        App.setupForTesting();
      });
      assert.ok(_test.default.adapter instanceof _qunit.default);
    };

    _proto2['@test Adapter is used by default (if QUnit is not available)'] = function testAdapterIsUsedByDefaultIfQUnitIsNotAvailable(assert) {
      assert.expect(2);
      delete window.QUnit;
      _test.default.adapter = null;
      (0, _runloop.run)(function () {
        App = _application.default.create();
        App.setupForTesting();
      });
      assert.ok(_test.default.adapter instanceof _adapter.default);
      assert.ok(!(_test.default.adapter instanceof _qunit.default));
    };

    _proto2['@test With Ember.Test.adapter set, errors in synchronous Ember.run are bubbled out'] = function testWithEmberTestAdapterSetErrorsInSynchronousEmberRunAreBubbledOut(assert) {
      var thrown = new Error('Boom!');
      var caughtInAdapter, caughtInCatch;
      _test.default.adapter = _qunit.default.create({
        exception: function (error) {
          caughtInAdapter = error;
        }
      });

      try {
        (0, _runloop.run)(function () {
          throw thrown;
        });
      } catch (e) {
        caughtInCatch = e;
      }

      assert.equal(caughtInAdapter, undefined, 'test adapter should never receive synchronous errors');
      assert.equal(caughtInCatch, thrown, 'a "normal" try/catch should catch errors in sync run');
    };

    _proto2['@test when both Ember.onerror (which rethrows) and TestAdapter are registered - sync run'] = function testWhenBothEmberOnerrorWhichRethrowsAndTestAdapterAreRegisteredSyncRun(assert) {
      assert.expect(2);
      _test.default.adapter = {
        exception: function () {
          assert.notOk(true, 'adapter is not called for errors thrown in sync run loops');
        }
      };
      (0, _errorHandling.setOnerror)(function (error) {
        assert.ok(true, 'onerror is called for sync errors even if TestAdapter is setup');
        throw error;
      });
      assert.throws(runThatThrowsSync, Error, 'error is thrown');
    };

    _proto2['@test when both Ember.onerror (which does not rethrow) and TestAdapter are registered - sync run'] = function testWhenBothEmberOnerrorWhichDoesNotRethrowAndTestAdapterAreRegisteredSyncRun(assert) {
      assert.expect(2);
      _test.default.adapter = {
        exception: function () {
          assert.notOk(true, 'adapter is not called for errors thrown in sync run loops');
        }
      };
      (0, _errorHandling.setOnerror)(function () {
        assert.ok(true, 'onerror is called for sync errors even if TestAdapter is setup');
      });
      runThatThrowsSync();
      assert.ok(true, 'no error was thrown, Ember.onerror can intercept errors');
    };

    _proto2['@test when TestAdapter is registered and error is thrown - async run'] = function testWhenTestAdapterIsRegisteredAndErrorIsThrownAsyncRun(assert) {
      assert.expect(3);
      var done = assert.async();
      var caughtInAdapter, caughtInCatch, caughtByWindowOnerror;
      _test.default.adapter = {
        exception: function (error) {
          caughtInAdapter = error;
        }
      };

      window.onerror = function (message) {
        caughtByWindowOnerror = message; // prevent "bubbling" and therefore failing the test

        return true;
      };

      try {
        runThatThrowsAsync();
      } catch (e) {
        caughtInCatch = e;
      }

      setTimeout(function () {
        assert.equal(caughtInAdapter, undefined, 'test adapter should never catch errors in run loops');
        assert.equal(caughtInCatch, undefined, 'a "normal" try/catch should never catch errors in an async run');
        assert.pushResult({
          result: /Error for testing error handling/.test(caughtByWindowOnerror),
          actual: caughtByWindowOnerror,
          expected: 'to include `Error for testing error handling`',
          message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
        });
        done();
      }, 20);
    };

    _proto2['@test when both Ember.onerror and TestAdapter are registered - async run'] = function testWhenBothEmberOnerrorAndTestAdapterAreRegisteredAsyncRun(assert) {
      assert.expect(1);
      var done = assert.async();
      _test.default.adapter = {
        exception: function () {
          assert.notOk(true, 'Adapter.exception is not called for errors thrown in next');
        }
      };
      (0, _errorHandling.setOnerror)(function () {
        assert.ok(true, 'onerror is invoked for errors thrown in next/later');
      });
      runThatThrowsAsync();
      setTimeout(done, 10);
    };

    return _class;
  }(AdapterSetupAndTearDown));

  function testAdapter(message, generatePromise) {
    var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
    return (
      /*#__PURE__*/
      function (_AdapterSetupAndTearD2) {
        (0, _emberBabel.inheritsLoose)(PromiseFailureTests, _AdapterSetupAndTearD2);

        function PromiseFailureTests() {
          return _AdapterSetupAndTearD2.apply(this, arguments) || this;
        }

        var _proto3 = PromiseFailureTests.prototype;

        _proto3["@test " + message + " when TestAdapter without `exception` method is present - rsvp"] = function (assert) {
          assert.expect(1);
          var thrown = new Error('the error');
          _test.default.adapter = _qunit.default.create({
            exception: undefined
          });

          window.onerror = function (message) {
            assert.pushResult({
              result: /the error/.test(message),
              actual: message,
              expected: 'to include `the error`',
              message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
            }); // prevent "bubbling" and therefore failing the test

            return true;
          };

          generatePromise(thrown); // RSVP.Promise's are configured to settle within the run loop, this
          // ensures that run loop has completed

          return new _runtime.RSVP.Promise(function (resolve) {
            return setTimeout(resolve, timeout);
          });
        };

        _proto3["@test " + message + " when both Ember.onerror and TestAdapter without `exception` method are present - rsvp"] = function (assert) {
          assert.expect(1);
          var thrown = new Error('the error');
          _test.default.adapter = _qunit.default.create({
            exception: undefined
          });
          (0, _errorHandling.setOnerror)(function (error) {
            assert.pushResult({
              result: /the error/.test(error.message),
              actual: error.message,
              expected: 'to include `the error`',
              message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
            });
          });
          generatePromise(thrown); // RSVP.Promise's are configured to settle within the run loop, this
          // ensures that run loop has completed

          return new _runtime.RSVP.Promise(function (resolve) {
            return setTimeout(resolve, timeout);
          });
        };

        _proto3["@test " + message + " when TestAdapter is present - rsvp"] = function (assert) {
          assert.expect(1);

          console.error = function () {}; // eslint-disable-line no-console


          var thrown = new Error('the error');
          _test.default.adapter = _qunit.default.create({
            exception: function (error) {
              assert.strictEqual(error, thrown, 'Adapter.exception is called for errors thrown in RSVP promises');
            }
          });
          generatePromise(thrown); // RSVP.Promise's are configured to settle within the run loop, this
          // ensures that run loop has completed

          return new _runtime.RSVP.Promise(function (resolve) {
            return setTimeout(resolve, timeout);
          });
        };

        _proto3["@test " + message + " when both Ember.onerror and TestAdapter are present - rsvp"] = function (assert) {
          assert.expect(1);
          var thrown = new Error('the error');
          _test.default.adapter = _qunit.default.create({
            exception: function (error) {
              assert.strictEqual(error, thrown, 'Adapter.exception is called for errors thrown in RSVP promises');
            }
          });
          (0, _errorHandling.setOnerror)(function () {
            assert.notOk(true, 'Ember.onerror is not called if Test.adapter does not rethrow');
          });
          generatePromise(thrown); // RSVP.Promise's are configured to settle within the run loop, this
          // ensures that run loop has completed

          return new _runtime.RSVP.Promise(function (resolve) {
            return setTimeout(resolve, timeout);
          });
        };

        _proto3["@test " + message + " when both Ember.onerror and TestAdapter are present - rsvp"] = function (assert) {
          assert.expect(2);
          var thrown = new Error('the error');
          _test.default.adapter = _qunit.default.create({
            exception: function (error) {
              assert.strictEqual(error, thrown, 'Adapter.exception is called for errors thrown in RSVP promises');
              throw error;
            }
          });
          (0, _errorHandling.setOnerror)(function (error) {
            assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises if Test.adapter rethrows');
          });
          generatePromise(thrown); // RSVP.Promise's are configured to settle within the run loop, this
          // ensures that run loop has completed

          return new _runtime.RSVP.Promise(function (resolve) {
            return setTimeout(resolve, timeout);
          });
        };

        return PromiseFailureTests;
      }(AdapterSetupAndTearDown)
    );
  }

  (0, _internalTestHelpers.moduleFor)('Adapter Errors: .then callback', testAdapter('errors in promise constructor', function (error) {
    new _runtime.RSVP.Promise(function () {
      throw error;
    });
  }));
  (0, _internalTestHelpers.moduleFor)('Adapter Errors: Promise Contructor', testAdapter('errors in promise constructor', function (error) {
    _runtime.RSVP.resolve().then(function () {
      throw error;
    });
  }));
  (0, _internalTestHelpers.moduleFor)('Adapter Errors: Promise chain .then callback', testAdapter('errors in promise constructor', function (error) {
    new _runtime.RSVP.Promise(function (resolve) {
      return setTimeout(resolve, 10);
    }).then(function () {
      throw error;
    });
  }, 20));
});
enifed("ember-testing/tests/ext/rsvp_test", ["ember-babel", "ember-testing/lib/ext/rsvp", "ember-testing/lib/test/adapter", "ember-testing/lib/test/promise", "@ember/runloop", "@ember/debug", "internal-test-helpers"], function (_emberBabel, _rsvp, _adapter, _promise, _runloop, _debug, _internalTestHelpers) {
  "use strict";

  var originalTestAdapter = (0, _adapter.getAdapter)();
  var originalTestingFlag = (0, _debug.isTesting)();
  var asyncStarted = 0;
  var asyncEnded = 0;
  (0, _internalTestHelpers.moduleFor)('ember-testing RSVP',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      (0, _debug.setTesting)(true);
      (0, _adapter.setAdapter)({
        asyncStart: function () {
          asyncStarted++;
        },
        asyncEnd: function () {
          asyncEnded++;
        }
      });
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      asyncStarted = 0;
      asyncEnded = 0;
      (0, _adapter.setAdapter)(originalTestAdapter);
      (0, _debug.setTesting)(originalTestingFlag);
    };

    _proto['@test given `Ember.testing = true`, correctly informs the test suite about async steps'] = function testGivenEmberTestingTrueCorrectlyInformsTheTestSuiteAboutAsyncSteps(assert) {
      var done = assert.async();
      assert.expect(19);
      assert.ok(!(0, _runloop.getCurrentRunLoop)(), 'expect no run-loop');
      (0, _debug.setTesting)(true);
      assert.equal(asyncStarted, 0);
      assert.equal(asyncEnded, 0);

      var user = _rsvp.default.Promise.resolve({
        name: 'tomster'
      });

      assert.equal(asyncStarted, 0);
      assert.equal(asyncEnded, 0);
      user.then(function (user) {
        assert.equal(asyncStarted, 1);
        assert.equal(asyncEnded, 1);
        assert.equal(user.name, 'tomster');
        return _rsvp.default.Promise.resolve(1).then(function () {
          assert.equal(asyncStarted, 1);
          assert.equal(asyncEnded, 1);
        });
      }).then(function () {
        assert.equal(asyncStarted, 1);
        assert.equal(asyncEnded, 1);
        return new _rsvp.default.Promise(function (resolve) {
          setTimeout(function () {
            assert.equal(asyncStarted, 1);
            assert.equal(asyncEnded, 1);
            resolve({
              name: 'async tomster'
            });
            assert.equal(asyncStarted, 2);
            assert.equal(asyncEnded, 1);
          }, 0);
        });
      }).then(function (user) {
        assert.equal(user.name, 'async tomster');
        assert.equal(asyncStarted, 2);
        assert.equal(asyncEnded, 2);
        done();
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('TestPromise',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['does not throw error when falsy value passed to then'] = function doesNotThrowErrorWhenFalsyValuePassedToThen(assert) {
      assert.expect(1);
      return new _promise.default(function (resolve) {
        resolve();
      }).then(null).then(function () {
        assert.ok(true);
      });
    };

    _proto2['able to get last Promise'] = function ableToGetLastPromise(assert) {
      assert.expect(2);
      var p1 = new _promise.default(function (resolve) {
        resolve();
      }).then(function () {
        assert.ok(true);
      });
      var p2 = new _promise.default(function (resolve) {
        resolve();
      });
      assert.deepEqual((0, _promise.getLastPromise)(), p2);
      return p1;
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-testing/tests/helper_registration_test", ["ember-babel", "@ember/runloop", "ember-testing/lib/test", "@ember/application", "internal-test-helpers"], function (_emberBabel, _runloop, _test, _application, _internalTestHelpers) {
  "use strict";

  var App, appBooted, helperContainer;

  function registerHelper() {
    _test.default.registerHelper('boot', function (app) {
      (0, _runloop.run)(app, app.advanceReadiness);
      appBooted = true;
      return app.testHelpers.wait();
    });
  }

  function unregisterHelper() {
    _test.default.unregisterHelper('boot');
  }

  var originalAdapter = _test.default.adapter;

  function setupApp() {
    appBooted = false;
    helperContainer = {};
    (0, _runloop.run)(function () {
      App = _application.default.create();
      App.setupForTesting();
      App.injectTestHelpers(helperContainer);
    });
  }

  function destroyApp() {
    if (App) {
      (0, _runloop.run)(App, 'destroy');
      App = null;
      helperContainer = null;
    }
  }

  (0, _internalTestHelpers.moduleFor)('Test - registerHelper/unregisterHelper',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _test.default.adapter = originalAdapter;
      destroyApp();
    };

    _proto['@test Helper gets registered'] = function testHelperGetsRegistered(assert) {
      assert.expect(2);
      registerHelper();
      setupApp();
      assert.ok(App.testHelpers.boot);
      assert.ok(helperContainer.boot);
    };

    _proto['@test Helper is ran when called'] = function testHelperIsRanWhenCalled(assert) {
      var done = assert.async();
      assert.expect(1);
      registerHelper();
      setupApp();
      App.testHelpers.boot().then(function () {
        assert.ok(appBooted);
      }).finally(done);
    };

    _proto['@test Helper can be unregistered'] = function testHelperCanBeUnregistered(assert) {
      assert.expect(4);
      registerHelper();
      setupApp();
      assert.ok(App.testHelpers.boot);
      assert.ok(helperContainer.boot);
      unregisterHelper();
      (0, _runloop.run)(App, 'destroy');
      setupApp();
      assert.ok(!App.testHelpers.boot, 'once unregistered the helper is not added to App.testHelpers');
      assert.ok(!helperContainer.boot, 'once unregistered the helper is not added to the helperContainer');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-testing/tests/helpers_test", ["ember-babel", "internal-test-helpers", "@ember/-internals/routing", "@ember/controller", "@ember/-internals/runtime", "@ember/runloop", "@ember/-internals/glimmer", "@ember/-internals/views", "ember-testing/lib/test", "ember-testing/lib/setup_for_testing", "ember-testing/lib/test/pending_requests", "ember-testing/lib/test/adapter", "ember-testing/lib/test/waiters", "@ember/debug"], function (_emberBabel, _internalTestHelpers, _routing, _controller, _runtime, _runloop, _glimmer, _views, _test, _setup_for_testing, _pending_requests, _adapter, _waiters, _debug) {
  "use strict";

  var originalInfo = (0, _debug.getDebugFunction)('info');

  var noop = function () {};

  function registerHelper() {
    _test.default.registerHelper('LeakyMcLeakLeak', function () {});
  }

  function assertHelpers(assert, application, helperContainer, expected) {
    if (!helperContainer) {
      helperContainer = window;
    }

    if (expected === undefined) {
      expected = true;
    }

    function checkHelperPresent(helper, expected) {
      var presentInHelperContainer = Boolean(helperContainer[helper]);
      var presentInTestHelpers = Boolean(application.testHelpers[helper]);
      assert.ok(presentInHelperContainer === expected, "Expected '" + helper + "' to be present in the helper container (defaults to window).");
      assert.ok(presentInTestHelpers === expected, "Expected '" + helper + "' to be present in App.testHelpers.");
    }

    checkHelperPresent('visit', expected);
    checkHelperPresent('click', expected);
    checkHelperPresent('keyEvent', expected);
    checkHelperPresent('fillIn', expected);
    checkHelperPresent('wait', expected);
    checkHelperPresent('triggerEvent', expected);
  }

  function assertNoHelpers(assert, application, helperContainer) {
    assertHelpers(assert, application, helperContainer, false);
  }

  var HelpersTestCase =
  /*#__PURE__*/
  function (_AutobootApplicationT) {
    (0, _emberBabel.inheritsLoose)(HelpersTestCase, _AutobootApplicationT);

    function HelpersTestCase() {
      var _this;

      _this = _AutobootApplicationT.call(this) || this;
      _this._originalAdapter = (0, _adapter.getAdapter)();
      return _this;
    }

    var _proto = HelpersTestCase.prototype;

    _proto.teardown = function teardown() {
      (0, _adapter.setAdapter)(this._originalAdapter);
      document.removeEventListener('ajaxSend', _pending_requests.incrementPendingRequests);
      document.removeEventListener('ajaxComplete', _pending_requests.decrementPendingRequests);
      (0, _pending_requests.clearPendingRequests)();

      if (this.application) {
        this.application.removeTestHelpers();
      }

      _AutobootApplicationT.prototype.teardown.call(this);
    };

    return HelpersTestCase;
  }(_internalTestHelpers.AutobootApplicationTestCase);

  var HelpersApplicationTestCase =
  /*#__PURE__*/
  function (_HelpersTestCase) {
    (0, _emberBabel.inheritsLoose)(HelpersApplicationTestCase, _HelpersTestCase);

    function HelpersApplicationTestCase() {
      var _this2;

      _this2 = _HelpersTestCase.call(this) || this;
      (0, _internalTestHelpers.runTask)(function () {
        _this2.createApplication();

        _this2.application.setupForTesting();

        _this2.application.injectTestHelpers();
      });
      return _this2;
    }

    return HelpersApplicationTestCase;
  }(HelpersTestCase);

  if (!_views.jQueryDisabled) {
    (0, _internalTestHelpers.moduleFor)('ember-testing: Helper setup',
    /*#__PURE__*/
    function (_HelpersTestCase2) {
      (0, _emberBabel.inheritsLoose)(_class, _HelpersTestCase2);

      function _class() {
        return _HelpersTestCase2.apply(this, arguments) || this;
      }

      var _proto2 = _class.prototype;

      _proto2["@test Ember.Application#injectTestHelpers/#removeTestHelper"] = function (assert) {
        var _this3 = this;

        (0, _internalTestHelpers.runTask)(function () {
          _this3.createApplication();
        });
        assertNoHelpers(assert, this.application);
        registerHelper();
        this.application.injectTestHelpers();
        assertHelpers(assert, this.application);
        assert.ok(_test.default.Promise.prototype.LeakyMcLeakLeak, 'helper in question SHOULD be present');
        this.application.removeTestHelpers();
        assertNoHelpers(assert, this.application);
        assert.equal(_test.default.Promise.prototype.LeakyMcLeakLeak, undefined, 'should NOT leak test promise extensions');
      };

      _proto2["@test Ember.Application#setupForTesting"] = function (assert) {
        var _this4 = this;

        (0, _internalTestHelpers.runTask)(function () {
          _this4.createApplication();

          _this4.application.setupForTesting();
        });
        var routerInstance = this.applicationInstance.lookup('router:main');
        assert.equal(routerInstance.location, 'none');
      };

      _proto2["@test Ember.Application.setupForTesting sets the application to 'testing'"] = function (assert) {
        var _this5 = this;

        (0, _internalTestHelpers.runTask)(function () {
          _this5.createApplication();

          _this5.application.setupForTesting();
        });
        assert.equal(this.application.testing, true, 'Application instance is set to testing.');
      };

      _proto2["@test Ember.Application.setupForTesting leaves the system in a deferred state."] = function (assert) {
        var _this6 = this;

        (0, _internalTestHelpers.runTask)(function () {
          _this6.createApplication();

          _this6.application.setupForTesting();
        });
        assert.equal(this.application._readinessDeferrals, 1, 'App is in deferred state after setupForTesting.');
      };

      _proto2["@test App.reset() after Application.setupForTesting leaves the system in a deferred state."] = function (assert) {
        var _this7 = this;

        (0, _internalTestHelpers.runTask)(function () {
          _this7.createApplication();

          _this7.application.setupForTesting();
        });
        assert.equal(this.application._readinessDeferrals, 1, 'App is in deferred state after setupForTesting.');
        this.application.reset();
        assert.equal(this.application._readinessDeferrals, 1, 'App is in deferred state after setupForTesting.');
      };

      _proto2["@test Ember.Application#injectTestHelpers calls callbacks registered with onInjectHelpers"] = function (assert) {
        var injected = 0;

        _test.default.onInjectHelpers(function () {
          injected++;
        }); // bind(this) so Babel doesn't leak _this
        // into the context onInjectHelpers.


        (0, _internalTestHelpers.runTask)(function () {
          this.createApplication();
          this.application.setupForTesting();
        }.bind(this));
        assert.equal(injected, 0, 'onInjectHelpers are not called before injectTestHelpers');
        this.application.injectTestHelpers();
        assert.equal(injected, 1, 'onInjectHelpers are called after injectTestHelpers');
      };

      _proto2["@test Ember.Application#injectTestHelpers adds helpers to provided object."] = function (assert) {
        var _this8 = this;

        var helpers = {};
        (0, _internalTestHelpers.runTask)(function () {
          _this8.createApplication();

          _this8.application.setupForTesting();
        });
        this.application.injectTestHelpers(helpers);
        assertHelpers(assert, this.application, helpers);
        this.application.removeTestHelpers();
        assertNoHelpers(assert, this.application, helpers);
      };

      _proto2["@test Ember.Application#removeTestHelpers resets the helperContainer's original values"] = function (assert) {
        var _this9 = this;

        var helpers = {
          visit: 'snazzleflabber'
        };
        (0, _internalTestHelpers.runTask)(function () {
          _this9.createApplication();

          _this9.application.setupForTesting();
        });
        this.application.injectTestHelpers(helpers);
        assert.notEqual(helpers.visit, 'snazzleflabber', 'helper added to container');
        this.application.removeTestHelpers();
        assert.equal(helpers.visit, 'snazzleflabber', 'original value added back to container');
      };

      return _class;
    }(HelpersTestCase));
    (0, _internalTestHelpers.moduleFor)('ember-testing: Helper methods',
    /*#__PURE__*/
    function (_HelpersApplicationTe) {
      (0, _emberBabel.inheritsLoose)(_class2, _HelpersApplicationTe);

      function _class2() {
        return _HelpersApplicationTe.apply(this, arguments) || this;
      }

      var _proto3 = _class2.prototype;

      _proto3["@test 'wait' respects registerWaiters"] = function (assert) {
        var _this10 = this;

        assert.expect(3);
        var counter = 0;

        function waiter() {
          return ++counter > 2;
        }

        var other = 0;

        function otherWaiter() {
          return ++other > 2;
        }

        (0, _internalTestHelpers.runTask)(function () {
          _this10.application.advanceReadiness();
        });
        (0, _waiters.registerWaiter)(waiter);
        (0, _waiters.registerWaiter)(otherWaiter);
        var testHelpers = this.application.testHelpers;
        return testHelpers.wait().then(function () {
          assert.equal(waiter(), true, 'should not resolve until our waiter is ready');
          (0, _waiters.unregisterWaiter)(waiter);
          counter = 0;
          return testHelpers.wait();
        }).then(function () {
          assert.equal(counter, 0, 'unregistered waiter was not checked');
          assert.equal(otherWaiter(), true, 'other waiter is still registered');
        }).finally(function () {
          (0, _waiters.unregisterWaiter)(otherWaiter);
        });
      };

      _proto3["@test 'visit' advances readiness."] = function (assert) {
        var _this11 = this;

        assert.expect(2);
        assert.equal(this.application._readinessDeferrals, 1, 'App is in deferred state after setupForTesting.');
        return this.application.testHelpers.visit('/').then(function () {
          assert.equal(_this11.application._readinessDeferrals, 0, "App's readiness was advanced by visit.");
        });
      };

      _proto3["@test 'wait' helper can be passed a resolution value"] = function (assert) {
        var _this12 = this;

        assert.expect(4);
        (0, _internalTestHelpers.runTask)(function () {
          _this12.application.advanceReadiness();
        });
        var promiseObjectValue = {};
        var objectValue = {};
        var testHelpers = this.application.testHelpers;
        return testHelpers.wait('text').then(function (val) {
          assert.equal(val, 'text', 'can resolve to a string');
          return testHelpers.wait(1);
        }).then(function (val) {
          assert.equal(val, 1, 'can resolve to an integer');
          return testHelpers.wait(objectValue);
        }).then(function (val) {
          assert.equal(val, objectValue, 'can resolve to an object');
          return testHelpers.wait(_runtime.RSVP.resolve(promiseObjectValue));
        }).then(function (val) {
          assert.equal(val, promiseObjectValue, 'can resolve to a promise resolution value');
        });
      };

      _proto3["@test 'click' triggers appropriate events in order"] = function (assert) {
        var _this13 = this;

        assert.expect(5);
        this.add('component:index-wrapper', _glimmer.Component.extend({
          classNames: 'index-wrapper',
          didInsertElement: function () {
            var wrapper = document.querySelector('.index-wrapper');
            wrapper.addEventListener('mousedown', function (e) {
              return events.push(e.type);
            });
            wrapper.addEventListener('mouseup', function (e) {
              return events.push(e.type);
            });
            wrapper.addEventListener('click', function (e) {
              return events.push(e.type);
            });
            wrapper.addEventListener('focusin', function (e) {
              // IE11 _sometimes_ triggers focusin **twice** in a row
              // (we believe this is when it is under higher load)
              //
              // the goal here is to only push a single focusin when running on
              // IE11
              if (_internalTestHelpers.isIE11) {
                if (events[events.length - 1] !== 'focusin') {
                  events.push(e.type);
                }
              } else {
                events.push(e.type);
              }
            });
          }
        }));
        this.add('component:x-checkbox', _glimmer.Component.extend({
          tagName: 'input',
          attributeBindings: ['type'],
          type: 'checkbox',
          click: function () {
            events.push('click:' + this.get('checked'));
          },
          change: function () {
            events.push('change:' + this.get('checked'));
          }
        }));
        this.addTemplate('index', "\n        {{#index-wrapper}}\n          {{input type=\"text\"}}\n          {{x-checkbox type=\"checkbox\"}}\n          {{textarea}}\n          <div contenteditable=\"true\"> </div>\n        {{/index-wrapper}}'));\n      ");
        (0, _internalTestHelpers.runTask)(function () {
          _this13.application.advanceReadiness();
        });
        var events;
        var testHelpers = this.application.testHelpers;
        return testHelpers.wait().then(function () {
          events = [];
          return testHelpers.click('.index-wrapper');
        }).then(function () {
          assert.deepEqual(events, ['mousedown', 'mouseup', 'click'], 'fires events in order');
        }).then(function () {
          events = [];
          return testHelpers.click('.index-wrapper input[type=text]');
        }).then(function () {
          assert.deepEqual(events, ['mousedown', 'focusin', 'mouseup', 'click'], 'fires focus events on inputs');
        }).then(function () {
          events = [];
          return testHelpers.click('.index-wrapper textarea');
        }).then(function () {
          assert.deepEqual(events, ['mousedown', 'focusin', 'mouseup', 'click'], 'fires focus events on textareas');
        }).then(function () {
          events = [];
          return testHelpers.click('.index-wrapper div');
        }).then(function () {
          assert.deepEqual(events, ['mousedown', 'focusin', 'mouseup', 'click'], 'fires focus events on contenteditable');
        }).then(function () {
          events = [];
          return testHelpers.click('.index-wrapper input[type=checkbox]');
        }).then(function () {
          // i.e. mousedown, mouseup, change:true, click, click:true
          // Firefox differs so we can't assert the exact ordering here.
          // See https://bugzilla.mozilla.org/show_bug.cgi?id=843554.
          assert.equal(events.length, 5, 'fires click and change on checkboxes');
        });
      };

      _proto3["@test 'click' triggers native events with simulated X/Y coordinates"] = function (assert) {
        var _this14 = this;

        assert.expect(15);
        this.add('component:index-wrapper', _glimmer.Component.extend({
          classNames: 'index-wrapper',
          didInsertElement: function () {
            var pushEvent = function (e) {
              return events.push(e);
            };

            this.element.addEventListener('mousedown', pushEvent);
            this.element.addEventListener('mouseup', pushEvent);
            this.element.addEventListener('click', pushEvent);
          }
        }));
        this.addTemplate('index', "\n        {{#index-wrapper}}some text{{/index-wrapper}}\n      ");
        (0, _internalTestHelpers.runTask)(function () {
          _this14.application.advanceReadiness();
        });
        var events;
        var _this$application$tes = this.application.testHelpers,
            wait = _this$application$tes.wait,
            click = _this$application$tes.click;
        return wait().then(function () {
          events = [];
          return click('.index-wrapper');
        }).then(function () {
          events.forEach(function (e) {
            assert.ok(e instanceof window.Event, 'The event is an instance of MouseEvent');
            assert.ok(typeof e.screenX === 'number', 'screenX is correct');
            assert.ok(typeof e.screenY === 'number', 'screenY is correct');
            assert.ok(typeof e.clientX === 'number', 'clientX is correct');
            assert.ok(typeof e.clientY === 'number', 'clientY is correct');
          });
        });
      };

      _proto3["@test 'triggerEvent' with mouseenter triggers native events with simulated X/Y coordinates"] = function (assert) {
        var _this15 = this;

        assert.expect(5);
        var evt;
        this.add('component:index-wrapper', _glimmer.Component.extend({
          classNames: 'index-wrapper',
          didInsertElement: function () {
            this.element.addEventListener('mouseenter', function (e) {
              return evt = e;
            });
          }
        }));
        this.addTemplate('index', "{{#index-wrapper}}some text{{/index-wrapper}}");
        (0, _internalTestHelpers.runTask)(function () {
          _this15.application.advanceReadiness();
        });
        var _this$application$tes2 = this.application.testHelpers,
            wait = _this$application$tes2.wait,
            triggerEvent = _this$application$tes2.triggerEvent;
        return wait().then(function () {
          return triggerEvent('.index-wrapper', 'mouseenter');
        }).then(function () {
          assert.ok(evt instanceof window.Event, 'The event is an instance of MouseEvent');
          assert.ok(typeof evt.screenX === 'number', 'screenX is correct');
          assert.ok(typeof evt.screenY === 'number', 'screenY is correct');
          assert.ok(typeof evt.clientX === 'number', 'clientX is correct');
          assert.ok(typeof evt.clientY === 'number', 'clientY is correct');
        });
      };

      _proto3["@test 'wait' waits for outstanding timers"] = function (assert) {
        var _this16 = this;

        assert.expect(1);
        (0, _internalTestHelpers.runTask)(function () {
          _this16.application.advanceReadiness();
        });
        var waitDone = false;
        (0, _runloop.later)(function () {
          waitDone = true;
        }, 20);
        return this.application.testHelpers.wait().then(function () {
          assert.equal(waitDone, true, 'should wait for the timer to be fired.');
        });
      };

      _proto3["@test 'wait' respects registerWaiters with optional context"] = function (assert) {
        var _this17 = this;

        assert.expect(3);
        var obj = {
          counter: 0,
          ready: function () {
            return ++this.counter > 2;
          }
        };
        var other = 0;

        function otherWaiter() {
          return ++other > 2;
        }

        (0, _internalTestHelpers.runTask)(function () {
          _this17.application.advanceReadiness();
        });
        (0, _waiters.registerWaiter)(obj, obj.ready);
        (0, _waiters.registerWaiter)(otherWaiter);
        var wait = this.application.testHelpers.wait;
        return wait().then(function () {
          assert.equal(obj.ready(), true, 'should not resolve until our waiter is ready');
          (0, _waiters.unregisterWaiter)(obj, obj.ready);
          obj.counter = 0;
          return wait();
        }).then(function () {
          assert.equal(obj.counter, 0, 'the unregistered waiter should still be at 0');
          assert.equal(otherWaiter(), true, 'other waiter should still be registered');
        }).finally(function () {
          (0, _waiters.unregisterWaiter)(otherWaiter);
        });
      };

      _proto3["@test 'wait' does not error if routing has not begun"] = function (assert) {
        assert.expect(1);
        return this.application.testHelpers.wait().then(function () {
          assert.ok(true, 'should not error without `visit`');
        });
      };

      _proto3["@test 'triggerEvent' accepts an optional options hash without context"] = function (assert) {
        var _this18 = this;

        assert.expect(3);
        var event;
        this.add('component:index-wrapper', _glimmer.Component.extend({
          didInsertElement: function () {
            var domElem = document.querySelector('.input');
            domElem.addEventListener('change', function (e) {
              return event = e;
            });
            domElem.addEventListener('keydown', function (e) {
              return event = e;
            });
          }
        }));
        this.addTemplate('index', "{{index-wrapper}}");
        this.addTemplate('components/index-wrapper', "\n        {{input type=\"text\" id=\"scope\" class=\"input\"}}\n      ");
        (0, _internalTestHelpers.runTask)(function () {
          _this18.application.advanceReadiness();
        });
        var _this$application$tes3 = this.application.testHelpers,
            wait = _this$application$tes3.wait,
            triggerEvent = _this$application$tes3.triggerEvent;
        return wait().then(function () {
          return triggerEvent('.input', 'keydown', {
            keyCode: 13
          });
        }).then(function () {
          assert.equal(event.keyCode, 13, 'options were passed');
          assert.equal(event.type, 'keydown', 'correct event was triggered');
          assert.equal(event.target.getAttribute('id'), 'scope', 'triggered on the correct element');
        });
      };

      _proto3["@test 'triggerEvent' can limit searching for a selector to a scope"] = function (assert) {
        var _this19 = this;

        assert.expect(2);
        var event;
        this.add('component:index-wrapper', _glimmer.Component.extend({
          didInsertElement: function () {
            var firstInput = document.querySelector('.input');
            firstInput.addEventListener('blur', function (e) {
              return event = e;
            });
            firstInput.addEventListener('change', function (e) {
              return event = e;
            });
            var secondInput = document.querySelector('#limited .input');
            secondInput.addEventListener('blur', function (e) {
              return event = e;
            });
            secondInput.addEventListener('change', function (e) {
              return event = e;
            });
          }
        }));
        this.addTemplate('components/index-wrapper', "\n        {{input type=\"text\" id=\"outside-scope\" class=\"input\"}}\n        <div id=\"limited\">\n          {{input type=\"text\" id=\"inside-scope\" class=\"input\"}}\n        </div>\n      ");
        this.addTemplate('index', "{{index-wrapper}}");
        (0, _internalTestHelpers.runTask)(function () {
          _this19.application.advanceReadiness();
        });
        var _this$application$tes4 = this.application.testHelpers,
            wait = _this$application$tes4.wait,
            triggerEvent = _this$application$tes4.triggerEvent;
        return wait().then(function () {
          return triggerEvent('.input', '#limited', 'blur');
        }).then(function () {
          assert.equal(event.type, 'blur', 'correct event was triggered');
          assert.equal(event.target.getAttribute('id'), 'inside-scope', 'triggered on the correct element');
        });
      };

      _proto3["@test 'triggerEvent' can be used to trigger arbitrary events"] = function (assert) {
        var _this20 = this;

        assert.expect(2);
        var event;
        this.add('component:index-wrapper', _glimmer.Component.extend({
          didInsertElement: function () {
            var foo = document.getElementById('foo');
            foo.addEventListener('blur', function (e) {
              return event = e;
            });
            foo.addEventListener('change', function (e) {
              return event = e;
            });
          }
        }));
        this.addTemplate('components/index-wrapper', "\n        {{input type=\"text\" id=\"foo\"}}\n      ");
        this.addTemplate('index', "{{index-wrapper}}");
        (0, _internalTestHelpers.runTask)(function () {
          _this20.application.advanceReadiness();
        });
        var _this$application$tes5 = this.application.testHelpers,
            wait = _this$application$tes5.wait,
            triggerEvent = _this$application$tes5.triggerEvent;
        return wait().then(function () {
          return triggerEvent('#foo', 'blur');
        }).then(function () {
          assert.equal(event.type, 'blur', 'correct event was triggered');
          assert.equal(event.target.getAttribute('id'), 'foo', 'triggered on the correct element');
        });
      };

      _proto3["@test 'fillIn' takes context into consideration"] = function (assert) {
        var _this21 = this;

        assert.expect(2);
        this.addTemplate('index', "\n        <div id=\"parent\">\n          {{input type=\"text\" id=\"first\" class=\"current\"}}\n        </div>\n        {{input type=\"text\" id=\"second\" class=\"current\"}}\n      ");
        (0, _internalTestHelpers.runTask)(function () {
          _this21.application.advanceReadiness();
        });
        var _this$application$tes6 = this.application.testHelpers,
            visit = _this$application$tes6.visit,
            fillIn = _this$application$tes6.fillIn,
            andThen = _this$application$tes6.andThen,
            find = _this$application$tes6.find;
        visit('/');
        fillIn('.current', '#parent', 'current value');
        return andThen(function () {
          assert.equal(find('#first')[0].value, 'current value');
          assert.equal(find('#second')[0].value, '');
        });
      };

      _proto3["@test 'fillIn' focuses on the element"] = function (assert) {
        var _this22 = this;

        var wasFocused = false;
        this.add('controller:index', _controller.default.extend({
          actions: {
            wasFocused: function () {
              wasFocused = true;
            }
          }
        }));
        this.addTemplate('index', "\n        <div id=\"parent\">\n          {{input type=\"text\" id=\"first\" focus-in=(action \"wasFocused\")}}\n        </div>'\n      ");
        (0, _internalTestHelpers.runTask)(function () {
          _this22.application.advanceReadiness();
        });
        var _this$application$tes7 = this.application.testHelpers,
            visit = _this$application$tes7.visit,
            fillIn = _this$application$tes7.fillIn,
            andThen = _this$application$tes7.andThen,
            find = _this$application$tes7.find,
            wait = _this$application$tes7.wait;
        visit('/');
        fillIn('#first', 'current value');
        andThen(function () {
          assert.ok(wasFocused, 'focusIn event was triggered');
          assert.equal(find('#first')[0].value, 'current value');
        });
        return wait();
      };

      _proto3["@test 'fillIn' fires 'input' and 'change' events in the proper order"] = function (assert) {
        var _this23 = this;

        assert.expect(1);
        var events = [];
        this.add('controller:index', _controller.default.extend({
          actions: {
            oninputHandler: function (e) {
              events.push(e.type);
            },
            onchangeHandler: function (e) {
              events.push(e.type);
            }
          }
        }));
        this.addTemplate('index', "\n        <input type=\"text\" id=\"first\"\n            oninput={{action \"oninputHandler\"}}\n            onchange={{action \"onchangeHandler\"}}>\n      ");
        (0, _internalTestHelpers.runTask)(function () {
          _this23.application.advanceReadiness();
        });
        var _this$application$tes8 = this.application.testHelpers,
            visit = _this$application$tes8.visit,
            fillIn = _this$application$tes8.fillIn,
            andThen = _this$application$tes8.andThen,
            wait = _this$application$tes8.wait;
        visit('/');
        fillIn('#first', 'current value');
        andThen(function () {
          assert.deepEqual(events, ['input', 'change'], '`input` and `change` events are fired in the proper order');
        });
        return wait();
      };

      _proto3["@test 'fillIn' only sets the value in the first matched element"] = function (assert) {
        var _this24 = this;

        this.addTemplate('index', "\n        <input type=\"text\" id=\"first\" class=\"in-test\">\n        <input type=\"text\" id=\"second\" class=\"in-test\">\n      ");
        (0, _internalTestHelpers.runTask)(function () {
          _this24.application.advanceReadiness();
        });
        var _this$application$tes9 = this.application.testHelpers,
            visit = _this$application$tes9.visit,
            fillIn = _this$application$tes9.fillIn,
            find = _this$application$tes9.find,
            andThen = _this$application$tes9.andThen,
            wait = _this$application$tes9.wait;
        visit('/');
        fillIn('input.in-test', 'new value');
        andThen(function () {
          assert.equal(find('#first')[0].value, 'new value');
          assert.equal(find('#second')[0].value, '');
        });
        return wait();
      };

      _proto3["@test 'triggerEvent' accepts an optional options hash and context"] = function (assert) {
        var _this25 = this;

        assert.expect(3);
        var event;
        this.add('component:index-wrapper', _glimmer.Component.extend({
          didInsertElement: function () {
            var firstInput = document.querySelector('.input');
            firstInput.addEventListener('keydown', function (e) {
              return event = e;
            }, false);
            firstInput.addEventListener('change', function (e) {
              return event = e;
            }, false);
            var secondInput = document.querySelector('#limited .input');
            secondInput.addEventListener('keydown', function (e) {
              return event = e;
            }, false);
            secondInput.addEventListener('change', function (e) {
              return event = e;
            }, false);
          }
        }));
        this.addTemplate('components/index-wrapper', "\n        {{input type=\"text\" id=\"outside-scope\" class=\"input\"}}\n        <div id=\"limited\">\n          {{input type=\"text\" id=\"inside-scope\" class=\"input\"}}\n        </div>\n      ");
        this.addTemplate('index', "{{index-wrapper}}");
        (0, _internalTestHelpers.runTask)(function () {
          _this25.application.advanceReadiness();
        });
        var _this$application$tes10 = this.application.testHelpers,
            wait = _this$application$tes10.wait,
            triggerEvent = _this$application$tes10.triggerEvent;
        return wait().then(function () {
          return triggerEvent('.input', '#limited', 'keydown', {
            keyCode: 13
          });
        }).then(function () {
          assert.equal(event.keyCode, 13, 'options were passed');
          assert.equal(event.type, 'keydown', 'correct event was triggered');
          assert.equal(event.target.getAttribute('id'), 'inside-scope', 'triggered on the correct element');
        });
      };

      return _class2;
    }(HelpersApplicationTestCase));
    (0, _internalTestHelpers.moduleFor)('ember-testing: debugging helpers',
    /*#__PURE__*/
    function (_HelpersApplicationTe2) {
      (0, _emberBabel.inheritsLoose)(_class3, _HelpersApplicationTe2);
      var _proto4 = _class3.prototype;

      _proto4.afterEach = function afterEach() {
        _HelpersApplicationTe2.prototype.afterEach.call(this);

        (0, _debug.setDebugFunction)('info', originalInfo);
      };

      function _class3() {
        var _this26;

        _this26 = _HelpersApplicationTe2.call(this) || this;
        (0, _internalTestHelpers.runTask)(function () {
          _this26.application.advanceReadiness();
        });
        return _this26;
      }

      _proto4["@test pauseTest pauses"] = function (assert) {
        assert.expect(1); // overwrite info to supress the console output (see https://github.com/emberjs/ember.js/issues/16391)

        (0, _debug.setDebugFunction)('info', noop);
        var _this$application$tes11 = this.application.testHelpers,
            andThen = _this$application$tes11.andThen,
            pauseTest = _this$application$tes11.pauseTest;
        andThen(function () {
          _test.default.adapter.asyncStart = function () {
            assert.ok(true, 'Async start should be called after waiting for other helpers');
          };
        });
        pauseTest();
      };

      _proto4["@test resumeTest resumes paused tests"] = function (assert) {
        assert.expect(1); // overwrite info to supress the console output (see https://github.com/emberjs/ember.js/issues/16391)

        (0, _debug.setDebugFunction)('info', noop);
        var _this$application$tes12 = this.application.testHelpers,
            pauseTest = _this$application$tes12.pauseTest,
            resumeTest = _this$application$tes12.resumeTest;
        (0, _runloop.later)(function () {
          return resumeTest();
        }, 20);
        return pauseTest().then(function () {
          assert.ok(true, 'pauseTest promise was resolved');
        });
      };

      _proto4["@test resumeTest throws if nothing to resume"] = function (assert) {
        var _this27 = this;

        assert.expect(1);
        assert.throws(function () {
          _this27.application.testHelpers.resumeTest();
        }, /Testing has not been paused. There is nothing to resume./);
      };

      return _class3;
    }(HelpersApplicationTestCase));
    (0, _internalTestHelpers.moduleFor)('ember-testing: routing helpers',
    /*#__PURE__*/
    function (_HelpersTestCase3) {
      (0, _emberBabel.inheritsLoose)(_class4, _HelpersTestCase3);

      function _class4() {
        var _this28;

        _this28 = _HelpersTestCase3.call(this) || this;
        (0, _internalTestHelpers.runTask)(function () {
          _this28.createApplication();

          _this28.application.setupForTesting();

          _this28.application.injectTestHelpers();

          _this28.router.map(function () {
            this.route('posts', {
              resetNamespace: true
            }, function () {
              this.route('new');
              this.route('edit', {
                resetNamespace: true
              });
            });
          });
        });
        (0, _internalTestHelpers.runTask)(function () {
          _this28.application.advanceReadiness();
        });
        return _this28;
      }

      var _proto5 = _class4.prototype;

      _proto5["@test currentRouteName for '/'"] = function (assert) {
        assert.expect(3);
        var testHelpers = this.application.testHelpers;
        return testHelpers.visit('/').then(function () {
          assert.equal(testHelpers.currentRouteName(), 'index', "should equal 'index'.");
          assert.equal(testHelpers.currentPath(), 'index', "should equal 'index'.");
          assert.equal(testHelpers.currentURL(), '/', "should equal '/'.");
        });
      };

      _proto5["@test currentRouteName for '/posts'"] = function (assert) {
        assert.expect(3);
        var testHelpers = this.application.testHelpers;
        return testHelpers.visit('/posts').then(function () {
          assert.equal(testHelpers.currentRouteName(), 'posts.index', "should equal 'posts.index'.");
          assert.equal(testHelpers.currentPath(), 'posts.index', "should equal 'posts.index'.");
          assert.equal(testHelpers.currentURL(), '/posts', "should equal '/posts'.");
        });
      };

      _proto5["@test currentRouteName for '/posts/new'"] = function (assert) {
        assert.expect(3);
        var testHelpers = this.application.testHelpers;
        return testHelpers.visit('/posts/new').then(function () {
          assert.equal(testHelpers.currentRouteName(), 'posts.new', "should equal 'posts.new'.");
          assert.equal(testHelpers.currentPath(), 'posts.new', "should equal 'posts.new'.");
          assert.equal(testHelpers.currentURL(), '/posts/new', "should equal '/posts/new'.");
        });
      };

      _proto5["@test currentRouteName for '/posts/edit'"] = function (assert) {
        assert.expect(3);
        var testHelpers = this.application.testHelpers;
        return testHelpers.visit('/posts/edit').then(function () {
          assert.equal(testHelpers.currentRouteName(), 'edit', "should equal 'edit'.");
          assert.equal(testHelpers.currentPath(), 'posts.edit', "should equal 'posts.edit'.");
          assert.equal(testHelpers.currentURL(), '/posts/edit', "should equal '/posts/edit'.");
        });
      };

      return _class4;
    }(HelpersTestCase));
    (0, _internalTestHelpers.moduleFor)('ember-testing: pendingRequests',
    /*#__PURE__*/
    function (_HelpersApplicationTe3) {
      (0, _emberBabel.inheritsLoose)(_class5, _HelpersApplicationTe3);

      function _class5() {
        return _HelpersApplicationTe3.apply(this, arguments) || this;
      }

      var _proto6 = _class5.prototype;

      _proto6.trigger = function trigger(type, xhr) {
        (0, _views.jQuery)(document).trigger(type, xhr);
      };

      _proto6["@test pendingRequests is maintained for ajaxSend and ajaxComplete events"] = function (assert) {
        var done = assert.async();
        assert.equal((0, _pending_requests.pendingRequests)(), 0);
        var xhr = {
          some: 'xhr'
        };
        this.trigger('ajaxSend', xhr);
        assert.equal((0, _pending_requests.pendingRequests)(), 1, 'Ember.Test.pendingRequests was incremented');
        this.trigger('ajaxComplete', xhr);
        setTimeout(function () {
          assert.equal((0, _pending_requests.pendingRequests)(), 0, 'Ember.Test.pendingRequests was decremented');
          done();
        }, 0);
      };

      _proto6["@test pendingRequests is ignores ajaxComplete events from past setupForTesting calls"] = function (assert) {
        assert.equal((0, _pending_requests.pendingRequests)(), 0);
        var xhr = {
          some: 'xhr'
        };
        this.trigger('ajaxSend', xhr);
        assert.equal((0, _pending_requests.pendingRequests)(), 1, 'Ember.Test.pendingRequests was incremented');
        (0, _setup_for_testing.default)();
        assert.equal((0, _pending_requests.pendingRequests)(), 0, 'Ember.Test.pendingRequests was reset');
        var altXhr = {
          some: 'more xhr'
        };
        this.trigger('ajaxSend', altXhr);
        assert.equal((0, _pending_requests.pendingRequests)(), 1, 'Ember.Test.pendingRequests was incremented');
        this.trigger('ajaxComplete', xhr);
        assert.equal((0, _pending_requests.pendingRequests)(), 1, 'Ember.Test.pendingRequests is not impressed with your unexpected complete');
      };

      _proto6["@test pendingRequests is reset by setupForTesting"] = function (assert) {
        (0, _pending_requests.incrementPendingRequests)();
        (0, _setup_for_testing.default)();
        assert.equal((0, _pending_requests.pendingRequests)(), 0, 'pendingRequests is reset');
      };

      return _class5;
    }(HelpersApplicationTestCase));
    (0, _internalTestHelpers.moduleFor)('ember-testing: async router',
    /*#__PURE__*/
    function (_HelpersTestCase4) {
      (0, _emberBabel.inheritsLoose)(_class6, _HelpersTestCase4);

      function _class6() {
        var _this29;

        _this29 = _HelpersTestCase4.call(this) || this;
        (0, _internalTestHelpers.runTask)(function () {
          _this29.createApplication();

          _this29.router.map(function () {
            this.route('user', {
              resetNamespace: true
            }, function () {
              this.route('profile');
              this.route('edit');
            });
          }); // Emulate a long-running unscheduled async operation.


          var resolveLater = function () {
            return new _runtime.RSVP.Promise(function (resolve) {
              /*
               * The wait() helper has a 10ms tick. We should resolve() after
               * at least one tick to test whether wait() held off while the
               * async router was still loading. 20ms should be enough.
               */
              (0, _runloop.later)(resolve, {
                firstName: 'Tom'
              }, 20);
            });
          };

          _this29.add('route:user', _routing.Route.extend({
            model: function () {
              return resolveLater();
            }
          }));

          _this29.add('route:user.profile', _routing.Route.extend({
            beforeModel: function () {
              var _this30 = this;

              return resolveLater().then(function () {
                return _this30.transitionTo('user.edit');
              });
            }
          }));

          _this29.application.setupForTesting();
        });

        _this29.application.injectTestHelpers();

        (0, _internalTestHelpers.runTask)(function () {
          _this29.application.advanceReadiness();
        });
        return _this29;
      }

      var _proto7 = _class6.prototype;

      _proto7["@test currentRouteName for '/user'"] = function (assert) {
        var _this31 = this;

        assert.expect(4);
        var testHelpers = this.application.testHelpers;
        return testHelpers.visit('/user').then(function () {
          assert.equal(testHelpers.currentRouteName(), 'user.index', "should equal 'user.index'.");
          assert.equal(testHelpers.currentPath(), 'user.index', "should equal 'user.index'.");
          assert.equal(testHelpers.currentURL(), '/user', "should equal '/user'.");

          var userRoute = _this31.applicationInstance.lookup('route:user');

          assert.equal(userRoute.get('controller.model.firstName'), 'Tom', "should equal 'Tom'.");
        });
      };

      _proto7["@test currentRouteName for '/user/profile'"] = function (assert) {
        var _this32 = this;

        assert.expect(4);
        var testHelpers = this.application.testHelpers;
        return testHelpers.visit('/user/profile').then(function () {
          assert.equal(testHelpers.currentRouteName(), 'user.edit', "should equal 'user.edit'.");
          assert.equal(testHelpers.currentPath(), 'user.edit', "should equal 'user.edit'.");
          assert.equal(testHelpers.currentURL(), '/user/edit', "should equal '/user/edit'.");

          var userRoute = _this32.applicationInstance.lookup('route:user');

          assert.equal(userRoute.get('controller.model.firstName'), 'Tom', "should equal 'Tom'.");
        });
      };

      return _class6;
    }(HelpersTestCase));
    (0, _internalTestHelpers.moduleFor)('ember-testing: can override built-in helpers',
    /*#__PURE__*/
    function (_HelpersTestCase5) {
      (0, _emberBabel.inheritsLoose)(_class7, _HelpersTestCase5);

      function _class7() {
        var _this33;

        _this33 = _HelpersTestCase5.call(this) || this;
        (0, _internalTestHelpers.runTask)(function () {
          _this33.createApplication();

          _this33.application.setupForTesting();
        });
        _this33._originalVisitHelper = _test.default._helpers.visit;
        _this33._originalFindHelper = _test.default._helpers.find;
        return _this33;
      }

      var _proto8 = _class7.prototype;

      _proto8.teardown = function teardown() {
        _test.default._helpers.visit = this._originalVisitHelper;
        _test.default._helpers.find = this._originalFindHelper;

        _HelpersTestCase5.prototype.teardown.call(this);
      };

      _proto8["@test can override visit helper"] = function (assert) {
        assert.expect(1);

        _test.default.registerHelper('visit', function () {
          assert.ok(true, 'custom visit helper was called');
        });

        this.application.injectTestHelpers();
        return this.application.testHelpers.visit();
      };

      _proto8["@test can override find helper"] = function (assert) {
        assert.expect(1);

        _test.default.registerHelper('find', function () {
          assert.ok(true, 'custom find helper was called');
          return ['not empty array'];
        });

        this.application.injectTestHelpers();
        return this.application.testHelpers.findWithAssert('.who-cares');
      };

      return _class7;
    }(HelpersTestCase));
  }
});
enifed("ember-testing/tests/integration_test", ["ember-babel", "internal-test-helpers", "ember-testing/lib/test", "@ember/-internals/runtime", "@ember/-internals/routing", "@ember/-internals/views"], function (_emberBabel, _internalTestHelpers, _test, _runtime, _routing, _views) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-testing Integration tests of acceptance',
  /*#__PURE__*/
  function (_AutobootApplicationT) {
    (0, _emberBabel.inheritsLoose)(_class, _AutobootApplicationT);

    function _class() {
      var _this;

      _this = _AutobootApplicationT.call(this) || this;
      _this.modelContent = [];
      _this._originalAdapter = _test.default.adapter;
      (0, _internalTestHelpers.runTask)(function () {
        _this.createApplication();

        _this.addTemplate('people', "\n        <div>\n          {{#each model as |person|}}\n            <div class=\"name\">{{person.firstName}}</div>\n          {{/each}}\n        </div>\n      ");

        _this.router.map(function () {
          this.route('people', {
            path: '/'
          });
        });

        _this.add('route:people', _routing.Route.extend({
          model: function () {
            return _this.modelContent;
          }
        }));

        _this.application.setupForTesting();
      });
      (0, _internalTestHelpers.runTask)(function () {
        _this.application.reset();
      });

      _this.application.injectTestHelpers();

      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _AutobootApplicationT.prototype.teardown.call(this);

      _test.default.adapter = this._originalAdapter;
    };

    _proto["@test template is bound to empty array of people"] = function (assert) {
      var _this2 = this;

      if (!_views.jQueryDisabled) {
        (0, _internalTestHelpers.runTask)(function () {
          return _this2.application.advanceReadiness();
        });
        window.visit('/').then(function () {
          var rows = window.find('.name').length;
          assert.equal(rows, 0, 'successfully stubbed an empty array of people');
        });
      } else {
        (0, _internalTestHelpers.runTask)(function () {
          return _this2.application.advanceReadiness();
        });
        window.visit('/').then(function () {
          expectAssertion(function () {
            return window.find('.name');
          }, 'If jQuery is disabled, please import and use helpers from @ember/test-helpers [https://github.com/emberjs/ember-test-helpers]. Note: `find` is not an available helper.');
        });
      }
    };

    _proto["@test template is bound to array of 2 people"] = function (assert) {
      var _this3 = this;

      if (!_views.jQueryDisabled) {
        this.modelContent = (0, _runtime.A)([]);
        this.modelContent.pushObject({
          firstName: 'x'
        });
        this.modelContent.pushObject({
          firstName: 'y'
        });
        (0, _internalTestHelpers.runTask)(function () {
          return _this3.application.advanceReadiness();
        });
        window.visit('/').then(function () {
          var rows = window.find('.name').length;
          assert.equal(rows, 2, 'successfully stubbed a non empty array of people');
        });
      } else {
        assert.expect(0);
      }
    };

    _proto["@test 'visit' can be called without advanceReadiness."] = function (assert) {
      if (!_views.jQueryDisabled) {
        window.visit('/').then(function () {
          var rows = window.find('.name').length;
          assert.equal(rows, 0, 'stubbed an empty array of people without calling advanceReadiness.');
        });
      } else {
        assert.expect(0);
      }
    };

    return _class;
  }(_internalTestHelpers.AutobootApplicationTestCase));
});
enifed("ember-testing/tests/reexports_test", ["ember-babel", "ember", "internal-test-helpers"], function (_emberBabel, _ember, _internalTestHelpers) {
  "use strict";

  var ReexportsTestCase =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(ReexportsTestCase, _AbstractTestCase);

    function ReexportsTestCase() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    return ReexportsTestCase;
  }(_internalTestHelpers.AbstractTestCase);

  [// ember-testing
  ['Test', 'ember-testing'], ['Test.Adapter', 'ember-testing', 'Adapter'], ['Test.QUnitAdapter', 'ember-testing', 'QUnitAdapter'], ['setupForTesting', 'ember-testing']].forEach(function (reexport) {
    var path = reexport[0],
        moduleId = reexport[1],
        exportName = reexport[2]; // default path === exportName if none present

    if (!exportName) {
      exportName = path;
    }

    ReexportsTestCase.prototype["@test Ember." + path + " exports correctly"] = function (assert) {
      (0, _internalTestHelpers.confirmExport)(_ember.default, assert, path, moduleId, exportName);
    };
  });
  (0, _internalTestHelpers.moduleFor)('ember-testing reexports', ReexportsTestCase);
});
enifed("ember-testing/tests/test/waiters-test", ["ember-babel", "ember-testing/lib/test/waiters", "internal-test-helpers"], function (_emberBabel, _waiters, _internalTestHelpers) {
  "use strict";

  var Waiters =
  /*#__PURE__*/
  function () {
    function Waiters() {
      this._waiters = [];
    }

    var _proto = Waiters.prototype;

    _proto.add = function add() {
      this._waiters.push(Array.prototype.slice.call(arguments));
    };

    _proto.register = function register() {
      this.forEach(function () {
        _waiters.registerWaiter.apply(void 0, arguments);
      });
    };

    _proto.unregister = function unregister() {
      this.forEach(function () {
        _waiters.unregisterWaiter.apply(void 0, arguments);
      });
    };

    _proto.forEach = function forEach(callback) {
      for (var i = 0; i < this._waiters.length; i++) {
        var args = this._waiters[i];
        callback.apply(void 0, args);
      }
    };

    _proto.check = function check() {
      this.register();
      var result = (0, _waiters.checkWaiters)();
      this.unregister();
      return result;
    };

    return Waiters;
  }();

  (0, _internalTestHelpers.moduleFor)('ember-testing: waiters',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      _this.waiters = new Waiters();
      return _this;
    }

    var _proto2 = _class.prototype;

    _proto2.teardown = function teardown() {
      this.waiters.unregister();
    };

    _proto2['@test registering a waiter'] = function testRegisteringAWaiter(assert) {
      assert.expect(2);
      var obj = {
        foo: true
      };
      this.waiters.add(obj, function () {
        assert.ok(this.foo, 'has proper `this` context');
        return true;
      });
      this.waiters.add(function () {
        assert.ok(true, 'is called');
        return true;
      });
      this.waiters.check();
    };

    _proto2['@test unregistering a waiter'] = function testUnregisteringAWaiter(assert) {
      assert.expect(2);
      var obj = {
        foo: true
      };
      this.waiters.add(obj, function () {
        assert.ok(true, 'precond - waiter with context is registered');
        return true;
      });
      this.waiters.add(function () {
        assert.ok(true, 'precond - waiter without context is registered');
        return true;
      });
      this.waiters.check();
      this.waiters.unregister();
      (0, _waiters.checkWaiters)();
    };

    _proto2['@test checkWaiters returns false if all waiters return true'] = function testCheckWaitersReturnsFalseIfAllWaitersReturnTrue(assert) {
      assert.expect(3);
      this.waiters.add(function () {
        assert.ok(true, 'precond - waiter is registered');
        return true;
      });
      this.waiters.add(function () {
        assert.ok(true, 'precond - waiter is registered');
        return true;
      });
      assert.notOk(this.waiters.check(), 'checkWaiters returns true if all waiters return true');
    };

    _proto2['@test checkWaiters returns true if any waiters return false'] = function testCheckWaitersReturnsTrueIfAnyWaitersReturnFalse(assert) {
      assert.expect(3);
      this.waiters.add(function () {
        assert.ok(true, 'precond - waiter is registered');
        return true;
      });
      this.waiters.add(function () {
        assert.ok(true, 'precond - waiter is registered');
        return false;
      });
      assert.ok(this.waiters.check(), 'checkWaiters returns false if any waiters return false');
    };

    _proto2['@test checkWaiters short circuits after first falsey waiter'] = function testCheckWaitersShortCircuitsAfterFirstFalseyWaiter(assert) {
      assert.expect(2);
      this.waiters.add(function () {
        assert.ok(true, 'precond - waiter is registered');
        return false;
      });
      this.waiters.add(function () {
        assert.notOk(true, 'waiter should not be called');
      });
      assert.ok(this.waiters.check(), 'checkWaiters returns false if any waiters return false');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember/tests/application_lifecycle_test", ["ember-babel", "internal-test-helpers", "@ember/application", "@ember/-internals/routing", "@ember/-internals/glimmer", "@ember/debug"], function (_emberBabel, _internalTestHelpers, _application, _routing, _glimmer, _debug) {
  "use strict";

  var originalDebug = (0, _debug.getDebugFunction)('debug');

  var noop = function () {};

  (0, _internalTestHelpers.moduleFor)('Application Lifecycle - route hooks',
  /*#__PURE__*/
  function (_AutobootApplicationT) {
    (0, _emberBabel.inheritsLoose)(_class, _AutobootApplicationT);
    var _proto = _class.prototype;

    _proto.createApplication = function createApplication() {
      var application = _AutobootApplicationT.prototype.createApplication.apply(this, arguments);

      this.add('router:main', _routing.Router.extend({
        location: 'none'
      }));
      return application;
    };

    function _class() {
      var _this;

      (0, _debug.setDebugFunction)('debug', noop);
      _this = _AutobootApplicationT.call(this) || this;
      var menuItem = _this.menuItem = {};
      (0, _internalTestHelpers.runTask)(function () {
        _this.createApplication();

        var SettingRoute = _routing.Route.extend({
          setupController: function () {
            this.controller.set('selectedMenuItem', menuItem);
          },
          deactivate: function () {
            this.controller.set('selectedMenuItem', null);
          }
        });

        _this.add('route:index', SettingRoute);

        _this.add('route:application', SettingRoute);
      });
      return _this;
    }

    _proto.teardown = function teardown() {
      (0, _debug.setDebugFunction)('debug', originalDebug);
    };

    _proto["@test Resetting the application allows controller properties to be set when a route deactivates"] = function (assert) {
      var indexController = this.indexController,
          applicationController = this.applicationController;
      assert.equal(indexController.get('selectedMenuItem'), this.menuItem);
      assert.equal(applicationController.get('selectedMenuItem'), this.menuItem);
      this.application.reset();
      assert.equal(indexController.get('selectedMenuItem'), null);
      assert.equal(applicationController.get('selectedMenuItem'), null);
    };

    _proto["@test Destroying the application resets the router before the appInstance is destroyed"] = function (assert) {
      var _this2 = this;

      var indexController = this.indexController,
          applicationController = this.applicationController;
      assert.equal(indexController.get('selectedMenuItem'), this.menuItem);
      assert.equal(applicationController.get('selectedMenuItem'), this.menuItem);
      (0, _internalTestHelpers.runTask)(function () {
        _this2.application.destroy();
      });
      assert.equal(indexController.get('selectedMenuItem'), null);
      assert.equal(applicationController.get('selectedMenuItem'), null);
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "indexController",
      get: function () {
        return this.applicationInstance.lookup('controller:index');
      }
    }, {
      key: "applicationController",
      get: function () {
        return this.applicationInstance.lookup('controller:application');
      }
    }]);
    return _class;
  }(_internalTestHelpers.AutobootApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application Lifecycle',
  /*#__PURE__*/
  function (_AutobootApplicationT2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AutobootApplicationT2);

    function _class2() {
      return _AutobootApplicationT2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2.createApplication = function createApplication() {
      var application = _AutobootApplicationT2.prototype.createApplication.apply(this, arguments);

      this.add('router:main', _routing.Router.extend({
        location: 'none'
      }));
      return application;
    };

    _proto2["@test Destroying a route after the router does create an undestroyed 'toplevelView'"] = function (assert) {
      var _this3 = this;

      (0, _internalTestHelpers.runTask)(function () {
        _this3.createApplication();

        _this3.addTemplate('index', "Index!");

        _this3.addTemplate('application', "Application! {{outlet}}");
      });
      var router = this.applicationInstance.lookup('router:main');
      var route = this.applicationInstance.lookup('route:index');
      (0, _internalTestHelpers.runTask)(function () {
        return router.destroy();
      });
      assert.equal(router._toplevelView, null, 'the toplevelView was cleared');
      (0, _internalTestHelpers.runTask)(function () {
        return route.destroy();
      });
      assert.equal(router._toplevelView, null, 'the toplevelView was not reinitialized');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.application.destroy();
      });
      assert.equal(router._toplevelView, null, 'the toplevelView was not reinitialized');
    };

    _proto2["@test initializers can augment an applications customEvents hash"] = function (assert) {
      var _this4 = this;

      assert.expect(1);

      var MyApplication = _application.default.extend();

      MyApplication.initializer({
        name: 'customize-things',
        initialize: function (application) {
          application.customEvents = {
            wowza: 'wowza'
          };
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        _this4.createApplication({}, MyApplication);

        _this4.add('component:foo-bar', _glimmer.Component.extend({
          wowza: function () {
            assert.ok(true, 'fired the event!');
          }
        }));

        _this4.addTemplate('application', "{{foo-bar}}");

        _this4.addTemplate('components/foo-bar', "<div id='wowza-thingy'></div>");
      });
      this.$('#wowza-thingy').trigger('wowza');
    };

    _proto2["@test instanceInitializers can augment an the customEvents hash"] = function (assert) {
      var _this5 = this;

      assert.expect(1);

      var MyApplication = _application.default.extend();

      MyApplication.instanceInitializer({
        name: 'customize-things',
        initialize: function (application) {
          application.customEvents = {
            herky: 'jerky'
          };
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        _this5.createApplication({}, MyApplication);

        _this5.add('component:foo-bar', _glimmer.Component.extend({
          jerky: function () {
            assert.ok(true, 'fired the event!');
          }
        }));

        _this5.addTemplate('application', "{{foo-bar}}");

        _this5.addTemplate('components/foo-bar', "<div id='herky-thingy'></div>");
      });
      this.$('#herky-thingy').trigger('herky');
    };

    return _class2;
  }(_internalTestHelpers.AutobootApplicationTestCase));
});
enifed("ember/tests/component_context_test", ["ember-babel", "@ember/controller", "@ember/-internals/glimmer", "internal-test-helpers"], function (_emberBabel, _controller, _glimmer, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application Lifecycle - Component Context',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Components with a block should have the proper content when a template is provided'] = function testComponentsWithABlockShouldHaveTheProperContentWhenATemplateIsProvided(assert) {
      var _this = this;

      this.addTemplate('application', "\n      <div id='wrapper'>\n        {{#my-component}}{{text}}{{/my-component}}\n      </div>\n    ");
      this.add('controller:application', _controller.default.extend({
        text: 'outer'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          text: 'inner'
        }),
        template: "{{text}}-{{yield}}"
      });
      return this.visit('/').then(function () {
        var text = (0, _internalTestHelpers.getTextOf)(_this.element.querySelector('#wrapper'));
        assert.equal(text, 'inner-outer', 'The component is composed correctly');
      });
    };

    _proto['@test Components with a block should yield the proper content without a template provided'] = function testComponentsWithABlockShouldYieldTheProperContentWithoutATemplateProvided(assert) {
      var _this2 = this;

      this.addTemplate('application', "\n      <div id='wrapper'>\n        {{#my-component}}{{text}}{{/my-component}}\n      </div>\n    ");
      this.add('controller:application', _controller.default.extend({
        text: 'outer'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          text: 'inner'
        })
      });
      return this.visit('/').then(function () {
        var text = (0, _internalTestHelpers.getTextOf)(_this2.element.querySelector('#wrapper'));
        assert.equal(text, 'outer', 'The component is composed correctly');
      });
    };

    _proto['@test Components without a block should have the proper content when a template is provided'] = function testComponentsWithoutABlockShouldHaveTheProperContentWhenATemplateIsProvided(assert) {
      var _this3 = this;

      this.addTemplate('application', "\n      <div id='wrapper'>{{my-component}}</div>\n    ");
      this.add('controller:application', _controller.default.extend({
        text: 'outer'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          text: 'inner'
        }),
        template: '{{text}}'
      });
      return this.visit('/').then(function () {
        var text = (0, _internalTestHelpers.getTextOf)(_this3.element.querySelector('#wrapper'));
        assert.equal(text, 'inner', 'The component is composed correctly');
      });
    };

    _proto['@test Components without a block should have the proper content'] = function testComponentsWithoutABlockShouldHaveTheProperContent(assert) {
      var _this4 = this;

      this.addTemplate('application', "\n      <div id='wrapper'>{{my-component}}</div>\n    ");
      this.add('controller:application', _controller.default.extend({
        text: 'outer'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          didInsertElement: function () {
            this.element.innerHTML = 'Some text inserted';
          }
        })
      });
      return this.visit('/').then(function () {
        var text = (0, _internalTestHelpers.getTextOf)(_this4.element.querySelector('#wrapper'));
        assert.equal(text, 'Some text inserted', 'The component is composed correctly');
      });
    };

    _proto['@test properties of a component without a template should not collide with internal structures [DEPRECATED]'] = function testPropertiesOfAComponentWithoutATemplateShouldNotCollideWithInternalStructuresDEPRECATED(assert) {
      var _this5 = this;

      this.addTemplate('application', "\n      <div id='wrapper'>{{my-component data=foo}}</div>");
      this.add('controller:application', _controller.default.extend({
        text: 'outer',
        foo: 'Some text inserted'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          didInsertElement: function () {
            this.element.innerHTML = this.get('data');
          }
        })
      });
      return this.visit('/').then(function () {
        var text = (0, _internalTestHelpers.getTextOf)(_this5.element.querySelector('#wrapper'));
        assert.equal(text, 'Some text inserted', 'The component is composed correctly');
      });
    };

    _proto['@test attrs property of a component without a template should not collide with internal structures'] = function testAttrsPropertyOfAComponentWithoutATemplateShouldNotCollideWithInternalStructures(assert) {
      var _this6 = this;

      this.addTemplate('application', "\n      <div id='wrapper'>{{my-component attrs=foo}}</div>\n    ");
      this.add('controller:application', _controller.default.extend({
        text: 'outer',
        foo: 'Some text inserted'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          didInsertElement: function () {
            this.element.innerHTML = this.get('attrs.attrs.value');
          }
        })
      });
      return this.visit('/').then(function () {
        var text = (0, _internalTestHelpers.getTextOf)(_this6.element.querySelector('#wrapper'));
        assert.equal(text, 'Some text inserted', 'The component is composed correctly');
      });
    };

    _proto['@test Components trigger actions in the parents context when called from within a block'] = function testComponentsTriggerActionsInTheParentsContextWhenCalledFromWithinABlock(assert) {
      var _this7 = this;

      this.addTemplate('application', "\n      <div id='wrapper'>\n        {{#my-component}}\n          <a href='#' id='fizzbuzz' {{action 'fizzbuzz'}}>Fizzbuzz</a>\n        {{/my-component}}\n      </div>\n    ");
      this.add('controller:application', _controller.default.extend({
        actions: {
          fizzbuzz: function () {
            assert.ok(true, 'action triggered on parent');
          }
        }
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({})
      });
      return this.visit('/').then(function () {
        _this7.$('#fizzbuzz', '#wrapper').click();
      });
    };

    _proto['@test Components trigger actions in the components context when called from within its template'] = function testComponentsTriggerActionsInTheComponentsContextWhenCalledFromWithinItsTemplate(assert) {
      var _this8 = this;

      this.addTemplate('application', "\n      <div id='wrapper'>{{#my-component}}{{text}}{{/my-component}}</div>\n    ");
      this.add('controller:application', _controller.default.extend({
        actions: {
          fizzbuzz: function () {
            assert.ok(false, 'action on the wrong context');
          }
        }
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          actions: {
            fizzbuzz: function () {
              assert.ok(true, 'action triggered on component');
            }
          }
        }),
        template: "<a href='#' id='fizzbuzz' {{action 'fizzbuzz'}}>Fizzbuzz</a>"
      });
      return this.visit('/').then(function () {
        _this8.$('#fizzbuzz', '#wrapper').click();
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/component_registration_test", ["ember-babel", "@ember/application", "@ember/controller", "@ember/-internals/glimmer", "ember-template-compiler", "internal-test-helpers", "@ember/-internals/environment"], function (_emberBabel, _application, _controller, _glimmer, _emberTemplateCompiler, _internalTestHelpers, _environment) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application Lifecycle - Component Registration',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype; // This is necessary for this.application.instanceInitializer to not leak between tests

    _proto.createApplication = function createApplication(options) {
      return _ApplicationTestCase.prototype.createApplication.call(this, options, _application.default.extend());
    };

    _proto['@test The helper becomes the body of the component'] = function testTheHelperBecomesTheBodyOfTheComponent() {
      var _this = this;

      this.addTemplate('components/expand-it', '<p>hello {{yield}}</p>');
      this.addTemplate('application', 'Hello world {{#expand-it}}world{{/expand-it}}');
      return this.visit('/').then(function () {
        _this.assertText('Hello world hello world');

        _this.assertComponentElement(_this.element.firstElementChild, {
          tagName: 'div',
          content: '<p>hello world</p>'
        });
      });
    };

    _proto['@test The helper becomes the body of the component (ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = true;)'] = function testTheHelperBecomesTheBodyOfTheComponentENV_TEMPLATE_ONLY_GLIMMER_COMPONENTSTrue() {
      var _this2 = this;

      _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = true;
      this.addTemplate('components/expand-it', '<p>hello {{yield}}</p>');
      this.addTemplate('application', 'Hello world {{#expand-it}}world{{/expand-it}}');
      return this.visit('/').then(function () {
        _this2.assertInnerHTML('Hello world <p>hello world</p>');

        _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = false;
      });
    };

    _proto['@test If a component is registered, it is used'] = function testIfAComponentIsRegisteredItIsUsed(assert) {
      var _this3 = this;

      this.addTemplate('components/expand-it', '<p>hello {{yield}}</p>');
      this.addTemplate('application', "Hello world {{#expand-it}}world{{/expand-it}}");
      this.application.instanceInitializer({
        name: 'expand-it-component',
        initialize: function (applicationInstance) {
          applicationInstance.register('component:expand-it', _glimmer.Component.extend({
            classNames: 'testing123'
          }));
        }
      });
      return this.visit('/').then(function () {
        var text = _this3.$('div.testing123').text().trim();

        assert.equal(text, 'hello world', 'The component is composed correctly');
      });
    };

    _proto['@test Late-registered components can be rendered with custom `layout` property'] = function testLateRegisteredComponentsCanBeRenderedWithCustomLayoutProperty(assert) {
      var _this4 = this;

      this.addTemplate('application', "<div id='wrapper'>there goes {{my-hero}}</div>");
      this.application.instanceInitializer({
        name: 'my-hero-component',
        initialize: function (applicationInstance) {
          applicationInstance.register('component:my-hero', _glimmer.Component.extend({
            classNames: 'testing123',
            layout: (0, _emberTemplateCompiler.compile)('watch him as he GOES')
          }));
        }
      });
      return this.visit('/').then(function () {
        var text = _this4.$('#wrapper').text().trim();

        assert.equal(text, 'there goes watch him as he GOES', 'The component is composed correctly');
      });
    };

    _proto['@test Late-registered components can be rendered with template registered on the container'] = function testLateRegisteredComponentsCanBeRenderedWithTemplateRegisteredOnTheContainer(assert) {
      var _this5 = this;

      this.addTemplate('application', "<div id='wrapper'>hello world {{sally-rutherford}}-{{#sally-rutherford}}!!!{{/sally-rutherford}}</div>");
      this.application.instanceInitializer({
        name: 'sally-rutherford-component-template',
        initialize: function (applicationInstance) {
          applicationInstance.register('template:components/sally-rutherford', (0, _emberTemplateCompiler.compile)('funkytowny{{yield}}'));
        }
      });
      this.application.instanceInitializer({
        name: 'sally-rutherford-component',
        initialize: function (applicationInstance) {
          applicationInstance.register('component:sally-rutherford', _glimmer.Component);
        }
      });
      return this.visit('/').then(function () {
        var text = _this5.$('#wrapper').text().trim();

        assert.equal(text, 'hello world funkytowny-funkytowny!!!', 'The component is composed correctly');
      });
    };

    _proto['@test Late-registered components can be rendered with ONLY the template registered on the container'] = function testLateRegisteredComponentsCanBeRenderedWithONLYTheTemplateRegisteredOnTheContainer(assert) {
      var _this6 = this;

      this.addTemplate('application', "<div id='wrapper'>hello world {{borf-snorlax}}-{{#borf-snorlax}}!!!{{/borf-snorlax}}</div>");
      this.application.instanceInitializer({
        name: 'borf-snorlax-component-template',
        initialize: function (applicationInstance) {
          applicationInstance.register('template:components/borf-snorlax', (0, _emberTemplateCompiler.compile)('goodfreakingTIMES{{yield}}'));
        }
      });
      return this.visit('/').then(function () {
        var text = _this6.$('#wrapper').text().trim();

        assert.equal(text, 'hello world goodfreakingTIMES-goodfreakingTIMES!!!', 'The component is composed correctly');
      });
    };

    _proto['@test Assigning layoutName to a component should setup the template as a layout'] = function testAssigningLayoutNameToAComponentShouldSetupTheTemplateAsALayout(assert) {
      var _this7 = this;

      assert.expect(1);
      this.addTemplate('application', "<div id='wrapper'>{{#my-component}}{{text}}{{/my-component}}</div>");
      this.addTemplate('foo-bar-baz', '{{text}}-{{yield}}');
      this.application.instanceInitializer({
        name: 'application-controller',
        initialize: function (applicationInstance) {
          applicationInstance.register('controller:application', _controller.default.extend({
            text: 'outer'
          }));
        }
      });
      this.application.instanceInitializer({
        name: 'my-component-component',
        initialize: function (applicationInstance) {
          applicationInstance.register('component:my-component', _glimmer.Component.extend({
            text: 'inner',
            layoutName: 'foo-bar-baz'
          }));
        }
      });
      return this.visit('/').then(function () {
        var text = _this7.$('#wrapper').text().trim();

        assert.equal(text, 'inner-outer', 'The component is composed correctly');
      });
    };

    _proto['@test Assigning layoutName and layout to a component should use the `layout` value'] = function testAssigningLayoutNameAndLayoutToAComponentShouldUseTheLayoutValue(assert) {
      var _this8 = this;

      assert.expect(1);
      this.addTemplate('application', "<div id='wrapper'>{{#my-component}}{{text}}{{/my-component}}</div>");
      this.addTemplate('foo-bar-baz', 'No way!');
      this.application.instanceInitializer({
        name: 'application-controller-layout',
        initialize: function (applicationInstance) {
          applicationInstance.register('controller:application', _controller.default.extend({
            text: 'outer'
          }));
        }
      });
      this.application.instanceInitializer({
        name: 'my-component-component-layout',
        initialize: function (applicationInstance) {
          applicationInstance.register('component:my-component', _glimmer.Component.extend({
            text: 'inner',
            layoutName: 'foo-bar-baz',
            layout: (0, _emberTemplateCompiler.compile)('{{text}}-{{yield}}')
          }));
        }
      });
      return this.visit('/').then(function () {
        var text = _this8.$('#wrapper').text().trim();

        assert.equal(text, 'inner-outer', 'The component is composed correctly');
      });
    };

    _proto['@test Using name of component that does not exist'] = function testUsingNameOfComponentThatDoesNotExist() {
      var _this9 = this;

      this.addTemplate('application', "<div id='wrapper'>{{#no-good}} {{/no-good}}</div>"); // TODO: Use the async form of expectAssertion here when it is available

      expectAssertion(function () {
        _this9.visit('/');
      }, /.* named "no-good" .*/);
      return (0, _internalTestHelpers.runLoopSettled)();
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/controller_test", ["ember-babel", "@ember/controller", "internal-test-helpers", "@ember/-internals/glimmer"], function (_emberBabel, _controller, _internalTestHelpers, _glimmer) {
  "use strict";

  /*
   In Ember 1.x, controllers subtly affect things like template scope
   and action targets in exciting and often inscrutable ways. This test
   file contains integration tests that verify the correct behavior of
   the many parts of the system that change and rely upon controller scope,
   from the runtime up to the templating layer.
  */
  (0, _internalTestHelpers.moduleFor)('Template scoping examples',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Actions inside an outlet go to the associated controller'] = function testActionsInsideAnOutletGoToTheAssociatedController(assert) {
      var _this = this;

      this.add('controller:index', _controller.default.extend({
        actions: {
          componentAction: function () {
            assert.ok(true, 'controller received the action');
          }
        }
      }));
      this.addComponent('component-with-action', {
        ComponentClass: _glimmer.Component.extend({
          classNames: ['component-with-action'],
          click: function () {
            this.action();
          }
        })
      });
      this.addTemplate('index', '{{component-with-action action=(action "componentAction")}}');
      return this.visit('/').then(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this.$('.component-with-action').click();
        });
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/error_handler_test", ["ember-babel", "@ember/debug", "@ember/runloop", "@ember/-internals/error-handling", "rsvp", "internal-test-helpers"], function (_emberBabel, _debug, _runloop, _errorHandling, _rsvp, _internalTestHelpers) {
  "use strict";

  var WINDOW_ONERROR;

  function runThatThrowsSync() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Error for testing error handling';
    return (0, _runloop.run)(function () {
      throw new Error(message);
    });
  }

  (0, _internalTestHelpers.moduleFor)('error_handler',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      // capturing this outside of module scope to ensure we grab
      // the test frameworks own window.onerror to reset it
      WINDOW_ONERROR = window.onerror;
    };

    _proto.afterEach = function afterEach() {
      (0, _debug.setTesting)(_debug.isTesting);
      window.onerror = WINDOW_ONERROR;
      (0, _errorHandling.setOnerror)(undefined);
    };

    _proto['@test by default there is no onerror - sync run'] = function testByDefaultThereIsNoOnerrorSyncRun(assert) {
      assert.strictEqual((0, _errorHandling.getOnerror)(), undefined, 'precond - there should be no Ember.onerror set by default');
      assert.throws(runThatThrowsSync, Error, 'errors thrown sync are catchable');
    };

    _proto['@test when Ember.onerror (which rethrows) is registered - sync run'] = function testWhenEmberOnerrorWhichRethrowsIsRegisteredSyncRun(assert) {
      assert.expect(2);
      (0, _errorHandling.setOnerror)(function (error) {
        assert.ok(true, 'onerror called');
        throw error;
      });
      assert.throws(runThatThrowsSync, Error, 'error is thrown');
    };

    _proto['@test when Ember.onerror (which does not rethrow) is registered - sync run'] = function testWhenEmberOnerrorWhichDoesNotRethrowIsRegisteredSyncRun(assert) {
      assert.expect(2);
      (0, _errorHandling.setOnerror)(function () {
        assert.ok(true, 'onerror called');
      });
      runThatThrowsSync();
      assert.ok(true, 'no error was thrown, Ember.onerror can intercept errors');
    };

    _proto['@test does not swallow exceptions by default (Ember.testing = true, no Ember.onerror) - sync run'] = function testDoesNotSwallowExceptionsByDefaultEmberTestingTrueNoEmberOnerrorSyncRun(assert) {
      (0, _debug.setTesting)(true);
      var error = new Error('the error');
      assert.throws(function () {
        (0, _runloop.run)(function () {
          throw error;
        });
      }, error);
    };

    _proto['@test does not swallow exceptions by default (Ember.testing = false, no Ember.onerror) - sync run'] = function testDoesNotSwallowExceptionsByDefaultEmberTestingFalseNoEmberOnerrorSyncRun(assert) {
      (0, _debug.setTesting)(false);
      var error = new Error('the error');
      assert.throws(function () {
        (0, _runloop.run)(function () {
          throw error;
        });
      }, error);
    };

    _proto['@test does not swallow exceptions (Ember.testing = false, Ember.onerror which rethrows) - sync run'] = function testDoesNotSwallowExceptionsEmberTestingFalseEmberOnerrorWhichRethrowsSyncRun(assert) {
      assert.expect(2);
      (0, _debug.setTesting)(false);
      (0, _errorHandling.setOnerror)(function (error) {
        assert.ok(true, 'Ember.onerror was called');
        throw error;
      });
      var error = new Error('the error');
      assert.throws(function () {
        (0, _runloop.run)(function () {
          throw error;
        });
      }, error);
    };

    _proto['@test Ember.onerror can intercept errors (aka swallow) by not rethrowing (Ember.testing = false) - sync run'] = function testEmberOnerrorCanInterceptErrorsAkaSwallowByNotRethrowingEmberTestingFalseSyncRun(assert) {
      assert.expect(1);
      (0, _debug.setTesting)(false);
      (0, _errorHandling.setOnerror)(function () {
        assert.ok(true, 'Ember.onerror was called');
      });
      var error = new Error('the error');

      try {
        (0, _runloop.run)(function () {
          throw error;
        });
      } catch (e) {
        assert.notOk(true, 'Ember.onerror that does not rethrow is intentionally swallowing errors, try / catch wrapping does not see error');
      }
    };

    _proto['@test does not swallow exceptions by default (Ember.testing = true, no Ember.onerror) - async run'] = function testDoesNotSwallowExceptionsByDefaultEmberTestingTrueNoEmberOnerrorAsyncRun(assert) {
      var done = assert.async();
      var caughtByWindowOnerror;
      (0, _debug.setTesting)(true);

      window.onerror = function (message) {
        caughtByWindowOnerror = message; // prevent "bubbling" and therefore failing the test

        return true;
      };

      (0, _runloop.later)(function () {
        throw new Error('the error');
      }, 10);
      setTimeout(function () {
        assert.pushResult({
          result: /the error/.test(caughtByWindowOnerror),
          actual: caughtByWindowOnerror,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
        });
        done();
      }, 20);
    };

    _proto['@test does not swallow exceptions by default (Ember.testing = false, no Ember.onerror) - async run'] = function testDoesNotSwallowExceptionsByDefaultEmberTestingFalseNoEmberOnerrorAsyncRun(assert) {
      var done = assert.async();
      var caughtByWindowOnerror;
      (0, _debug.setTesting)(false);

      window.onerror = function (message) {
        caughtByWindowOnerror = message; // prevent "bubbling" and therefore failing the test

        return true;
      };

      (0, _runloop.later)(function () {
        throw new Error('the error');
      }, 10);
      setTimeout(function () {
        assert.pushResult({
          result: /the error/.test(caughtByWindowOnerror),
          actual: caughtByWindowOnerror,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
        });
        done();
      }, 20);
    };

    _proto['@test Ember.onerror can intercept errors (aka swallow) by not rethrowing (Ember.testing = false) - async run'] = function testEmberOnerrorCanInterceptErrorsAkaSwallowByNotRethrowingEmberTestingFalseAsyncRun(assert) {
      var done = assert.async();
      (0, _debug.setTesting)(false);

      window.onerror = function () {
        assert.notOk(true, 'window.onerror is never invoked when Ember.onerror intentionally swallows errors'); // prevent "bubbling" and therefore failing the test

        return true;
      };

      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called with the error');
      });
      (0, _runloop.later)(function () {
        throw thrown;
      }, 10);
      setTimeout(done, 20);
    };

    _proto["@test errors in promise constructor when Ember.onerror which does not rethrow is present - rsvp"] = function (assert) {
      assert.expect(1);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });
      new _rsvp.default.Promise(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed

      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      });
    };

    _proto["@test errors in promise constructor when Ember.onerror which does rethrow is present - rsvp"] = function (assert) {
      assert.expect(2);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      });

      window.onerror = function (message) {
        assert.pushResult({
          result: /the error/.test(message),
          actual: message,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
        }); // prevent "bubbling" and therefore failing the test

        return true;
      };

      new _rsvp.default.Promise(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed

      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      });
    };

    _proto["@test errors in promise constructor when Ember.onerror which does not rethrow is present (Ember.testing = false) - rsvp"] = function (assert) {
      assert.expect(1);
      (0, _debug.setTesting)(false);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });
      new _rsvp.default.Promise(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed

      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      });
    };

    _proto["@test errors in promise constructor when Ember.onerror which does rethrow is present (Ember.testing = false) - rsvp"] = function (assert) {
      assert.expect(2);
      (0, _debug.setTesting)(false);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      });

      window.onerror = function (message) {
        assert.pushResult({
          result: /the error/.test(message),
          actual: message,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
        }); // prevent "bubbling" and therefore failing the test

        return true;
      };

      new _rsvp.default.Promise(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed

      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      });
    };

    _proto["@test errors in promise .then callback when Ember.onerror which does not rethrow is present - rsvp"] = function (assert) {
      assert.expect(1);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });

      _rsvp.default.resolve().then(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed


      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      });
    };

    _proto["@test errors in promise .then callback when Ember.onerror which does rethrow is present - rsvp"] = function (assert) {
      assert.expect(2);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      });

      window.onerror = function (message) {
        assert.pushResult({
          result: /the error/.test(message),
          actual: message,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
        }); // prevent "bubbling" and therefore failing the test

        return true;
      };

      _rsvp.default.resolve().then(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed


      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      });
    };

    _proto["@test errors in promise .then callback when Ember.onerror which does not rethrow is present (Ember.testing = false) - rsvp"] = function (assert) {
      assert.expect(1);
      (0, _debug.setTesting)(false);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });

      _rsvp.default.resolve().then(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed


      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      });
    };

    _proto["@test errors in promise .then callback when Ember.onerror which does rethrow is present (Ember.testing = false) - rsvp"] = function (assert) {
      assert.expect(2);
      (0, _debug.setTesting)(false);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      });

      window.onerror = function (message) {
        assert.pushResult({
          result: /the error/.test(message),
          actual: message,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
        }); // prevent "bubbling" and therefore failing the test

        return true;
      };

      _rsvp.default.resolve().then(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed


      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      });
    };

    _proto["@test errors in async promise .then callback when Ember.onerror which does not rethrow is present - rsvp"] = function (assert) {
      assert.expect(1);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });
      new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      }).then(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed

      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 20);
      });
    };

    _proto["@test errors in async promise .then callback when Ember.onerror which does rethrow is present - rsvp"] = function (assert) {
      assert.expect(2);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      });

      window.onerror = function (message) {
        assert.pushResult({
          result: /the error/.test(message),
          actual: message,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
        }); // prevent "bubbling" and therefore failing the test

        return true;
      };

      new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      }).then(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed

      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 20);
      });
    };

    _proto["@test errors in async promise .then callback when Ember.onerror which does not rethrow is present (Ember.testing = false) - rsvp"] = function (assert) {
      assert.expect(1);
      (0, _debug.setTesting)(false);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });
      new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      }).then(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed

      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 20);
      });
    };

    _proto["@test errors in async promise .then callback when Ember.onerror which does rethrow is present (Ember.testing = false) - rsvp"] = function (assert) {
      assert.expect(2);
      (0, _debug.setTesting)(false);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      });

      window.onerror = function (message) {
        assert.pushResult({
          result: /the error/.test(message),
          actual: message,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
        }); // prevent "bubbling" and therefore failing the test

        return true;
      };

      new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      }).then(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed

      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 20);
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember/tests/helpers/helper_registration_test", ["ember-babel", "internal-test-helpers", "@ember/controller", "@ember/service", "@ember/-internals/glimmer"], function (_emberBabel, _internalTestHelpers, _controller, _service, _glimmer) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application Lifecycle - Helper Registration',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Unbound dashed helpers registered on the container can be late-invoked'] = function testUnboundDashedHelpersRegisteredOnTheContainerCanBeLateInvoked(assert) {
      var _this = this;

      this.addTemplate('application', "<div id='wrapper'>{{x-borf}} {{x-borf 'YES'}}</div>");
      var myHelper = (0, _glimmer.helper)(function (params) {
        return params[0] || 'BORF';
      });
      this.application.register('helper:x-borf', myHelper);
      return this.visit('/').then(function () {
        assert.equal(_this.$('#wrapper').text(), 'BORF YES', 'The helper was invoked from the container');
      });
    };

    _proto['@test Bound helpers registered on the container can be late-invoked'] = function testBoundHelpersRegisteredOnTheContainerCanBeLateInvoked(assert) {
      var _this2 = this;

      this.addTemplate('application', "<div id='wrapper'>{{x-reverse}} {{x-reverse foo}}</div>");
      this.add('controller:application', _controller.default.extend({
        foo: 'alex'
      }));
      this.application.register('helper:x-reverse', (0, _glimmer.helper)(function (_ref) {
        var value = _ref[0];
        return value ? value.split('').reverse().join('') : '--';
      }));
      return this.visit('/').then(function () {
        assert.equal(_this2.$('#wrapper').text(), '-- xela', 'The bound helper was invoked from the container');
      });
    };

    _proto['@test Undashed helpers registered on the container can be invoked'] = function testUndashedHelpersRegisteredOnTheContainerCanBeInvoked(assert) {
      var _this3 = this;

      this.addTemplate('application', "<div id='wrapper'>{{omg}}|{{yorp 'boo'}}|{{yorp 'ya'}}</div>");
      this.application.register('helper:omg', (0, _glimmer.helper)(function () {
        return 'OMG';
      }));
      this.application.register('helper:yorp', (0, _glimmer.helper)(function (_ref2) {
        var value = _ref2[0];
        return value;
      }));
      return this.visit('/').then(function () {
        assert.equal(_this3.$('#wrapper').text(), 'OMG|boo|ya', 'The helper was invoked from the container');
      });
    };

    _proto['@test Helpers can receive injections'] = function testHelpersCanReceiveInjections(assert) {
      this.addTemplate('application', "<div id='wrapper'>{{full-name}}</div>");
      var serviceCalled = false;
      this.add('service:name-builder', _service.default.extend({
        build: function () {
          serviceCalled = true;
        }
      }));
      this.add('helper:full-name', _glimmer.Helper.extend({
        nameBuilder: (0, _service.inject)('name-builder'),
        compute: function () {
          this.get('nameBuilder').build();
        }
      }));
      return this.visit('/').then(function () {
        assert.ok(serviceCalled, 'service was injected, method called');
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/helpers/link_to_test", ["ember-babel", "internal-test-helpers", "@ember/controller", "@ember/-internals/runtime", "@ember/-internals/metal", "@ember/instrumentation", "@ember/-internals/routing"], function (_emberBabel, _internalTestHelpers, _controller, _runtime, _metal, _instrumentation, _routing) {
  "use strict";

  // IE includes the host name
  function normalizeUrl(url) {
    return url.replace(/https?:\/\/[^\/]+/, '');
  }

  function shouldNotBeActive(assert, element) {
    checkActive(assert, element, false);
  }

  function shouldBeActive(assert, element) {
    checkActive(assert, element, true);
  }

  function checkActive(assert, element, active) {
    var classList = element.attr('class');
    assert.equal(classList.indexOf('active') > -1, active, element + " active should be " + active);
  }

  (0, _internalTestHelpers.moduleFor)('The {{link-to}} helper - basic tests',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.call(this) || this;

      _this.router.map(function () {
        this.route('about');
      });

      _this.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      {{#link-to 'about' id='about-link'}}About{{/link-to}}\n      {{#link-to 'index' id='self-link'}}Self{{/link-to}}\n    ");

      _this.addTemplate('about', "\n      <h3 class=\"about\">About</h3>\n      {{#link-to 'index' id='home-link'}}Home{{/link-to}}\n      {{#link-to 'about' id='self-link'}}Self{{/link-to}}\n    ");

      return _this;
    }

    var _proto = _class.prototype;

    _proto['@test The {{link-to}} helper moves into the named route'] = function testTheLinkToHelperMovesIntoTheNamedRoute(assert) {
      var _this2 = this;

      return this.visit('/').then(function () {
        assert.equal(_this2.$('h3.home').length, 1, 'The home template was rendered');
        assert.equal(_this2.$('#self-link.active').length, 1, 'The self-link was rendered with active class');
        assert.equal(_this2.$('#about-link:not(.active)').length, 1, 'The other link was rendered without active class');
        return _this2.click('#about-link');
      }).then(function () {
        assert.equal(_this2.$('h3.about').length, 1, 'The about template was rendered');
        assert.equal(_this2.$('#self-link.active').length, 1, 'The self-link was rendered with active class');
        assert.equal(_this2.$('#home-link:not(.active)').length, 1, 'The other link was rendered without active class');
      });
    };

    _proto["@test the {{link-to}} helper doesn't add an href when the tagName isn't 'a'"] = function (assert) {
      var _this3 = this;

      this.addTemplate('index', "\n      {{#link-to 'about' id='about-link' tagName='div'}}About{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        assert.equal(_this3.$('#about-link').attr('href'), undefined, 'there is no href attribute');
      });
    };

    _proto["@test the {{link-to}} applies a 'disabled' class when disabled"] = function (assert) {
      var _this4 = this;

      this.addTemplate('index', "\n      {{#link-to \"about\" id=\"about-link-static\" disabledWhen=\"shouldDisable\"}}About{{/link-to}}\n      {{#link-to \"about\" id=\"about-link-dynamic\" disabledWhen=dynamicDisabledWhen}}About{{/link-to}}\n    ");
      this.add('controller:index', _controller.default.extend({
        shouldDisable: true,
        dynamicDisabledWhen: 'shouldDisable'
      }));
      return this.visit('/').then(function () {
        assert.equal(_this4.$('#about-link-static.disabled').length, 1, 'The static link is disabled when its disabledWhen is true');
        assert.equal(_this4.$('#about-link-dynamic.disabled').length, 1, 'The dynamic link is disabled when its disabledWhen is true');

        var controller = _this4.applicationInstance.lookup('controller:index');

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('dynamicDisabledWhen', false);
        });
        assert.equal(_this4.$('#about-link-dynamic.disabled').length, 0, 'The dynamic link is re-enabled when its disabledWhen becomes false');
      });
    };

    _proto["@test the {{link-to}} doesn't apply a 'disabled' class if disabledWhen is not provided"] = function (assert) {
      var _this5 = this;

      this.addTemplate('index', "{{#link-to \"about\" id=\"about-link\"}}About{{/link-to}}");
      return this.visit('/').then(function () {
        assert.ok(!_this5.$('#about-link').hasClass('disabled'), 'The link is not disabled if disabledWhen not provided');
      });
    };

    _proto["@test the {{link-to}} helper supports a custom disabledClass"] = function (assert) {
      var _this6 = this;

      this.addTemplate('index', "\n      {{#link-to \"about\" id=\"about-link\" disabledWhen=true disabledClass=\"do-not-want\"}}About{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        assert.equal(_this6.$('#about-link.do-not-want').length, 1, 'The link can apply a custom disabled class');
      });
    };

    _proto["@test the {{link-to}} helper supports a custom disabledClass set via bound param"] = function (assert) {
      var _this7 = this;

      this.addTemplate('index', "\n      {{#link-to \"about\" id=\"about-link\" disabledWhen=true disabledClass=disabledClass}}About{{/link-to}}\n    ");
      this.add('controller:index', _controller.default.extend({
        disabledClass: 'do-not-want'
      }));
      return this.visit('/').then(function () {
        assert.equal(_this7.$('#about-link.do-not-want').length, 1, 'The link can apply a custom disabled class via bound param');
      });
    };

    _proto["@test the {{link-to}} helper does not respond to clicks when disabledWhen"] = function (assert) {
      var _this8 = this;

      this.addTemplate('index', "\n      {{#link-to \"about\" id=\"about-link\" disabledWhen=true}}About{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        return _this8.click('#about-link');
      }).then(function () {
        assert.equal(_this8.$('h3.about').length, 0, 'Transitioning did not occur');
      });
    };

    _proto["@test the {{link-to}} helper does not respond to clicks when disabled"] = function (assert) {
      var _this9 = this;

      this.addTemplate('index', "\n      {{#link-to \"about\" id=\"about-link\" disabled=true}}About{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        return _this9.click('#about-link');
      }).then(function () {
        assert.equal(_this9.$('h3.about').length, 0, 'Transitioning did not occur');
      });
    };

    _proto["@test the {{link-to}} helper responds to clicks according to its disabledWhen bound param"] = function (assert) {
      var _this10 = this;

      this.addTemplate('index', "\n      {{#link-to \"about\" id=\"about-link\" disabledWhen=disabledWhen}}About{{/link-to}}\n    ");
      this.add('controller:index', _controller.default.extend({
        disabledWhen: true
      }));
      return this.visit('/').then(function () {
        return _this10.click('#about-link');
      }).then(function () {
        assert.equal(_this10.$('h3.about').length, 0, 'Transitioning did not occur');

        var controller = _this10.applicationInstance.lookup('controller:index');

        controller.set('disabledWhen', false);
        return (0, _internalTestHelpers.runLoopSettled)();
      }).then(function () {
        return _this10.click('#about-link');
      }).then(function () {
        assert.equal(_this10.$('h3.about').length, 1, 'Transitioning did occur when disabledWhen became false');
      });
    };

    _proto["@test The {{link-to}} helper supports a custom activeClass"] = function (assert) {
      var _this11 = this;

      this.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      {{#link-to 'about' id='about-link'}}About{{/link-to}}\n      {{#link-to 'index' id='self-link' activeClass='zomg-active'}}Self{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        assert.equal(_this11.$('h3.home').length, 1, 'The home template was rendered');
        assert.equal(_this11.$('#self-link.zomg-active').length, 1, 'The self-link was rendered with active class');
        assert.equal(_this11.$('#about-link:not(.active)').length, 1, 'The other link was rendered without active class');
      });
    };

    _proto["@test The {{link-to}} helper supports a custom activeClass from a bound param"] = function (assert) {
      var _this12 = this;

      this.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      {{#link-to 'about' id='about-link'}}About{{/link-to}}\n      {{#link-to 'index' id='self-link' activeClass=activeClass}}Self{{/link-to}}\n    ");
      this.add('controller:index', _controller.default.extend({
        activeClass: 'zomg-active'
      }));
      return this.visit('/').then(function () {
        assert.equal(_this12.$('h3.home').length, 1, 'The home template was rendered');
        assert.equal(_this12.$('#self-link.zomg-active').length, 1, 'The self-link was rendered with active class');
        assert.equal(_this12.$('#about-link:not(.active)').length, 1, 'The other link was rendered without active class');
      });
    };

    _proto["@test The {{link-to}} helper supports 'classNameBindings' with custom values [GH #11699]"] = function (assert) {
      var _this13 = this;

      this.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      {{#link-to 'about' id='about-link' classNameBindings='foo:foo-is-true:foo-is-false'}}About{{/link-to}}\n    ");
      this.add('controller:index', _controller.default.extend({
        foo: false
      }));
      return this.visit('/').then(function () {
        assert.equal(_this13.$('#about-link.foo-is-false').length, 1, 'The about-link was rendered with the falsy class');

        var controller = _this13.applicationInstance.lookup('controller:index');

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('foo', true);
        });
        assert.equal(_this13.$('#about-link.foo-is-true').length, 1, 'The about-link was rendered with the truthy class after toggling the property');
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('The {{link-to}} helper - location hooks',
  /*#__PURE__*/
  function (_ApplicationTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase2);

    function _class2() {
      var _this14;

      _this14 = _ApplicationTestCase2.call(this) || this;
      _this14.updateCount = 0;
      _this14.replaceCount = 0;
      var testContext = (0, _emberBabel.assertThisInitialized)((0, _emberBabel.assertThisInitialized)(_this14));

      _this14.add('location:none', _routing.NoneLocation.extend({
        setURL: function () {
          testContext.updateCount++;
          return this._super.apply(this, arguments);
        },
        replaceURL: function () {
          testContext.replaceCount++;
          return this._super.apply(this, arguments);
        }
      }));

      _this14.router.map(function () {
        this.route('about');
      });

      _this14.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      {{#link-to 'about' id='about-link'}}About{{/link-to}}\n      {{#link-to 'index' id='self-link'}}Self{{/link-to}}\n    ");

      _this14.addTemplate('about', "\n      <h3 class=\"about\">About</h3>\n      {{#link-to 'index' id='home-link'}}Home{{/link-to}}\n      {{#link-to 'about' id='self-link'}}Self{{/link-to}}\n    ");

      return _this14;
    }

    var _proto2 = _class2.prototype;

    _proto2.visit = function visit() {
      var _this15 = this;

      return _ApplicationTestCase2.prototype.visit.apply(this, arguments).then(function () {
        _this15.updateCountAfterVisit = _this15.updateCount;
        _this15.replaceCountAfterVisit = _this15.replaceCount;
      });
    };

    _proto2['@test The {{link-to}} helper supports URL replacement'] = function testTheLinkToHelperSupportsURLReplacement(assert) {
      var _this16 = this;

      this.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      {{#link-to 'about' id='about-link' replace=true}}About{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        return _this16.click('#about-link');
      }).then(function () {
        assert.equal(_this16.updateCount, _this16.updateCountAfterVisit, 'setURL should not be called');
        assert.equal(_this16.replaceCount, _this16.replaceCountAfterVisit + 1, 'replaceURL should be called once');
      });
    };

    _proto2['@test The {{link-to}} helper supports URL replacement via replace=boundTruthyThing'] = function testTheLinkToHelperSupportsURLReplacementViaReplaceBoundTruthyThing(assert) {
      var _this17 = this;

      this.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      {{#link-to 'about' id='about-link' replace=boundTruthyThing}}About{{/link-to}}\n    ");
      this.add('controller:index', _controller.default.extend({
        boundTruthyThing: true
      }));
      return this.visit('/').then(function () {
        return _this17.click('#about-link');
      }).then(function () {
        assert.equal(_this17.updateCount, _this17.updateCountAfterVisit, 'setURL should not be called');
        assert.equal(_this17.replaceCount, _this17.replaceCountAfterVisit + 1, 'replaceURL should be called once');
      });
    };

    _proto2['@test The {{link-to}} helper supports setting replace=boundFalseyThing'] = function testTheLinkToHelperSupportsSettingReplaceBoundFalseyThing(assert) {
      var _this18 = this;

      this.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      {{#link-to 'about' id='about-link' replace=boundFalseyThing}}About{{/link-to}}\n    ");
      this.add('controller:index', _controller.default.extend({
        boundFalseyThing: false
      }));
      return this.visit('/').then(function () {
        return _this18.click('#about-link');
      }).then(function () {
        assert.equal(_this18.updateCount, _this18.updateCountAfterVisit + 1, 'setURL should be called');
        assert.equal(_this18.replaceCount, _this18.replaceCountAfterVisit, 'replaceURL should not be called');
      });
    };

    return _class2;
  }(_internalTestHelpers.ApplicationTestCase));

  if (false
  /* EMBER_IMPROVED_INSTRUMENTATION */
  ) {
      (0, _internalTestHelpers.moduleFor)('The {{link-to}} helper with EMBER_IMPROVED_INSTRUMENTATION',
      /*#__PURE__*/
      function (_ApplicationTestCase3) {
        (0, _emberBabel.inheritsLoose)(_class3, _ApplicationTestCase3);

        function _class3() {
          var _this19;

          _this19 = _ApplicationTestCase3.call(this) || this;

          _this19.router.map(function () {
            this.route('about');
          });

          _this19.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{#link-to 'about' id='about-link'}}About{{/link-to}}\n        {{#link-to 'index' id='self-link'}}Self{{/link-to}}\n      ");

          _this19.addTemplate('about', "\n        <h3 class=\"about\">About</h3>\n        {{#link-to 'index' id='home-link'}}Home{{/link-to}}\n        {{#link-to 'about' id='self-link'}}Self{{/link-to}}\n      ");

          return _this19;
        }

        var _proto3 = _class3.prototype;

        _proto3.beforeEach = function beforeEach() {
          return this.visit('/');
        };

        _proto3.afterEach = function afterEach() {
          (0, _instrumentation.reset)();
          return _ApplicationTestCase3.prototype.afterEach.call(this);
        };

        _proto3['@test The {{link-to}} helper fires an interaction event'] = function testTheLinkToHelperFiresAnInteractionEvent(assert) {
          assert.expect(2);
          (0, _instrumentation.subscribe)('interaction.link-to', {
            before: function () {
              assert.ok(true, 'instrumentation subscriber was called');
            },
            after: function () {
              assert.ok(true, 'instrumentation subscriber was called');
            }
          });
          return this.click('#about-link');
        };

        _proto3['@test The {{link-to}} helper interaction event includes the route name'] = function testTheLinkToHelperInteractionEventIncludesTheRouteName(assert) {
          assert.expect(2);
          (0, _instrumentation.subscribe)('interaction.link-to', {
            before: function (name, timestamp, _ref) {
              var routeName = _ref.routeName;
              assert.equal(routeName, 'about', 'instrumentation subscriber was passed route name');
            },
            after: function (name, timestamp, _ref2) {
              var routeName = _ref2.routeName;
              assert.equal(routeName, 'about', 'instrumentation subscriber was passed route name');
            }
          });
          return this.click('#about-link');
        };

        _proto3['@test The {{link-to}} helper interaction event includes the transition in the after hook'] = function testTheLinkToHelperInteractionEventIncludesTheTransitionInTheAfterHook(assert) {
          assert.expect(1);
          (0, _instrumentation.subscribe)('interaction.link-to', {
            before: function () {},
            after: function (name, timestamp, _ref3) {
              var transition = _ref3.transition;
              assert.equal(transition.targetName, 'about', 'instrumentation subscriber was passed route name');
            }
          });
          return this.click('#about-link');
        };

        return _class3;
      }(_internalTestHelpers.ApplicationTestCase));
    }

  (0, _internalTestHelpers.moduleFor)('The {{link-to}} helper - nested routes and link-to arguments',
  /*#__PURE__*/
  function (_ApplicationTestCase4) {
    (0, _emberBabel.inheritsLoose)(_class4, _ApplicationTestCase4);

    function _class4() {
      return _ApplicationTestCase4.apply(this, arguments) || this;
    }

    var _proto4 = _class4.prototype;

    _proto4['@test The {{link-to}} helper supports leaving off .index for nested routes'] = function testTheLinkToHelperSupportsLeavingOffIndexForNestedRoutes(assert) {
      var _this20 = this;

      this.router.map(function () {
        this.route('about', function () {
          this.route('item');
        });
      });
      this.addTemplate('about', "<h1>About</h1>{{outlet}}");
      this.addTemplate('about.index', "<div id='index'>Index</div>");
      this.addTemplate('about.item', "<div id='item'>{{#link-to 'about'}}About{{/link-to}}</div>");
      return this.visit('/about/item').then(function () {
        assert.equal(normalizeUrl(_this20.$('#item a').attr('href')), '/about');
      });
    };

    _proto4["@test The {{link-to}} helper supports custom, nested, current-when"] = function (assert) {
      var _this21 = this;

      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('item');
      });
      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
      this.addTemplate('index.about', "\n      {{#link-to 'item' id='other-link' current-when='index'}}ITEM{{/link-to}}\n    ");
      return this.visit('/about').then(function () {
        assert.equal(_this21.$('#other-link.active').length, 1, 'The link is active since current-when is a parent route');
      });
    };

    _proto4["@test The {{link-to}} helper does not disregard current-when when it is given explicitly for a route"] = function (assert) {
      var _this22 = this;

      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('items', function () {
          this.route('item');
        });
      });
      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
      this.addTemplate('index.about', "\n      {{#link-to 'items' id='other-link' current-when='index'}}ITEM{{/link-to}}\n    ");
      return this.visit('/about').then(function () {
        assert.equal(_this22.$('#other-link.active').length, 1, 'The link is active when current-when is given for explicitly for a route');
      });
    };

    _proto4['@test The {{link-to}} helper does not disregard current-when when it is set via a bound param'] = function testTheLinkToHelperDoesNotDisregardCurrentWhenWhenItIsSetViaABoundParam(assert) {
      var _this23 = this;

      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('items', function () {
          this.route('item');
        });
      });
      this.add('controller:index.about', _controller.default.extend({
        currentWhen: 'index'
      }));
      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
      this.addTemplate('index.about', "{{#link-to 'items' id='other-link' current-when=currentWhen}}ITEM{{/link-to}}");
      return this.visit('/about').then(function () {
        assert.equal(_this23.$('#other-link.active').length, 1, 'The link is active when current-when is given for explicitly for a route');
      });
    };

    _proto4['@test The {{link-to}} helper supports multiple current-when routes'] = function testTheLinkToHelperSupportsMultipleCurrentWhenRoutes(assert) {
      var _this24 = this;

      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('item');
        this.route('foo');
      });
      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
      this.addTemplate('index.about', "{{#link-to 'item' id='link1' current-when='item index'}}ITEM{{/link-to}}");
      this.addTemplate('item', "{{#link-to 'item' id='link2' current-when='item index'}}ITEM{{/link-to}}");
      this.addTemplate('foo', "{{#link-to 'item' id='link3' current-when='item index'}}ITEM{{/link-to}}");
      return this.visit('/about').then(function () {
        assert.equal(_this24.$('#link1.active').length, 1, 'The link is active since current-when contains the parent route');
        return _this24.visit('/item');
      }).then(function () {
        assert.equal(_this24.$('#link2.active').length, 1, 'The link is active since you are on the active route');
        return _this24.visit('/foo');
      }).then(function () {
        assert.equal(_this24.$('#link3.active').length, 0, 'The link is not active since current-when does not contain the active route');
      });
    };

    _proto4['@test The {{link-to}} helper supports boolean values for current-when'] = function testTheLinkToHelperSupportsBooleanValuesForCurrentWhen(assert) {
      var _this25 = this;

      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('item');
      });
      this.addTemplate('index.about', "\n      {{#link-to 'index' id='index-link' current-when=isCurrent}}index{{/link-to}}\n      {{#link-to 'item' id='about-link' current-when=true}}ITEM{{/link-to}}\n    ");
      this.add('controller:index.about', _controller.default.extend({
        isCurrent: false
      }));
      return this.visit('/about').then(function () {
        assert.ok(_this25.$('#about-link').hasClass('active'), 'The link is active since current-when is true');
        assert.notOk(_this25.$('#index-link').hasClass('active'), 'The link is not active since current-when is false');

        var controller = _this25.applicationInstance.lookup('controller:index.about');

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('isCurrent', true);
        });
        assert.ok(_this25.$('#index-link').hasClass('active'), 'The link is active since current-when is true');
      });
    };

    _proto4['@test The {{link-to}} helper defaults to bubbling'] = function testTheLinkToHelperDefaultsToBubbling(assert) {
      var _this26 = this;

      this.addTemplate('about', "\n      <div {{action 'hide'}}>\n        {{#link-to 'about.contact' id='about-contact'}}About{{/link-to}}\n      </div>\n      {{outlet}}\n    ");
      this.addTemplate('about.contact', "\n      <h1 id='contact'>Contact</h1>\n    ");
      this.router.map(function () {
        this.route('about', function () {
          this.route('contact');
        });
      });
      var hidden = 0;
      this.add('route:about', _routing.Route.extend({
        actions: {
          hide: function () {
            hidden++;
          }
        }
      }));
      return this.visit('/about').then(function () {
        return _this26.click('#about-contact');
      }).then(function () {
        assert.equal(_this26.$('#contact').text(), 'Contact', 'precond - the link worked');
        assert.equal(hidden, 1, 'The link bubbles');
      });
    };

    _proto4["@test The {{link-to}} helper supports bubbles=false"] = function (assert) {
      var _this27 = this;

      this.addTemplate('about', "\n      <div {{action 'hide'}}>\n        {{#link-to 'about.contact' id='about-contact' bubbles=false}}\n          About\n        {{/link-to}}\n      </div>\n      {{outlet}}\n    ");
      this.addTemplate('about.contact', "<h1 id='contact'>Contact</h1>");
      this.router.map(function () {
        this.route('about', function () {
          this.route('contact');
        });
      });
      var hidden = 0;
      this.add('route:about', _routing.Route.extend({
        actions: {
          hide: function () {
            hidden++;
          }
        }
      }));
      return this.visit('/about').then(function () {
        return _this27.click('#about-contact');
      }).then(function () {
        assert.equal(_this27.$('#contact').text(), 'Contact', 'precond - the link worked');
        assert.equal(hidden, 0, "The link didn't bubble");
      });
    };

    _proto4["@test The {{link-to}} helper supports bubbles=boundFalseyThing"] = function (assert) {
      var _this28 = this;

      this.addTemplate('about', "\n      <div {{action 'hide'}}>\n        {{#link-to 'about.contact' id='about-contact' bubbles=boundFalseyThing}}\n          About\n        {{/link-to}}\n      </div>\n      {{outlet}}\n    ");
      this.addTemplate('about.contact', "<h1 id='contact'>Contact</h1>");
      this.add('controller:about', _controller.default.extend({
        boundFalseyThing: false
      }));
      this.router.map(function () {
        this.route('about', function () {
          this.route('contact');
        });
      });
      var hidden = 0;
      this.add('route:about', _routing.Route.extend({
        actions: {
          hide: function () {
            hidden++;
          }
        }
      }));
      return this.visit('/about').then(function () {
        return _this28.click('#about-contact');
      }).then(function () {
        assert.equal(_this28.$('#contact').text(), 'Contact', 'precond - the link worked');
        assert.equal(hidden, 0, "The link didn't bubble");
      });
    };

    _proto4["@test The {{link-to}} helper moves into the named route with context"] = function (assert) {
      var _this29 = this;

      this.router.map(function () {
        this.route('about');
        this.route('item', {
          path: '/item/:id'
        });
      });
      this.addTemplate('about', "\n      <h3 class=\"list\">List</h3>\n      <ul>\n        {{#each model as |person|}}\n          <li>\n            {{#link-to 'item' person id=person.id}}\n              {{person.name}}\n            {{/link-to}}\n          </li>\n        {{/each}}\n      </ul>\n      {{#link-to 'index' id='home-link'}}Home{{/link-to}}\n    ");
      this.addTemplate('item', "\n      <h3 class=\"item\">Item</h3>\n      <p>{{model.name}}</p>\n      {{#link-to 'index' id='home-link'}}Home{{/link-to}}\n    ");
      this.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      {{#link-to 'about' id='about-link'}}About{{/link-to}}\n    ");
      this.add('route:about', _routing.Route.extend({
        model: function () {
          return [{
            id: 'yehuda',
            name: 'Yehuda Katz'
          }, {
            id: 'tom',
            name: 'Tom Dale'
          }, {
            id: 'erik',
            name: 'Erik Brynroflsson'
          }];
        }
      }));
      return this.visit('/about').then(function () {
        assert.equal(_this29.$('h3.list').length, 1, 'The home template was rendered');
        assert.equal(normalizeUrl(_this29.$('#home-link').attr('href')), '/', 'The home link points back at /');
        return _this29.click('#yehuda');
      }).then(function () {
        assert.equal(_this29.$('h3.item').length, 1, 'The item template was rendered');
        assert.equal(_this29.$('p').text(), 'Yehuda Katz', 'The name is correct');
        return _this29.click('#home-link');
      }).then(function () {
        return _this29.click('#about-link');
      }).then(function () {
        assert.equal(normalizeUrl(_this29.$('li a#yehuda').attr('href')), '/item/yehuda');
        assert.equal(normalizeUrl(_this29.$('li a#tom').attr('href')), '/item/tom');
        assert.equal(normalizeUrl(_this29.$('li a#erik').attr('href')), '/item/erik');
        return _this29.click('#erik');
      }).then(function () {
        assert.equal(_this29.$('h3.item').length, 1, 'The item template was rendered');
        assert.equal(_this29.$('p').text(), 'Erik Brynroflsson', 'The name is correct');
      });
    };

    _proto4["@test The {{link-to}} helper binds some anchor html tag common attributes"] = function (assert) {
      var _this30 = this;

      this.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      {{#link-to 'index' id='self-link' title='title-attr' rel='rel-attr' tabindex='-1'}}\n        Self\n      {{/link-to}}\n    ");
      return this.visit('/').then(function () {
        var link = _this30.$('#self-link');

        assert.equal(link.attr('title'), 'title-attr', 'The self-link contains title attribute');
        assert.equal(link.attr('rel'), 'rel-attr', 'The self-link contains rel attribute');
        assert.equal(link.attr('tabindex'), '-1', 'The self-link contains tabindex attribute');
      });
    };

    _proto4["@test The {{link-to}} helper supports 'target' attribute"] = function (assert) {
      var _this31 = this;

      this.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      {{#link-to 'index' id='self-link' target='_blank'}}Self{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        var link = _this31.$('#self-link');

        assert.equal(link.attr('target'), '_blank', 'The self-link contains `target` attribute');
      });
    };

    _proto4["@test The {{link-to}} helper supports 'target' attribute specified as a bound param"] = function (assert) {
      var _this32 = this;

      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{#link-to 'index' id='self-link' target=boundLinkTarget}}Self{{/link-to}}");
      this.add('controller:index', _controller.default.extend({
        boundLinkTarget: '_blank'
      }));
      return this.visit('/').then(function () {
        var link = _this32.$('#self-link');

        assert.equal(link.attr('target'), '_blank', 'The self-link contains `target` attribute');
      });
    };

    _proto4["@test the {{link-to}} helper calls preventDefault"] = function (assert) {
      var _this33 = this;

      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n      {{#link-to 'about' id='about-link'}}About{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        assertNav({
          prevented: true
        }, function () {
          return _this33.$('#about-link').click();
        }, assert);
      });
    };

    _proto4["@test the {{link-to}} helper does not call preventDefault if 'preventDefault=false' is passed as an option"] = function (assert) {
      var _this34 = this;

      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n      {{#link-to 'about' id='about-link' preventDefault=false}}About{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        assertNav({
          prevented: false
        }, function () {
          return _this34.$('#about-link').trigger('click');
        }, assert);
      });
    };

    _proto4["@test the {{link-to}} helper does not call preventDefault if 'preventDefault=boundFalseyThing' is passed as an option"] = function (assert) {
      var _this35 = this;

      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n      {{#link-to 'about' id='about-link' preventDefault=boundFalseyThing}}About{{/link-to}}\n    ");
      this.add('controller:index', _controller.default.extend({
        boundFalseyThing: false
      }));
      return this.visit('/').then(function () {
        assertNav({
          prevented: false
        }, function () {
          return _this35.$('#about-link').trigger('click');
        }, assert);
      });
    };

    _proto4["@test The {{link-to}} helper does not call preventDefault if 'target' attribute is provided"] = function (assert) {
      var _this36 = this;

      this.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      {{#link-to 'index' id='self-link' target='_blank'}}Self{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        assertNav({
          prevented: false
        }, function () {
          return _this36.$('#self-link').click();
        }, assert);
      });
    };

    _proto4["@test The {{link-to}} helper should preventDefault when 'target = _self'"] = function (assert) {
      var _this37 = this;

      this.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      {{#link-to 'index' id='self-link' target='_self'}}Self{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        assertNav({
          prevented: true
        }, function () {
          return _this37.$('#self-link').click();
        }, assert);
      });
    };

    _proto4["@test The {{link-to}} helper should not transition if target is not equal to _self or empty"] = function (assert) {
      var _this38 = this;

      this.addTemplate('index', "\n      {{#link-to 'about' id='about-link' replace=true target='_blank'}}\n        About\n      {{/link-to}}\n    ");
      this.router.map(function () {
        this.route('about');
      });
      return this.visit('/').then(function () {
        return _this38.click('#about-link');
      }).then(function () {
        var currentRouteName = _this38.applicationInstance.lookup('controller:application').get('currentRouteName');

        assert.notEqual(currentRouteName, 'about', 'link-to should not transition if target is not equal to _self or empty');
      });
    };

    _proto4["@test The {{link-to}} helper accepts string/numeric arguments"] = function (assert) {
      var _this39 = this;

      this.router.map(function () {
        this.route('filter', {
          path: '/filters/:filter'
        });
        this.route('post', {
          path: '/post/:post_id'
        });
        this.route('repo', {
          path: '/repo/:owner/:name'
        });
      });
      this.add('controller:filter', _controller.default.extend({
        filter: 'unpopular',
        repo: {
          owner: 'ember',
          name: 'ember.js'
        },
        post_id: 123
      }));
      this.addTemplate('filter', "\n      <p>{{filter}}</p>\n      {{#link-to \"filter\" \"unpopular\" id=\"link\"}}Unpopular{{/link-to}}\n      {{#link-to \"filter\" filter id=\"path-link\"}}Unpopular{{/link-to}}\n      {{#link-to \"post\" post_id id=\"post-path-link\"}}Post{{/link-to}}\n      {{#link-to \"post\" 123 id=\"post-number-link\"}}Post{{/link-to}}\n      {{#link-to \"repo\" repo id=\"repo-object-link\"}}Repo{{/link-to}}\n    ");
      return this.visit('/filters/popular').then(function () {
        assert.equal(normalizeUrl(_this39.$('#link').attr('href')), '/filters/unpopular');
        assert.equal(normalizeUrl(_this39.$('#path-link').attr('href')), '/filters/unpopular');
        assert.equal(normalizeUrl(_this39.$('#post-path-link').attr('href')), '/post/123');
        assert.equal(normalizeUrl(_this39.$('#post-number-link').attr('href')), '/post/123');
        assert.equal(normalizeUrl(_this39.$('#repo-object-link').attr('href')), '/repo/ember/ember.js');
      });
    };

    _proto4["@test Issue 4201 - Shorthand for route.index shouldn't throw errors about context arguments"] = function (assert) {
      var _this40 = this;

      assert.expect(2);
      this.router.map(function () {
        this.route('lobby', function () {
          this.route('index', {
            path: ':lobby_id'
          });
          this.route('list');
        });
      });
      this.add('route:lobby.index', _routing.Route.extend({
        model: function (params) {
          assert.equal(params.lobby_id, 'foobar');
          return params.lobby_id;
        }
      }));
      this.addTemplate('lobby.index', "\n      {{#link-to 'lobby' 'foobar' id='lobby-link'}}Lobby{{/link-to}}\n    ");
      this.addTemplate('lobby.list', "\n      {{#link-to 'lobby' 'foobar' id='lobby-link'}}Lobby{{/link-to}}\n    ");
      return this.visit('/lobby/list').then(function () {
        return _this40.click('#lobby-link');
      }).then(function () {
        return shouldBeActive(assert, _this40.$('#lobby-link'));
      });
    };

    _proto4["@test Quoteless route param performs property lookup"] = function (assert) {
      var _this41 = this;

      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n      {{#link-to 'index' id='string-link'}}string{{/link-to}}\n      {{#link-to foo id='path-link'}}path{{/link-to}}\n    ");
      this.add('controller:index', _controller.default.extend({
        foo: 'index'
      }));

      var assertEquality = function (href) {
        assert.equal(normalizeUrl(_this41.$('#string-link').attr('href')), '/');
        assert.equal(normalizeUrl(_this41.$('#path-link').attr('href')), href);
      };

      return this.visit('/').then(function () {
        assertEquality('/');

        var controller = _this41.applicationInstance.lookup('controller:index');

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('foo', 'about');
        });
        assertEquality('/about');
      });
    };

    _proto4["@test The {{link-to}} helper refreshes href element when one of params changes"] = function (assert) {
      var _this42 = this;

      this.router.map(function () {
        this.route('post', {
          path: '/posts/:post_id'
        });
      });
      var post = {
        id: '1'
      };
      var secondPost = {
        id: '2'
      };
      this.addTemplate('index', "\n      {{#link-to \"post\" post id=\"post\"}}post{{/link-to}}\n    ");
      this.add('controller:index', _controller.default.extend());
      return this.visit('/').then(function () {
        var indexController = _this42.applicationInstance.lookup('controller:index');

        (0, _internalTestHelpers.runTask)(function () {
          return indexController.set('post', post);
        });
        assert.equal(normalizeUrl(_this42.$('#post').attr('href')), '/posts/1', 'precond - Link has rendered href attr properly');
        (0, _internalTestHelpers.runTask)(function () {
          return indexController.set('post', secondPost);
        });
        assert.equal(_this42.$('#post').attr('href'), '/posts/2', 'href attr was updated after one of the params had been changed');
        (0, _internalTestHelpers.runTask)(function () {
          return indexController.set('post', null);
        });
        assert.equal(_this42.$('#post').attr('href'), '#', 'href attr becomes # when one of the arguments in nullified');
      });
    };

    _proto4["@test The {{link-to}} helper is active when a route is active"] = function (assert) {
      var _this43 = this;

      this.router.map(function () {
        this.route('about', function () {
          this.route('item');
        });
      });
      this.addTemplate('about', "\n      <div id='about'>\n        {{#link-to 'about' id='about-link'}}About{{/link-to}}\n        {{#link-to 'about.item' id='item-link'}}Item{{/link-to}}\n        {{outlet}}\n      </div>\n    ");
      return this.visit('/about').then(function () {
        assert.equal(_this43.$('#about-link.active').length, 1, 'The about route link is active');
        assert.equal(_this43.$('#item-link.active').length, 0, 'The item route link is inactive');
        return _this43.visit('/about/item');
      }).then(function () {
        assert.equal(_this43.$('#about-link.active').length, 1, 'The about route link is active');
        assert.equal(_this43.$('#item-link.active').length, 1, 'The item route link is active');
      });
    };

    _proto4["@test The {{link-to}} helper works in an #each'd array of string route names"] = function (assert) {
      var _this44 = this;

      this.router.map(function () {
        this.route('foo');
        this.route('bar');
        this.route('rar');
      });
      this.add('controller:index', _controller.default.extend({
        routeNames: (0, _runtime.A)(['foo', 'bar', 'rar']),
        route1: 'bar',
        route2: 'foo'
      }));
      this.addTemplate('index', "\n      {{#each routeNames as |routeName|}}\n        {{#link-to routeName}}{{routeName}}{{/link-to}}\n      {{/each}}\n      {{#each routeNames as |r|}}\n        {{#link-to r}}{{r}}{{/link-to}}\n      {{/each}}\n      {{#link-to route1}}a{{/link-to}}\n      {{#link-to route2}}b{{/link-to}}\n    ");

      var linksEqual = function (links, expected) {
        assert.equal(links.length, expected.length, 'Has correct number of links');
        var idx;

        for (idx = 0; idx < links.length; idx++) {
          var href = _this44.$(links[idx]).attr('href'); // Old IE includes the whole hostname as well


          assert.equal(href.slice(-expected[idx].length), expected[idx], "Expected link to be '" + expected[idx] + "', but was '" + href + "'");
        }
      };

      return this.visit('/').then(function () {
        linksEqual(_this44.$('a'), ['/foo', '/bar', '/rar', '/foo', '/bar', '/rar', '/bar', '/foo']);

        var indexController = _this44.applicationInstance.lookup('controller:index');

        (0, _internalTestHelpers.runTask)(function () {
          return indexController.set('route1', 'rar');
        });
        linksEqual(_this44.$('a'), ['/foo', '/bar', '/rar', '/foo', '/bar', '/rar', '/rar', '/foo']);
        (0, _internalTestHelpers.runTask)(function () {
          return indexController.routeNames.shiftObject();
        });
        linksEqual(_this44.$('a'), ['/bar', '/rar', '/bar', '/rar', '/rar', '/foo']);
      });
    };

    _proto4["@test The non-block form {{link-to}} helper moves into the named route"] = function (assert) {
      var _this45 = this;

      assert.expect(3);
      this.router.map(function () {
        this.route('contact');
      });
      this.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      {{link-to 'Contact us' 'contact' id='contact-link'}}\n      {{#link-to 'index' id='self-link'}}Self{{/link-to}}\n    ");
      this.addTemplate('contact', "\n      <h3 class=\"contact\">Contact</h3>\n      {{link-to 'Home' 'index' id='home-link'}}\n      {{link-to 'Self' 'contact' id='self-link'}}\n    ");
      return this.visit('/').then(function () {
        return _this45.click('#contact-link');
      }).then(function () {
        assert.equal(_this45.$('h3.contact').length, 1, 'The contact template was rendered');
        assert.equal(_this45.$('#self-link.active').length, 1, 'The self-link was rendered with active class');
        assert.equal(_this45.$('#home-link:not(.active)').length, 1, 'The other link was rendered without active class');
      });
    };

    _proto4["@test The non-block form {{link-to}} helper updates the link text when it is a binding"] = function (assert) {
      var _this46 = this;

      assert.expect(8);
      this.router.map(function () {
        this.route('contact');
      });
      this.add('controller:index', _controller.default.extend({
        contactName: 'Jane'
      }));
      this.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      {{link-to contactName 'contact' id='contact-link'}}\n      {{#link-to 'index' id='self-link'}}Self{{/link-to}}\n    ");
      this.addTemplate('contact', "\n      <h3 class=\"contact\">Contact</h3>\n      {{link-to 'Home' 'index' id='home-link'}}\n      {{link-to 'Self' 'contact' id='self-link'}}\n    ");
      return this.visit('/').then(function () {
        assert.equal(_this46.$('#contact-link').text(), 'Jane', 'The link title is correctly resolved');

        var controller = _this46.applicationInstance.lookup('controller:index');

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('contactName', 'Joe');
        });
        assert.equal(_this46.$('#contact-link').text(), 'Joe', 'The link title is correctly updated when the bound property changes');
        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('contactName', 'Robert');
        });
        assert.equal(_this46.$('#contact-link').text(), 'Robert', 'The link title is correctly updated when the bound property changes a second time');
        return _this46.click('#contact-link');
      }).then(function () {
        assert.equal(_this46.$('h3.contact').length, 1, 'The contact template was rendered');
        assert.equal(_this46.$('#self-link.active').length, 1, 'The self-link was rendered with active class');
        assert.equal(_this46.$('#home-link:not(.active)').length, 1, 'The other link was rendered without active class');
        return _this46.click('#home-link');
      }).then(function () {
        assert.equal(_this46.$('h3.home').length, 1, 'The index template was rendered');
        assert.equal(_this46.$('#contact-link').text(), 'Robert', 'The link title is correctly updated when the route changes');
      });
    };

    _proto4["@test The non-block form {{link-to}} helper moves into the named route with context"] = function (assert) {
      var _this47 = this;

      assert.expect(5);
      this.router.map(function () {
        this.route('item', {
          path: '/item/:id'
        });
      });
      this.add('route:index', _routing.Route.extend({
        model: function () {
          return [{
            id: 'yehuda',
            name: 'Yehuda Katz'
          }, {
            id: 'tom',
            name: 'Tom Dale'
          }, {
            id: 'erik',
            name: 'Erik Brynroflsson'
          }];
        }
      }));
      this.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      <ul>\n        {{#each model as |person|}}\n          <li>\n            {{link-to person.name 'item' person id=person.id}}\n          </li>\n        {{/each}}\n      </ul>\n    ");
      this.addTemplate('item', "\n      <h3 class=\"item\">Item</h3>\n      <p>{{model.name}}</p>\n      {{#link-to 'index' id='home-link'}}Home{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        return _this47.click('#yehuda');
      }).then(function () {
        assert.equal(_this47.$('h3.item').length, 1, 'The item template was rendered');
        assert.equal(_this47.$('p').text(), 'Yehuda Katz', 'The name is correct');
        return _this47.click('#home-link');
      }).then(function () {
        assert.equal(normalizeUrl(_this47.$('li a#yehuda').attr('href')), '/item/yehuda');
        assert.equal(normalizeUrl(_this47.$('li a#tom').attr('href')), '/item/tom');
        assert.equal(normalizeUrl(_this47.$('li a#erik').attr('href')), '/item/erik');
      });
    };

    _proto4["@test The non-block form {{link-to}} performs property lookup"] = function (assert) {
      var _this48 = this;

      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n      {{link-to 'string' 'index' id='string-link'}}\n      {{link-to path foo id='path-link'}}\n    ");
      this.add('controller:index', _controller.default.extend({
        foo: 'index'
      }));
      return this.visit('/').then(function () {
        var assertEquality = function (href) {
          assert.equal(normalizeUrl(_this48.$('#string-link').attr('href')), '/');
          assert.equal(normalizeUrl(_this48.$('#path-link').attr('href')), href);
        };

        assertEquality('/');

        var controller = _this48.applicationInstance.lookup('controller:index');

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('foo', 'about');
        });
        assertEquality('/about');
      });
    };

    _proto4["@test The non-block form {{link-to}} protects against XSS"] = function (assert) {
      var _this49 = this;

      this.addTemplate('application', "{{link-to display 'index' id='link'}}");
      this.add('controller:application', _controller.default.extend({
        display: 'blahzorz'
      }));
      return this.visit('/').then(function () {
        assert.equal(_this49.$('#link').text(), 'blahzorz');

        var controller = _this49.applicationInstance.lookup('controller:application');

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('display', '<b>BLAMMO</b>');
        });
        assert.equal(_this49.$('#link').text(), '<b>BLAMMO</b>');
        assert.equal(_this49.$('b').length, 0);
      });
    };

    _proto4["@test the {{link-to}} helper throws a useful error if you invoke it wrong"] = function (assert) {
      var _this50 = this;

      assert.expect(1);
      this.router.map(function () {
        this.route('post', {
          path: 'post/:post_id'
        });
      });
      this.addTemplate('application', "{{#link-to 'post'}}Post{{/link-to}}");
      assert.throws(function () {
        _this50.visit('/');
      }, /(You attempted to define a `\{\{link-to "post"\}\}` but did not pass the parameters required for generating its dynamic segments.|You must provide param `post_id` to `generate`)/);
      return (0, _internalTestHelpers.runLoopSettled)();
    };

    _proto4["@test the {{link-to}} helper does not throw an error if its route has exited"] = function (assert) {
      var _this51 = this;

      assert.expect(0);
      this.router.map(function () {
        this.route('post', {
          path: 'post/:post_id'
        });
      });
      this.addTemplate('application', "\n      {{#link-to 'index' id='home-link'}}Home{{/link-to}}\n      {{#link-to 'post' defaultPost id='default-post-link'}}Default Post{{/link-to}}\n      {{#if currentPost}}\n        {{#link-to 'post' currentPost id='current-post-link'}}Current Post{{/link-to}}\n      {{/if}}\n    ");
      this.add('controller:application', _controller.default.extend({
        defaultPost: {
          id: 1
        },
        postController: (0, _controller.inject)('post'),
        currentPost: (0, _metal.alias)('postController.model')
      }));
      this.add('controller:post', _controller.default.extend());
      this.add('route:post', _routing.Route.extend({
        model: function () {
          return {
            id: 2
          };
        },
        serialize: function (model) {
          return {
            post_id: model.id
          };
        }
      }));
      return this.visit('/').then(function () {
        return _this51.click('#default-post-link');
      }).then(function () {
        return _this51.click('#home-link');
      }).then(function () {
        return _this51.click('#current-post-link');
      }).then(function () {
        return _this51.click('#home-link');
      });
    };

    _proto4["@test {{link-to}} active property respects changing parent route context"] = function (assert) {
      var _this52 = this;

      this.router.map(function () {
        this.route('things', {
          path: '/things/:name'
        }, function () {
          this.route('other');
        });
      });
      this.addTemplate('application', "\n      {{link-to 'OMG' 'things' 'omg' id='omg-link'}}\n      {{link-to 'LOL' 'things' 'lol' id='lol-link'}}\n    ");
      return this.visit('/things/omg').then(function () {
        shouldBeActive(assert, _this52.$('#omg-link'));
        shouldNotBeActive(assert, _this52.$('#lol-link'));
        return _this52.visit('/things/omg/other');
      }).then(function () {
        shouldBeActive(assert, _this52.$('#omg-link'));
        shouldNotBeActive(assert, _this52.$('#lol-link'));
      });
    };

    _proto4["@test {{link-to}} populates href with default query param values even without query-params object"] = function (assert) {
      var _this53 = this;

      this.add('controller:index', _controller.default.extend({
        queryParams: ['foo'],
        foo: '123'
      }));
      this.addTemplate('index', "{{#link-to 'index' id='the-link'}}Index{{/link-to}}");
      return this.visit('/').then(function () {
        assert.equal(_this53.$('#the-link').attr('href'), '/', 'link has right href');
      });
    };

    _proto4["@test {{link-to}} populates href with default query param values with empty query-params object"] = function (assert) {
      var _this54 = this;

      this.add('controller:index', _controller.default.extend({
        queryParams: ['foo'],
        foo: '123'
      }));
      this.addTemplate('index', "\n      {{#link-to 'index' (query-params) id='the-link'}}Index{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        assert.equal(_this54.$('#the-link').attr('href'), '/', 'link has right href');
      });
    };

    _proto4["@test {{link-to}} with only query-params and a block updates when route changes"] = function (assert) {
      var _this55 = this;

      this.router.map(function () {
        this.route('about');
      });
      this.add('controller:application', _controller.default.extend({
        queryParams: ['foo', 'bar'],
        foo: '123',
        bar: 'yes'
      }));
      this.addTemplate('application', "\n      {{#link-to (query-params foo='456' bar='NAW') id='the-link'}}Index{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        assert.equal(_this55.$('#the-link').attr('href'), '/?bar=NAW&foo=456', 'link has right href');
        return _this55.visit('/about');
      }).then(function () {
        assert.equal(_this55.$('#the-link').attr('href'), '/about?bar=NAW&foo=456', 'link has right href');
      });
    };

    _proto4["@test Block-less {{link-to}} with only query-params updates when route changes"] = function (assert) {
      var _this56 = this;

      this.router.map(function () {
        this.route('about');
      });
      this.add('controller:application', _controller.default.extend({
        queryParams: ['foo', 'bar'],
        foo: '123',
        bar: 'yes'
      }));
      this.addTemplate('application', "\n      {{link-to \"Index\" (query-params foo='456' bar='NAW') id='the-link'}}\n    ");
      return this.visit('/').then(function () {
        assert.equal(_this56.$('#the-link').attr('href'), '/?bar=NAW&foo=456', 'link has right href');
        return _this56.visit('/about');
      }).then(function () {
        assert.equal(_this56.$('#the-link').attr('href'), '/about?bar=NAW&foo=456', 'link has right href');
      });
    };

    _proto4["@test The {{link-to}} helper can use dynamic params"] = function (assert) {
      var _this57 = this;

      this.router.map(function () {
        this.route('foo', {
          path: 'foo/:some/:thing'
        });
        this.route('bar', {
          path: 'bar/:some/:thing/:else'
        });
      });
      this.add('controller:index', _controller.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.dynamicLinkParams = ['foo', 'one', 'two'];
        }
      }));
      this.addTemplate('index', "\n      <h3 class=\"home\">Home</h3>\n      {{#link-to params=dynamicLinkParams id=\"dynamic-link\"}}Dynamic{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        var link = _this57.$('#dynamic-link');

        assert.equal(link.attr('href'), '/foo/one/two');

        var controller = _this57.applicationInstance.lookup('controller:index');

        (0, _internalTestHelpers.runTask)(function () {
          controller.set('dynamicLinkParams', ['bar', 'one', 'two', 'three']);
        });
        assert.equal(link.attr('href'), '/bar/one/two/three');
      });
    };

    _proto4["@test GJ: {{link-to}} to a parent root model hook which performs a 'transitionTo' has correct active class #13256"] = function (assert) {
      var _this58 = this;

      assert.expect(1);
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });
      this.add('route:parent', _routing.Route.extend({
        afterModel: function () {
          this.transitionTo('parent.child');
        }
      }));
      this.addTemplate('application', "\n      {{link-to 'Parent' 'parent' id='parent-link'}}\n    ");
      return this.visit('/').then(function () {
        return _this58.click('#parent-link');
      }).then(function () {
        shouldBeActive(assert, _this58.$('#parent-link'));
      });
    };

    return _class4;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('The {{link-to}} helper - loading states and warnings',
  /*#__PURE__*/
  function (_ApplicationTestCase5) {
    (0, _emberBabel.inheritsLoose)(_class5, _ApplicationTestCase5);

    function _class5() {
      return _ApplicationTestCase5.apply(this, arguments) || this;
    }

    var _proto5 = _class5.prototype;

    _proto5["@test link-to with null/undefined dynamic parameters are put in a loading state"] = function (assert) {
      var _this59 = this;

      assert.expect(19);
      var warningMessage = 'This link-to is in an inactive loading state because at least one of its parameters presently has a null/undefined value, or the provided route name is invalid.';
      this.router.map(function () {
        this.route('thing', {
          path: '/thing/:thing_id'
        });
        this.route('about');
      });
      this.addTemplate('index', "\n      {{#link-to destinationRoute routeContext loadingClass='i-am-loading' id='context-link'}}\n        string\n      {{/link-to}}\n      {{#link-to secondRoute loadingClass=loadingClass id='static-link'}}\n        string\n      {{/link-to}}\n    ");
      this.add('controller:index', _controller.default.extend({
        destinationRoute: null,
        routeContext: null,
        loadingClass: 'i-am-loading'
      }));
      this.add('route:about', _routing.Route.extend({
        activate: function () {
          assert.ok(true, 'About was entered');
        }
      }));

      function assertLinkStatus(link, url) {
        if (url) {
          assert.equal(normalizeUrl(link.attr('href')), url, 'loaded link-to has expected href');
          assert.ok(!link.hasClass('i-am-loading'), 'loaded linkComponent has no loadingClass');
        } else {
          assert.equal(normalizeUrl(link.attr('href')), '#', "unloaded link-to has href='#'");
          assert.ok(link.hasClass('i-am-loading'), 'loading linkComponent has loadingClass');
        }
      }

      var contextLink, staticLink, controller;
      return this.visit('/').then(function () {
        contextLink = _this59.$('#context-link');
        staticLink = _this59.$('#static-link');
        controller = _this59.applicationInstance.lookup('controller:index');
        assertLinkStatus(contextLink);
        assertLinkStatus(staticLink);
        return expectWarning(function () {
          return _this59.click(contextLink[0]);
        }, warningMessage);
      }).then(function () {
        // Set the destinationRoute (context is still null).
        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('destinationRoute', 'thing');
        });
        assertLinkStatus(contextLink); // Set the routeContext to an id

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('routeContext', '456');
        });
        assertLinkStatus(contextLink, '/thing/456'); // Test that 0 isn't interpreted as falsy.

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('routeContext', 0);
        });
        assertLinkStatus(contextLink, '/thing/0'); // Set the routeContext to an object

        (0, _internalTestHelpers.runTask)(function () {
          controller.set('routeContext', {
            id: 123
          });
        });
        assertLinkStatus(contextLink, '/thing/123'); // Set the destinationRoute back to null.

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('destinationRoute', null);
        });
        assertLinkStatus(contextLink);
        return expectWarning(function () {
          return _this59.click(staticLink[0]);
        }, warningMessage);
      }).then(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('secondRoute', 'about');
        });
        assertLinkStatus(staticLink, '/about'); // Click the now-active link

        return _this59.click(staticLink[0]);
      });
    };

    return _class5;
  }(_internalTestHelpers.ApplicationTestCase));

  function assertNav(options, callback, assert) {
    var nav = false;

    function check(event) {
      assert.equal(event.defaultPrevented, options.prevented, "expected defaultPrevented=" + options.prevented);
      nav = true;
      event.preventDefault();
    }

    try {
      document.addEventListener('click', check);
      callback();
    } finally {
      document.removeEventListener('click', check);
      assert.ok(nav, 'Expected a link to be clicked');
    }
  }
});
enifed("ember/tests/helpers/link_to_test/link_to_transitioning_classes_test", ["ember-babel", "@ember/-internals/runtime", "@ember/-internals/routing", "internal-test-helpers"], function (_emberBabel, _runtime, _routing, _internalTestHelpers) {
  "use strict";

  function assertHasClass(assert, selector, label) {
    var testLabel = selector.attr('id') + " should have class " + label;
    assert.equal(selector.hasClass(label), true, testLabel);
  }

  function assertHasNoClass(assert, selector, label) {
    var testLabel = selector.attr('id') + " should not have class " + label;
    assert.equal(selector.hasClass(label), false, testLabel);
  }

  (0, _internalTestHelpers.moduleFor)('The {{link-to}} helper: .transitioning-in .transitioning-out CSS classes',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this2;

      _this2 = _ApplicationTestCase.call(this) || this;
      _this2.aboutDefer = _runtime.RSVP.defer();
      _this2.otherDefer = _runtime.RSVP.defer();
      _this2.newsDefer = _runtime.RSVP.defer();

      var _this = (0, _emberBabel.assertThisInitialized)((0, _emberBabel.assertThisInitialized)(_this2));

      _this2.router.map(function () {
        this.route('about');
        this.route('other');
        this.route('news');
      });

      _this2.add('route:about', _routing.Route.extend({
        model: function () {
          return _this.aboutDefer.promise;
        }
      }));

      _this2.add('route:other', _routing.Route.extend({
        model: function () {
          return _this.otherDefer.promise;
        }
      }));

      _this2.add('route:news', _routing.Route.extend({
        model: function () {
          return _this.newsDefer.promise;
        }
      }));

      _this2.addTemplate('application', "\n      {{outlet}}\n      {{link-to 'Index' 'index' id='index-link'}}\n      {{link-to 'About' 'about' id='about-link'}}\n      {{link-to 'Other' 'other' id='other-link'}}\n      {{link-to 'News' 'news' activeClass=false id='news-link'}}\n    ");

      return _this2;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      return this.visit('/');
    };

    _proto.afterEach = function afterEach() {
      _ApplicationTestCase.prototype.afterEach.call(this);

      this.aboutDefer = null;
      this.otherDefer = null;
      this.newsDefer = null;
    };

    _proto['@test while a transition is underway'] = function testWhileATransitionIsUnderway(assert) {
      var _this3 = this;

      var $index = this.$('#index-link');
      var $about = this.$('#about-link');
      var $other = this.$('#other-link');
      $about.click();
      assertHasClass(assert, $index, 'active');
      assertHasNoClass(assert, $about, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.aboutDefer.resolve();
      });
      assertHasNoClass(assert, $index, 'active');
      assertHasClass(assert, $about, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasNoClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
    };

    _proto['@test while a transition is underway with activeClass is false'] = function testWhileATransitionIsUnderwayWithActiveClassIsFalse(assert) {
      var _this4 = this;

      var $index = this.$('#index-link');
      var $news = this.$('#news-link');
      var $other = this.$('#other-link');
      $news.click();
      assertHasClass(assert, $index, 'active');
      assertHasNoClass(assert, $news, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasClass(assert, $news, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $news, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.newsDefer.resolve();
      });
      assertHasNoClass(assert, $index, 'active');
      assertHasNoClass(assert, $news, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasNoClass(assert, $news, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $news, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)("The {{link-to}} helper: .transitioning-in .transitioning-out CSS classes - nested link-to's",
  /*#__PURE__*/
  function (_ApplicationTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase2);

    function _class2() {
      var _this5;

      _this5 = _ApplicationTestCase2.call(this) || this;
      _this5.aboutDefer = _runtime.RSVP.defer();
      _this5.otherDefer = _runtime.RSVP.defer();

      var _this = (0, _emberBabel.assertThisInitialized)((0, _emberBabel.assertThisInitialized)(_this5));

      _this5.router.map(function () {
        this.route('parent-route', function () {
          this.route('about');
          this.route('other');
        });
      });

      _this5.add('route:parent-route.about', _routing.Route.extend({
        model: function () {
          return _this.aboutDefer.promise;
        }
      }));

      _this5.add('route:parent-route.other', _routing.Route.extend({
        model: function () {
          return _this.otherDefer.promise;
        }
      }));

      _this5.addTemplate('application', "\n      {{outlet}}\n      {{#link-to 'index' tagName='li'}}\n        {{link-to 'Index' 'index' id='index-link'}}\n      {{/link-to}}\n      {{#link-to 'parent-route.about' tagName='li'}}\n        {{link-to 'About' 'parent-route.about' id='about-link'}}\n      {{/link-to}}\n      {{#link-to 'parent-route.other' tagName='li'}}\n        {{link-to 'Other' 'parent-route.other' id='other-link'}}\n      {{/link-to}}\n    ");

      return _this5;
    }

    var _proto2 = _class2.prototype;

    _proto2.beforeEach = function beforeEach() {
      return this.visit('/');
    };

    _proto2.resolveAbout = function resolveAbout() {
      var _this6 = this;

      return (0, _internalTestHelpers.runTask)(function () {
        _this6.aboutDefer.resolve();

        _this6.aboutDefer = _runtime.RSVP.defer();
      });
    };

    _proto2.resolveOther = function resolveOther() {
      var _this7 = this;

      return (0, _internalTestHelpers.runTask)(function () {
        _this7.otherDefer.resolve();

        _this7.otherDefer = _runtime.RSVP.defer();
      });
    };

    _proto2.teardown = function teardown() {
      _ApplicationTestCase2.prototype.teardown.call(this);

      this.aboutDefer = null;
      this.otherDefer = null;
    };

    _proto2["@test while a transition is underway with nested link-to's"] = function (assert) {
      // TODO undo changes to this test but currently this test navigates away if navigation
      // outlet is not stable and the second $about.click() is triggered.
      var $about = this.$('#about-link');
      $about.click();
      var $index = this.$('#index-link');
      $about = this.$('#about-link');
      var $other = this.$('#other-link');
      assertHasClass(assert, $index, 'active');
      assertHasNoClass(assert, $about, 'active');
      assertHasNoClass(assert, $about, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
      this.resolveAbout();
      $index = this.$('#index-link');
      $about = this.$('#about-link');
      $other = this.$('#other-link');
      assertHasNoClass(assert, $index, 'active');
      assertHasClass(assert, $about, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasNoClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
      $other.click();
      $index = this.$('#index-link');
      $about = this.$('#about-link');
      $other = this.$('#other-link');
      assertHasNoClass(assert, $index, 'active');
      assertHasClass(assert, $about, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasNoClass(assert, $about, 'ember-transitioning-in');
      assertHasClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
      this.resolveOther();
      $index = this.$('#index-link');
      $about = this.$('#about-link');
      $other = this.$('#other-link');
      assertHasNoClass(assert, $index, 'active');
      assertHasNoClass(assert, $about, 'active');
      assertHasClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasNoClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
      $about.click();
      $index = this.$('#index-link');
      $about = this.$('#about-link');
      $other = this.$('#other-link');
      assertHasNoClass(assert, $index, 'active');
      assertHasNoClass(assert, $about, 'active');
      assertHasClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasClass(assert, $other, 'ember-transitioning-out');
      this.resolveAbout();
      $index = this.$('#index-link');
      $about = this.$('#about-link');
      $other = this.$('#other-link');
      assertHasNoClass(assert, $index, 'active');
      assertHasClass(assert, $about, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasNoClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
    };

    return _class2;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/helpers/link_to_test/link_to_with_query_params_test", ["ember-babel", "@ember/controller", "@ember/-internals/runtime", "@ember/-internals/routing", "internal-test-helpers"], function (_emberBabel, _controller, _runtime, _routing, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('The {{link-to}} helper: invoking with query params',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.call(this) || this;
      var indexProperties = {
        foo: '123',
        bar: 'abc'
      };

      _this.add('controller:index', _controller.default.extend({
        queryParams: ['foo', 'bar', 'abool'],
        foo: indexProperties.foo,
        bar: indexProperties.bar,
        boundThing: 'OMG',
        abool: true
      }));

      _this.add('controller:about', _controller.default.extend({
        queryParams: ['baz', 'bat'],
        baz: 'alex',
        bat: 'borf'
      }));

      _this.indexProperties = indexProperties;
      return _this;
    }

    var _proto = _class.prototype;

    _proto.shouldNotBeActive = function shouldNotBeActive(assert, selector) {
      this.checkActive(assert, selector, false);
    };

    _proto.shouldBeActive = function shouldBeActive(assert, selector) {
      this.checkActive(assert, selector, true);
    };

    _proto.getController = function getController(name) {
      return this.applicationInstance.lookup("controller:" + name);
    };

    _proto.checkActive = function checkActive(assert, selector, active) {
      var classList = this.$(selector)[0].className;
      assert.equal(classList.indexOf('active') > -1, active, selector + ' active should be ' + active.toString());
    };

    _proto["@test doesn't update controller QP properties on current route when invoked"] = function (assert) {
      var _this2 = this;

      this.addTemplate('index', "\n      {{#link-to 'index' id='the-link'}}Index{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        _this2.click('#the-link');

        var indexController = _this2.getController('index');

        assert.deepEqual(indexController.getProperties('foo', 'bar'), _this2.indexProperties, 'controller QP properties do not update');
      });
    };

    _proto["@test doesn't update controller QP properties on current route when invoked (empty query-params obj)"] = function (assert) {
      var _this3 = this;

      this.addTemplate('index', "\n      {{#link-to 'index' (query-params) id='the-link'}}Index{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        _this3.click('#the-link');

        var indexController = _this3.getController('index');

        assert.deepEqual(indexController.getProperties('foo', 'bar'), _this3.indexProperties, 'controller QP properties do not update');
      });
    };

    _proto["@test doesn't update controller QP properties on current route when invoked (empty query-params obj, inferred route)"] = function (assert) {
      var _this4 = this;

      this.addTemplate('index', "\n      {{#link-to (query-params) id='the-link'}}Index{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        _this4.click('#the-link');

        var indexController = _this4.getController('index');

        assert.deepEqual(indexController.getProperties('foo', 'bar'), _this4.indexProperties, 'controller QP properties do not update');
      });
    };

    _proto['@test updates controller QP properties on current route when invoked'] = function testUpdatesControllerQPPropertiesOnCurrentRouteWhenInvoked(assert) {
      var _this5 = this;

      this.addTemplate('index', "\n      {{#link-to 'index' (query-params foo='456') id=\"the-link\"}}\n        Index\n      {{/link-to}}\n    ");
      return this.visit('/').then(function () {
        _this5.click('#the-link');

        var indexController = _this5.getController('index');

        assert.deepEqual(indexController.getProperties('foo', 'bar'), {
          foo: '456',
          bar: 'abc'
        }, 'controller QP properties updated');
      });
    };

    _proto['@test updates controller QP properties on current route when invoked (inferred route)'] = function testUpdatesControllerQPPropertiesOnCurrentRouteWhenInvokedInferredRoute(assert) {
      var _this6 = this;

      this.addTemplate('index', "\n      {{#link-to (query-params foo='456') id=\"the-link\"}}\n        Index\n      {{/link-to}}\n    ");
      return this.visit('/').then(function () {
        _this6.click('#the-link');

        var indexController = _this6.getController('index');

        assert.deepEqual(indexController.getProperties('foo', 'bar'), {
          foo: '456',
          bar: 'abc'
        }, 'controller QP properties updated');
      });
    };

    _proto['@test updates controller QP properties on other route after transitioning to that route'] = function testUpdatesControllerQPPropertiesOnOtherRouteAfterTransitioningToThatRoute(assert) {
      var _this7 = this;

      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n      {{#link-to 'about' (query-params baz='lol') id='the-link'}}\n        About\n      {{/link-to}}\n    ");
      return this.visit('/').then(function () {
        var theLink = _this7.$('#the-link');

        assert.equal(theLink.attr('href'), '/about?baz=lol');
        (0, _internalTestHelpers.runTask)(function () {
          return _this7.click('#the-link');
        });

        var aboutController = _this7.getController('about');

        assert.deepEqual(aboutController.getProperties('baz', 'bat'), {
          baz: 'lol',
          bat: 'borf'
        }, 'about controller QP properties updated');
      });
    };

    _proto['@test supplied QP properties can be bound'] = function testSuppliedQPPropertiesCanBeBound(assert) {
      var _this8 = this;

      this.addTemplate('index', "\n      {{#link-to (query-params foo=boundThing) id='the-link'}}Index{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        var indexController = _this8.getController('index');

        var theLink = _this8.$('#the-link');

        assert.equal(theLink.attr('href'), '/?foo=OMG');
        (0, _internalTestHelpers.runTask)(function () {
          return indexController.set('boundThing', 'ASL');
        });
        assert.equal(theLink.attr('href'), '/?foo=ASL');
      });
    };

    _proto['@test supplied QP properties can be bound (booleans)'] = function testSuppliedQPPropertiesCanBeBoundBooleans(assert) {
      var _this9 = this;

      this.addTemplate('index', "\n      {{#link-to (query-params abool=boundThing) id='the-link'}}\n        Index\n      {{/link-to}}\n    ");
      return this.visit('/').then(function () {
        var indexController = _this9.getController('index');

        var theLink = _this9.$('#the-link');

        assert.equal(theLink.attr('href'), '/?abool=OMG');
        (0, _internalTestHelpers.runTask)(function () {
          return indexController.set('boundThing', false);
        });
        assert.equal(theLink.attr('href'), '/?abool=false');

        _this9.click('#the-link');

        assert.deepEqual(indexController.getProperties('foo', 'bar', 'abool'), {
          foo: '123',
          bar: 'abc',
          abool: false
        }, 'bound bool QP properties update');
      });
    };

    _proto['@test href updates when unsupplied controller QP props change'] = function testHrefUpdatesWhenUnsuppliedControllerQPPropsChange(assert) {
      var _this10 = this;

      this.addTemplate('index', "\n      {{#link-to (query-params foo='lol') id='the-link'}}Index{{/link-to}}\n    ");
      return this.visit('/').then(function () {
        var indexController = _this10.getController('index');

        var theLink = _this10.$('#the-link');

        assert.equal(theLink.attr('href'), '/?foo=lol');
        (0, _internalTestHelpers.runTask)(function () {
          return indexController.set('bar', 'BORF');
        });
        assert.equal(theLink.attr('href'), '/?bar=BORF&foo=lol');
        (0, _internalTestHelpers.runTask)(function () {
          return indexController.set('foo', 'YEAH');
        });
        assert.equal(theLink.attr('href'), '/?bar=BORF&foo=lol');
      });
    };

    _proto['@test The {{link-to}} with only query params always transitions to the current route with the query params applied'] = function testTheLinkToWithOnlyQueryParamsAlwaysTransitionsToTheCurrentRouteWithTheQueryParamsApplied(assert) {
      var _this11 = this; // Test harness for bug #12033


      this.addTemplate('cars', "\n      {{#link-to 'cars.create' id='create-link'}}Create new car{{/link-to}}\n      {{#link-to (query-params page='2') id='page2-link'}}Page 2{{/link-to}}\n      {{outlet}}\n    ");
      this.addTemplate('cars.create', "{{#link-to 'cars' id='close-link'}}Close create form{{/link-to}}");
      this.router.map(function () {
        this.route('cars', function () {
          this.route('create');
        });
      });
      this.add('controller:cars', _controller.default.extend({
        queryParams: ['page'],
        page: 1
      }));
      return this.visit('/cars/create').then(function () {
        var router = _this11.appRouter;

        var carsController = _this11.getController('cars');

        assert.equal(router.currentRouteName, 'cars.create');
        (0, _internalTestHelpers.runTask)(function () {
          return _this11.click('#close-link');
        });
        assert.equal(router.currentRouteName, 'cars.index');
        assert.equal(router.get('url'), '/cars');
        assert.equal(carsController.get('page'), 1, 'The page query-param is 1');
        (0, _internalTestHelpers.runTask)(function () {
          return _this11.click('#page2-link');
        });
        assert.equal(router.currentRouteName, 'cars.index', 'The active route is still cars');
        assert.equal(router.get('url'), '/cars?page=2', 'The url has been updated');
        assert.equal(carsController.get('page'), 2, 'The query params have been updated');
      });
    };

    _proto['@test the {{link-to}} applies activeClass when query params are not changed'] = function testTheLinkToAppliesActiveClassWhenQueryParamsAreNotChanged(assert) {
      var _this12 = this;

      this.addTemplate('index', "\n      {{#link-to (query-params foo='cat') id='cat-link'}}Index{{/link-to}}\n      {{#link-to (query-params foo='dog') id='dog-link'}}Index{{/link-to}}\n      {{#link-to 'index' id='change-nothing'}}Index{{/link-to}}\n    ");
      this.addTemplate('search', "\n      {{#link-to (query-params search='same') id='same-search'}}Index{{/link-to}}\n      {{#link-to (query-params search='change') id='change-search'}}Index{{/link-to}}\n      {{#link-to (query-params search='same' archive=true) id='same-search-add-archive'}}Index{{/link-to}}\n      {{#link-to (query-params archive=true) id='only-add-archive'}}Index{{/link-to}}\n      {{#link-to (query-params search='same' archive=true) id='both-same'}}Index{{/link-to}}\n      {{#link-to (query-params search='different' archive=true) id='change-one'}}Index{{/link-to}}\n      {{#link-to (query-params search='different' archive=false) id='remove-one'}}Index{{/link-to}}\n      {{outlet}}\n    ");
      this.addTemplate('search.results', "\n      {{#link-to (query-params sort='title') id='same-sort-child-only'}}Index{{/link-to}}\n      {{#link-to (query-params search='same') id='same-search-parent-only'}}Index{{/link-to}}\n      {{#link-to (query-params search='change') id='change-search-parent-only'}}Index{{/link-to}}\n      {{#link-to (query-params search='same' sort='title') id='same-search-same-sort-child-and-parent'}}Index{{/link-to}}\n      {{#link-to (query-params search='same' sort='author') id='same-search-different-sort-child-and-parent'}}Index{{/link-to}}\n      {{#link-to (query-params search='change' sort='title') id='change-search-same-sort-child-and-parent'}}Index{{/link-to}}\n      {{#link-to (query-params foo='dog') id='dog-link'}}Index{{/link-to}}\n    ");
      this.router.map(function () {
        this.route('search', function () {
          this.route('results');
        });
      });
      this.add('controller:search', _controller.default.extend({
        queryParams: ['search', 'archive'],
        search: '',
        archive: false
      }));
      this.add('controller:search.results', _controller.default.extend({
        queryParams: ['sort', 'showDetails'],
        sort: 'title',
        showDetails: true
      }));
      return this.visit('/').then(function () {
        _this12.shouldNotBeActive(assert, '#cat-link');

        _this12.shouldNotBeActive(assert, '#dog-link');

        return _this12.visit('/?foo=cat');
      }).then(function () {
        _this12.shouldBeActive(assert, '#cat-link');

        _this12.shouldNotBeActive(assert, '#dog-link');

        return _this12.visit('/?foo=dog');
      }).then(function () {
        _this12.shouldBeActive(assert, '#dog-link');

        _this12.shouldNotBeActive(assert, '#cat-link');

        _this12.shouldBeActive(assert, '#change-nothing');

        return _this12.visit('/search?search=same');
      }).then(function () {
        _this12.shouldBeActive(assert, '#same-search');

        _this12.shouldNotBeActive(assert, '#change-search');

        _this12.shouldNotBeActive(assert, '#same-search-add-archive');

        _this12.shouldNotBeActive(assert, '#only-add-archive');

        _this12.shouldNotBeActive(assert, '#remove-one');

        return _this12.visit('/search?search=same&archive=true');
      }).then(function () {
        _this12.shouldBeActive(assert, '#both-same');

        _this12.shouldNotBeActive(assert, '#change-one');

        return _this12.visit('/search/results?search=same&sort=title&showDetails=true');
      }).then(function () {
        _this12.shouldBeActive(assert, '#same-sort-child-only');

        _this12.shouldBeActive(assert, '#same-search-parent-only');

        _this12.shouldNotBeActive(assert, '#change-search-parent-only');

        _this12.shouldBeActive(assert, '#same-search-same-sort-child-and-parent');

        _this12.shouldNotBeActive(assert, '#same-search-different-sort-child-and-parent');

        _this12.shouldNotBeActive(assert, '#change-search-same-sort-child-and-parent');
      });
    };

    _proto['@test the {{link-to}} applies active class when query-param is a number'] = function testTheLinkToAppliesActiveClassWhenQueryParamIsANumber(assert) {
      var _this13 = this;

      this.addTemplate('index', "\n      {{#link-to (query-params page=pageNumber) id='page-link'}}\n        Index\n      {{/link-to}}\n    ");
      this.add('controller:index', _controller.default.extend({
        queryParams: ['page'],
        page: 1,
        pageNumber: 5
      }));
      return this.visit('/').then(function () {
        _this13.shouldNotBeActive(assert, '#page-link');

        return _this13.visit('/?page=5');
      }).then(function () {
        _this13.shouldBeActive(assert, '#page-link');
      });
    };

    _proto['@test the {{link-to}} applies active class when query-param is an array'] = function testTheLinkToAppliesActiveClassWhenQueryParamIsAnArray(assert) {
      var _this14 = this;

      this.addTemplate('index', "\n      {{#link-to (query-params pages=pagesArray) id='array-link'}}Index{{/link-to}}\n      {{#link-to (query-params pages=biggerArray) id='bigger-link'}}Index{{/link-to}}\n      {{#link-to (query-params pages=emptyArray) id='empty-link'}}Index{{/link-to}}\n    ");
      this.add('controller:index', _controller.default.extend({
        queryParams: ['pages'],
        pages: [],
        pagesArray: [1, 2],
        biggerArray: [1, 2, 3],
        emptyArray: []
      }));
      return this.visit('/').then(function () {
        _this14.shouldNotBeActive(assert, '#array-link');

        return _this14.visit('/?pages=%5B1%2C2%5D');
      }).then(function () {
        _this14.shouldBeActive(assert, '#array-link');

        _this14.shouldNotBeActive(assert, '#bigger-link');

        _this14.shouldNotBeActive(assert, '#empty-link');

        return _this14.visit('/?pages=%5B2%2C1%5D');
      }).then(function () {
        _this14.shouldNotBeActive(assert, '#array-link');

        _this14.shouldNotBeActive(assert, '#bigger-link');

        _this14.shouldNotBeActive(assert, '#empty-link');

        return _this14.visit('/?pages=%5B1%2C2%2C3%5D');
      }).then(function () {
        _this14.shouldBeActive(assert, '#bigger-link');

        _this14.shouldNotBeActive(assert, '#array-link');

        _this14.shouldNotBeActive(assert, '#empty-link');
      });
    };

    _proto['@test the {{link-to}} helper applies active class to the parent route'] = function testTheLinkToHelperAppliesActiveClassToTheParentRoute(assert) {
      var _this15 = this;

      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });
      this.addTemplate('application', "\n      {{#link-to 'parent' id='parent-link'}}Parent{{/link-to}}\n      {{#link-to 'parent.child' id='parent-child-link'}}Child{{/link-to}}\n      {{#link-to 'parent' (query-params foo=cat) id='parent-link-qp'}}Parent{{/link-to}}\n      {{outlet}}\n    ");
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['foo'],
        foo: 'bar'
      }));
      return this.visit('/').then(function () {
        _this15.shouldNotBeActive(assert, '#parent-link');

        _this15.shouldNotBeActive(assert, '#parent-child-link');

        _this15.shouldNotBeActive(assert, '#parent-link-qp');

        return _this15.visit('/parent/child?foo=dog');
      }).then(function () {
        _this15.shouldBeActive(assert, '#parent-link');

        _this15.shouldNotBeActive(assert, '#parent-link-qp');
      });
    };

    _proto['@test The {{link-to}} helper disregards query-params in activeness computation when current-when is specified'] = function testTheLinkToHelperDisregardsQueryParamsInActivenessComputationWhenCurrentWhenIsSpecified(assert) {
      var _this16 = this;

      var appLink;
      this.router.map(function () {
        this.route('parent');
      });
      this.addTemplate('application', "\n      {{#link-to 'parent' (query-params page=1) current-when='parent' id='app-link'}}\n        Parent\n      {{/link-to}}\n      {{outlet}}\n    ");
      this.addTemplate('parent', "\n      {{#link-to 'parent' (query-params page=1) current-when='parent' id='parent-link'}}\n        Parent\n      {{/link-to}}\n      {{outlet}}\n    ");
      this.add('controller:parent', _controller.default.extend({
        queryParams: ['page'],
        page: 1
      }));
      return this.visit('/').then(function () {
        appLink = _this16.$('#app-link');
        assert.equal(appLink.attr('href'), '/parent');

        _this16.shouldNotBeActive(assert, '#app-link');

        return _this16.visit('/parent?page=2');
      }).then(function () {
        appLink = _this16.$('#app-link');
        var router = _this16.appRouter;
        assert.equal(appLink.attr('href'), '/parent');

        _this16.shouldBeActive(assert, '#app-link');

        assert.equal(_this16.$('#parent-link').attr('href'), '/parent');

        _this16.shouldBeActive(assert, '#parent-link');

        var parentController = _this16.getController('parent');

        assert.equal(parentController.get('page'), 2);
        (0, _internalTestHelpers.runTask)(function () {
          return parentController.set('page', 3);
        });
        assert.equal(router.get('location.path'), '/parent?page=3');

        _this16.shouldBeActive(assert, '#app-link');

        _this16.shouldBeActive(assert, '#parent-link');

        (0, _internalTestHelpers.runTask)(function () {
          return _this16.click('#app-link');
        });
        assert.equal(router.get('location.path'), '/parent');
      });
    };

    _proto['@test link-to default query params while in active transition regression test'] = function testLinkToDefaultQueryParamsWhileInActiveTransitionRegressionTest(assert) {
      var _this17 = this;

      this.router.map(function () {
        this.route('foos');
        this.route('bars');
      });

      var foos = _runtime.RSVP.defer();

      var bars = _runtime.RSVP.defer();

      this.addTemplate('application', "\n      {{link-to 'Foos' 'foos' id='foos-link'}}\n      {{link-to 'Baz Foos' 'foos' (query-params baz=true) id='baz-foos-link'}}\n      {{link-to 'Quux Bars' 'bars' (query-params quux=true) id='bars-link'}}\n    ");
      this.add('controller:foos', _controller.default.extend({
        queryParams: ['status'],
        baz: false
      }));
      this.add('route:foos', _routing.Route.extend({
        model: function () {
          return foos.promise;
        }
      }));
      this.add('controller:bars', _controller.default.extend({
        queryParams: ['status'],
        quux: false
      }));
      this.add('route:bars', _routing.Route.extend({
        model: function () {
          return bars.promise;
        }
      }));
      return this.visit('/').then(function () {
        var router = _this17.appRouter;

        var foosLink = _this17.$('#foos-link');

        var barsLink = _this17.$('#bars-link');

        var bazLink = _this17.$('#baz-foos-link');

        assert.equal(foosLink.attr('href'), '/foos');
        assert.equal(bazLink.attr('href'), '/foos?baz=true');
        assert.equal(barsLink.attr('href'), '/bars?quux=true');
        assert.equal(router.get('location.path'), '/');

        _this17.shouldNotBeActive(assert, '#foos-link');

        _this17.shouldNotBeActive(assert, '#baz-foos-link');

        _this17.shouldNotBeActive(assert, '#bars-link');

        (0, _internalTestHelpers.runTask)(function () {
          return barsLink.click();
        });

        _this17.shouldNotBeActive(assert, '#bars-link');

        (0, _internalTestHelpers.runTask)(function () {
          return foosLink.click();
        });

        _this17.shouldNotBeActive(assert, '#foos-link');

        (0, _internalTestHelpers.runTask)(function () {
          return foos.resolve();
        });
        assert.equal(router.get('location.path'), '/foos');

        _this17.shouldBeActive(assert, '#foos-link');
      });
    };

    _proto["@test the {{link-to}} helper throws a useful error if you invoke it wrong"] = function (assert) {
      var _this18 = this;

      assert.expect(1);
      this.addTemplate('application', "{{#link-to id='the-link'}}Index{{/link-to}}");
      expectAssertion(function () {
        _this18.visit('/');
      }, /You must provide one or more parameters to the link-to component/);
      return (0, _internalTestHelpers.runLoopSettled)();
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/homepage_example_test", ["ember-babel", "@ember/-internals/routing", "@ember/-internals/metal", "@ember/-internals/runtime", "internal-test-helpers"], function (_emberBabel, _routing, _metal, _runtime, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('The example renders correctly',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Render index template into application outlet'] = function testRenderIndexTemplateIntoApplicationOutlet(assert) {
      var _this = this;

      this.addTemplate('application', '{{outlet}}');
      this.addTemplate('index', '<h1>People</h1><ul>{{#each model as |person|}}<li>Hello, <b>{{person.fullName}}</b>!</li>{{/each}}</ul>');

      var Person = _runtime.Object.extend({
        firstName: null,
        lastName: null,
        fullName: (0, _metal.computed)('firstName', 'lastName', function () {
          return this.get('firstName') + " " + this.get('lastName');
        })
      });

      this.add('route:index', _routing.Route.extend({
        model: function () {
          return (0, _runtime.A)([Person.create({
            firstName: 'Tom',
            lastName: 'Dale'
          }), Person.create({
            firstName: 'Yehuda',
            lastName: 'Katz'
          })]);
        }
      }));
      return this.visit('/').then(function () {
        var $ = _this.$();

        assert.equal($.findAll('h1').text(), 'People');
        assert.equal($.findAll('li').length, 2);
        assert.equal($.findAll('li:nth-of-type(1)').text(), 'Hello, Tom Dale!');
        assert.equal($.findAll('li:nth-of-type(2)').text(), 'Hello, Yehuda Katz!');
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/integration/multiple-app-test", ["ember-babel", "internal-test-helpers", "@ember/application", "@ember/-internals/glimmer", "@ember/-internals/owner", "@ember/polyfills", "rsvp"], function (_emberBabel, _internalTestHelpers, _application, _glimmer, _owner, _polyfills, _rsvp) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('View Integration',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      document.getElementById('qunit-fixture').innerHTML = "\n      <div id=\"one\"></div>\n      <div id=\"two\"></div>\n    ";
      _this = _ApplicationTestCase.call(this) || this;
      (0, _internalTestHelpers.runTask)(function () {
        _this.createSecondApplication();
      });
      return _this;
    }

    var _proto = _class.prototype;

    _proto.createSecondApplication = function createSecondApplication(options) {
      var applicationOptions = this.applicationOptions;
      var secondApplicationOptions = {
        rootElement: '#two'
      };
      var myOptions = (0, _polyfills.assign)(applicationOptions, secondApplicationOptions, options);
      this.secondApp = _application.default.create(myOptions);
      this.secondResolver = this.secondApp.__registry__.resolver;
      return this.secondApp;
    };

    _proto.teardown = function teardown() {
      var _this2 = this;

      _ApplicationTestCase.prototype.teardown.call(this);

      if (this.secondApp) {
        (0, _internalTestHelpers.runTask)(function () {
          _this2.secondApp.destroy();
        });
      }
    };

    _proto.addFactoriesToResolver = function addFactoriesToResolver(actions, resolver) {
      resolver.add('component:special-button', _glimmer.Component.extend({
        actions: {
          doStuff: function () {
            var rootElement = (0, _owner.getOwner)(this).application.rootElement;
            actions.push(rootElement);
          }
        }
      }));
      resolver.add('template:index', this.compile("\n        <h1>Node 1</h1>{{special-button}}\n      ", {
        moduleName: 'my-app/templates/index.hbs'
      }));
      resolver.add('template:components/special-button', this.compile("\n        <button class='do-stuff' {{action 'doStuff'}}>Button</button>\n      ", {
        moduleName: 'my-app/templates/components/special-button.hbs'
      }));
    };

    _proto["@test booting multiple applications can properly handle events"] = function (assert) {
      var _this3 = this;

      var actions = [];
      this.addFactoriesToResolver(actions, this.resolver);
      this.addFactoriesToResolver(actions, this.secondResolver);
      return (0, _rsvp.resolve)().then(function () {
        return _this3.application.visit('/');
      }).then(function () {
        return _this3.secondApp.visit('/');
      }).then(function () {
        document.querySelector('#two .do-stuff').click();
        document.querySelector('#one .do-stuff').click();
        assert.deepEqual(actions, ['#two', '#one']);
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_ApplicationTestCase.prototype.applicationOptions, {
          rootElement: '#one',
          router: null
        });
      }
    }]);
    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/production_build_test", ["ember-babel", "@ember/debug", "internal-test-helpers"], function (_emberBabel, _debug, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('production builds',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test assert does not throw in production builds'] = function testAssertDoesNotThrowInProductionBuilds(assert) {
      if (!false
      /* DEBUG */
      ) {
          assert.expect(1);

          try {
            false && !false && (0, _debug.assert)('Should not throw');
            assert.ok(true, 'Ember.assert did not throw');
          } catch (e) {
            assert.ok(false, "Expected assert not to throw but it did: " + e.message);
          }
        } else {
        assert.expect(0);
      }
    };

    _proto['@test runInDebug does not run the callback in production builds'] = function testRunInDebugDoesNotRunTheCallbackInProductionBuilds(assert) {
      if (!false
      /* DEBUG */
      ) {
          var fired = false;
          (0, _debug.runInDebug)(function () {
            return fired = true;
          });
          assert.equal(fired, false, 'runInDebug callback should not be ran');
        } else {
        assert.expect(0);
      }
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember/tests/reexports_test", ["ember-babel", "ember/index", "@ember/canary-features", "internal-test-helpers", "@ember/-internals/views"], function (_emberBabel, _index, _canaryFeatures, _internalTestHelpers, _views) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember reexports',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto["@test Ember exports correctly"] = function (assert) {
      allExports.forEach(function (reexport) {
        var path = reexport[0],
            moduleId = reexport[1],
            exportName = reexport[2]; // default path === exportName if none present

        if (!exportName) {
          exportName = path;
        }

        (0, _internalTestHelpers.confirmExport)(_index.default, assert, path, moduleId, exportName, "Ember." + path + " exports correctly");
      });
    };

    _proto['@test Ember.String.isHTMLSafe exports correctly'] = function testEmberStringIsHTMLSafeExportsCorrectly(assert) {
      (0, _internalTestHelpers.confirmExport)(_index.default, assert, 'String.isHTMLSafe', '@ember/-internals/glimmer', 'isHTMLSafe');
    };

    _proto['@test Ember.EXTEND_PROTOTYPES is present (but deprecated)'] = function testEmberEXTEND_PROTOTYPESIsPresentButDeprecated(assert) {
      expectDeprecation(function () {
        assert.strictEqual(_index.default.ENV.EXTEND_PROTOTYPES, _index.default.EXTEND_PROTOTYPES, 'Ember.EXTEND_PROTOTYPES exists');
      }, /EXTEND_PROTOTYPES is deprecated/);
    };

    _proto['@test Ember.NAME_KEY is deprecated'] = function testEmberNAME_KEYIsDeprecated() {
      expectDeprecation(function () {
        _index.default.NAME_KEY;
      }, 'Using `Ember.NAME_KEY` is deprecated, override `.toString` instead');
    };

    _proto['@test Ember.FEATURES is exported'] = function testEmberFEATURESIsExported(assert) {
      for (var feature in _canaryFeatures.FEATURES) {
        assert.equal(_index.default.FEATURES[feature], _canaryFeatures.FEATURES[feature], 'Ember.FEATURES contains ${feature} with correct value');
      }
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  var allExports = [// @ember/-internals/environment
  ['ENV', '@ember/-internals/environment', {
    get: 'getENV'
  }], ['lookup', '@ember/-internals/environment', {
    get: 'getLookup',
    set: 'setLookup'
  }], ['getOwner', '@ember/application', 'getOwner'], ['setOwner', '@ember/application', 'setOwner'], ['assign', '@ember/polyfills'], // @ember/-internals/utils
  ['GUID_KEY', '@ember/-internals/utils'], ['uuid', '@ember/-internals/utils'], ['generateGuid', '@ember/-internals/utils'], ['guidFor', '@ember/-internals/utils'], ['inspect', '@ember/-internals/utils'], ['makeArray', '@ember/-internals/utils'], ['canInvoke', '@ember/-internals/utils'], ['tryInvoke', '@ember/-internals/utils'], ['wrap', '@ember/-internals/utils'], // @ember/-internals/container
  ['Registry', '@ember/-internals/container', 'Registry'], ['Container', '@ember/-internals/container', 'Container'], // @ember/debug
  ['deprecateFunc', '@ember/debug'], ['deprecate', '@ember/debug'], ['assert', '@ember/debug'], ['warn', '@ember/debug'], ['debug', '@ember/debug'], ['runInDebug', '@ember/debug'], ['Debug.registerDeprecationHandler', '@ember/debug', 'registerDeprecationHandler'], ['Debug.registerWarnHandler', '@ember/debug', 'registerWarnHandler'], ['Error', '@ember/error', 'default'], // @ember/-internals/metal
  ['computed', '@ember/-internals/metal', '_globalsComputed'], ['computed.alias', '@ember/-internals/metal', 'alias'], ['ComputedProperty', '@ember/-internals/metal'], ['cacheFor', '@ember/-internals/metal', 'getCachedValueFor'], ['merge', '@ember/polyfills'], ['instrument', '@ember/instrumentation'], ['subscribe', '@ember/instrumentation', 'subscribe'], ['Instrumentation.instrument', '@ember/instrumentation', 'instrument'], ['Instrumentation.subscribe', '@ember/instrumentation', 'subscribe'], ['Instrumentation.unsubscribe', '@ember/instrumentation', 'unsubscribe'], ['Instrumentation.reset', '@ember/instrumentation', 'reset'], ['testing', '@ember/debug', {
    get: 'isTesting',
    set: 'setTesting'
  }], ['onerror', '@ember/-internals/error-handling', {
    get: 'getOnerror',
    set: 'setOnerror'
  }], ['FEATURES.isEnabled', '@ember/canary-features', 'isEnabled'], ['meta', '@ember/-internals/meta'], ['get', '@ember/-internals/metal'], ['set', '@ember/-internals/metal'], ['_getPath', '@ember/-internals/metal'], ['getWithDefault', '@ember/-internals/metal'], ['trySet', '@ember/-internals/metal'], ['_Cache', '@ember/-internals/utils', 'Cache'], ['on', '@ember/-internals/metal'], ['addListener', '@ember/-internals/metal'], ['removeListener', '@ember/-internals/metal'], ['sendEvent', '@ember/-internals/metal'], ['hasListeners', '@ember/-internals/metal'], ['isNone', '@ember/-internals/metal'], ['isEmpty', '@ember/-internals/metal'], ['isBlank', '@ember/-internals/metal'], ['isPresent', '@ember/-internals/metal'], ['_Backburner', 'backburner', 'default'], ['run', '@ember/runloop', '_globalsRun'], ['run.backburner', '@ember/runloop', 'backburner'], ['run.begin', '@ember/runloop', 'begin'], ['run.bind', '@ember/runloop', 'bind'], ['run.cancel', '@ember/runloop', 'cancel'], ['run.debounce', '@ember/runloop', 'debounce'], ['run.end', '@ember/runloop', 'end'], ['run.hasScheduledTimers', '@ember/runloop', 'hasScheduledTimers'], ['run.join', '@ember/runloop', 'join'], ['run.later', '@ember/runloop', 'later'], ['run.next', '@ember/runloop', 'next'], ['run.once', '@ember/runloop', 'once'], ['run.schedule', '@ember/runloop', 'schedule'], ['run.scheduleOnce', '@ember/runloop', 'scheduleOnce'], ['run.throttle', '@ember/runloop', 'throttle'], ['run.currentRunLoop', '@ember/runloop', {
    get: 'getCurrentRunLoop'
  }], ['run.cancelTimers', '@ember/runloop', 'cancelTimers'], ['notifyPropertyChange', '@ember/-internals/metal'], ['overrideChains', '@ember/-internals/metal'], ['beginPropertyChanges', '@ember/-internals/metal'], ['endPropertyChanges', '@ember/-internals/metal'], ['changeProperties', '@ember/-internals/metal'], ['platform.defineProperty', null, {
    value: true
  }], ['platform.hasPropertyAccessors', null, {
    value: true
  }], ['defineProperty', '@ember/-internals/metal'], ['watchKey', '@ember/-internals/metal'], ['unwatchKey', '@ember/-internals/metal'], ['removeChainWatcher', '@ember/-internals/metal'], ['_ChainNode', '@ember/-internals/metal', 'ChainNode'], ['finishChains', '@ember/-internals/metal'], ['watchPath', '@ember/-internals/metal'], ['unwatchPath', '@ember/-internals/metal'], ['watch', '@ember/-internals/metal'], ['isWatching', '@ember/-internals/metal'], ['unwatch', '@ember/-internals/metal'], ['destroy', '@ember/-internals/meta', 'deleteMeta'], ['libraries', '@ember/-internals/metal'], ['getProperties', '@ember/-internals/metal'], ['setProperties', '@ember/-internals/metal'], ['expandProperties', '@ember/-internals/metal'], ['addObserver', '@ember/-internals/metal'], ['removeObserver', '@ember/-internals/metal'], ['aliasMethod', '@ember/-internals/metal'], ['observer', '@ember/-internals/metal'], ['mixin', '@ember/-internals/metal'], ['Mixin', '@ember/-internals/metal'], // @ember/-internals/console
  ['Logger', '@ember/-internals/console', 'default'], // @ember/-internals/views
  !_views.jQueryDisabled && ['$', '@ember/-internals/views', 'jQuery'], ['ViewUtils.isSimpleClick', '@ember/-internals/views', 'isSimpleClick'], ['ViewUtils.getViewElement', '@ember/-internals/views', 'getViewElement'], ['ViewUtils.getViewBounds', '@ember/-internals/views', 'getViewBounds'], ['ViewUtils.getViewClientRects', '@ember/-internals/views', 'getViewClientRects'], ['ViewUtils.getViewBoundingClientRect', '@ember/-internals/views', 'getViewBoundingClientRect'], ['ViewUtils.getRootViews', '@ember/-internals/views', 'getRootViews'], ['ViewUtils.getChildViews', '@ember/-internals/views', 'getChildViews'], ['ViewUtils.isSerializationFirstNode', '@ember/-internals/glimmer', 'isSerializationFirstNode'], ['TextSupport', '@ember/-internals/views'], ['ComponentLookup', '@ember/-internals/views'], ['EventDispatcher', '@ember/-internals/views'], // @ember/-internals/glimmer
  ['Component', '@ember/-internals/glimmer', 'Component'], ['Helper', '@ember/-internals/glimmer', 'Helper'], ['Helper.helper', '@ember/-internals/glimmer', 'helper'], ['Checkbox', '@ember/-internals/glimmer', 'Checkbox'], ['LinkComponent', '@ember/-internals/glimmer', 'LinkComponent'], ['TextArea', '@ember/-internals/glimmer', 'TextArea'], ['TextField', '@ember/-internals/glimmer', 'TextField'], ['TEMPLATES', '@ember/-internals/glimmer', {
    get: 'getTemplates',
    set: 'setTemplates'
  }], ['Handlebars.template', '@ember/-internals/glimmer', 'template'], ['HTMLBars.template', '@ember/-internals/glimmer', 'template'], ['Handlebars.Utils.escapeExpression', '@ember/-internals/glimmer', 'escapeExpression'], ['String.htmlSafe', '@ember/-internals/glimmer', 'htmlSafe'], ['_setComponentManager', '@ember/-internals/glimmer', 'setComponentManager'], ['_componentManagerCapabilities', '@ember/-internals/glimmer', 'capabilities'], // @ember/-internals/runtime
  ['A', '@ember/-internals/runtime'], ['_RegistryProxyMixin', '@ember/-internals/runtime', 'RegistryProxyMixin'], ['_ContainerProxyMixin', '@ember/-internals/runtime', 'ContainerProxyMixin'], ['Object', '@ember/-internals/runtime'], ['String.loc', '@ember/string', 'loc'], ['String.w', '@ember/string', 'w'], ['String.dasherize', '@ember/string', 'dasherize'], ['String.decamelize', '@ember/string', 'decamelize'], ['String.camelize', '@ember/string', 'camelize'], ['String.classify', '@ember/string', 'classify'], ['String.underscore', '@ember/string', 'underscore'], ['String.capitalize', '@ember/string', 'capitalize'], ['compare', '@ember/-internals/runtime'], ['copy', '@ember/-internals/runtime'], ['isEqual', '@ember/-internals/runtime'], ['inject.controller', '@ember/controller', 'inject'], ['inject.service', '@ember/service', 'inject'], ['Array', '@ember/-internals/runtime'], ['Comparable', '@ember/-internals/runtime'], ['Namespace', '@ember/-internals/runtime'], ['Enumerable', '@ember/-internals/runtime'], ['ArrayProxy', '@ember/-internals/runtime'], ['ObjectProxy', '@ember/-internals/runtime'], ['ActionHandler', '@ember/-internals/runtime'], ['CoreObject', '@ember/-internals/runtime'], ['NativeArray', '@ember/-internals/runtime'], ['Copyable', '@ember/-internals/runtime'], ['MutableEnumerable', '@ember/-internals/runtime'], ['MutableArray', '@ember/-internals/runtime'], ['TargetActionSupport', '@ember/-internals/runtime'], ['Evented', '@ember/-internals/runtime'], ['PromiseProxyMixin', '@ember/-internals/runtime'], ['Observable', '@ember/-internals/runtime'], ['typeOf', '@ember/-internals/runtime'], ['isArray', '@ember/-internals/runtime'], ['Object', '@ember/-internals/runtime'], ['onLoad', '@ember/application'], ['runLoadHooks', '@ember/application'], ['Controller', '@ember/controller', 'default'], ['ControllerMixin', '@ember/controller/lib/controller_mixin', 'default'], ['Service', '@ember/service', 'default'], ['_ProxyMixin', '@ember/-internals/runtime'], ['RSVP', '@ember/-internals/runtime'], ['STRINGS', '@ember/string', {
    get: '_getStrings',
    set: '_setStrings'
  }], ['BOOTED', '@ember/-internals/metal', {
    get: 'isNamespaceSearchDisabled',
    set: 'setNamespaceSearchDisabled'
  }], ['computed.empty', '@ember/object/computed', 'empty'], ['computed.notEmpty', '@ember/object/computed', 'notEmpty'], ['computed.none', '@ember/object/computed', 'none'], ['computed.not', '@ember/object/computed', 'not'], ['computed.bool', '@ember/object/computed', 'bool'], ['computed.match', '@ember/object/computed', 'match'], ['computed.equal', '@ember/object/computed', 'equal'], ['computed.gt', '@ember/object/computed', 'gt'], ['computed.gte', '@ember/object/computed', 'gte'], ['computed.lt', '@ember/object/computed', 'lt'], ['computed.lte', '@ember/object/computed', 'lte'], ['computed.oneWay', '@ember/object/computed', 'oneWay'], ['computed.reads', '@ember/object/computed', 'oneWay'], ['computed.readOnly', '@ember/object/computed', 'readOnly'], ['computed.deprecatingAlias', '@ember/object/computed', 'deprecatingAlias'], ['computed.and', '@ember/object/computed', 'and'], ['computed.or', '@ember/object/computed', 'or'], ['computed.sum', '@ember/object/computed', 'sum'], ['computed.min', '@ember/object/computed', 'min'], ['computed.max', '@ember/object/computed', 'max'], ['computed.map', '@ember/object/computed', 'map'], ['computed.sort', '@ember/object/computed', 'sort'], ['computed.setDiff', '@ember/object/computed', 'setDiff'], ['computed.mapBy', '@ember/object/computed', 'mapBy'], ['computed.filter', '@ember/object/computed', 'filter'], ['computed.filterBy', '@ember/object/computed', 'filterBy'], ['computed.uniq', '@ember/object/computed', 'uniq'], ['computed.uniqBy', '@ember/object/computed', 'uniqBy'], ['computed.union', '@ember/object/computed', 'union'], ['computed.intersect', '@ember/object/computed', 'intersect'], ['computed.collect', '@ember/object/computed', 'collect'], // @ember/-internals/routing
  ['Location', '@ember/-internals/routing'], ['AutoLocation', '@ember/-internals/routing'], ['HashLocation', '@ember/-internals/routing'], ['HistoryLocation', '@ember/-internals/routing'], ['NoneLocation', '@ember/-internals/routing'], ['controllerFor', '@ember/-internals/routing'], ['generateControllerFactory', '@ember/-internals/routing'], ['generateController', '@ember/-internals/routing'], ['RouterDSL', '@ember/-internals/routing'], ['Router', '@ember/-internals/routing'], ['Route', '@ember/-internals/routing'], // ember-application
  ['Application', '@ember/application', 'default'], ['ApplicationInstance', '@ember/application/instance', 'default'], ['Engine', '@ember/engine', 'default'], ['EngineInstance', '@ember/engine/instance', 'default'], ['Resolver', '@ember/application/globals-resolver', 'default'], ['DefaultResolver', '@ember/application/globals-resolver', 'default'], // @ember/-internals/extension-support
  ['DataAdapter', '@ember/-internals/extension-support'], ['ContainerDebugAdapter', '@ember/-internals/extension-support']].filter(Boolean);
});
enifed("ember/tests/routing/decoupled_basic_test", ["@ember/polyfills", "ember-babel", "@ember/-internals/owner", "rsvp", "ember-template-compiler", "@ember/-internals/routing", "@ember/controller", "@ember/-internals/runtime", "internal-test-helpers", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/glimmer", "@ember/engine", "router_js"], function (_polyfills, _emberBabel, _owner, _rsvp, _emberTemplateCompiler, _routing, _controller, _runtime, _internalTestHelpers, _runloop, _metal, _glimmer, _engine, _router_js) {
  "use strict";

  /* eslint-disable no-console */
  var originalConsoleError;
  (0, _internalTestHelpers.moduleFor)('Basic Routing - Decoupled from global resolver',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.apply(this, arguments) || this;

      _this.addTemplate('home', '<h3 class="hours">Hours</h3>');

      _this.addTemplate('camelot', '<section id="camelot"><h3>Is a silly place</h3></section>');

      _this.addTemplate('homepage', '<h3 id="troll">Megatroll</h3><p>{{model.home}}</p>');

      _this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });

      originalConsoleError = console.error;
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _ApplicationTestCase.prototype.teardown.call(this);

      console.error = originalConsoleError;
    };

    _proto.getController = function getController(name) {
      return this.applicationInstance.lookup("controller:" + name);
    };

    _proto.handleURLAborts = function handleURLAborts(assert, path, deprecated) {
      var _this2 = this;

      (0, _runloop.run)(function () {
        var router = _this2.applicationInstance.lookup('router:main');

        var result;

        if (deprecated !== undefined) {
          expectDeprecation(function () {
            result = router.handleURL(path);
          });
        } else {
          result = router.handleURL(path);
        }

        result.then(function () {
          assert.ok(false, 'url: `' + path + '` was NOT to be handled');
        }, function (reason) {
          assert.ok(reason && reason.message === 'TransitionAborted', 'url: `' + path + '` was to be aborted');
        });
      });
    };

    _proto.handleURLRejectsWith = function handleURLRejectsWith(context, assert, path, expectedReason) {
      return context.visit(path).then(function () {
        assert.ok(false, 'expected handleURLing: `' + path + '` to fail');
      }).catch(function (reason) {
        assert.equal(reason.message, expectedReason);
      });
    };

    _proto['@test warn on URLs not included in the route set'] = function testWarnOnURLsNotIncludedInTheRouteSet() {
      var _this3 = this;

      return this.visit('/').then(function () {
        expectAssertion(function () {
          _this3.visit('/what-is-this-i-dont-even');
        }, /'\/what-is-this-i-dont-even' did not match any routes/);
      });
    };

    _proto['@test The Homepage'] = function testTheHomepage(assert) {
      var _this4 = this;

      return this.visit('/').then(function () {
        assert.equal(_this4.currentPath, 'home', 'currently on the home route');

        var text = _this4.$('.hours').text();

        assert.equal(text, 'Hours', 'the home template was rendered');
      });
    };

    _proto["@test The Homepage and the Camelot page with multiple Router.map calls"] = function (assert) {
      var _this5 = this;

      this.router.map(function () {
        this.route('camelot', {
          path: '/camelot'
        });
      });
      return this.visit('/camelot').then(function () {
        assert.equal(_this5.currentPath, 'camelot');

        var text = _this5.$('#camelot').text();

        assert.equal(text, 'Is a silly place', 'the camelot template was rendered');
        return _this5.visit('/');
      }).then(function () {
        assert.equal(_this5.currentPath, 'home');

        var text = _this5.$('.hours').text();

        assert.equal(text, 'Hours', 'the home template was rendered');
      });
    };

    _proto["@test The Homepage with explicit template name in renderTemplate"] = function (assert) {
      var _this6 = this;

      this.add('route:home', _routing.Route.extend({
        renderTemplate: function () {
          this.render('homepage');
        }
      }));
      return this.visit('/').then(function () {
        var text = _this6.$('#troll').text();

        assert.equal(text, 'Megatroll', 'the homepage template was rendered');
      });
    };

    _proto["@test an alternate template will pull in an alternate controller"] = function (assert) {
      var _this7 = this;

      this.add('route:home', _routing.Route.extend({
        renderTemplate: function () {
          this.render('homepage');
        }
      }));
      this.add('controller:homepage', _controller.default.extend({
        model: {
          home: 'Comes from homepage'
        }
      }));
      return this.visit('/').then(function () {
        var text = _this7.$('p').text();

        assert.equal(text, 'Comes from homepage', 'the homepage template was rendered');
      });
    };

    _proto["@test An alternate template will pull in an alternate controller instead of controllerName"] = function (assert) {
      var _this8 = this;

      this.add('route:home', _routing.Route.extend({
        controllerName: 'foo',
        renderTemplate: function () {
          this.render('homepage');
        }
      }));
      this.add('controller:foo', _controller.default.extend({
        model: {
          home: 'Comes from foo'
        }
      }));
      this.add('controller:homepage', _controller.default.extend({
        model: {
          home: 'Comes from homepage'
        }
      }));
      return this.visit('/').then(function () {
        var text = _this8.$('p').text();

        assert.equal(text, 'Comes from homepage', 'the homepage template was rendered');
      });
    };

    _proto["@test The template will pull in an alternate controller via key/value"] = function (assert) {
      var _this9 = this;

      this.router.map(function () {
        this.route('homepage', {
          path: '/'
        });
      });
      this.add('route:homepage', _routing.Route.extend({
        renderTemplate: function () {
          this.render({
            controller: 'home'
          });
        }
      }));
      this.add('controller:home', _controller.default.extend({
        model: {
          home: 'Comes from home.'
        }
      }));
      return this.visit('/').then(function () {
        var text = _this9.$('p').text();

        assert.equal(text, 'Comes from home.', 'the homepage template was rendered from data from the HomeController');
      });
    };

    _proto["@test The Homepage with explicit template name in renderTemplate and controller"] = function (assert) {
      var _this10 = this;

      this.add('controller:home', _controller.default.extend({
        model: {
          home: 'YES I AM HOME'
        }
      }));
      this.add('route:home', _routing.Route.extend({
        renderTemplate: function () {
          this.render('homepage');
        }
      }));
      return this.visit('/').then(function () {
        var text = _this10.$('p').text();

        assert.equal(text, 'YES I AM HOME', 'The homepage template was rendered');
      });
    };

    _proto["@test Model passed via renderTemplate model is set as controller's model"] = function (assert) {
      var _this11 = this;

      this.addTemplate('bio', '<p>{{model.name}}</p>');
      this.add('route:home', _routing.Route.extend({
        renderTemplate: function () {
          this.render('bio', {
            model: {
              name: 'emberjs'
            }
          });
        }
      }));
      return this.visit('/').then(function () {
        var text = _this11.$('p').text();

        assert.equal(text, 'emberjs', "Passed model was set as controller's model");
      });
    };

    _proto['@test render uses templateName from route'] = function testRenderUsesTemplateNameFromRoute(assert) {
      var _this12 = this;

      this.addTemplate('the_real_home_template', '<p>THIS IS THE REAL HOME</p>');
      this.add('route:home', _routing.Route.extend({
        templateName: 'the_real_home_template'
      }));
      return this.visit('/').then(function () {
        var text = _this12.$('p').text();

        assert.equal(text, 'THIS IS THE REAL HOME', 'the homepage template was rendered');
      });
    };

    _proto['@test defining templateName allows other templates to be rendered'] = function testDefiningTemplateNameAllowsOtherTemplatesToBeRendered(assert) {
      var _this13 = this;

      this.addTemplate('alert', "<div class='alert-box'>Invader!</div>");
      this.addTemplate('the_real_home_template', "<p>THIS IS THE REAL HOME</p>{{outlet 'alert'}}");
      this.add('route:home', _routing.Route.extend({
        templateName: 'the_real_home_template',
        actions: {
          showAlert: function () {
            this.render('alert', {
              into: 'home',
              outlet: 'alert'
            });
          }
        }
      }));
      return this.visit('/').then(function () {
        var text = _this13.$('p').text();

        assert.equal(text, 'THIS IS THE REAL HOME', 'the homepage template was rendered');
        return (0, _internalTestHelpers.runTask)(function () {
          return _this13.appRouter.send('showAlert');
        });
      }).then(function () {
        var text = _this13.$('.alert-box').text();

        assert.equal(text, 'Invader!', 'Template for alert was rendered into the outlet');
      });
    };

    _proto['@test templateName is still used when calling render with no name and options'] = function testTemplateNameIsStillUsedWhenCallingRenderWithNoNameAndOptions(assert) {
      var _this14 = this;

      this.addTemplate('alert', "<div class='alert-box'>Invader!</div>");
      this.addTemplate('home', "<p>THIS IS THE REAL HOME</p>{{outlet 'alert'}}");
      this.add('route:home', _routing.Route.extend({
        templateName: 'alert',
        renderTemplate: function () {
          this.render({});
        }
      }));
      return this.visit('/').then(function () {
        var text = _this14.$('.alert-box').text();

        assert.equal(text, 'Invader!', 'default templateName was rendered into outlet');
      });
    };

    _proto['@test The Homepage with a `setupController` hook'] = function testTheHomepageWithASetupControllerHook(assert) {
      var _this15 = this;

      this.addTemplate('home', "<ul>{{#each hours as |entry|}}\n        <li>{{entry}}</li>\n      {{/each}}\n      </ul>\n    ");
      this.add('route:home', _routing.Route.extend({
        setupController: function (controller) {
          controller.set('hours', ['Monday through Friday: 9am to 5pm', 'Saturday: Noon to Midnight', 'Sunday: Noon to 6pm']);
        }
      }));
      return this.visit('/').then(function () {
        var text = _this15.$('ul li:nth-child(3)').text();

        assert.equal(text, 'Sunday: Noon to 6pm', 'The template was rendered with the hours context');
      });
    };

    _proto["@test The route controller is still set when overriding the setupController hook"] = function (assert) {
      var _this16 = this;

      this.add('route:home', _routing.Route.extend({
        setupController: function () {// no-op
          // importantly, we are not calling this._super
        }
      }));
      this.add('controller:home', _controller.default.extend());
      return this.visit('/').then(function () {
        var homeRoute = _this16.applicationInstance.lookup('route:home');

        var homeController = _this16.applicationInstance.lookup('controller:home');

        assert.equal(homeRoute.controller, homeController, 'route controller is the home controller');
      });
    };

    _proto['@test the route controller can be specified via controllerName'] = function testTheRouteControllerCanBeSpecifiedViaControllerName(assert) {
      var _this17 = this;

      this.addTemplate('home', '<p>{{myValue}}</p>');
      this.add('route:home', _routing.Route.extend({
        controllerName: 'myController'
      }));
      this.add('controller:myController', _controller.default.extend({
        myValue: 'foo'
      }));
      return this.visit('/').then(function () {
        var homeRoute = _this17.applicationInstance.lookup('route:home');

        var myController = _this17.applicationInstance.lookup('controller:myController');

        var text = _this17.$('p').text();

        assert.equal(homeRoute.controller, myController, 'route controller is set by controllerName');
        assert.equal(text, 'foo', 'The homepage template was rendered with data from the custom controller');
      });
    };

    _proto["@test The route controller specified via controllerName is used in render"] = function (assert) {
      var _this18 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add('route:home', _routing.Route.extend({
        controllerName: 'myController',
        renderTemplate: function () {
          this.render('alternative_home');
        }
      }));
      this.add('controller:myController', _controller.default.extend({
        myValue: 'foo'
      }));
      this.addTemplate('alternative_home', '<p>alternative home: {{myValue}}</p>');
      return this.visit('/').then(function () {
        var homeRoute = _this18.applicationInstance.lookup('route:home');

        var myController = _this18.applicationInstance.lookup('controller:myController');

        var text = _this18.$('p').text();

        assert.equal(homeRoute.controller, myController, 'route controller is set by controllerName');
        assert.equal(text, 'alternative home: foo', 'The homepage template was rendered with data from the custom controller');
      });
    };

    _proto["@test The route controller specified via controllerName is used in render even when a controller with the routeName is available"] = function (assert) {
      var _this19 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.addTemplate('home', '<p>home: {{myValue}}</p>');
      this.add('route:home', _routing.Route.extend({
        controllerName: 'myController'
      }));
      this.add('controller:home', _controller.default.extend({
        myValue: 'home'
      }));
      this.add('controller:myController', _controller.default.extend({
        myValue: 'myController'
      }));
      return this.visit('/').then(function () {
        var homeRoute = _this19.applicationInstance.lookup('route:home');

        var myController = _this19.applicationInstance.lookup('controller:myController');

        var text = _this19.$('p').text();

        assert.equal(homeRoute.controller, myController, 'route controller is set by controllerName');
        assert.equal(text, 'home: myController', 'The homepage template was rendered with data from the custom controller');
      });
    };

    _proto["@test The Homepage with a 'setupController' hook modifying other controllers"] = function (assert) {
      var _this20 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add('route:home', _routing.Route.extend({
        setupController: function ()
        /* controller */
        {
          this.controllerFor('home').set('hours', ['Monday through Friday: 9am to 5pm', 'Saturday: Noon to Midnight', 'Sunday: Noon to 6pm']);
        }
      }));
      this.addTemplate('home', '<ul>{{#each hours as |entry|}}<li>{{entry}}</li>{{/each}}</ul>');
      return this.visit('/').then(function () {
        var text = _this20.$('ul li:nth-child(3)').text();

        assert.equal(text, 'Sunday: Noon to 6pm', 'The template was rendered with the hours context');
      });
    };

    _proto["@test The Homepage with a computed model that does not get overridden"] = function (assert) {
      var _this21 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add('controller:home', _controller.default.extend({
        model: (0, _metal.computed)(function () {
          return ['Monday through Friday: 9am to 5pm', 'Saturday: Noon to Midnight', 'Sunday: Noon to 6pm'];
        })
      }));
      this.addTemplate('home', '<ul>{{#each model as |passage|}}<li>{{passage}}</li>{{/each}}</ul>');
      return this.visit('/').then(function () {
        var text = _this21.$('ul li:nth-child(3)').text();

        assert.equal(text, 'Sunday: Noon to 6pm', 'The template was rendered with the context intact');
      });
    };

    _proto["@test The Homepage getting its controller context via model"] = function (assert) {
      var _this22 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add('route:home', _routing.Route.extend({
        model: function () {
          return ['Monday through Friday: 9am to 5pm', 'Saturday: Noon to Midnight', 'Sunday: Noon to 6pm'];
        },
        setupController: function (controller, model) {
          assert.equal(this.controllerFor('home'), controller);
          this.controllerFor('home').set('hours', model);
        }
      }));
      this.addTemplate('home', '<ul>{{#each hours as |entry|}}<li>{{entry}}</li>{{/each}}</ul>');
      return this.visit('/').then(function () {
        var text = _this22.$('ul li:nth-child(3)').text();

        assert.equal(text, 'Sunday: Noon to 6pm', 'The template was rendered with the hours context');
      });
    };

    _proto["@test The Specials Page getting its controller context by deserializing the params hash"] = function (assert) {
      var _this23 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      this.add('route:special', _routing.Route.extend({
        model: function (params) {
          return _runtime.Object.create({
            menuItemId: params.menu_item_id
          });
        }
      }));
      this.addTemplate('special', '<p>{{model.menuItemId}}</p>');
      return this.visit('/specials/1').then(function () {
        var text = _this23.$('p').text();

        assert.equal(text, '1', 'The model was used to render the template');
      });
    };

    _proto['@test The Specials Page defaults to looking models up via `find`'] = function testTheSpecialsPageDefaultsToLookingModelsUpViaFind() {
      var _this24 = this;

      var MenuItem = _runtime.Object.extend();

      MenuItem.reopenClass({
        find: function (id) {
          return MenuItem.create({
            id: id
          });
        }
      });
      this.add('model:menu_item', MenuItem);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      this.addTemplate('special', '{{model.id}}');
      return this.visit('/specials/1').then(function () {
        _this24.assertText('1', 'The model was used to render the template');
      });
    };

    _proto['@test The Special Page returning a promise puts the app into a loading state until the promise is resolved'] = function testTheSpecialPageReturningAPromisePutsTheAppIntoALoadingStateUntilThePromiseIsResolved() {
      var _this25 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      var menuItem, resolve;

      var MenuItem = _runtime.Object.extend();

      MenuItem.reopenClass({
        find: function (id) {
          menuItem = MenuItem.create({
            id: id
          });
          return new _rsvp.default.Promise(function (res) {
            resolve = res;
          });
        }
      });
      this.add('model:menu_item', MenuItem);
      this.addTemplate('special', '<p>{{model.id}}</p>');
      this.addTemplate('loading', '<p>LOADING!</p>');
      var visited = this.visit('/specials/1');
      this.assertText('LOADING!', 'The app is in the loading state');
      resolve(menuItem);
      return visited.then(function () {
        _this25.assertText('1', 'The app is now in the specials state');
      });
    };

    _proto["@test The loading state doesn't get entered for promises that resolve on the same run loop"] = function (assert) {
      var _this26 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });

      var MenuItem = _runtime.Object.extend();

      MenuItem.reopenClass({
        find: function (id) {
          return {
            id: id
          };
        }
      });
      this.add('model:menu_item', MenuItem);
      this.add('route:loading', _routing.Route.extend({
        enter: function () {
          assert.ok(false, "LoadingRoute shouldn't have been entered.");
        }
      }));
      this.addTemplate('special', '<p>{{model.id}}</p>');
      this.addTemplate('loading', '<p>LOADING!</p>');
      return this.visit('/specials/1').then(function () {
        var text = _this26.$('p').text();

        assert.equal(text, '1', 'The app is now in the specials state');
      });
    };

    _proto["@test The Special page returning an error invokes SpecialRoute's error handler"] = function testTheSpecialPageReturningAnErrorInvokesSpecialRouteSErrorHandler(assert) {
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      var menuItem, promise, resolve;

      var MenuItem = _runtime.Object.extend();

      MenuItem.reopenClass({
        find: function (id) {
          menuItem = MenuItem.create({
            id: id
          });
          promise = new _rsvp.default.Promise(function (res) {
            return resolve = res;
          });
          return promise;
        }
      });
      this.add('model:menu_item', MenuItem);
      this.add('route:special', _routing.Route.extend({
        setup: function () {
          throw new Error('Setup error');
        },
        actions: {
          error: function (reason) {
            assert.equal(reason.message, 'Setup error', 'SpecialRoute#error received the error thrown from setup');
            return true;
          }
        }
      }));
      this.handleURLRejectsWith(this, assert, 'specials/1', 'Setup error');
      (0, _runloop.run)(function () {
        return resolve(menuItem);
      });
    };

    _proto["@test ApplicationRoute's default error handler can be overridden"] = function testApplicationRouteSDefaultErrorHandlerCanBeOverridden(assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      var menuItem, resolve;

      var MenuItem = _runtime.Object.extend();

      MenuItem.reopenClass({
        find: function (id) {
          menuItem = MenuItem.create({
            id: id
          });
          return new _rsvp.default.Promise(function (res) {
            return resolve = res;
          });
        }
      });
      this.add('model:menu_item', MenuItem);
      this.add('route:application', _routing.Route.extend({
        actions: {
          error: function (reason) {
            assert.equal(reason.message, 'Setup error', 'error was correctly passed to custom ApplicationRoute handler');
            return true;
          }
        }
      }));
      this.add('route:special', _routing.Route.extend({
        setup: function () {
          throw new Error('Setup error');
        }
      }));
      this.handleURLRejectsWith(this, assert, '/specials/1', 'Setup error');
      (0, _runloop.run)(function () {
        return resolve(menuItem);
      });
    };

    _proto['@test Moving from one page to another triggers the correct callbacks'] = function testMovingFromOnePageToAnotherTriggersTheCorrectCallbacks(assert) {
      var _this27 = this;

      assert.expect(3);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });

      var MenuItem = _runtime.Object.extend();

      MenuItem.reopenClass({
        find: function (id) {
          return MenuItem.create({
            id: id
          });
        }
      });
      this.add('model:menu_item', MenuItem);
      this.addTemplate('home', '<h3>Home</h3>');
      this.addTemplate('special', '<p>{{model.id}}</p>');
      return this.visit('/').then(function () {
        _this27.assertText('Home', 'The app is now in the initial state');

        var promiseContext = MenuItem.create({
          id: 1
        });
        return _this27.visit('/specials/1', promiseContext);
      }).then(function () {
        assert.equal(_this27.currentURL, '/specials/1');

        _this27.assertText('1', 'The app is now transitioned');
      });
    };

    _proto['@test Nested callbacks are not exited when moving to siblings'] = function testNestedCallbacksAreNotExitedWhenMovingToSiblings(assert) {
      var _this28 = this;

      var rootSetup = 0;
      var rootRender = 0;
      var rootModel = 0;
      var rootSerialize = 0;
      var menuItem;
      var rootElement;

      var MenuItem = _runtime.Object.extend();

      MenuItem.reopenClass({
        find: function (id) {
          menuItem = MenuItem.create({
            id: id
          });
          return menuItem;
        }
      });
      this.router.map(function () {
        this.route('root', {
          path: '/'
        }, function () {
          this.route('special', {
            path: '/specials/:menu_item_id',
            resetNamespace: true
          });
        });
      });
      this.add('route:root', _routing.Route.extend({
        model: function () {
          rootModel++;
          return this._super.apply(this, arguments);
        },
        setupController: function () {
          rootSetup++;
        },
        renderTemplate: function () {
          rootRender++;
        },
        serialize: function () {
          rootSerialize++;
          return this._super.apply(this, arguments);
        }
      }));
      this.add('route:loading', _routing.Route.extend({}));
      this.add('route:home', _routing.Route.extend({}));
      this.add('route:special', _routing.Route.extend({
        model: function (_ref) {
          var menu_item_id = _ref.menu_item_id;
          return MenuItem.find(menu_item_id);
        },
        setupController: function (controller, model) {
          (0, _metal.set)(controller, 'model', model);
        }
      }));
      this.addTemplate('root.index', '<h3>Home</h3>');
      this.addTemplate('special', '<p>{{model.id}}</p>');
      this.addTemplate('loading', '<p>LOADING!</p>');
      return this.visit('/').then(function () {
        rootElement = document.getElementById('qunit-fixture');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('h3')), 'Home', 'The app is now in the initial state');
        assert.equal(rootSetup, 1, 'The root setup was triggered');
        assert.equal(rootRender, 1, 'The root render was triggered');
        assert.equal(rootSerialize, 0, 'The root serialize was not called');
        assert.equal(rootModel, 1, 'The root model was called');

        var router = _this28.applicationInstance.lookup('router:main');

        var menuItem = MenuItem.create({
          id: 1
        });
        return router.transitionTo('special', menuItem).then(function () {
          assert.equal(rootSetup, 1, 'The root setup was not triggered again');
          assert.equal(rootRender, 1, 'The root render was not triggered again');
          assert.equal(rootSerialize, 0, 'The root serialize was not called'); // TODO: Should this be changed?

          assert.equal(rootModel, 1, 'The root model was called again');
          assert.deepEqual(router.location.path, '/specials/1');
          assert.equal(router.currentPath, 'root.special');
        });
      });
    };

    _proto['@test Events are triggered on the controller if a matching action name is implemented'] = function testEventsAreTriggeredOnTheControllerIfAMatchingActionNameIsImplemented(assert) {
      var done = assert.async();
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      var model = {
        name: 'Tom Dale'
      };
      var stateIsNotCalled = true;
      this.add('route:home', _routing.Route.extend({
        model: function () {
          return model;
        },
        actions: {
          showStuff: function () {
            stateIsNotCalled = false;
          }
        }
      }));
      this.addTemplate('home', '<a {{action "showStuff" model}}>{{name}}</a>');
      this.add('controller:home', _controller.default.extend({
        actions: {
          showStuff: function (context) {
            assert.ok(stateIsNotCalled, 'an event on the state is not triggered');
            assert.deepEqual(context, {
              name: 'Tom Dale'
            }, 'an event with context is passed');
            done();
          }
        }
      }));
      this.visit('/').then(function () {
        document.getElementById('qunit-fixture').querySelector('a').click();
      });
    };

    _proto['@test Events are triggered on the current state when defined in `actions` object'] = function testEventsAreTriggeredOnTheCurrentStateWhenDefinedInActionsObject(assert) {
      var done = assert.async();
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      var model = {
        name: 'Tom Dale'
      };

      var HomeRoute = _routing.Route.extend({
        model: function () {
          return model;
        },
        actions: {
          showStuff: function (obj) {
            assert.ok(this instanceof HomeRoute, 'the handler is an App.HomeRoute');
            assert.deepEqual((0, _polyfills.assign)({}, obj), {
              name: 'Tom Dale'
            }, 'the context is correct');
            done();
          }
        }
      });

      this.add('route:home', HomeRoute);
      this.addTemplate('home', '<a {{action "showStuff" model}}>{{model.name}}</a>');
      this.visit('/').then(function () {
        document.getElementById('qunit-fixture').querySelector('a').click();
      });
    };

    _proto['@test Events defined in `actions` object are triggered on the current state when routes are nested'] = function testEventsDefinedInActionsObjectAreTriggeredOnTheCurrentStateWhenRoutesAreNested(assert) {
      var done = assert.async();
      this.router.map(function () {
        this.route('root', {
          path: '/'
        }, function () {
          this.route('index', {
            path: '/'
          });
        });
      });
      var model = {
        name: 'Tom Dale'
      };

      var RootRoute = _routing.Route.extend({
        actions: {
          showStuff: function (obj) {
            assert.ok(this instanceof RootRoute, 'the handler is an App.HomeRoute');
            assert.deepEqual((0, _polyfills.assign)({}, obj), {
              name: 'Tom Dale'
            }, 'the context is correct');
            done();
          }
        }
      });

      this.add('route:root', RootRoute);
      this.add('route:root.index', _routing.Route.extend({
        model: function () {
          return model;
        }
      }));
      this.addTemplate('root.index', '<a {{action "showStuff" model}}>{{model.name}}</a>');
      this.visit('/').then(function () {
        document.getElementById('qunit-fixture').querySelector('a').click();
      });
    };

    _proto['@test Events can be handled by inherited event handlers'] = function testEventsCanBeHandledByInheritedEventHandlers(assert) {
      assert.expect(4);

      var SuperRoute = _routing.Route.extend({
        actions: {
          foo: function () {
            assert.ok(true, 'foo');
          },
          bar: function (msg) {
            assert.equal(msg, 'HELLO', 'bar hander in super route');
          }
        }
      });

      var RouteMixin = _metal.Mixin.create({
        actions: {
          bar: function (msg) {
            assert.equal(msg, 'HELLO', 'bar handler in mixin');

            this._super(msg);
          }
        }
      });

      this.add('route:home', SuperRoute.extend(RouteMixin, {
        actions: {
          baz: function () {
            assert.ok(true, 'baz', 'baz hander in route');
          }
        }
      }));
      this.addTemplate('home', "\n      <a class=\"do-foo\" {{action \"foo\"}}>Do foo</a>\n      <a class=\"do-bar-with-arg\" {{action \"bar\" \"HELLO\"}}>Do bar with arg</a>\n      <a class=\"do-baz\" {{action \"baz\"}}>Do bar</a>\n    ");
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        rootElement.querySelector('.do-foo').click();
        rootElement.querySelector('.do-bar-with-arg').click();
        rootElement.querySelector('.do-baz').click();
      });
    };

    _proto['@test Actions are not triggered on the controller if a matching action name is implemented as a method'] = function testActionsAreNotTriggeredOnTheControllerIfAMatchingActionNameIsImplementedAsAMethod(assert) {
      var done = assert.async();
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      var model = {
        name: 'Tom Dale'
      };
      var stateIsNotCalled = true;
      this.add('route:home', _routing.Route.extend({
        model: function () {
          return model;
        },
        actions: {
          showStuff: function (context) {
            assert.ok(stateIsNotCalled, 'an event on the state is not triggered');
            assert.deepEqual(context, {
              name: 'Tom Dale'
            }, 'an event with context is passed');
            done();
          }
        }
      }));
      this.addTemplate('home', '<a {{action "showStuff" model}}>{{name}}</a>');
      this.add('controller:home', _controller.default.extend({
        showStuff: function () {
          stateIsNotCalled = false;
          assert.ok(stateIsNotCalled, 'an event on the state is not triggered');
        }
      }));
      this.visit('/').then(function () {
        document.getElementById('qunit-fixture').querySelector('a').click();
      });
    };

    _proto['@test actions can be triggered with multiple arguments'] = function testActionsCanBeTriggeredWithMultipleArguments(assert) {
      var done = assert.async();
      this.router.map(function () {
        this.route('root', {
          path: '/'
        }, function () {
          this.route('index', {
            path: '/'
          });
        });
      });
      var model1 = {
        name: 'Tilde'
      };
      var model2 = {
        name: 'Tom Dale'
      };

      var RootRoute = _routing.Route.extend({
        actions: {
          showStuff: function (obj1, obj2) {
            assert.ok(this instanceof RootRoute, 'the handler is an App.HomeRoute');
            assert.deepEqual((0, _polyfills.assign)({}, obj1), {
              name: 'Tilde'
            }, 'the first context is correct');
            assert.deepEqual((0, _polyfills.assign)({}, obj2), {
              name: 'Tom Dale'
            }, 'the second context is correct');
            done();
          }
        }
      });

      this.add('route:root', RootRoute);
      this.add('controller:root.index', _controller.default.extend({
        model1: model1,
        model2: model2
      }));
      this.addTemplate('root.index', '<a {{action "showStuff" model1 model2}}>{{model1.name}}</a>');
      this.visit('/').then(function () {
        document.getElementById('qunit-fixture').querySelector('a').click();
      });
    };

    _proto['@test transitioning multiple times in a single run loop only sets the URL once'] = function testTransitioningMultipleTimesInASingleRunLoopOnlySetsTheURLOnce(assert) {
      var _this29 = this;

      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('foo');
        this.route('bar');
      });
      return this.visit('/').then(function () {
        var urlSetCount = 0;

        var router = _this29.applicationInstance.lookup('router:main');

        router.get('location').setURL = function (path) {
          urlSetCount++;
          (0, _metal.set)(this, 'path', path);
        };

        assert.equal(urlSetCount, 0);
        (0, _runloop.run)(function () {
          router.transitionTo('foo');
          router.transitionTo('bar');
        });
        assert.equal(urlSetCount, 1);
        assert.equal(router.get('location').getURL(), '/bar');
      });
    };

    _proto['@test navigating away triggers a url property change'] = function testNavigatingAwayTriggersAUrlPropertyChange(assert) {
      var _this30 = this;

      assert.expect(3);
      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('foo', {
          path: '/foo'
        });
        this.route('bar', {
          path: '/bar'
        });
      });
      return this.visit('/').then(function () {
        var router = _this30.applicationInstance.lookup('router:main');

        (0, _metal.addObserver)(router, 'url', function () {
          assert.ok(true, 'url change event was fired');
        });
        ['foo', 'bar', '/foo'].forEach(function (destination) {
          return (0, _runloop.run)(router, 'transitionTo', destination);
        });
      });
    };

    _proto['@test using replaceWith calls location.replaceURL if available'] = function testUsingReplaceWithCallsLocationReplaceURLIfAvailable(assert) {
      var _this31 = this;

      var setCount = 0;
      var replaceCount = 0;
      this.router.reopen({
        location: _routing.NoneLocation.create({
          setURL: function (path) {
            setCount++;
            (0, _metal.set)(this, 'path', path);
          },
          replaceURL: function (path) {
            replaceCount++;
            (0, _metal.set)(this, 'path', path);
          }
        })
      });
      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('foo');
      });
      return this.visit('/').then(function () {
        var router = _this31.applicationInstance.lookup('router:main');

        assert.equal(setCount, 1);
        assert.equal(replaceCount, 0);
        (0, _runloop.run)(function () {
          return router.replaceWith('foo');
        });
        assert.equal(setCount, 1, 'should not call setURL');
        assert.equal(replaceCount, 1, 'should call replaceURL once');
        assert.equal(router.get('location').getURL(), '/foo');
      });
    };

    _proto['@test using replaceWith calls setURL if location.replaceURL is not defined'] = function testUsingReplaceWithCallsSetURLIfLocationReplaceURLIsNotDefined(assert) {
      var _this32 = this;

      var setCount = 0;
      this.router.reopen({
        location: _routing.NoneLocation.create({
          setURL: function (path) {
            setCount++;
            (0, _metal.set)(this, 'path', path);
          }
        })
      });
      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('foo');
      });
      return this.visit('/').then(function () {
        var router = _this32.applicationInstance.lookup('router:main');

        assert.equal(setCount, 1);
        (0, _runloop.run)(function () {
          return router.replaceWith('foo');
        });
        assert.equal(setCount, 2, 'should call setURL once');
        assert.equal(router.get('location').getURL(), '/foo');
      });
    };

    _proto['@test Route inherits model from parent route'] = function testRouteInheritsModelFromParentRoute(assert) {
      var _this33 = this;

      assert.expect(9);
      this.router.map(function () {
        this.route('the-post', {
          path: '/posts/:post_id'
        }, function () {
          this.route('comments');
          this.route('shares', {
            path: '/shares/:share_id',
            resetNamespace: true
          }, function () {
            this.route('share');
          });
        });
      });
      var post1 = {};
      var post2 = {};
      var post3 = {};
      var share1 = {};
      var share2 = {};
      var share3 = {};
      var posts = {
        1: post1,
        2: post2,
        3: post3
      };
      var shares = {
        1: share1,
        2: share2,
        3: share3
      };
      this.add('route:the-post', _routing.Route.extend({
        model: function (params) {
          return posts[params.post_id];
        }
      }));
      this.add('route:the-post.comments', _routing.Route.extend({
        afterModel: function (post
        /*, transition */
        ) {
          var parent_model = this.modelFor('the-post');
          assert.equal(post, parent_model);
        }
      }));
      this.add('route:shares', _routing.Route.extend({
        model: function (params) {
          return shares[params.share_id];
        }
      }));
      this.add('route:shares.share', _routing.Route.extend({
        afterModel: function (share
        /*, transition */
        ) {
          var parent_model = this.modelFor('shares');
          assert.equal(share, parent_model);
        }
      }));
      return this.visit('/posts/1/comments').then(function () {
        assert.ok(true, 'url: /posts/1/comments was handled');
        return _this33.visit('/posts/1/shares/1');
      }).then(function () {
        assert.ok(true, 'url: /posts/1/shares/1 was handled');
        return _this33.visit('/posts/2/comments');
      }).then(function () {
        assert.ok(true, 'url: /posts/2/comments was handled');
        return _this33.visit('/posts/2/shares/2');
      }).then(function () {
        assert.ok(true, 'url: /posts/2/shares/2 was handled');
        return _this33.visit('/posts/3/comments');
      }).then(function () {
        assert.ok(true, 'url: /posts/3/shares was handled');
        return _this33.visit('/posts/3/shares/3');
      }).then(function () {
        assert.ok(true, 'url: /posts/3/shares/3 was handled');
      });
    };

    _proto['@test Routes with { resetNamespace: true } inherits model from parent route'] = function testRoutesWithResetNamespaceTrueInheritsModelFromParentRoute(assert) {
      var _this34 = this;

      assert.expect(6);
      this.router.map(function () {
        this.route('the-post', {
          path: '/posts/:post_id'
        }, function () {
          this.route('comments', {
            resetNamespace: true
          }, function () {});
        });
      });
      var post1 = {};
      var post2 = {};
      var post3 = {};
      var posts = {
        1: post1,
        2: post2,
        3: post3
      };
      this.add('route:the-post', _routing.Route.extend({
        model: function (params) {
          return posts[params.post_id];
        }
      }));
      this.add('route:comments', _routing.Route.extend({
        afterModel: function (post
        /*, transition */
        ) {
          var parent_model = this.modelFor('the-post');
          assert.equal(post, parent_model);
        }
      }));
      return this.visit('/posts/1/comments').then(function () {
        assert.ok(true, '/posts/1/comments');
        return _this34.visit('/posts/2/comments');
      }).then(function () {
        assert.ok(true, '/posts/2/comments');
        return _this34.visit('/posts/3/comments');
      }).then(function () {
        assert.ok(true, '/posts/3/comments');
      });
    };

    _proto['@test It is possible to get the model from a parent route'] = function testItIsPossibleToGetTheModelFromAParentRoute(assert) {
      var _this35 = this;

      assert.expect(6);
      this.router.map(function () {
        this.route('the-post', {
          path: '/posts/:post_id'
        }, function () {
          this.route('comments', {
            resetNamespace: true
          });
        });
      });
      var post1 = {};
      var post2 = {};
      var post3 = {};
      var currentPost;
      var posts = {
        1: post1,
        2: post2,
        3: post3
      };
      this.add('route:the-post', _routing.Route.extend({
        model: function (params) {
          return posts[params.post_id];
        }
      }));
      this.add('route:comments', _routing.Route.extend({
        model: function () {
          assert.equal(this.modelFor('the-post'), currentPost);
        }
      }));
      currentPost = post1;
      return this.visit('/posts/1/comments').then(function () {
        assert.ok(true, '/posts/1/comments has been handled');
        currentPost = post2;
        return _this35.visit('/posts/2/comments');
      }).then(function () {
        assert.ok(true, '/posts/2/comments has been handled');
        currentPost = post3;
        return _this35.visit('/posts/3/comments');
      }).then(function () {
        assert.ok(true, '/posts/3/comments has been handled');
      });
    };

    _proto['@test A redirection hook is provided'] = function testARedirectionHookIsProvided(assert) {
      var _this36 = this;

      this.router.map(function () {
        this.route('choose', {
          path: '/'
        });
        this.route('home');
      });
      var chooseFollowed = 0;
      var destination = 'home';
      this.add('route:choose', _routing.Route.extend({
        redirect: function () {
          if (destination) {
            this.transitionTo(destination);
          }
        },
        setupController: function () {
          chooseFollowed++;
        }
      }));
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(chooseFollowed, 0, "The choose route wasn't entered since a transition occurred");
        assert.equal(rootElement.querySelectorAll('h3.hours').length, 1, 'The home template was rendered');
        assert.equal(_this36.applicationInstance.lookup('controller:application').get('currentPath'), 'home');
      });
    };

    _proto['@test Redirecting from the middle of a route aborts the remainder of the routes'] = function testRedirectingFromTheMiddleOfARouteAbortsTheRemainderOfTheRoutes(assert) {
      var _this37 = this;

      assert.expect(3);
      this.router.map(function () {
        this.route('home');
        this.route('foo', function () {
          this.route('bar', {
            resetNamespace: true
          }, function () {
            this.route('baz');
          });
        });
      });
      this.add('route:bar', _routing.Route.extend({
        redirect: function () {
          this.transitionTo('home');
        },
        setupController: function () {
          assert.ok(false, 'Should transition before setupController');
        }
      }));
      this.add('route:bar-baz', _routing.Route.extend({
        enter: function () {
          assert.ok(false, 'Should abort transition getting to next route');
        }
      }));
      return this.visit('/').then(function () {
        var router = _this37.applicationInstance.lookup('router:main');

        _this37.handleURLAborts(assert, '/foo/bar/baz');

        assert.equal(_this37.applicationInstance.lookup('controller:application').get('currentPath'), 'home');
        assert.equal(router.get('location').getURL(), '/home');
      });
    };

    _proto['@test Redirecting to the current target in the middle of a route does not abort initial routing'] = function testRedirectingToTheCurrentTargetInTheMiddleOfARouteDoesNotAbortInitialRouting(assert) {
      var _this38 = this;

      assert.expect(5);
      this.router.map(function () {
        this.route('home');
        this.route('foo', function () {
          this.route('bar', {
            resetNamespace: true
          }, function () {
            this.route('baz');
          });
        });
      });
      var successCount = 0;
      this.add('route:bar', _routing.Route.extend({
        redirect: function () {
          return this.transitionTo('bar.baz').then(function () {
            successCount++;
          });
        },
        setupController: function () {
          assert.ok(true, "Should still invoke bar's setupController");
        }
      }));
      this.add('route:bar.baz', _routing.Route.extend({
        setupController: function () {
          assert.ok(true, "Should still invoke bar.baz's setupController");
        }
      }));
      return this.visit('/foo/bar/baz').then(function () {
        assert.ok(true, '/foo/bar/baz has been handled');
        assert.equal(_this38.applicationInstance.lookup('controller:application').get('currentPath'), 'foo.bar.baz');
        assert.equal(successCount, 1, 'transitionTo success handler was called once');
      });
    };

    _proto['@test Redirecting to the current target with a different context aborts the remainder of the routes'] = function testRedirectingToTheCurrentTargetWithADifferentContextAbortsTheRemainderOfTheRoutes(assert) {
      var _this39 = this;

      assert.expect(4);
      this.router.map(function () {
        this.route('home');
        this.route('foo', function () {
          this.route('bar', {
            path: 'bar/:id',
            resetNamespace: true
          }, function () {
            this.route('baz');
          });
        });
      });
      var model = {
        id: 2
      };
      var count = 0;
      this.add('route:bar', _routing.Route.extend({
        afterModel: function () {
          if (count++ > 10) {
            assert.ok(false, 'infinite loop');
          } else {
            this.transitionTo('bar.baz', model);
          }
        }
      }));
      this.add('route:bar.baz', _routing.Route.extend({
        setupController: function () {
          assert.ok(true, 'Should still invoke setupController');
        }
      }));
      return this.visit('/').then(function () {
        _this39.handleURLAborts(assert, '/foo/bar/1/baz');

        assert.equal(_this39.applicationInstance.lookup('controller:application').get('currentPath'), 'foo.bar.baz');
        assert.equal(_this39.applicationInstance.lookup('router:main').get('location').getURL(), '/foo/bar/2/baz');
      });
    };

    _proto['@test Transitioning from a parent event does not prevent currentPath from being set'] = function testTransitioningFromAParentEventDoesNotPreventCurrentPathFromBeingSet(assert) {
      var _this40 = this;

      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar', {
            resetNamespace: true
          }, function () {
            this.route('baz');
          });
          this.route('qux');
        });
      });
      this.add('route:foo', _routing.Route.extend({
        actions: {
          goToQux: function () {
            this.transitionTo('foo.qux');
          }
        }
      }));
      return this.visit('/foo/bar/baz').then(function () {
        assert.ok(true, '/foo/bar/baz has been handled');

        var applicationController = _this40.applicationInstance.lookup('controller:application');

        var router = _this40.applicationInstance.lookup('router:main');

        assert.equal(applicationController.get('currentPath'), 'foo.bar.baz');
        (0, _runloop.run)(function () {
          return router.send('goToQux');
        });
        assert.equal(applicationController.get('currentPath'), 'foo.qux');
        assert.equal(router.get('location').getURL(), '/foo/qux');
      });
    };

    _proto['@test Generated names can be customized when providing routes with dot notation'] = function testGeneratedNamesCanBeCustomizedWhenProvidingRoutesWithDotNotation(assert) {
      assert.expect(4);
      this.addTemplate('index', '<div>Index</div>');
      this.addTemplate('application', "<h1>Home</h1><div class='main'>{{outlet}}</div>");
      this.addTemplate('foo', "<div class='middle'>{{outlet}}</div>");
      this.addTemplate('bar', "<div class='bottom'>{{outlet}}</div>");
      this.addTemplate('bar.baz', '<p>{{name}}Bottom!</p>');
      this.router.map(function () {
        this.route('foo', {
          path: '/top'
        }, function () {
          this.route('bar', {
            path: '/middle',
            resetNamespace: true
          }, function () {
            this.route('baz', {
              path: '/bottom'
            });
          });
        });
      });
      this.add('route:foo', _routing.Route.extend({
        renderTemplate: function () {
          assert.ok(true, 'FooBarRoute was called');
          return this._super.apply(this, arguments);
        }
      }));
      this.add('route:bar.baz', _routing.Route.extend({
        renderTemplate: function () {
          assert.ok(true, 'BarBazRoute was called');
          return this._super.apply(this, arguments);
        }
      }));
      this.add('controller:bar', _controller.default.extend({
        name: 'Bar'
      }));
      this.add('controller:bar.baz', _controller.default.extend({
        name: 'BarBaz'
      }));
      return this.visit('/top/middle/bottom').then(function () {
        assert.ok(true, '/top/middle/bottom has been handled');
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('.main .middle .bottom p')), 'BarBazBottom!', 'The templates were rendered into their appropriate parents');
      });
    };

    _proto["@test Child routes render into their parent route's template by default"] = function testChildRoutesRenderIntoTheirParentRouteSTemplateByDefault(assert) {
      this.addTemplate('index', '<div>Index</div>');
      this.addTemplate('application', "<h1>Home</h1><div class='main'>{{outlet}}</div>");
      this.addTemplate('top', "<div class='middle'>{{outlet}}</div>");
      this.addTemplate('middle', "<div class='bottom'>{{outlet}}</div>");
      this.addTemplate('middle.bottom', '<p>Bottom!</p>');
      this.router.map(function () {
        this.route('top', function () {
          this.route('middle', {
            resetNamespace: true
          }, function () {
            this.route('bottom');
          });
        });
      });
      return this.visit('/top/middle/bottom').then(function () {
        assert.ok(true, '/top/middle/bottom has been handled');
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('.main .middle .bottom p')), 'Bottom!', 'The templates were rendered into their appropriate parents');
      });
    };

    _proto['@test Child routes render into specified template'] = function testChildRoutesRenderIntoSpecifiedTemplate(assert) {
      this.addTemplate('index', '<div>Index</div>');
      this.addTemplate('application', "<h1>Home</h1><div class='main'>{{outlet}}</div>");
      this.addTemplate('top', "<div class='middle'>{{outlet}}</div>");
      this.addTemplate('middle', "<div class='bottom'>{{outlet}}</div>");
      this.addTemplate('middle.bottom', '<p>Bottom!</p>');
      this.router.map(function () {
        this.route('top', function () {
          this.route('middle', {
            resetNamespace: true
          }, function () {
            this.route('bottom');
          });
        });
      });
      this.add('route:middle.bottom', _routing.Route.extend({
        renderTemplate: function () {
          this.render('middle/bottom', {
            into: 'top'
          });
        }
      }));
      return this.visit('/top/middle/bottom').then(function () {
        assert.ok(true, '/top/middle/bottom has been handled');
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.querySelectorAll('.main .middle .bottom p').length, 0, 'should not render into the middle template');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('.main .middle > p')), 'Bottom!', 'The template was rendered into the top template');
      });
    };

    _proto['@test Rendering into specified template with slash notation'] = function testRenderingIntoSpecifiedTemplateWithSlashNotation(assert) {
      this.addTemplate('person.profile', 'profile {{outlet}}');
      this.addTemplate('person.details', 'details!');
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add('route:home', _routing.Route.extend({
        renderTemplate: function () {
          this.render('person/profile');
          this.render('person/details', {
            into: 'person/profile'
          });
        }
      }));
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.textContent.trim(), 'profile details!', 'The templates were rendered');
      });
    };

    _proto['@test Parent route context change'] = function testParentRouteContextChange(assert) {
      var _this41 = this;

      var editCount = 0;
      var editedPostIds = (0, _runtime.A)();
      this.addTemplate('application', '{{outlet}}');
      this.addTemplate('posts', '{{outlet}}');
      this.addTemplate('post', '{{outlet}}');
      this.addTemplate('post/index', 'showing');
      this.addTemplate('post/edit', 'editing');
      this.router.map(function () {
        this.route('posts', function () {
          this.route('post', {
            path: '/:postId',
            resetNamespace: true
          }, function () {
            this.route('edit');
          });
        });
      });
      this.add('route:posts', _routing.Route.extend({
        actions: {
          showPost: function (context) {
            this.transitionTo('post', context);
          }
        }
      }));
      this.add('route:post', _routing.Route.extend({
        model: function (params) {
          return {
            id: params.postId
          };
        },
        serialize: function (model) {
          return {
            postId: model.id
          };
        },
        actions: {
          editPost: function () {
            this.transitionTo('post.edit');
          }
        }
      }));
      this.add('route:post.edit', _routing.Route.extend({
        model: function () {
          var postId = this.modelFor('post').id;
          editedPostIds.push(postId);
          return null;
        },
        setup: function () {
          this._super.apply(this, arguments);

          editCount++;
        }
      }));
      return this.visit('/posts/1').then(function () {
        assert.ok(true, '/posts/1 has been handled');

        var router = _this41.applicationInstance.lookup('router:main');

        (0, _runloop.run)(function () {
          return router.send('editPost');
        });
        (0, _runloop.run)(function () {
          return router.send('showPost', {
            id: '2'
          });
        });
        (0, _runloop.run)(function () {
          return router.send('editPost');
        });
        assert.equal(editCount, 2, 'set up the edit route twice without failure');
        assert.deepEqual(editedPostIds, ['1', '2'], 'modelFor posts.post returns the right context');
      });
    };

    _proto['@test Router accounts for rootURL on page load when using history location'] = function testRouterAccountsForRootURLOnPageLoadWhenUsingHistoryLocation(assert) {
      var rootURL = window.location.pathname + '/app';
      var postsTemplateRendered = false;
      var setHistory;

      setHistory = function (obj, path) {
        obj.set('history', {
          state: {
            path: path
          }
        });
      };

      var location = _routing.HistoryLocation.create({
        initState: function () {
          var path = rootURL + '/posts';
          setHistory(this, path);
          this.set('location', {
            pathname: path,
            href: 'http://localhost/' + path
          });
        },
        replaceState: function (path) {
          setHistory(this, path);
        },
        pushState: function (path) {
          setHistory(this, path);
        }
      });

      this.router.reopen({
        // location: 'historyTest',
        location: location,
        rootURL: rootURL
      });
      this.router.map(function () {
        this.route('posts', {
          path: '/posts'
        });
      });
      this.add('route:posts', _routing.Route.extend({
        model: function () {},
        renderTemplate: function () {
          postsTemplateRendered = true;
        }
      }));
      return this.visit('/').then(function () {
        assert.ok(postsTemplateRendered, 'Posts route successfully stripped from rootURL');
        (0, _internalTestHelpers.runDestroy)(location);
        location = null;
      });
    };

    _proto['@test The rootURL is passed properly to the location implementation'] = function testTheRootURLIsPassedProperlyToTheLocationImplementation(assert) {
      assert.expect(1);
      var rootURL = '/blahzorz';
      this.add('location:history-test', _routing.HistoryLocation.extend({
        rootURL: 'this is not the URL you are looking for',
        history: {
          pushState: function () {}
        },
        initState: function () {
          assert.equal(this.get('rootURL'), rootURL);
        }
      }));
      this.router.reopen({
        location: 'history-test',
        rootURL: rootURL,
        // if we transition in this test we will receive failures
        // if the tests are run from a static file
        _doURLTransition: function () {
          return _rsvp.default.resolve('');
        }
      });
      return this.visit('/');
    };

    _proto['@test Only use route rendered into main outlet for default into property on child'] = function testOnlyUseRouteRenderedIntoMainOutletForDefaultIntoPropertyOnChild(assert) {
      this.addTemplate('application', "{{outlet 'menu'}}{{outlet}}");
      this.addTemplate('posts', '{{outlet}}');
      this.addTemplate('posts.index', '<p class="posts-index">postsIndex</p>');
      this.addTemplate('posts.menu', '<div class="posts-menu">postsMenu</div>');
      this.router.map(function () {
        this.route('posts', function () {});
      });
      this.add('route:posts', _routing.Route.extend({
        renderTemplate: function () {
          this.render();
          this.render('posts/menu', {
            into: 'application',
            outlet: 'menu'
          });
        }
      }));
      return this.visit('/posts').then(function () {
        assert.ok(true, '/posts has been handled');
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-menu')), 'postsMenu', 'The posts/menu template was rendered');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p.posts-index')), 'postsIndex', 'The posts/index template was rendered');
      });
    };

    _proto['@test Generating a URL should not affect currentModel'] = function testGeneratingAURLShouldNotAffectCurrentModel(assert) {
      var _this42 = this;

      this.router.map(function () {
        this.route('post', {
          path: '/posts/:post_id'
        });
      });
      var posts = {
        1: {
          id: 1
        },
        2: {
          id: 2
        }
      };
      this.add('route:post', _routing.Route.extend({
        model: function (params) {
          return posts[params.post_id];
        }
      }));
      return this.visit('/posts/1').then(function () {
        assert.ok(true, '/posts/1 has been handled');

        var route = _this42.applicationInstance.lookup('route:post');

        assert.equal(route.modelFor('post'), posts[1]);

        var url = _this42.applicationInstance.lookup('router:main').generate('post', posts[2]);

        assert.equal(url, '/posts/2');
        assert.equal(route.modelFor('post'), posts[1]);
      });
    };

    _proto["@test Nested index route is not overridden by parent's implicit index route"] = function testNestedIndexRouteIsNotOverriddenByParentSImplicitIndexRoute(assert) {
      var _this43 = this;

      this.router.map(function () {
        this.route('posts', function () {
          this.route('index', {
            path: ':category'
          });
        });
      });
      return this.visit('/').then(function () {
        var router = _this43.applicationInstance.lookup('router:main');

        return router.transitionTo('posts', {
          category: 'emberjs'
        });
      }).then(function () {
        var router = _this43.applicationInstance.lookup('router:main');

        assert.deepEqual(router.location.path, '/posts/emberjs');
      });
    };

    _proto['@test Application template does not duplicate when re-rendered'] = function testApplicationTemplateDoesNotDuplicateWhenReRendered(assert) {
      this.addTemplate('application', '<h3 class="render-once">I render once</h3>{{outlet}}');
      this.router.map(function () {
        this.route('posts');
      });
      this.add('route:application', _routing.Route.extend({
        model: function () {
          return (0, _runtime.A)();
        }
      }));
      return this.visit('/posts').then(function () {
        assert.ok(true, '/posts has been handled');
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('h3.render-once')), 'I render once');
      });
    };

    _proto['@test Child routes should render inside the application template if the application template causes a redirect'] = function testChildRoutesShouldRenderInsideTheApplicationTemplateIfTheApplicationTemplateCausesARedirect(assert) {
      this.addTemplate('application', '<h3>App</h3> {{outlet}}');
      this.addTemplate('posts', 'posts');
      this.router.map(function () {
        this.route('posts');
        this.route('photos');
      });
      this.add('route:application', _routing.Route.extend({
        afterModel: function () {
          this.transitionTo('posts');
        }
      }));
      return this.visit('/posts').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.textContent.trim(), 'App posts');
      });
    };

    _proto["@test The template is not re-rendered when the route's context changes"] = function testTheTemplateIsNotReRenderedWhenTheRouteSContextChanges(assert) {
      var _this44 = this;

      this.router.map(function () {
        this.route('page', {
          path: '/page/:name'
        });
      });
      this.add('route:page', _routing.Route.extend({
        model: function (params) {
          return _runtime.Object.create({
            name: params.name
          });
        }
      }));
      var insertionCount = 0;
      this.add('component:foo-bar', _glimmer.Component.extend({
        didInsertElement: function () {
          insertionCount += 1;
        }
      }));
      this.addTemplate('page', '<p>{{model.name}}{{foo-bar}}</p>');
      var rootElement = document.getElementById('qunit-fixture');
      return this.visit('/page/first').then(function () {
        assert.ok(true, '/page/first has been handled');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'first');
        assert.equal(insertionCount, 1);
        return _this44.visit('/page/second');
      }).then(function () {
        assert.ok(true, '/page/second has been handled');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'second');
        assert.equal(insertionCount, 1, 'view should have inserted only once');

        var router = _this44.applicationInstance.lookup('router:main');

        return (0, _runloop.run)(function () {
          return router.transitionTo('page', _runtime.Object.create({
            name: 'third'
          }));
        });
      }).then(function () {
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'third');
        assert.equal(insertionCount, 1, 'view should still have inserted only once');
      });
    };

    _proto['@test The template is not re-rendered when two routes present the exact same template & controller'] = function testTheTemplateIsNotReRenderedWhenTwoRoutesPresentTheExactSameTemplateController(assert) {
      var _this45 = this;

      this.router.map(function () {
        this.route('first');
        this.route('second');
        this.route('third');
        this.route('fourth');
      }); // Note add a component to test insertion

      var insertionCount = 0;
      this.add('component:x-input', _glimmer.Component.extend({
        didInsertElement: function () {
          insertionCount += 1;
        }
      }));

      var SharedRoute = _routing.Route.extend({
        setupController: function () {
          this.controllerFor('shared').set('message', 'This is the ' + this.routeName + ' message');
        },
        renderTemplate: function () {
          this.render('shared', {
            controller: 'shared'
          });
        }
      });

      this.add('route:shared', SharedRoute);
      this.add('route:first', SharedRoute.extend());
      this.add('route:second', SharedRoute.extend());
      this.add('route:third', SharedRoute.extend());
      this.add('route:fourth', SharedRoute.extend());
      this.add('controller:shared', _controller.default.extend());
      this.addTemplate('shared', '<p>{{message}}{{x-input}}</p>');
      var rootElement = document.getElementById('qunit-fixture');
      return this.visit('/first').then(function () {
        assert.ok(true, '/first has been handled');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'This is the first message');
        assert.equal(insertionCount, 1, 'expected one assertion');
        return _this45.visit('/second');
      }).then(function () {
        assert.ok(true, '/second has been handled');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'This is the second message');
        assert.equal(insertionCount, 1, 'expected one assertion');
        return (0, _runloop.run)(function () {
          _this45.applicationInstance.lookup('router:main').transitionTo('third').then(function () {
            assert.ok(true, 'expected transition');
          }, function (reason) {
            assert.ok(false, 'unexpected transition failure: ', QUnit.jsDump.parse(reason));
          });
        });
      }).then(function () {
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'This is the third message');
        assert.equal(insertionCount, 1, 'expected one assertion');
        return _this45.visit('fourth');
      }).then(function () {
        assert.ok(true, '/fourth has been handled');
        assert.equal(insertionCount, 1, 'expected one assertion');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'This is the fourth message');
      });
    };

    _proto['@test ApplicationRoute with model does not proxy the currentPath'] = function testApplicationRouteWithModelDoesNotProxyTheCurrentPath(assert) {
      var model = {};
      var currentPath;
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('route:application', _routing.Route.extend({
        model: function () {
          return model;
        }
      }));
      this.add('controller:application', _controller.default.extend({
        currentPathDidChange: (0, _metal.observer)('currentPath', function () {
          currentPath = this.currentPath;
        })
      }));
      return this.visit('/').then(function () {
        assert.equal(currentPath, 'index', 'currentPath is index');
        assert.equal('currentPath' in model, false, 'should have defined currentPath on controller');
      });
    };

    _proto['@test Promises encountered on app load put app into loading state until resolved'] = function testPromisesEncounteredOnAppLoadPutAppIntoLoadingStateUntilResolved(assert) {
      var _this46 = this;

      assert.expect(2);

      var deferred = _rsvp.default.defer();

      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('route:index', _routing.Route.extend({
        model: function () {
          return deferred.promise;
        }
      }));
      this.addTemplate('index', '<p>INDEX</p>');
      this.addTemplate('loading', '<p>LOADING</p>');
      (0, _runloop.run)(function () {
        return _this46.visit('/');
      });
      var rootElement = document.getElementById('qunit-fixture');
      assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'LOADING', 'The loading state is displaying.');
      (0, _runloop.run)(deferred.resolve);
      assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'INDEX', 'The index route is display.');
    };

    _proto['@test Route should tear down multiple outlets'] = function testRouteShouldTearDownMultipleOutlets(assert) {
      var _this47 = this;

      this.addTemplate('application', "{{outlet 'menu'}}{{outlet}}{{outlet 'footer'}}");
      this.addTemplate('posts', '{{outlet}}');
      this.addTemplate('users', 'users');
      this.addTemplate('posts.index', '<p class="posts-index">postsIndex</p>');
      this.addTemplate('posts.menu', '<div class="posts-menu">postsMenu</div>');
      this.addTemplate('posts.footer', '<div class="posts-footer">postsFooter</div>');
      this.router.map(function () {
        this.route('posts', function () {});
        this.route('users', function () {});
      });
      this.add('route:posts', _routing.Route.extend({
        renderTemplate: function () {
          this.render('posts/menu', {
            into: 'application',
            outlet: 'menu'
          });
          this.render();
          this.render('posts/footer', {
            into: 'application',
            outlet: 'footer'
          });
        }
      }));
      var rootElement = document.getElementById('qunit-fixture');
      return this.visit('/posts').then(function () {
        assert.ok(true, '/posts has been handled');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-menu')), 'postsMenu', 'The posts/menu template was rendered');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p.posts-index')), 'postsIndex', 'The posts/index template was rendered');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-footer')), 'postsFooter', 'The posts/footer template was rendered');
        return _this47.visit('/users');
      }).then(function () {
        assert.ok(true, '/users has been handled');
        assert.equal(rootElement.querySelector('div.posts-menu'), null, 'The posts/menu template was removed');
        assert.equal(rootElement.querySelector('p.posts-index'), null, 'The posts/index template was removed');
        assert.equal(rootElement.querySelector('div.posts-footer'), null, 'The posts/footer template was removed');
      });
    };

    _proto['@test Route supports clearing outlet explicitly'] = function testRouteSupportsClearingOutletExplicitly(assert) {
      var _this48 = this;

      this.addTemplate('application', "{{outlet}}{{outlet 'modal'}}");
      this.addTemplate('posts', '{{outlet}}');
      this.addTemplate('users', 'users');
      this.addTemplate('posts.index', '<div class="posts-index">postsIndex {{outlet}}</div>');
      this.addTemplate('posts.modal', '<div class="posts-modal">postsModal</div>');
      this.addTemplate('posts.extra', '<div class="posts-extra">postsExtra</div>');
      this.router.map(function () {
        this.route('posts', function () {});
        this.route('users', function () {});
      });
      this.add('route:posts', _routing.Route.extend({
        actions: {
          showModal: function () {
            this.render('posts/modal', {
              into: 'application',
              outlet: 'modal'
            });
          },
          hideModal: function () {
            this.disconnectOutlet({
              outlet: 'modal',
              parentView: 'application'
            });
          }
        }
      }));
      this.add('route:posts.index', _routing.Route.extend({
        actions: {
          showExtra: function () {
            this.render('posts/extra', {
              into: 'posts/index'
            });
          },
          hideExtra: function () {
            this.disconnectOutlet({
              parentView: 'posts/index'
            });
          }
        }
      }));
      var rootElement = document.getElementById('qunit-fixture');
      return this.visit('/posts').then(function () {
        var router = _this48.applicationInstance.lookup('router:main');

        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-index')), 'postsIndex', 'The posts/index template was rendered');
        (0, _runloop.run)(function () {
          return router.send('showModal');
        });
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-modal')), 'postsModal', 'The posts/modal template was rendered');
        (0, _runloop.run)(function () {
          return router.send('showExtra');
        });
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-extra')), 'postsExtra', 'The posts/extra template was rendered');
        (0, _runloop.run)(function () {
          return router.send('hideModal');
        });
        assert.equal(rootElement.querySelector('div.posts-modal'), null, 'The posts/modal template was removed');
        (0, _runloop.run)(function () {
          return router.send('hideExtra');
        });
        assert.equal(rootElement.querySelector('div.posts-extra'), null, 'The posts/extra template was removed');
        (0, _runloop.run)(function () {
          router.send('showModal');
        });
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-modal')), 'postsModal', 'The posts/modal template was rendered');
        (0, _runloop.run)(function () {
          router.send('showExtra');
        });
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-extra')), 'postsExtra', 'The posts/extra template was rendered');
        return _this48.visit('/users');
      }).then(function () {
        assert.equal(rootElement.querySelector('div.posts-index'), null, 'The posts/index template was removed');
        assert.equal(rootElement.querySelector('div.posts-modal'), null, 'The posts/modal template was removed');
        assert.equal(rootElement.querySelector('div.posts-extra'), null, 'The posts/extra template was removed');
      });
    };

    _proto['@test Route supports clearing outlet using string parameter'] = function testRouteSupportsClearingOutletUsingStringParameter(assert) {
      var _this49 = this;

      this.addTemplate('application', "{{outlet}}{{outlet 'modal'}}");
      this.addTemplate('posts', '{{outlet}}');
      this.addTemplate('users', 'users');
      this.addTemplate('posts.index', '<div class="posts-index">postsIndex {{outlet}}</div>');
      this.addTemplate('posts.modal', '<div class="posts-modal">postsModal</div>');
      this.router.map(function () {
        this.route('posts', function () {});
        this.route('users', function () {});
      });
      this.add('route:posts', _routing.Route.extend({
        actions: {
          showModal: function () {
            this.render('posts/modal', {
              into: 'application',
              outlet: 'modal'
            });
          },
          hideModal: function () {
            this.disconnectOutlet('modal');
          }
        }
      }));
      var rootElement = document.getElementById('qunit-fixture');
      return this.visit('/posts').then(function () {
        var router = _this49.applicationInstance.lookup('router:main');

        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-index')), 'postsIndex', 'The posts/index template was rendered');
        (0, _runloop.run)(function () {
          return router.send('showModal');
        });
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-modal')), 'postsModal', 'The posts/modal template was rendered');
        (0, _runloop.run)(function () {
          return router.send('hideModal');
        });
        assert.equal(rootElement.querySelector('div.posts-modal'), null, 'The posts/modal template was removed');
        return _this49.visit('/users');
      }).then(function () {
        assert.equal(rootElement.querySelector('div.posts-index'), null, 'The posts/index template was removed');
        assert.equal(rootElement.querySelector('div.posts-modal'), null, 'The posts/modal template was removed');
      });
    };

    _proto['@test Route silently fails when cleaning an outlet from an inactive view'] = function testRouteSilentlyFailsWhenCleaningAnOutletFromAnInactiveView(assert) {
      var _this50 = this;

      assert.expect(1); // handleURL

      this.addTemplate('application', '{{outlet}}');
      this.addTemplate('posts', "{{outlet 'modal'}}");
      this.addTemplate('modal', 'A Yo.');
      this.router.map(function () {
        this.route('posts');
      });
      this.add('route:posts', _routing.Route.extend({
        actions: {
          hideSelf: function () {
            this.disconnectOutlet({
              outlet: 'main',
              parentView: 'application'
            });
          },
          showModal: function () {
            this.render('modal', {
              into: 'posts',
              outlet: 'modal'
            });
          },
          hideModal: function () {
            this.disconnectOutlet({
              outlet: 'modal',
              parentView: 'posts'
            });
          }
        }
      }));
      return this.visit('/posts').then(function () {
        assert.ok(true, '/posts has been handled');

        var router = _this50.applicationInstance.lookup('router:main');

        (0, _runloop.run)(function () {
          return router.send('showModal');
        });
        (0, _runloop.run)(function () {
          return router.send('hideSelf');
        });
        (0, _runloop.run)(function () {
          return router.send('hideModal');
        });
      });
    };

    _proto['@test Router `willTransition` hook passes in cancellable transition'] = function testRouterWillTransitionHookPassesInCancellableTransition(assert) {
      var _this51 = this;

      assert.expect(8);
      this.router.reopen({
        willTransition: function (_, _2, transition) {
          assert.ok(true, 'willTransition was called');

          if (transition.intent.url !== '/') {
            transition.abort();
          }
        }
      });
      this.router.map(function () {
        this.route('nork');
        this.route('about');
      });
      this.add('route:loading', _routing.Route.extend({
        activate: function () {
          assert.ok(false, 'LoadingRoute was not entered');
        }
      }));
      this.add('route:nork', _routing.Route.extend({
        activate: function () {
          assert.ok(false, 'NorkRoute was not entered');
        }
      }));
      this.add('route:about', _routing.Route.extend({
        activate: function () {
          assert.ok(false, 'AboutRoute was not entered');
        }
      }));
      var deprecation = /You attempted to override the "willTransition" method which is deprecated\./;
      return expectDeprecation(function () {
        return _this51.visit('/').then(function () {
          _this51.handleURLAborts(assert, '/nork', deprecation);

          _this51.handleURLAborts(assert, '/about', deprecation);
        });
      }, deprecation);
    };

    _proto['@test Aborting/redirecting the transition in `willTransition` prevents LoadingRoute from being entered'] = function testAbortingRedirectingTheTransitionInWillTransitionPreventsLoadingRouteFromBeingEntered(assert) {
      var _this52 = this;

      assert.expect(5);
      this.router.map(function () {
        this.route('index');
        this.route('nork');
        this.route('about');
      });
      var redirect = false;
      this.add('route:index', _routing.Route.extend({
        actions: {
          willTransition: function (transition) {
            assert.ok(true, 'willTransition was called');

            if (redirect) {
              // router.js won't refire `willTransition` for this redirect
              this.transitionTo('about');
            } else {
              transition.abort();
            }
          }
        }
      }));
      var deferred = null;
      this.add('route:loading', _routing.Route.extend({
        activate: function () {
          assert.ok(deferred, 'LoadingRoute should be entered at this time');
        },
        deactivate: function () {
          assert.ok(true, 'LoadingRoute was exited');
        }
      }));
      this.add('route:nork', _routing.Route.extend({
        activate: function () {
          assert.ok(true, 'NorkRoute was entered');
        }
      }));
      this.add('route:about', _routing.Route.extend({
        activate: function () {
          assert.ok(true, 'AboutRoute was entered');
        },
        model: function () {
          if (deferred) {
            return deferred.promise;
          }
        }
      }));
      return this.visit('/').then(function () {
        var router = _this52.applicationInstance.lookup('router:main'); // Attempted transitions out of index should abort.


        (0, _runloop.run)(router, 'transitionTo', 'nork');
        (0, _runloop.run)(router, 'handleURL', '/nork'); // Attempted transitions out of index should redirect to about

        redirect = true;
        (0, _runloop.run)(router, 'transitionTo', 'nork');
        (0, _runloop.run)(router, 'transitionTo', 'index'); // Redirected transitions out of index to a route with a
        // promise model should pause the transition and
        // activate LoadingRoute

        deferred = _rsvp.default.defer();
        (0, _runloop.run)(router, 'transitionTo', 'nork');
        (0, _runloop.run)(deferred.resolve);
      });
    };

    _proto['@test `didTransition` event fires on the router'] = function testDidTransitionEventFiresOnTheRouter(assert) {
      var _this53 = this;

      assert.expect(3);
      this.router.map(function () {
        this.route('nork');
      });
      return this.visit('/').then(function () {
        var router = _this53.applicationInstance.lookup('router:main');

        router.one('didTransition', function () {
          assert.ok(true, 'didTransition fired on initial routing');
        });

        _this53.visit('/');
      }).then(function () {
        var router = _this53.applicationInstance.lookup('router:main');

        router.one('didTransition', function () {
          assert.ok(true, 'didTransition fired on the router');
          assert.equal(router.get('url'), '/nork', 'The url property is updated by the time didTransition fires');
        });
        return _this53.visit('/nork');
      });
    };

    _proto['@test `didTransition` can be reopened'] = function testDidTransitionCanBeReopened(assert) {
      assert.expect(1);
      this.router.map(function () {
        this.route('nork');
      });

      if (true
      /* EMBER_ROUTING_ROUTER_SERVICE */
      ) {
          assert.ok(true, 'no longer a valid test');
          return;
        } else {
        this.router.reopen({
          didTransition: function () {
            this._super.apply(this, arguments);

            assert.ok(true, 'reopened didTransition was called');
          }
        });
      }

      return this.visit('/');
    };

    _proto['@test `activate` event fires on the route'] = function testActivateEventFiresOnTheRoute(assert) {
      assert.expect(2);
      var eventFired = 0;
      this.router.map(function () {
        this.route('nork');
      });
      this.add('route:nork', _routing.Route.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.on('activate', function () {
            assert.equal(++eventFired, 1, 'activate event is fired once');
          });
        },
        activate: function () {
          assert.ok(true, 'activate hook is called');
        }
      }));
      return this.visit('/nork');
    };

    _proto['@test `deactivate` event fires on the route'] = function testDeactivateEventFiresOnTheRoute(assert) {
      var _this54 = this;

      assert.expect(2);
      var eventFired = 0;
      this.router.map(function () {
        this.route('nork');
        this.route('dork');
      });
      this.add('route:nork', _routing.Route.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.on('deactivate', function () {
            assert.equal(++eventFired, 1, 'deactivate event is fired once');
          });
        },
        deactivate: function () {
          assert.ok(true, 'deactivate hook is called');
        }
      }));
      return this.visit('/nork').then(function () {
        return _this54.visit('/dork');
      });
    };

    _proto['@test Actions can be handled by inherited action handlers'] = function testActionsCanBeHandledByInheritedActionHandlers(assert) {
      assert.expect(4);

      var SuperRoute = _routing.Route.extend({
        actions: {
          foo: function () {
            assert.ok(true, 'foo');
          },
          bar: function (msg) {
            assert.equal(msg, 'HELLO');
          }
        }
      });

      var RouteMixin = _metal.Mixin.create({
        actions: {
          bar: function (msg) {
            assert.equal(msg, 'HELLO');

            this._super(msg);
          }
        }
      });

      this.add('route:home', SuperRoute.extend(RouteMixin, {
        actions: {
          baz: function () {
            assert.ok(true, 'baz');
          }
        }
      }));
      this.addTemplate('home', "\n      <a class=\"do-foo\" {{action \"foo\"}}>Do foo</a>\n      <a class=\"do-bar-with-arg\" {{action \"bar\" \"HELLO\"}}>Do bar with arg</a>\n      <a class=\"do-baz\" {{action \"baz\"}}>Do bar</a>\n    ");
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        rootElement.querySelector('.do-foo').click();
        rootElement.querySelector('.do-bar-with-arg').click();
        rootElement.querySelector('.do-baz').click();
      });
    };

    _proto['@test transitionTo returns Transition when passed a route name'] = function testTransitionToReturnsTransitionWhenPassedARouteName(assert) {
      var _this55 = this;

      assert.expect(1);
      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('bar');
      });
      return this.visit('/').then(function () {
        var router = _this55.applicationInstance.lookup('router:main');

        var transition = (0, _runloop.run)(function () {
          return router.transitionTo('bar');
        });
        assert.equal(transition instanceof _router_js.InternalTransition, true);
      });
    };

    _proto['@test transitionTo returns Transition when passed a url'] = function testTransitionToReturnsTransitionWhenPassedAUrl(assert) {
      var _this56 = this;

      assert.expect(1);
      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('bar', function () {
          this.route('baz');
        });
      });
      return this.visit('/').then(function () {
        var router = _this56.applicationInstance.lookup('router:main');

        var transition = (0, _runloop.run)(function () {
          return router.transitionTo('/bar/baz');
        });
        assert.equal(transition instanceof _router_js.InternalTransition, true);
      });
    };

    _proto['@test currentRouteName is a property installed on ApplicationController that can be used in transitionTo'] = function testCurrentRouteNameIsAPropertyInstalledOnApplicationControllerThatCanBeUsedInTransitionTo(assert) {
      var _this57 = this;

      assert.expect(24);
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
        this.route('be', function () {
          this.route('excellent', {
            resetNamespace: true
          }, function () {
            this.route('to', {
              resetNamespace: true
            }, function () {
              this.route('each', {
                resetNamespace: true
              }, function () {
                this.route('other');
              });
            });
          });
        });
      });
      return this.visit('/').then(function () {
        var appController = _this57.applicationInstance.lookup('controller:application');

        var router = _this57.applicationInstance.lookup('router:main');

        function transitionAndCheck(path, expectedPath, expectedRouteName) {
          if (path) {
            (0, _runloop.run)(router, 'transitionTo', path);
          }

          assert.equal(appController.get('currentPath'), expectedPath);
          assert.equal(appController.get('currentRouteName'), expectedRouteName);
        }

        transitionAndCheck(null, 'index', 'index');
        transitionAndCheck('/be', 'be.index', 'be.index');
        transitionAndCheck('/be/excellent', 'be.excellent.index', 'excellent.index');
        transitionAndCheck('/be/excellent/to', 'be.excellent.to.index', 'to.index');
        transitionAndCheck('/be/excellent/to/each', 'be.excellent.to.each.index', 'each.index');
        transitionAndCheck('/be/excellent/to/each/other', 'be.excellent.to.each.other', 'each.other');
        transitionAndCheck('index', 'index', 'index');
        transitionAndCheck('be', 'be.index', 'be.index');
        transitionAndCheck('excellent', 'be.excellent.index', 'excellent.index');
        transitionAndCheck('to.index', 'be.excellent.to.index', 'to.index');
        transitionAndCheck('each', 'be.excellent.to.each.index', 'each.index');
        transitionAndCheck('each.other', 'be.excellent.to.each.other', 'each.other');
      });
    };

    _proto['@test Route model hook finds the same model as a manual find'] = function testRouteModelHookFindsTheSameModelAsAManualFind(assert) {
      var post;

      var Post = _runtime.Object.extend();

      this.add('model:post', Post);
      Post.reopenClass({
        find: function () {
          post = this;
          return {};
        }
      });
      this.router.map(function () {
        this.route('post', {
          path: '/post/:post_id'
        });
      });
      return this.visit('/post/1').then(function () {
        assert.equal(Post, post);
      });
    };

    _proto['@test Routes can refresh themselves causing their model hooks to be re-run'] = function testRoutesCanRefreshThemselvesCausingTheirModelHooksToBeReRun(assert) {
      var _this58 = this;

      this.router.map(function () {
        this.route('parent', {
          path: '/parent/:parent_id'
        }, function () {
          this.route('child');
        });
      });
      var appcount = 0;
      this.add('route:application', _routing.Route.extend({
        model: function () {
          ++appcount;
        }
      }));
      var parentcount = 0;
      this.add('route:parent', _routing.Route.extend({
        model: function (params) {
          assert.equal(params.parent_id, '123');
          ++parentcount;
        },
        actions: {
          refreshParent: function () {
            this.refresh();
          }
        }
      }));
      var childcount = 0;
      this.add('route:parent.child', _routing.Route.extend({
        model: function () {
          ++childcount;
        }
      }));
      var router;
      return this.visit('/').then(function () {
        router = _this58.applicationInstance.lookup('router:main');
        assert.equal(appcount, 1);
        assert.equal(parentcount, 0);
        assert.equal(childcount, 0);
        return (0, _runloop.run)(router, 'transitionTo', 'parent.child', '123');
      }).then(function () {
        assert.equal(appcount, 1);
        assert.equal(parentcount, 1);
        assert.equal(childcount, 1);
        return (0, _runloop.run)(router, 'send', 'refreshParent');
      }).then(function () {
        assert.equal(appcount, 1);
        assert.equal(parentcount, 2);
        assert.equal(childcount, 2);
      });
    };

    _proto['@test Specifying non-existent controller name in route#render throws'] = function testSpecifyingNonExistentControllerNameInRouteRenderThrows(assert) {
      assert.expect(1);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add('route:home', _routing.Route.extend({
        renderTemplate: function () {
          var _this59 = this;

          expectAssertion(function () {
            _this59.render('homepage', {
              controller: 'stefanpenneristhemanforme'
            });
          }, "You passed `controller: 'stefanpenneristhemanforme'` into the `render` method, but no such controller could be found.");
        }
      }));
      return this.visit('/');
    };

    _proto["@test Redirecting with null model doesn't error out"] = function testRedirectingWithNullModelDoesnTErrorOut(assert) {
      var _this60 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('about', {
          path: '/about/:hurhurhur'
        });
      });
      this.add('route:about', _routing.Route.extend({
        serialize: function (model) {
          if (model === null) {
            return {
              hurhurhur: 'TreeklesMcGeekles'
            };
          }
        }
      }));
      this.add('route:home', _routing.Route.extend({
        beforeModel: function () {
          this.transitionTo('about', null);
        }
      }));
      return this.visit('/').then(function () {
        var router = _this60.applicationInstance.lookup('router:main');

        assert.equal(router.get('location.path'), '/about/TreeklesMcGeekles');
      });
    };

    _proto['@test rejecting the model hooks promise with a non-error prints the `message` property'] = function testRejectingTheModelHooksPromiseWithANonErrorPrintsTheMessageProperty(assert) {
      var _this61 = this;

      assert.expect(5);
      var rejectedMessage = 'OMG!! SOOOOOO BAD!!!!';
      var rejectedStack = 'Yeah, buddy: stack gets printed too.';
      this.router.map(function () {
        this.route('yippie', {
          path: '/'
        });
      });

      console.error = function (initialMessage, errorMessage, errorStack) {
        assert.equal(initialMessage, 'Error while processing route: yippie', 'a message with the current route name is printed');
        assert.equal(errorMessage, rejectedMessage, "the rejected reason's message property is logged");
        assert.equal(errorStack, rejectedStack, "the rejected reason's stack property is logged");
      };

      this.add('route:yippie', _routing.Route.extend({
        model: function () {
          return _rsvp.default.reject({
            message: rejectedMessage,
            stack: rejectedStack
          });
        }
      }));
      return assert.throws(function () {
        return _this61.visit('/');
      }, function (err) {
        assert.equal(err.message, rejectedMessage);
        return true;
      }, 'expected an exception');
    };

    _proto['@test rejecting the model hooks promise with an error with `errorThrown` property prints `errorThrown.message` property'] = function testRejectingTheModelHooksPromiseWithAnErrorWithErrorThrownPropertyPrintsErrorThrownMessageProperty(assert) {
      var _this62 = this;

      assert.expect(5);
      var rejectedMessage = 'OMG!! SOOOOOO BAD!!!!';
      var rejectedStack = 'Yeah, buddy: stack gets printed too.';
      this.router.map(function () {
        this.route('yippie', {
          path: '/'
        });
      });

      console.error = function (initialMessage, errorMessage, errorStack) {
        assert.equal(initialMessage, 'Error while processing route: yippie', 'a message with the current route name is printed');
        assert.equal(errorMessage, rejectedMessage, "the rejected reason's message property is logged");
        assert.equal(errorStack, rejectedStack, "the rejected reason's stack property is logged");
      };

      this.add('route:yippie', _routing.Route.extend({
        model: function () {
          return _rsvp.default.reject({
            errorThrown: {
              message: rejectedMessage,
              stack: rejectedStack
            }
          });
        }
      }));
      assert.throws(function () {
        return _this62.visit('/');
      }, function (err) {
        assert.equal(err.message, rejectedMessage);
        return true;
      }, 'expected an exception');
    };

    _proto['@test rejecting the model hooks promise with no reason still logs error'] = function testRejectingTheModelHooksPromiseWithNoReasonStillLogsError(assert) {
      var _this63 = this;

      assert.expect(2);
      this.router.map(function () {
        this.route('wowzers', {
          path: '/'
        });
      });

      console.error = function (initialMessage) {
        assert.equal(initialMessage, 'Error while processing route: wowzers', 'a message with the current route name is printed');
      };

      this.add('route:wowzers', _routing.Route.extend({
        model: function () {
          return _rsvp.default.reject();
        }
      }));
      return assert.throws(function () {
        return _this63.visit('/');
      });
    };

    _proto['@test rejecting the model hooks promise with a string shows a good error'] = function testRejectingTheModelHooksPromiseWithAStringShowsAGoodError(assert) {
      var _this64 = this;

      assert.expect(3);
      var rejectedMessage = 'Supercalifragilisticexpialidocious';
      this.router.map(function () {
        this.route('yondo', {
          path: '/'
        });
      });

      console.error = function (initialMessage, errorMessage) {
        assert.equal(initialMessage, 'Error while processing route: yondo', 'a message with the current route name is printed');
        assert.equal(errorMessage, rejectedMessage, "the rejected reason's message property is logged");
      };

      this.add('route:yondo', _routing.Route.extend({
        model: function () {
          return _rsvp.default.reject(rejectedMessage);
        }
      }));
      assert.throws(function () {
        return _this64.visit('/');
      }, new RegExp(rejectedMessage), 'expected an exception');
    };

    _proto["@test willLeave, willChangeContext, willChangeModel actions don't fire unless feature flag enabled"] = function testWillLeaveWillChangeContextWillChangeModelActionsDonTFireUnlessFeatureFlagEnabled(assert) {
      assert.expect(1);
      this.router.map(function () {
        this.route('about');
      });

      function shouldNotFire() {
        assert.ok(false, "this action shouldn't have been received");
      }

      this.add('route:index', _routing.Route.extend({
        actions: {
          willChangeModel: shouldNotFire,
          willChangeContext: shouldNotFire,
          willLeave: shouldNotFire
        }
      }));
      this.add('route:about', _routing.Route.extend({
        setupController: function () {
          assert.ok(true, 'about route was entered');
        }
      }));
      return this.visit('/about');
    };

    _proto['@test Errors in transitionTo within redirect hook are logged'] = function testErrorsInTransitionToWithinRedirectHookAreLogged(assert) {
      var _this65 = this;

      assert.expect(4);
      var actual = [];
      this.router.map(function () {
        this.route('yondo', {
          path: '/'
        });
        this.route('stink-bomb');
      });
      this.add('route:yondo', _routing.Route.extend({
        redirect: function () {
          this.transitionTo('stink-bomb', {
            something: 'goes boom'
          });
        }
      }));

      console.error = function () {
        // push the arguments onto an array so we can detect if the error gets logged twice
        actual.push(arguments);
      };

      assert.throws(function () {
        return _this65.visit('/');
      }, /More context objects were passed/);
      assert.equal(actual.length, 1, 'the error is only logged once');
      assert.equal(actual[0][0], 'Error while processing route: yondo', 'source route is printed');
      assert.ok(actual[0][1].match(/More context objects were passed than there are dynamic segments for the route: stink-bomb/), 'the error is printed');
    };

    _proto['@test Errors in transition show error template if available'] = function testErrorsInTransitionShowErrorTemplateIfAvailable(assert) {
      this.addTemplate('error', "<div id='error'>Error!</div>");
      this.router.map(function () {
        this.route('yondo', {
          path: '/'
        });
        this.route('stink-bomb');
      });
      this.add('route:yondo', _routing.Route.extend({
        redirect: function () {
          this.transitionTo('stink-bomb', {
            something: 'goes boom'
          });
        }
      }));

      console.error = function () {};

      return this.visit('/').then(function () {
        var rootElement = document.querySelector('#qunit-fixture');
        assert.equal(rootElement.querySelectorAll('#error').length, 1, 'Error template was rendered.');
      });
    };

    _proto['@test Route#resetController gets fired when changing models and exiting routes'] = function testRouteResetControllerGetsFiredWhenChangingModelsAndExitingRoutes(assert) {
      var _this66 = this;

      assert.expect(4);
      this.router.map(function () {
        this.route('a', function () {
          this.route('b', {
            path: '/b/:id',
            resetNamespace: true
          }, function () {});
          this.route('c', {
            path: '/c/:id',
            resetNamespace: true
          }, function () {});
        });
        this.route('out');
      });
      var calls = [];

      var SpyRoute = _routing.Route.extend({
        setupController: function ()
        /* controller, model, transition */
        {
          calls.push(['setup', this.routeName]);
        },
        resetController: function ()
        /* controller */
        {
          calls.push(['reset', this.routeName]);
        }
      });

      this.add('route:a', SpyRoute.extend());
      this.add('route:b', SpyRoute.extend());
      this.add('route:c', SpyRoute.extend());
      this.add('route:out', SpyRoute.extend());
      var router;
      return this.visit('/').then(function () {
        router = _this66.applicationInstance.lookup('router:main');
        assert.deepEqual(calls, []);
        return (0, _runloop.run)(router, 'transitionTo', 'b', 'b-1');
      }).then(function () {
        assert.deepEqual(calls, [['setup', 'a'], ['setup', 'b']]);
        calls.length = 0;
        return (0, _runloop.run)(router, 'transitionTo', 'c', 'c-1');
      }).then(function () {
        assert.deepEqual(calls, [['reset', 'b'], ['setup', 'c']]);
        calls.length = 0;
        return (0, _runloop.run)(router, 'transitionTo', 'out');
      }).then(function () {
        assert.deepEqual(calls, [['reset', 'c'], ['reset', 'a'], ['setup', 'out']]);
      });
    };

    _proto['@test Exception during initialization of non-initial route is not swallowed'] = function testExceptionDuringInitializationOfNonInitialRouteIsNotSwallowed(assert) {
      var _this67 = this;

      this.router.map(function () {
        this.route('boom');
      });
      this.add('route:boom', _routing.Route.extend({
        init: function () {
          throw new Error('boom!');
        }
      }));
      return assert.throws(function () {
        return _this67.visit('/boom');
      }, /\bboom\b/);
    };

    _proto['@test Exception during initialization of initial route is not swallowed'] = function testExceptionDuringInitializationOfInitialRouteIsNotSwallowed(assert) {
      var _this68 = this;

      this.router.map(function () {
        this.route('boom', {
          path: '/'
        });
      });
      this.add('route:boom', _routing.Route.extend({
        init: function () {
          throw new Error('boom!');
        }
      }));
      return assert.throws(function () {
        return _this68.visit('/');
      }, /\bboom\b/);
    };

    _proto['@test {{outlet}} works when created after initial render'] = function testOutletWorksWhenCreatedAfterInitialRender(assert) {
      var _this69 = this;

      this.addTemplate('sample', 'Hi{{#if showTheThing}}{{outlet}}{{/if}}Bye');
      this.addTemplate('sample.inner', 'Yay');
      this.addTemplate('sample.inner2', 'Boo');
      this.router.map(function () {
        this.route('sample', {
          path: '/'
        }, function () {
          this.route('inner', {
            path: '/'
          });
          this.route('inner2', {
            path: '/2'
          });
        });
      });
      var rootElement;
      return this.visit('/').then(function () {
        rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.textContent.trim(), 'HiBye', 'initial render');
        (0, _runloop.run)(function () {
          return _this69.applicationInstance.lookup('controller:sample').set('showTheThing', true);
        });
        assert.equal(rootElement.textContent.trim(), 'HiYayBye', 'second render');
        return _this69.visit('/2');
      }).then(function () {
        assert.equal(rootElement.textContent.trim(), 'HiBooBye', 'third render');
      });
    };

    _proto['@test Can render into a named outlet at the top level'] = function testCanRenderIntoANamedOutletAtTheTopLevel(assert) {
      this.addTemplate('application', 'A-{{outlet}}-B-{{outlet "other"}}-C');
      this.addTemplate('modal', 'Hello world');
      this.addTemplate('index', 'The index');
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('route:application', _routing.Route.extend({
        renderTemplate: function () {
          this.render();
          this.render('modal', {
            into: 'application',
            outlet: 'other'
          });
        }
      }));
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.textContent.trim(), 'A-The index-B-Hello world-C', 'initial render');
      });
    };

    _proto['@test Can disconnect a named outlet at the top level'] = function testCanDisconnectANamedOutletAtTheTopLevel(assert) {
      var _this70 = this;

      this.addTemplate('application', 'A-{{outlet}}-B-{{outlet "other"}}-C');
      this.addTemplate('modal', 'Hello world');
      this.addTemplate('index', 'The index');
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('route:application', _routing.Route.extend({
        renderTemplate: function () {
          this.render();
          this.render('modal', {
            into: 'application',
            outlet: 'other'
          });
        },
        actions: {
          banish: function () {
            this.disconnectOutlet({
              parentView: 'application',
              outlet: 'other'
            });
          }
        }
      }));
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.textContent.trim(), 'A-The index-B-Hello world-C', 'initial render');
        (0, _runloop.run)(_this70.applicationInstance.lookup('router:main'), 'send', 'banish');
        assert.equal(rootElement.textContent.trim(), 'A-The index-B--C', 'second render');
      });
    };

    _proto['@test Can render into a named outlet at the top level, with empty main outlet'] = function testCanRenderIntoANamedOutletAtTheTopLevelWithEmptyMainOutlet(assert) {
      this.addTemplate('application', 'A-{{outlet}}-B-{{outlet "other"}}-C');
      this.addTemplate('modal', 'Hello world');
      this.router.map(function () {
        this.route('hasNoTemplate', {
          path: '/'
        });
      });
      this.add('route:application', _routing.Route.extend({
        renderTemplate: function () {
          this.render();
          this.render('modal', {
            into: 'application',
            outlet: 'other'
          });
        }
      }));
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.textContent.trim(), 'A--B-Hello world-C', 'initial render');
      });
    };

    _proto['@test Can render into a named outlet at the top level, later'] = function testCanRenderIntoANamedOutletAtTheTopLevelLater(assert) {
      var _this71 = this;

      this.addTemplate('application', 'A-{{outlet}}-B-{{outlet "other"}}-C');
      this.addTemplate('modal', 'Hello world');
      this.addTemplate('index', 'The index');
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('route:application', _routing.Route.extend({
        actions: {
          launch: function () {
            this.render('modal', {
              into: 'application',
              outlet: 'other'
            });
          }
        }
      }));
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.textContent.trim(), 'A-The index-B--C', 'initial render');
        (0, _runloop.run)(_this71.applicationInstance.lookup('router:main'), 'send', 'launch');
        assert.equal(rootElement.textContent.trim(), 'A-The index-B-Hello world-C', 'second render');
      });
    };

    _proto["@test Can render routes with no 'main' outlet and their children"] = function testCanRenderRoutesWithNoMainOutletAndTheirChildren(assert) {
      var _this72 = this;

      this.addTemplate('application', '<div id="application">{{outlet "app"}}</div>');
      this.addTemplate('app', '<div id="app-common">{{outlet "common"}}</div><div id="app-sub">{{outlet "sub"}}</div>');
      this.addTemplate('common', '<div id="common"></div>');
      this.addTemplate('sub', '<div id="sub"></div>');
      this.router.map(function () {
        this.route('app', {
          path: '/app'
        }, function () {
          this.route('sub', {
            path: '/sub',
            resetNamespace: true
          });
        });
      });
      this.add('route:app', _routing.Route.extend({
        renderTemplate: function () {
          this.render('app', {
            outlet: 'app',
            into: 'application'
          });
          this.render('common', {
            outlet: 'common',
            into: 'app'
          });
        }
      }));
      this.add('route:sub', _routing.Route.extend({
        renderTemplate: function () {
          this.render('sub', {
            outlet: 'sub',
            into: 'app'
          });
        }
      }));
      var rootElement;
      return this.visit('/app').then(function () {
        rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.querySelectorAll('#app-common #common').length, 1, 'Finds common while viewing /app');
        return _this72.visit('/app/sub');
      }).then(function () {
        assert.equal(rootElement.querySelectorAll('#app-common #common').length, 1, 'Finds common while viewing /app/sub');
        assert.equal(rootElement.querySelectorAll('#app-sub #sub').length, 1, 'Finds sub while viewing /app/sub');
      });
    };

    _proto['@test Tolerates stacked renders'] = function testToleratesStackedRenders(assert) {
      var _this73 = this;

      this.addTemplate('application', '{{outlet}}{{outlet "modal"}}');
      this.addTemplate('index', 'hi');
      this.addTemplate('layer', 'layer');
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('route:application', _routing.Route.extend({
        actions: {
          openLayer: function () {
            this.render('layer', {
              into: 'application',
              outlet: 'modal'
            });
          },
          close: function () {
            this.disconnectOutlet({
              outlet: 'modal',
              parentView: 'application'
            });
          }
        }
      }));
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');

        var router = _this73.applicationInstance.lookup('router:main');

        assert.equal(rootElement.textContent.trim(), 'hi');
        (0, _runloop.run)(router, 'send', 'openLayer');
        assert.equal(rootElement.textContent.trim(), 'hilayer');
        (0, _runloop.run)(router, 'send', 'openLayer');
        assert.equal(rootElement.textContent.trim(), 'hilayer');
        (0, _runloop.run)(router, 'send', 'close');
        assert.equal(rootElement.textContent.trim(), 'hi');
      });
    };

    _proto['@test Renders child into parent with non-default template name'] = function testRendersChildIntoParentWithNonDefaultTemplateName(assert) {
      this.addTemplate('application', '<div class="a">{{outlet}}</div>');
      this.addTemplate('exports.root', '<div class="b">{{outlet}}</div>');
      this.addTemplate('exports.index', '<div class="c"></div>');
      this.router.map(function () {
        this.route('root', function () {});
      });
      this.add('route:root', _routing.Route.extend({
        renderTemplate: function () {
          this.render('exports/root');
        }
      }));
      this.add('route:root.index', _routing.Route.extend({
        renderTemplate: function () {
          this.render('exports/index');
        }
      }));
      return this.visit('/root').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.querySelectorAll('.a .b .c').length, 1);
      });
    };

    _proto["@test Allows any route to disconnectOutlet another route's templates"] = function testAllowsAnyRouteToDisconnectOutletAnotherRouteSTemplates(assert) {
      var _this74 = this;

      this.addTemplate('application', '{{outlet}}{{outlet "modal"}}');
      this.addTemplate('index', 'hi');
      this.addTemplate('layer', 'layer');
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('route:application', _routing.Route.extend({
        actions: {
          openLayer: function () {
            this.render('layer', {
              into: 'application',
              outlet: 'modal'
            });
          }
        }
      }));
      this.add('route:index', _routing.Route.extend({
        actions: {
          close: function () {
            this.disconnectOutlet({
              parentView: 'application',
              outlet: 'modal'
            });
          }
        }
      }));
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');

        var router = _this74.applicationInstance.lookup('router:main');

        assert.equal(rootElement.textContent.trim(), 'hi');
        (0, _runloop.run)(router, 'send', 'openLayer');
        assert.equal(rootElement.textContent.trim(), 'hilayer');
        (0, _runloop.run)(router, 'send', 'close');
        assert.equal(rootElement.textContent.trim(), 'hi');
      });
    };

    _proto['@test Components inside an outlet have their didInsertElement hook invoked when the route is displayed'] = function testComponentsInsideAnOutletHaveTheirDidInsertElementHookInvokedWhenTheRouteIsDisplayed(assert) {
      this.addTemplate('index', '{{#if showFirst}}{{my-component}}{{else}}{{other-component}}{{/if}}');
      var myComponentCounter = 0;
      var otherComponentCounter = 0;
      var indexController;
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('controller:index', _controller.default.extend({
        showFirst: true
      }));
      this.add('route:index', _routing.Route.extend({
        setupController: function (controller) {
          indexController = controller;
        }
      }));
      this.add('component:my-component', _glimmer.Component.extend({
        didInsertElement: function () {
          myComponentCounter++;
        }
      }));
      this.add('component:other-component', _glimmer.Component.extend({
        didInsertElement: function () {
          otherComponentCounter++;
        }
      }));
      return this.visit('/').then(function () {
        assert.strictEqual(myComponentCounter, 1, 'didInsertElement invoked on displayed component');
        assert.strictEqual(otherComponentCounter, 0, 'didInsertElement not invoked on displayed component');
        (0, _runloop.run)(function () {
          return indexController.set('showFirst', false);
        });
        assert.strictEqual(myComponentCounter, 1, 'didInsertElement not invoked on displayed component');
        assert.strictEqual(otherComponentCounter, 1, 'didInsertElement invoked on displayed component');
      });
    };

    _proto['@test Doesnt swallow exception thrown from willTransition'] = function testDoesntSwallowExceptionThrownFromWillTransition(assert) {
      var _this75 = this;

      assert.expect(1);
      this.addTemplate('application', '{{outlet}}');
      this.addTemplate('index', 'index');
      this.addTemplate('other', 'other');
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
        this.route('other', function () {});
      });
      this.add('route:index', _routing.Route.extend({
        actions: {
          willTransition: function () {
            throw new Error('boom');
          }
        }
      }));
      return this.visit('/').then(function () {
        return assert.throws(function () {
          return _this75.visit('/other');
        }, /boom/, 'expected an exception but none was thrown');
      });
    };

    _proto['@test Exception if outlet name is undefined in render and disconnectOutlet'] = function testExceptionIfOutletNameIsUndefinedInRenderAndDisconnectOutlet() {
      var _this76 = this;

      this.add('route:application', _routing.Route.extend({
        actions: {
          showModal: function () {
            this.render({
              outlet: undefined,
              parentView: 'application'
            });
          },
          hideModal: function () {
            this.disconnectOutlet({
              outlet: undefined,
              parentView: 'application'
            });
          }
        }
      }));
      return this.visit('/').then(function () {
        var router = _this76.applicationInstance.lookup('router:main');

        expectAssertion(function () {
          (0, _runloop.run)(function () {
            return router.send('showModal');
          });
        }, /You passed undefined as the outlet name/);
        expectAssertion(function () {
          (0, _runloop.run)(function () {
            return router.send('hideModal');
          });
        }, /You passed undefined as the outlet name/);
      });
    };

    _proto['@test Route serializers work for Engines'] = function testRouteSerializersWorkForEngines(assert) {
      var _this77 = this;

      assert.expect(2); // Register engine

      var BlogEngine = _engine.default.extend();

      this.add('engine:blog', BlogEngine); // Register engine route map

      var postSerialize = function (params) {
        assert.ok(true, 'serialize hook runs');
        return {
          post_id: params.id
        };
      };

      var BlogMap = function () {
        this.route('post', {
          path: '/post/:post_id',
          serialize: postSerialize
        });
      };

      this.add('route-map:blog', BlogMap);
      this.router.map(function () {
        this.mount('blog');
      });
      return this.visit('/').then(function () {
        var router = _this77.applicationInstance.lookup('router:main');

        assert.equal(router._routerMicrolib.generate('blog.post', {
          id: '13'
        }), '/blog/post/13', 'url is generated properly');
      });
    };

    _proto['@test Defining a Route#serialize method in an Engine throws an error'] = function testDefiningARouteSerializeMethodInAnEngineThrowsAnError(assert) {
      var _this78 = this;

      assert.expect(1); // Register engine

      var BlogEngine = _engine.default.extend();

      this.add('engine:blog', BlogEngine); // Register engine route map

      var BlogMap = function () {
        this.route('post');
      };

      this.add('route-map:blog', BlogMap);
      this.router.map(function () {
        this.mount('blog');
      });
      return this.visit('/').then(function () {
        var router = _this78.applicationInstance.lookup('router:main');

        var PostRoute = _routing.Route.extend({
          serialize: function () {}
        });

        _this78.applicationInstance.lookup('engine:blog').register('route:post', PostRoute);

        assert.throws(function () {
          return router.transitionTo('blog.post');
        }, /Defining a custom serialize method on an Engine route is not supported/);
      });
    };

    _proto['@test App.destroy does not leave undestroyed views after clearing engines'] = function testAppDestroyDoesNotLeaveUndestroyedViewsAfterClearingEngines(assert) {
      var _this79 = this;

      assert.expect(4);
      var engineInstance; // Register engine

      var BlogEngine = _engine.default.extend();

      this.add('engine:blog', BlogEngine);

      var EngineIndexRoute = _routing.Route.extend({
        init: function () {
          this._super.apply(this, arguments);

          engineInstance = (0, _owner.getOwner)(this);
        }
      }); // Register engine route map


      var BlogMap = function () {
        this.route('post');
      };

      this.add('route-map:blog', BlogMap);
      this.router.map(function () {
        this.mount('blog');
      });
      return this.visit('/').then(function () {
        var engine = _this79.applicationInstance.lookup('engine:blog');

        engine.register('route:index', EngineIndexRoute);
        engine.register('template:index', (0, _emberTemplateCompiler.compile)('Engine Post!'));
        return _this79.visit('/blog');
      }).then(function () {
        assert.ok(true, '/blog has been handled');
        var route = engineInstance.lookup('route:index');

        var router = _this79.applicationInstance.lookup('router:main');

        (0, _runloop.run)(router, 'destroy');
        assert.equal(router._toplevelView, null, 'the toplevelView was cleared');
        (0, _runloop.run)(route, 'destroy');
        assert.equal(router._toplevelView, null, 'the toplevelView was not reinitialized');
        (0, _runloop.run)(_this79.applicationInstance, 'destroy');
        assert.equal(router._toplevelView, null, 'the toplevelView was not reinitialized');
      });
    };

    _proto["@test Generated route should be an instance of App's default route if provided"] = function testGeneratedRouteShouldBeAnInstanceOfAppSDefaultRouteIfProvided(assert) {
      var _this80 = this;

      var generatedRoute;
      this.router.map(function () {
        this.route('posts');
      });

      var AppRoute = _routing.Route.extend();

      this.add('route:basic', AppRoute);
      return this.visit('/posts').then(function () {
        generatedRoute = _this80.applicationInstance.lookup('route:posts');
        assert.ok(generatedRoute instanceof AppRoute, 'should extend the correct route');
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "currentPath",
      get: function () {
        return this.getController('application').get('currentPath');
      }
    }, {
      key: "currentURL",
      get: function () {
        return this.appRouter.get('currentURL');
      }
    }]);
    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/routing/deprecated_handler_infos_test", ["ember-babel", "internal-test-helpers"], function (_emberBabel, _internalTestHelpers) {
  "use strict";

  if (true
  /* EMBER_ROUTING_ROUTER_SERVICE */
  ) {
      (0, _internalTestHelpers.moduleFor)('Deprecated HandlerInfos',
      /*#__PURE__*/
      function (_ApplicationTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

        function _class() {
          var _this;

          _this = _ApplicationTestCase.apply(this, arguments) || this;

          _this.router.map(function () {
            this.route('parent', function () {
              this.route('child');
              this.route('sibling');
            });
          });

          return _this;
        }

        var _proto = _class.prototype;

        _proto['@test handlerInfos are deprecated and associated private apis'] = function testHandlerInfosAreDeprecatedAndAssociatedPrivateApis(assert) {
          var _this2 = this;

          var done = assert.async();
          expectDeprecation(function () {
            return _this2.visit('/parent').then(function () {
              done();
            });
          }, /You attempted to override the \"(willTransition|didTransition)\" method which is deprecated. Please inject the router service and listen to the \"(routeWillChange|routeDidChange)\" event\./);
        };

        (0, _emberBabel.createClass)(_class, [{
          key: "routerOptions",
          get: function () {
            return {
              willTransition: function (oldHandlers, newHandlers, transition) {
                var _this3 = this;

                expectDeprecation(function () {
                  _this3._routerMicrolib.currentHandlerInfos;
                }, 'You attempted to use "_routerMicrolib.currentHandlerInfos" which is a private API that will be removed.');
                expectDeprecation(function () {
                  _this3._routerMicrolib.getHandler('parent');
                }, 'You attempted to use "_routerMicrolib.getHandler" which is a private API that will be removed.');
                oldHandlers.forEach(function (handler) {
                  expectDeprecation(function () {
                    handler.handler;
                  }, 'You attempted to read "handlerInfo.handler" which is a private API that will be removed.');
                });
                newHandlers.forEach(function (handler) {
                  expectDeprecation(function () {
                    handler.handler;
                  }, 'You attempted to read "handlerInfo.handler" which is a private API that will be removed.');
                });
                expectDeprecation(function () {
                  transition.handlerInfos;
                }, 'You attempted to use "transition.handlerInfos" which is a private API that will be removed.');
                expectDeprecation(function () {
                  transition.state.handlerInfos;
                }, 'You attempted to use "transition.state.handlerInfos" which is a private API that will be removed.');
                QUnit.assert.ok(true, 'willTransition');
              },
              didTransition: function (newHandlers) {
                newHandlers.forEach(function (handler) {
                  expectDeprecation(function () {
                    handler.handler;
                  }, 'You attempted to read "handlerInfo.handler" which is a private API that will be removed.');
                });
                QUnit.assert.ok(true, 'didTransition');
              }
            };
          }
        }]);
        return _class;
      }(_internalTestHelpers.ApplicationTestCase));
    }
});
enifed("ember/tests/routing/deprecated_transition_state_test", ["ember-babel", "internal-test-helpers"], function (_emberBabel, _internalTestHelpers) {
  "use strict";

  if (true
  /* EMBER_ROUTING_ROUTER_SERVICE */
  ) {
      (0, _internalTestHelpers.moduleFor)('Deprecated Transition State',
      /*#__PURE__*/
      function (_RouterTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

        function _class() {
          return _RouterTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto['@test touching transition.state is deprecated'] = function testTouchingTransitionStateIsDeprecated(assert) {
          var _this = this;

          assert.expect(1);
          return this.visit('/').then(function () {
            _this.routerService.on('routeWillChange', function (transition) {
              expectDeprecation(function () {
                transition.state;
              }, 'You attempted to read "transition.state" which is a private API. You should read the `RouteInfo` object on "transition.to" or "transition.from" which has the public state on it.');
            });

            return _this.routerService.transitionTo('/child');
          });
        };

        _proto['@test touching transition.queryParams is deprecated'] = function testTouchingTransitionQueryParamsIsDeprecated(assert) {
          var _this2 = this;

          assert.expect(1);
          return this.visit('/').then(function () {
            _this2.routerService.on('routeWillChange', function (transition) {
              expectDeprecation(function () {
                transition.queryParams;
              }, 'You attempted to read "transition.queryParams" which is a private API. You should read the `RouteInfo` object on "transition.to" or "transition.from" which has the queryParams on it.');
            });

            return _this2.routerService.transitionTo('/child');
          });
        };

        _proto['@test touching transition.params is deprecated'] = function testTouchingTransitionParamsIsDeprecated(assert) {
          var _this3 = this;

          assert.expect(1);
          return this.visit('/').then(function () {
            _this3.routerService.on('routeWillChange', function (transition) {
              expectDeprecation(function () {
                transition.params;
              }, 'You attempted to read "transition.params" which is a private API. You should read the `RouteInfo` object on "transition.to" or "transition.from" which has the params on it.');
            });

            return _this3.routerService.transitionTo('/child');
          });
        };

        return _class;
      }(_internalTestHelpers.RouterTestCase));
    }
});
enifed("ember/tests/routing/query_params_test", ["ember-babel", "@ember/controller", "@ember/string", "@ember/-internals/runtime", "@ember/runloop", "@ember/-internals/meta", "@ember/-internals/metal", "@ember/-internals/routing", "router_js", "internal-test-helpers"], function (_emberBabel, _controller, _string, _runtime, _runloop, _meta, _metal, _routing, _router_js, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Query Params - main',
  /*#__PURE__*/
  function (_QueryParamTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _QueryParamTestCase);

    function _class() {
      return _QueryParamTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.refreshModelWhileLoadingTest = function refreshModelWhileLoadingTest(loadingReturn) {
      var _actions,
          _this = this;

      var assert = this.assert;
      assert.expect(9);
      var appModelCount = 0;
      var promiseResolve;
      this.add('route:application', _routing.Route.extend({
        queryParams: {
          appomg: {
            defaultValue: 'applol'
          }
        },
        model: function ()
        /* params */
        {
          appModelCount++;
        }
      }));
      this.setSingleQPController('index', 'omg', undefined, {
        omg: undefined
      });
      var actionName = typeof loadingReturn !== 'undefined' ? 'loading' : 'ignore';
      var indexModelCount = 0;
      this.add('route:index', _routing.Route.extend({
        queryParams: {
          omg: {
            refreshModel: true
          }
        },
        actions: (_actions = {}, _actions[actionName] = function () {
          return loadingReturn;
        }, _actions),
        model: function (params) {
          indexModelCount++;

          if (indexModelCount === 2) {
            assert.deepEqual(params, {
              omg: 'lex'
            });
            return new _runtime.RSVP.Promise(function (resolve) {
              promiseResolve = resolve;
              return;
            });
          } else if (indexModelCount === 3) {
            assert.deepEqual(params, {
              omg: 'hello'
            }, "Model hook reruns even if the previous one didn't finish");
          }
        }
      }));
      return this.visit('/').then(function () {
        assert.equal(appModelCount, 1, 'appModelCount is 1');
        assert.equal(indexModelCount, 1);

        var indexController = _this.getController('index');

        _this.setAndFlush(indexController, 'omg', 'lex');

        assert.equal(appModelCount, 1, 'appModelCount is 1');
        assert.equal(indexModelCount, 2);

        _this.setAndFlush(indexController, 'omg', 'hello');

        assert.equal(appModelCount, 1, 'appModelCount is 1');
        assert.equal(indexModelCount, 3);
        (0, _runloop.run)(function () {
          promiseResolve();
        });
        assert.equal((0, _metal.get)(indexController, 'omg'), 'hello', 'At the end last value prevails');
      });
    };

    _proto["@test No replaceURL occurs on startup because default values don't show up in URL"] = function testNoReplaceURLOccursOnStartupBecauseDefaultValuesDonTShowUpInURL(assert) {
      assert.expect(1);
      this.setSingleQPController('index');
      return this.visitAndAssert('/');
    };

    _proto['@test Calling transitionTo does not lose query params already on the activeTransition'] = function testCallingTransitionToDoesNotLoseQueryParamsAlreadyOnTheActiveTransition(assert) {
      var _this2 = this;

      assert.expect(2);
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
          this.route('sibling');
        });
      });
      this.add('route:parent.child', _routing.Route.extend({
        afterModel: function () {
          this.transitionTo('parent.sibling');
        }
      }));
      this.setSingleQPController('parent');
      return this.visit('/parent/child?foo=lol').then(function () {
        _this2.assertCurrentPath('/parent/sibling?foo=lol', 'redirected to the sibling route, instead of child route');

        assert.equal(_this2.getController('parent').get('foo'), 'lol', 'controller has value from the active transition');
      });
    };

    _proto['@test Single query params can be set on the controller and reflected in the url'] = function testSingleQueryParamsCanBeSetOnTheControllerAndReflectedInTheUrl(assert) {
      var _this3 = this;

      assert.expect(3);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.setSingleQPController('home');
      return this.visitAndAssert('/').then(function () {
        var controller = _this3.getController('home');

        _this3.setAndFlush(controller, 'foo', '456');

        _this3.assertCurrentPath('/?foo=456');

        _this3.setAndFlush(controller, 'foo', '987');

        _this3.assertCurrentPath('/?foo=987');
      });
    };

    _proto['@test Query params can map to different url keys configured on the controller'] = function testQueryParamsCanMapToDifferentUrlKeysConfiguredOnTheController(assert) {
      var _this4 = this;

      assert.expect(6);
      this.add('controller:index', _controller.default.extend({
        queryParams: [{
          foo: 'other_foo',
          bar: {
            as: 'other_bar'
          }
        }],
        foo: 'FOO',
        bar: 'BAR'
      }));
      return this.visitAndAssert('/').then(function () {
        var controller = _this4.getController('index');

        _this4.setAndFlush(controller, 'foo', 'LEX');

        _this4.assertCurrentPath('/?other_foo=LEX', "QP mapped correctly without 'as'");

        _this4.setAndFlush(controller, 'foo', 'WOO');

        _this4.assertCurrentPath('/?other_foo=WOO', "QP updated correctly without 'as'");

        _this4.transitionTo('/?other_foo=NAW');

        assert.equal(controller.get('foo'), 'NAW', 'QP managed correctly on URL transition');

        _this4.setAndFlush(controller, 'bar', 'NERK');

        _this4.assertCurrentPath('/?other_bar=NERK&other_foo=NAW', "QP mapped correctly with 'as'");

        _this4.setAndFlush(controller, 'bar', 'NUKE');

        _this4.assertCurrentPath('/?other_bar=NUKE&other_foo=NAW', "QP updated correctly with 'as'");
      });
    };

    _proto['@test Routes have a private overridable serializeQueryParamKey hook'] = function testRoutesHaveAPrivateOverridableSerializeQueryParamKeyHook(assert) {
      var _this5 = this;

      assert.expect(2);
      this.add('route:index', _routing.Route.extend({
        serializeQueryParamKey: _string.dasherize
      }));
      this.setSingleQPController('index', 'funTimes', '');
      return this.visitAndAssert('/').then(function () {
        var controller = _this5.getController('index');

        _this5.setAndFlush(controller, 'funTimes', 'woot');

        _this5.assertCurrentPath('/?fun-times=woot');
      });
    };

    _proto['@test Can override inherited QP behavior by specifying queryParams as a computed property'] = function testCanOverrideInheritedQPBehaviorBySpecifyingQueryParamsAsAComputedProperty(assert) {
      var _this6 = this;

      assert.expect(3);
      this.setSingleQPController('index', 'a', 0, {
        queryParams: (0, _metal.computed)(function () {
          return ['c'];
        }),
        c: true
      });
      return this.visitAndAssert('/').then(function () {
        var indexController = _this6.getController('index');

        _this6.setAndFlush(indexController, 'a', 1);

        _this6.assertCurrentPath('/', 'QP did not update due to being overriden');

        _this6.setAndFlush(indexController, 'c', false);

        _this6.assertCurrentPath('/?c=false', 'QP updated with overridden param');
      });
    };

    _proto['@test Can concatenate inherited QP behavior by specifying queryParams as an array'] = function testCanConcatenateInheritedQPBehaviorBySpecifyingQueryParamsAsAnArray(assert) {
      var _this7 = this;

      assert.expect(3);
      this.setSingleQPController('index', 'a', 0, {
        queryParams: ['c'],
        c: true
      });
      return this.visitAndAssert('/').then(function () {
        var indexController = _this7.getController('index');

        _this7.setAndFlush(indexController, 'a', 1);

        _this7.assertCurrentPath('/?a=1', 'Inherited QP did update');

        _this7.setAndFlush(indexController, 'c', false);

        _this7.assertCurrentPath('/?a=1&c=false', 'New QP did update');
      });
    };

    _proto['@test model hooks receives query params'] = function testModelHooksReceivesQueryParams(assert) {
      assert.expect(2);
      this.setSingleQPController('index');
      this.add('route:index', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            foo: 'bar'
          });
        }
      }));
      return this.visitAndAssert('/');
    };

    _proto['@test model hooks receives query params with dynamic segment params'] = function testModelHooksReceivesQueryParamsWithDynamicSegmentParams(assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:id'
        });
      });
      this.setSingleQPController('index');
      this.add('route:index', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            foo: 'bar',
            id: 'baz'
          });
        }
      }));
      return this.visitAndAssert('/baz');
    };

    _proto['@test model hooks receives query params (overridden by incoming url value)'] = function testModelHooksReceivesQueryParamsOverriddenByIncomingUrlValue(assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:id'
        });
      });
      this.setSingleQPController('index');
      this.add('route:index', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            foo: 'baz',
            id: 'boo'
          });
        }
      }));
      return this.visitAndAssert('/boo?foo=baz');
    };

    _proto['@test error is thrown if dynamic segment and query param have same name'] = function testErrorIsThrownIfDynamicSegmentAndQueryParamHaveSameName(assert) {
      var _this8 = this;

      assert.expect(1);
      this.router.map(function () {
        this.route('index', {
          path: '/:foo'
        });
      });
      this.setSingleQPController('index');
      expectAssertion(function () {
        _this8.visitAndAssert('/boo?foo=baz');
      }, "The route 'index' has both a dynamic segment and query param with name 'foo'. Please rename one to avoid collisions.");
    };

    _proto['@test query params have been set by the time setupController is called'] = function testQueryParamsHaveBeenSetByTheTimeSetupControllerIsCalled(assert) {
      assert.expect(2);
      this.setSingleQPController('application');
      this.add('route:application', _routing.Route.extend({
        setupController: function (controller) {
          assert.equal(controller.get('foo'), 'YEAH', "controller's foo QP property set before setupController called");
        }
      }));
      return this.visitAndAssert('/?foo=YEAH');
    };

    _proto['@test mapped query params have been set by the time setupController is called'] = function testMappedQueryParamsHaveBeenSetByTheTimeSetupControllerIsCalled(assert) {
      assert.expect(2);
      this.setSingleQPController('application', {
        faz: 'foo'
      });
      this.add('route:application', _routing.Route.extend({
        setupController: function (controller) {
          assert.equal(controller.get('faz'), 'YEAH', "controller's foo QP property set before setupController called");
        }
      }));
      return this.visitAndAssert('/?foo=YEAH');
    };

    _proto['@test Route#paramsFor fetches query params with default value'] = function testRouteParamsForFetchesQueryParamsWithDefaultValue(assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:something'
        });
      });
      this.setSingleQPController('index');
      this.add('route:index', _routing.Route.extend({
        model: function ()
        /* params, transition */
        {
          assert.deepEqual(this.paramsFor('index'), {
            something: 'baz',
            foo: 'bar'
          }, 'could retrieve params for index');
        }
      }));
      return this.visitAndAssert('/baz');
    };

    _proto['@test Route#paramsFor fetches query params with non-default value'] = function testRouteParamsForFetchesQueryParamsWithNonDefaultValue(assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:something'
        });
      });
      this.setSingleQPController('index');
      this.add('route:index', _routing.Route.extend({
        model: function ()
        /* params, transition */
        {
          assert.deepEqual(this.paramsFor('index'), {
            something: 'baz',
            foo: 'boo'
          }, 'could retrieve params for index');
        }
      }));
      return this.visitAndAssert('/baz?foo=boo');
    };

    _proto['@test Route#paramsFor fetches default falsy query params'] = function testRouteParamsForFetchesDefaultFalsyQueryParams(assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:something'
        });
      });
      this.setSingleQPController('index', 'foo', false);
      this.add('route:index', _routing.Route.extend({
        model: function ()
        /* params, transition */
        {
          assert.deepEqual(this.paramsFor('index'), {
            something: 'baz',
            foo: false
          }, 'could retrieve params for index');
        }
      }));
      return this.visitAndAssert('/baz');
    };

    _proto['@test Route#paramsFor fetches non-default falsy query params'] = function testRouteParamsForFetchesNonDefaultFalsyQueryParams(assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:something'
        });
      });
      this.setSingleQPController('index', 'foo', true);
      this.add('route:index', _routing.Route.extend({
        model: function ()
        /* params, transition */
        {
          assert.deepEqual(this.paramsFor('index'), {
            something: 'baz',
            foo: false
          }, 'could retrieve params for index');
        }
      }));
      return this.visitAndAssert('/baz?foo=false');
    };

    _proto['@test model hook can query prefix-less application params'] = function testModelHookCanQueryPrefixLessApplicationParams(assert) {
      assert.expect(4);
      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');
      this.add('route:application', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            appomg: 'applol'
          });
        }
      }));
      this.add('route:index', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            omg: 'lol'
          });
          assert.deepEqual(this.paramsFor('application'), {
            appomg: 'applol'
          });
        }
      }));
      return this.visitAndAssert('/');
    };

    _proto['@test model hook can query prefix-less application params (overridden by incoming url value)'] = function testModelHookCanQueryPrefixLessApplicationParamsOverriddenByIncomingUrlValue(assert) {
      assert.expect(4);
      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');
      this.add('route:application', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            appomg: 'appyes'
          });
        }
      }));
      this.add('route:index', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            omg: 'yes'
          });
          assert.deepEqual(this.paramsFor('application'), {
            appomg: 'appyes'
          });
        }
      }));
      return this.visitAndAssert('/?appomg=appyes&omg=yes');
    };

    _proto['@test can opt into full transition by setting refreshModel in route queryParams'] = function testCanOptIntoFullTransitionBySettingRefreshModelInRouteQueryParams(assert) {
      var _this9 = this;

      assert.expect(7);
      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');
      var appModelCount = 0;
      this.add('route:application', _routing.Route.extend({
        model: function ()
        /* params, transition */
        {
          appModelCount++;
        }
      }));
      var indexModelCount = 0;
      this.add('route:index', _routing.Route.extend({
        queryParams: {
          omg: {
            refreshModel: true
          }
        },
        model: function (params) {
          indexModelCount++;

          if (indexModelCount === 1) {
            assert.deepEqual(params, {
              omg: 'lol'
            }, 'params are correct on first pass');
          } else if (indexModelCount === 2) {
            assert.deepEqual(params, {
              omg: 'lex'
            }, 'params are correct on second pass');
          }
        }
      }));
      return this.visitAndAssert('/').then(function () {
        assert.equal(appModelCount, 1, 'app model hook ran');
        assert.equal(indexModelCount, 1, 'index model hook ran');

        var indexController = _this9.getController('index');

        _this9.setAndFlush(indexController, 'omg', 'lex');

        assert.equal(appModelCount, 1, 'app model hook did not run again');
        assert.equal(indexModelCount, 2, 'index model hook ran again due to refreshModel');
      });
    };

    _proto['@test refreshModel and replace work together'] = function testRefreshModelAndReplaceWorkTogether(assert) {
      var _this10 = this;

      assert.expect(8);
      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');
      var appModelCount = 0;
      this.add('route:application', _routing.Route.extend({
        model: function ()
        /* params */
        {
          appModelCount++;
        }
      }));
      var indexModelCount = 0;
      this.add('route:index', _routing.Route.extend({
        queryParams: {
          omg: {
            refreshModel: true,
            replace: true
          }
        },
        model: function (params) {
          indexModelCount++;

          if (indexModelCount === 1) {
            assert.deepEqual(params, {
              omg: 'lol'
            }, 'params are correct on first pass');
          } else if (indexModelCount === 2) {
            assert.deepEqual(params, {
              omg: 'lex'
            }, 'params are correct on second pass');
          }
        }
      }));
      return this.visitAndAssert('/').then(function () {
        assert.equal(appModelCount, 1, 'app model hook ran');
        assert.equal(indexModelCount, 1, 'index model hook ran');

        var indexController = _this10.getController('index');

        _this10.expectedReplaceURL = '/?omg=lex';

        _this10.setAndFlush(indexController, 'omg', 'lex');

        assert.equal(appModelCount, 1, 'app model hook did not run again');
        assert.equal(indexModelCount, 2, 'index model hook ran again due to refreshModel');
      });
    };

    _proto['@test multiple QP value changes only cause a single model refresh'] = function testMultipleQPValueChangesOnlyCauseASingleModelRefresh(assert) {
      var _this11 = this;

      assert.expect(2);
      this.setSingleQPController('index', 'alex', 'lol');
      this.setSingleQPController('index', 'steely', 'lel');
      var refreshCount = 0;
      this.add('route:index', _routing.Route.extend({
        queryParams: {
          alex: {
            refreshModel: true
          },
          steely: {
            refreshModel: true
          }
        },
        refresh: function () {
          refreshCount++;
        }
      }));
      return this.visitAndAssert('/').then(function () {
        var indexController = _this11.getController('index');

        (0, _runloop.run)(indexController, 'setProperties', {
          alex: 'fran',
          steely: 'david'
        });
        assert.equal(refreshCount, 1, 'index refresh hook only run once');
      });
    };

    _proto['@test refreshModel does not cause a second transition during app boot '] = function testRefreshModelDoesNotCauseASecondTransitionDuringAppBoot(assert) {
      assert.expect(1);
      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');
      this.add('route:index', _routing.Route.extend({
        queryParams: {
          omg: {
            refreshModel: true
          }
        },
        refresh: function () {
          assert.ok(false);
        }
      }));
      return this.visitAndAssert('/?appomg=hello&omg=world');
    };

    _proto['@test queryParams are updated when a controller property is set and the route is refreshed. Issue #13263  '] = function testQueryParamsAreUpdatedWhenAControllerPropertyIsSetAndTheRouteIsRefreshedIssue13263(assert) {
      var _this12 = this;

      this.addTemplate('application', '<button id="test-button" {{action \'increment\'}}>Increment</button><span id="test-value">{{foo}}</span>{{outlet}}');
      this.setSingleQPController('application', 'foo', 1, {
        actions: {
          increment: function () {
            this.incrementProperty('foo');
            this.send('refreshRoute');
          }
        }
      });
      this.add('route:application', _routing.Route.extend({
        actions: {
          refreshRoute: function () {
            this.refresh();
          }
        }
      }));
      return this.visitAndAssert('/').then(function () {
        assert.equal((0, _internalTestHelpers.getTextOf)(document.getElementById('test-value')), '1');
        (0, _runloop.run)(document.getElementById('test-button'), 'click');
        assert.equal((0, _internalTestHelpers.getTextOf)(document.getElementById('test-value')), '2');

        _this12.assertCurrentPath('/?foo=2');

        (0, _runloop.run)(document.getElementById('test-button'), 'click');
        assert.equal((0, _internalTestHelpers.getTextOf)(document.getElementById('test-value')), '3');

        _this12.assertCurrentPath('/?foo=3');
      });
    };

    _proto["@test Use Ember.get to retrieve query params 'refreshModel' configuration"] = function testUseEmberGetToRetrieveQueryParamsRefreshModelConfiguration(assert) {
      var _this13 = this;

      assert.expect(7);
      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');
      var appModelCount = 0;
      this.add('route:application', _routing.Route.extend({
        model: function ()
        /* params */
        {
          appModelCount++;
        }
      }));
      var indexModelCount = 0;
      this.add('route:index', _routing.Route.extend({
        queryParams: _runtime.Object.create({
          unknownProperty: function () {
            return {
              refreshModel: true
            };
          }
        }),
        model: function (params) {
          indexModelCount++;

          if (indexModelCount === 1) {
            assert.deepEqual(params, {
              omg: 'lol'
            });
          } else if (indexModelCount === 2) {
            assert.deepEqual(params, {
              omg: 'lex'
            });
          }
        }
      }));
      return this.visitAndAssert('/').then(function () {
        assert.equal(appModelCount, 1);
        assert.equal(indexModelCount, 1);

        var indexController = _this13.getController('index');

        _this13.setAndFlush(indexController, 'omg', 'lex');

        assert.equal(appModelCount, 1);
        assert.equal(indexModelCount, 2);
      });
    };

    _proto['@test can use refreshModel even with URL changes that remove QPs from address bar'] = function testCanUseRefreshModelEvenWithURLChangesThatRemoveQPsFromAddressBar(assert) {
      var _this14 = this;

      assert.expect(4);
      this.setSingleQPController('index', 'omg', 'lol');
      var indexModelCount = 0;
      this.add('route:index', _routing.Route.extend({
        queryParams: {
          omg: {
            refreshModel: true
          }
        },
        model: function (params) {
          indexModelCount++;
          var data;

          if (indexModelCount === 1) {
            data = 'foo';
          } else if (indexModelCount === 2) {
            data = 'lol';
          }

          assert.deepEqual(params, {
            omg: data
          }, 'index#model receives right data');
        }
      }));
      return this.visitAndAssert('/?omg=foo').then(function () {
        _this14.transitionTo('/');

        var indexController = _this14.getController('index');

        assert.equal(indexController.get('omg'), 'lol');
      });
    };

    _proto['@test can opt into a replace query by specifying replace:true in the Route config hash'] = function testCanOptIntoAReplaceQueryBySpecifyingReplaceTrueInTheRouteConfigHash(assert) {
      var _this15 = this;

      assert.expect(2);
      this.setSingleQPController('application', 'alex', 'matchneer');
      this.add('route:application', _routing.Route.extend({
        queryParams: {
          alex: {
            replace: true
          }
        }
      }));
      return this.visitAndAssert('/').then(function () {
        var appController = _this15.getController('application');

        _this15.expectedReplaceURL = '/?alex=wallace';

        _this15.setAndFlush(appController, 'alex', 'wallace');
      });
    };

    _proto['@test Route query params config can be configured using property name instead of URL key'] = function testRouteQueryParamsConfigCanBeConfiguredUsingPropertyNameInsteadOfURLKey(assert) {
      var _this16 = this;

      assert.expect(2);
      this.add('controller:application', _controller.default.extend({
        queryParams: [{
          commitBy: 'commit_by'
        }]
      }));
      this.add('route:application', _routing.Route.extend({
        queryParams: {
          commitBy: {
            replace: true
          }
        }
      }));
      return this.visitAndAssert('/').then(function () {
        var appController = _this16.getController('application');

        _this16.expectedReplaceURL = '/?commit_by=igor_seb';

        _this16.setAndFlush(appController, 'commitBy', 'igor_seb');
      });
    };

    _proto['@test An explicit replace:false on a changed QP always wins and causes a pushState'] = function testAnExplicitReplaceFalseOnAChangedQPAlwaysWinsAndCausesAPushState(assert) {
      var _this17 = this;

      assert.expect(3);
      this.add('controller:application', _controller.default.extend({
        queryParams: ['alex', 'steely'],
        alex: 'matchneer',
        steely: 'dan'
      }));
      this.add('route:application', _routing.Route.extend({
        queryParams: {
          alex: {
            replace: true
          },
          steely: {
            replace: false
          }
        }
      }));
      return this.visit('/').then(function () {
        var appController = _this17.getController('application');

        _this17.expectedPushURL = '/?alex=wallace&steely=jan';
        (0, _runloop.run)(appController, 'setProperties', {
          alex: 'wallace',
          steely: 'jan'
        });
        _this17.expectedPushURL = '/?alex=wallace&steely=fran';
        (0, _runloop.run)(appController, 'setProperties', {
          steely: 'fran'
        });
        _this17.expectedReplaceURL = '/?alex=sriracha&steely=fran';
        (0, _runloop.run)(appController, 'setProperties', {
          alex: 'sriracha'
        });
      });
    };

    _proto['@test can opt into full transition by setting refreshModel in route queryParams when transitioning from child to parent'] = function testCanOptIntoFullTransitionBySettingRefreshModelInRouteQueryParamsWhenTransitioningFromChildToParent(assert) {
      this.addTemplate('parent', '{{outlet}}');
      this.addTemplate('parent.child', "{{link-to 'Parent' 'parent' (query-params foo='change') id='parent-link'}}");
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });
      var parentModelCount = 0;
      this.add('route:parent', _routing.Route.extend({
        model: function () {
          parentModelCount++;
        },
        queryParams: {
          foo: {
            refreshModel: true
          }
        }
      }));
      this.setSingleQPController('parent', 'foo', 'abc');
      return this.visit('/parent/child?foo=lol').then(function () {
        assert.equal(parentModelCount, 1);
        (0, _runloop.run)(document.getElementById('parent-link'), 'click');
        assert.equal(parentModelCount, 2);
      });
    };

    _proto["@test Use Ember.get to retrieve query params 'replace' configuration"] = function testUseEmberGetToRetrieveQueryParamsReplaceConfiguration(assert) {
      var _this18 = this;

      assert.expect(2);
      this.setSingleQPController('application', 'alex', 'matchneer');
      this.add('route:application', _routing.Route.extend({
        queryParams: _runtime.Object.create({
          unknownProperty: function ()
          /* keyName */
          {
            // We are simulating all qps requiring refresh
            return {
              replace: true
            };
          }
        })
      }));
      return this.visitAndAssert('/').then(function () {
        var appController = _this18.getController('application');

        _this18.expectedReplaceURL = '/?alex=wallace';

        _this18.setAndFlush(appController, 'alex', 'wallace');
      });
    };

    _proto['@test can override incoming QP values in setupController'] = function testCanOverrideIncomingQPValuesInSetupController(assert) {
      var _this19 = this;

      assert.expect(3);
      this.router.map(function () {
        this.route('about');
      });
      this.setSingleQPController('index', 'omg', 'lol');
      this.add('route:index', _routing.Route.extend({
        setupController: function (controller) {
          assert.ok(true, 'setupController called');
          controller.set('omg', 'OVERRIDE');
        },
        actions: {
          queryParamsDidChange: function () {
            assert.ok(false, "queryParamsDidChange shouldn't fire");
          }
        }
      }));
      return this.visitAndAssert('/about').then(function () {
        _this19.transitionTo('index');

        _this19.assertCurrentPath('/?omg=OVERRIDE');
      });
    };

    _proto['@test can override incoming QP array values in setupController'] = function testCanOverrideIncomingQPArrayValuesInSetupController(assert) {
      var _this20 = this;

      assert.expect(3);
      this.router.map(function () {
        this.route('about');
      });
      this.setSingleQPController('index', 'omg', ['lol']);
      this.add('route:index', _routing.Route.extend({
        setupController: function (controller) {
          assert.ok(true, 'setupController called');
          controller.set('omg', ['OVERRIDE']);
        },
        actions: {
          queryParamsDidChange: function () {
            assert.ok(false, "queryParamsDidChange shouldn't fire");
          }
        }
      }));
      return this.visitAndAssert('/about').then(function () {
        _this20.transitionTo('index');

        _this20.assertCurrentPath('/?omg=' + encodeURIComponent(JSON.stringify(['OVERRIDE'])));
      });
    };

    _proto['@test URL transitions that remove QPs still register as QP changes'] = function testURLTransitionsThatRemoveQPsStillRegisterAsQPChanges(assert) {
      var _this21 = this;

      assert.expect(2);
      this.setSingleQPController('index', 'omg', 'lol');
      return this.visit('/?omg=borf').then(function () {
        var indexController = _this21.getController('index');

        assert.equal(indexController.get('omg'), 'borf');

        _this21.transitionTo('/');

        assert.equal(indexController.get('omg'), 'lol');
      });
    };

    _proto['@test Subresource naming style is supported'] = function testSubresourceNamingStyleIsSupported(assert) {
      var _this22 = this;

      assert.expect(5);
      this.router.map(function () {
        this.route('abc.def', {
          path: '/abcdef'
        }, function () {
          this.route('zoo');
        });
      });
      this.addTemplate('application', "{{link-to 'A' 'abc.def' (query-params foo='123') id='one'}}{{link-to 'B' 'abc.def.zoo' (query-params foo='123' bar='456') id='two'}}{{outlet}}");
      this.setSingleQPController('abc.def', 'foo', 'lol');
      this.setSingleQPController('abc.def.zoo', 'bar', 'haha');
      return this.visitAndAssert('/').then(function () {
        assert.equal(_this22.$('#one').attr('href'), '/abcdef?foo=123');
        assert.equal(_this22.$('#two').attr('href'), '/abcdef/zoo?bar=456&foo=123');
        (0, _runloop.run)(_this22.$('#one'), 'click');

        _this22.assertCurrentPath('/abcdef?foo=123');

        (0, _runloop.run)(_this22.$('#two'), 'click');

        _this22.assertCurrentPath('/abcdef/zoo?bar=456&foo=123');
      });
    };

    _proto['@test transitionTo supports query params'] = function testTransitionToSupportsQueryParams() {
      var _this23 = this;

      this.setSingleQPController('index', 'foo', 'lol');
      return this.visitAndAssert('/').then(function () {
        _this23.transitionTo({
          queryParams: {
            foo: 'borf'
          }
        });

        _this23.assertCurrentPath('/?foo=borf', 'shorthand supported');

        _this23.transitionTo({
          queryParams: {
            'index:foo': 'blaf'
          }
        });

        _this23.assertCurrentPath('/?foo=blaf', 'longform supported');

        _this23.transitionTo({
          queryParams: {
            'index:foo': false
          }
        });

        _this23.assertCurrentPath('/?foo=false', 'longform supported (bool)');

        _this23.transitionTo({
          queryParams: {
            foo: false
          }
        });

        _this23.assertCurrentPath('/?foo=false', 'shorhand supported (bool)');
      });
    };

    _proto['@test transitionTo supports query params (multiple)'] = function testTransitionToSupportsQueryParamsMultiple() {
      var _this24 = this;

      this.add('controller:index', _controller.default.extend({
        queryParams: ['foo', 'bar'],
        foo: 'lol',
        bar: 'wat'
      }));
      return this.visitAndAssert('/').then(function () {
        _this24.transitionTo({
          queryParams: {
            foo: 'borf'
          }
        });

        _this24.assertCurrentPath('/?foo=borf', 'shorthand supported');

        _this24.transitionTo({
          queryParams: {
            'index:foo': 'blaf'
          }
        });

        _this24.assertCurrentPath('/?foo=blaf', 'longform supported');

        _this24.transitionTo({
          queryParams: {
            'index:foo': false
          }
        });

        _this24.assertCurrentPath('/?foo=false', 'longform supported (bool)');

        _this24.transitionTo({
          queryParams: {
            foo: false
          }
        });

        _this24.assertCurrentPath('/?foo=false', 'shorhand supported (bool)');
      });
    };

    _proto["@test setting controller QP to empty string doesn't generate null in URL"] = function testSettingControllerQPToEmptyStringDoesnTGenerateNullInURL(assert) {
      var _this25 = this;

      assert.expect(1);
      this.setSingleQPController('index', 'foo', '123');
      return this.visit('/').then(function () {
        var controller = _this25.getController('index');

        _this25.expectedPushURL = '/?foo=';

        _this25.setAndFlush(controller, 'foo', '');
      });
    };

    _proto["@test setting QP to empty string doesn't generate null in URL"] = function testSettingQPToEmptyStringDoesnTGenerateNullInURL(assert) {
      var _this26 = this;

      assert.expect(1);
      this.add('route:index', _routing.Route.extend({
        queryParams: {
          foo: {
            defaultValue: '123'
          }
        }
      }));
      return this.visit('/').then(function () {
        var controller = _this26.getController('index');

        _this26.expectedPushURL = '/?foo=';

        _this26.setAndFlush(controller, 'foo', '');
      });
    };

    _proto['@test A default boolean value deserializes QPs as booleans rather than strings'] = function testADefaultBooleanValueDeserializesQPsAsBooleansRatherThanStrings(assert) {
      var _this27 = this;

      assert.expect(3);
      this.setSingleQPController('index', 'foo', false);
      this.add('route:index', _routing.Route.extend({
        model: function (params) {
          assert.equal(params.foo, true, 'model hook received foo as boolean true');
        }
      }));
      return this.visit('/?foo=true').then(function () {
        var controller = _this27.getController('index');

        assert.equal(controller.get('foo'), true);

        _this27.transitionTo('/?foo=false');

        assert.equal(controller.get('foo'), false);
      });
    };

    _proto['@test Query param without value are empty string'] = function testQueryParamWithoutValueAreEmptyString(assert) {
      var _this28 = this;

      assert.expect(1);
      this.add('controller:index', _controller.default.extend({
        queryParams: ['foo'],
        foo: ''
      }));
      return this.visit('/?foo=').then(function () {
        var controller = _this28.getController('index');

        assert.equal(controller.get('foo'), '');
      });
    };

    _proto['@test Array query params can be set'] = function testArrayQueryParamsCanBeSet(assert) {
      var _this29 = this;

      assert.expect(2);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.setSingleQPController('home', 'foo', []);
      return this.visit('/').then(function () {
        var controller = _this29.getController('home');

        _this29.setAndFlush(controller, 'foo', [1, 2]);

        _this29.assertCurrentPath('/?foo=%5B1%2C2%5D');

        _this29.setAndFlush(controller, 'foo', [3, 4]);

        _this29.assertCurrentPath('/?foo=%5B3%2C4%5D');
      });
    };

    _proto['@test (de)serialization: arrays'] = function testDeSerializationArrays(assert) {
      var _this30 = this;

      assert.expect(4);
      this.setSingleQPController('index', 'foo', [1]);
      return this.visitAndAssert('/').then(function () {
        _this30.transitionTo({
          queryParams: {
            foo: [2, 3]
          }
        });

        _this30.assertCurrentPath('/?foo=%5B2%2C3%5D', 'shorthand supported');

        _this30.transitionTo({
          queryParams: {
            'index:foo': [4, 5]
          }
        });

        _this30.assertCurrentPath('/?foo=%5B4%2C5%5D', 'longform supported');

        _this30.transitionTo({
          queryParams: {
            foo: []
          }
        });

        _this30.assertCurrentPath('/?foo=%5B%5D', 'longform supported');
      });
    };

    _proto['@test Url with array query param sets controller property to array'] = function testUrlWithArrayQueryParamSetsControllerPropertyToArray(assert) {
      var _this31 = this;

      assert.expect(1);
      this.setSingleQPController('index', 'foo', '');
      return this.visit('/?foo[]=1&foo[]=2&foo[]=3').then(function () {
        var controller = _this31.getController('index');

        assert.deepEqual(controller.get('foo'), ['1', '2', '3']);
      });
    };

    _proto['@test Array query params can be pushed/popped'] = function testArrayQueryParamsCanBePushedPopped(assert) {
      var _this32 = this;

      assert.expect(17);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.setSingleQPController('home', 'foo', (0, _runtime.A)());
      return this.visitAndAssert('/').then(function () {
        var controller = _this32.getController('home');

        (0, _runloop.run)(controller.foo, 'pushObject', 1);

        _this32.assertCurrentPath('/?foo=%5B1%5D');

        assert.deepEqual(controller.foo, [1]);
        (0, _runloop.run)(controller.foo, 'popObject');

        _this32.assertCurrentPath('/');

        assert.deepEqual(controller.foo, []);
        (0, _runloop.run)(controller.foo, 'pushObject', 1);

        _this32.assertCurrentPath('/?foo=%5B1%5D');

        assert.deepEqual(controller.foo, [1]);
        (0, _runloop.run)(controller.foo, 'popObject');

        _this32.assertCurrentPath('/');

        assert.deepEqual(controller.foo, []);
        (0, _runloop.run)(controller.foo, 'pushObject', 1);

        _this32.assertCurrentPath('/?foo=%5B1%5D');

        assert.deepEqual(controller.foo, [1]);
        (0, _runloop.run)(controller.foo, 'pushObject', 2);

        _this32.assertCurrentPath('/?foo=%5B1%2C2%5D');

        assert.deepEqual(controller.foo, [1, 2]);
        (0, _runloop.run)(controller.foo, 'popObject');

        _this32.assertCurrentPath('/?foo=%5B1%5D');

        assert.deepEqual(controller.foo, [1]);
        (0, _runloop.run)(controller.foo, 'unshiftObject', 'lol');

        _this32.assertCurrentPath('/?foo=%5B%22lol%22%2C1%5D');

        assert.deepEqual(controller.foo, ['lol', 1]);
      });
    };

    _proto["@test Overwriting with array with same content shouldn't refire update"] = function testOverwritingWithArrayWithSameContentShouldnTRefireUpdate(assert) {
      var _this33 = this;

      assert.expect(4);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      var modelCount = 0;
      this.add('route:home', _routing.Route.extend({
        model: function () {
          modelCount++;
        }
      }));
      this.setSingleQPController('home', 'foo', (0, _runtime.A)([1]));
      return this.visitAndAssert('/').then(function () {
        assert.equal(modelCount, 1);

        var controller = _this33.getController('home');

        _this33.setAndFlush(controller, 'model', (0, _runtime.A)([1]));

        assert.equal(modelCount, 1);

        _this33.assertCurrentPath('/');
      });
    };

    _proto['@test Defaulting to params hash as the model should not result in that params object being watched'] = function testDefaultingToParamsHashAsTheModelShouldNotResultInThatParamsObjectBeingWatched(assert) {
      var _this34 = this;

      assert.expect(1);
      this.router.map(function () {
        this.route('other');
      }); // This causes the params hash, which is returned as a route's
      // model if no other model could be resolved given the provided
      // params (and no custom model hook was defined), to be watched,
      // unless we return a copy of the params hash.

      this.setSingleQPController('application', 'woot', 'wat');
      this.add('route:other', _routing.Route.extend({
        model: function (p, trans) {
          var m = (0, _meta.peekMeta)(trans[_router_js.PARAMS_SYMBOL].application);
          assert.ok(m === null, "A meta object isn't constructed for this params POJO");
        }
      }));
      return this.visit('/').then(function () {
        _this34.transitionTo('other');
      });
    };

    _proto['@test Setting bound query param property to null or undefined does not serialize to url'] = function testSettingBoundQueryParamPropertyToNullOrUndefinedDoesNotSerializeToUrl(assert) {
      var _this35 = this;

      assert.expect(9);
      this.router.map(function () {
        this.route('home');
      });
      this.setSingleQPController('home', 'foo', [1, 2]);
      return this.visitAndAssert('/home').then(function () {
        var controller = _this35.getController('home');

        assert.deepEqual(controller.get('foo'), [1, 2]);

        _this35.assertCurrentPath('/home');

        _this35.setAndFlush(controller, 'foo', (0, _runtime.A)([1, 3]));

        _this35.assertCurrentPath('/home?foo=%5B1%2C3%5D');

        return _this35.transitionTo('/home').then(function () {
          assert.deepEqual(controller.get('foo'), [1, 2]);

          _this35.assertCurrentPath('/home');

          _this35.setAndFlush(controller, 'foo', null);

          _this35.assertCurrentPath('/home', 'Setting property to null');

          _this35.setAndFlush(controller, 'foo', (0, _runtime.A)([1, 3]));

          _this35.assertCurrentPath('/home?foo=%5B1%2C3%5D');

          _this35.setAndFlush(controller, 'foo', undefined);

          _this35.assertCurrentPath('/home', 'Setting property to undefined');
        });
      });
    };

    _proto['@test {{link-to}} with null or undefined QPs does not get serialized into url'] = function testLinkToWithNullOrUndefinedQPsDoesNotGetSerializedIntoUrl(assert) {
      var _this36 = this;

      assert.expect(3);
      this.addTemplate('home', "{{link-to 'Home' 'home' (query-params foo=nullValue) id='null-link'}}{{link-to 'Home' 'home' (query-params foo=undefinedValue) id='undefined-link'}}");
      this.router.map(function () {
        this.route('home');
      });
      this.setSingleQPController('home', 'foo', [], {
        nullValue: null,
        undefinedValue: undefined
      });
      return this.visitAndAssert('/home').then(function () {
        assert.equal(_this36.$('#null-link').attr('href'), '/home');
        assert.equal(_this36.$('#undefined-link').attr('href'), '/home');
      });
    };

    _proto["@test A child of a resource route still defaults to parent route's model even if the child route has a query param"] = function testAChildOfAResourceRouteStillDefaultsToParentRouteSModelEvenIfTheChildRouteHasAQueryParam(assert) {
      assert.expect(2);
      this.setSingleQPController('index', 'woot', undefined, {
        woot: undefined
      });
      this.add('route:application', _routing.Route.extend({
        model: function ()
        /* p, trans */
        {
          return {
            woot: true
          };
        }
      }));
      this.add('route:index', _routing.Route.extend({
        setupController: function (controller, model) {
          assert.deepEqual(model, {
            woot: true
          }, 'index route inherited model route from parent route');
        }
      }));
      return this.visitAndAssert('/');
    };

    _proto['@test opting into replace does not affect transitions between routes'] = function testOptingIntoReplaceDoesNotAffectTransitionsBetweenRoutes(assert) {
      var _this37 = this;

      assert.expect(5);
      this.addTemplate('application', "{{link-to 'Foo' 'foo' id='foo-link'}}{{link-to 'Bar' 'bar' id='bar-no-qp-link'}}{{link-to 'Bar' 'bar' (query-params raytiley='isthebest') id='bar-link'}}{{outlet}}");
      this.router.map(function () {
        this.route('foo');
        this.route('bar');
      });
      this.setSingleQPController('bar', 'raytiley', 'israd');
      this.add('route:bar', _routing.Route.extend({
        queryParams: {
          raytiley: {
            replace: true
          }
        }
      }));
      return this.visit('/').then(function () {
        var controller = _this37.getController('bar');

        _this37.expectedPushURL = '/foo';
        (0, _runloop.run)(document.getElementById('foo-link'), 'click');
        _this37.expectedPushURL = '/bar';
        (0, _runloop.run)(document.getElementById('bar-no-qp-link'), 'click');
        _this37.expectedReplaceURL = '/bar?raytiley=woot';

        _this37.setAndFlush(controller, 'raytiley', 'woot');

        _this37.expectedPushURL = '/foo';
        (0, _runloop.run)(document.getElementById('foo-link'), 'click');
        _this37.expectedPushURL = '/bar?raytiley=isthebest';
        (0, _runloop.run)(document.getElementById('bar-link'), 'click');
      });
    };

    _proto["@test undefined isn't serialized or deserialized into a string"] = function testUndefinedIsnTSerializedOrDeserializedIntoAString(assert) {
      var _this38 = this;

      assert.expect(4);
      this.router.map(function () {
        this.route('example');
      });
      this.addTemplate('application', "{{link-to 'Example' 'example' (query-params foo=undefined) id='the-link'}}");
      this.setSingleQPController('example', 'foo', undefined, {
        foo: undefined
      });
      this.add('route:example', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            foo: undefined
          });
        }
      }));
      return this.visitAndAssert('/').then(function () {
        assert.equal(_this38.$('#the-link').attr('href'), '/example', 'renders without undefined qp serialized');
        return _this38.transitionTo('example', {
          queryParams: {
            foo: undefined
          }
        }).then(function () {
          _this38.assertCurrentPath('/example');
        });
      });
    };

    _proto['@test when refreshModel is true and loading hook is undefined, model hook will rerun when QPs change even if previous did not finish'] = function testWhenRefreshModelIsTrueAndLoadingHookIsUndefinedModelHookWillRerunWhenQPsChangeEvenIfPreviousDidNotFinish() {
      return this.refreshModelWhileLoadingTest();
    };

    _proto['@test when refreshModel is true and loading hook returns false, model hook will rerun when QPs change even if previous did not finish'] = function testWhenRefreshModelIsTrueAndLoadingHookReturnsFalseModelHookWillRerunWhenQPsChangeEvenIfPreviousDidNotFinish() {
      return this.refreshModelWhileLoadingTest(false);
    };

    _proto['@test when refreshModel is true and loading hook returns true, model hook will rerun when QPs change even if previous did not finish'] = function testWhenRefreshModelIsTrueAndLoadingHookReturnsTrueModelHookWillRerunWhenQPsChangeEvenIfPreviousDidNotFinish() {
      return this.refreshModelWhileLoadingTest(true);
    };

    _proto["@test warn user that Route's queryParams configuration must be an Object, not an Array"] = function testWarnUserThatRouteSQueryParamsConfigurationMustBeAnObjectNotAnArray(assert) {
      var _this39 = this;

      assert.expect(1);
      this.add('route:application', _routing.Route.extend({
        queryParams: [{
          commitBy: {
            replace: true
          }
        }]
      }));
      expectAssertion(function () {
        _this39.visit('/');
      }, 'You passed in `[{"commitBy":{"replace":true}}]` as the value for `queryParams` but `queryParams` cannot be an Array');
    };

    _proto['@test handle route names that clash with Object.prototype properties'] = function testHandleRouteNamesThatClashWithObjectPrototypeProperties(assert) {
      var _this40 = this;

      assert.expect(1);
      this.router.map(function () {
        this.route('constructor');
      });
      this.add('route:constructor', _routing.Route.extend({
        queryParams: {
          foo: {
            defaultValue: '123'
          }
        }
      }));
      return this.visit('/').then(function () {
        _this40.transitionTo('constructor', {
          queryParams: {
            foo: '999'
          }
        });

        var controller = _this40.getController('constructor');

        assert.equal((0, _metal.get)(controller, 'foo'), '999');
      });
    };

    return _class;
  }(_internalTestHelpers.QueryParamTestCase));
});
enifed("ember/tests/routing/query_params_test/model_dependent_state_with_query_params_test", ["ember-babel", "@ember/controller", "@ember/-internals/runtime", "@ember/-internals/routing", "@ember/runloop", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _controller, _runtime, _routing, _runloop, _metal, _internalTestHelpers) {
  "use strict";

  var ModelDependentQPTestCase =
  /*#__PURE__*/
  function (_QueryParamTestCase) {
    (0, _emberBabel.inheritsLoose)(ModelDependentQPTestCase, _QueryParamTestCase);

    function ModelDependentQPTestCase() {
      return _QueryParamTestCase.apply(this, arguments) || this;
    }

    var _proto = ModelDependentQPTestCase.prototype;

    _proto.boot = function boot() {
      this.setupApplication();
      return this.visitApplication();
    };

    _proto.teardown = function teardown() {
      _QueryParamTestCase.prototype.teardown.apply(this, arguments);

      this.assert.ok(!this.expectedModelHookParams, 'there should be no pending expectation of expected model hook params');
    };

    _proto.reopenController = function reopenController(name, options) {
      this.application.resolveRegistration("controller:" + name).reopen(options);
    };

    _proto.reopenRoute = function reopenRoute(name, options) {
      this.application.resolveRegistration("route:" + name).reopen(options);
    };

    _proto.queryParamsStickyTest1 = function queryParamsStickyTest1(urlPrefix) {
      var _this = this;

      var assert = this.assert;
      assert.expect(14);
      return this.boot().then(function () {
        (0, _runloop.run)(_this.$link1, 'click');

        _this.assertCurrentPath(urlPrefix + "/a-1");

        _this.setAndFlush(_this.controller, 'q', 'lol');

        assert.equal(_this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
        assert.equal(_this.$link2.getAttribute('href'), urlPrefix + "/a-2");
        assert.equal(_this.$link3.getAttribute('href'), urlPrefix + "/a-3");
        (0, _runloop.run)(_this.$link2, 'click');
        assert.equal(_this.controller.get('q'), 'wat');
        assert.equal(_this.controller.get('z'), 0);
        assert.deepEqual(_this.controller.get('model'), {
          id: 'a-2'
        });
        assert.equal(_this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
        assert.equal(_this.$link2.getAttribute('href'), urlPrefix + "/a-2");
        assert.equal(_this.$link3.getAttribute('href'), urlPrefix + "/a-3");
      });
    };

    _proto.queryParamsStickyTest2 = function queryParamsStickyTest2(urlPrefix) {
      var _this2 = this;

      var assert = this.assert;
      assert.expect(24);
      return this.boot().then(function () {
        _this2.expectedModelHookParams = {
          id: 'a-1',
          q: 'lol',
          z: 0
        };

        _this2.transitionTo(urlPrefix + "/a-1?q=lol");

        assert.deepEqual(_this2.controller.get('model'), {
          id: 'a-1'
        });
        assert.equal(_this2.controller.get('q'), 'lol');
        assert.equal(_this2.controller.get('z'), 0);
        assert.equal(_this2.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
        assert.equal(_this2.$link2.getAttribute('href'), urlPrefix + "/a-2");
        assert.equal(_this2.$link3.getAttribute('href'), urlPrefix + "/a-3");
        _this2.expectedModelHookParams = {
          id: 'a-2',
          q: 'lol',
          z: 0
        };

        _this2.transitionTo(urlPrefix + "/a-2?q=lol");

        assert.deepEqual(_this2.controller.get('model'), {
          id: 'a-2'
        }, "controller's model changed to a-2");
        assert.equal(_this2.controller.get('q'), 'lol');
        assert.equal(_this2.controller.get('z'), 0);
        assert.equal(_this2.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
        assert.equal(_this2.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
        assert.equal(_this2.$link3.getAttribute('href'), urlPrefix + "/a-3");
        _this2.expectedModelHookParams = {
          id: 'a-3',
          q: 'lol',
          z: 123
        };

        _this2.transitionTo(urlPrefix + "/a-3?q=lol&z=123");

        assert.equal(_this2.controller.get('q'), 'lol');
        assert.equal(_this2.controller.get('z'), 123);
        assert.equal(_this2.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
        assert.equal(_this2.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
        assert.equal(_this2.$link3.getAttribute('href'), urlPrefix + "/a-3?q=lol&z=123");
      });
    };

    _proto.queryParamsStickyTest3 = function queryParamsStickyTest3(urlPrefix, articleLookup) {
      var _this3 = this;

      var assert = this.assert;
      assert.expect(32);
      this.addTemplate('application', "{{#each articles as |a|}} {{link-to 'Article' '" + articleLookup + "' a.id id=a.id}} {{/each}}");
      return this.boot().then(function () {
        _this3.expectedModelHookParams = {
          id: 'a-1',
          q: 'wat',
          z: 0
        };

        _this3.transitionTo(articleLookup, 'a-1');

        assert.deepEqual(_this3.controller.get('model'), {
          id: 'a-1'
        });
        assert.equal(_this3.controller.get('q'), 'wat');
        assert.equal(_this3.controller.get('z'), 0);
        assert.equal(_this3.$link1.getAttribute('href'), urlPrefix + "/a-1");
        assert.equal(_this3.$link2.getAttribute('href'), urlPrefix + "/a-2");
        assert.equal(_this3.$link3.getAttribute('href'), urlPrefix + "/a-3");
        _this3.expectedModelHookParams = {
          id: 'a-2',
          q: 'lol',
          z: 0
        };

        _this3.transitionTo(articleLookup, 'a-2', {
          queryParams: {
            q: 'lol'
          }
        });

        assert.deepEqual(_this3.controller.get('model'), {
          id: 'a-2'
        });
        assert.equal(_this3.controller.get('q'), 'lol');
        assert.equal(_this3.controller.get('z'), 0);
        assert.equal(_this3.$link1.getAttribute('href'), urlPrefix + "/a-1");
        assert.equal(_this3.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
        assert.equal(_this3.$link3.getAttribute('href'), urlPrefix + "/a-3");
        _this3.expectedModelHookParams = {
          id: 'a-3',
          q: 'hay',
          z: 0
        };

        _this3.transitionTo(articleLookup, 'a-3', {
          queryParams: {
            q: 'hay'
          }
        });

        assert.deepEqual(_this3.controller.get('model'), {
          id: 'a-3'
        });
        assert.equal(_this3.controller.get('q'), 'hay');
        assert.equal(_this3.controller.get('z'), 0);
        assert.equal(_this3.$link1.getAttribute('href'), urlPrefix + "/a-1");
        assert.equal(_this3.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
        assert.equal(_this3.$link3.getAttribute('href'), urlPrefix + "/a-3?q=hay");
        _this3.expectedModelHookParams = {
          id: 'a-2',
          q: 'lol',
          z: 1
        };

        _this3.transitionTo(articleLookup, 'a-2', {
          queryParams: {
            z: 1
          }
        });

        assert.deepEqual(_this3.controller.get('model'), {
          id: 'a-2'
        });
        assert.equal(_this3.controller.get('q'), 'lol');
        assert.equal(_this3.controller.get('z'), 1);
        assert.equal(_this3.$link1.getAttribute('href'), urlPrefix + "/a-1");
        assert.equal(_this3.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol&z=1");
        assert.equal(_this3.$link3.getAttribute('href'), urlPrefix + "/a-3?q=hay");
      });
    };

    _proto.queryParamsStickyTest4 = function queryParamsStickyTest4(urlPrefix, articleLookup) {
      var _this4 = this;

      var assert = this.assert;
      assert.expect(24);
      this.setupApplication();
      this.reopenController(articleLookup, {
        queryParams: {
          q: {
            scope: 'controller'
          }
        }
      });
      return this.visitApplication().then(function () {
        (0, _runloop.run)(_this4.$link1, 'click');

        _this4.assertCurrentPath(urlPrefix + "/a-1");

        _this4.setAndFlush(_this4.controller, 'q', 'lol');

        assert.equal(_this4.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
        assert.equal(_this4.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
        assert.equal(_this4.$link3.getAttribute('href'), urlPrefix + "/a-3?q=lol");
        (0, _runloop.run)(_this4.$link2, 'click');
        assert.equal(_this4.controller.get('q'), 'lol');
        assert.equal(_this4.controller.get('z'), 0);
        assert.deepEqual(_this4.controller.get('model'), {
          id: 'a-2'
        });
        assert.equal(_this4.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
        assert.equal(_this4.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
        assert.equal(_this4.$link3.getAttribute('href'), urlPrefix + "/a-3?q=lol");
        _this4.expectedModelHookParams = {
          id: 'a-3',
          q: 'haha',
          z: 123
        };

        _this4.transitionTo(urlPrefix + "/a-3?q=haha&z=123");

        assert.deepEqual(_this4.controller.get('model'), {
          id: 'a-3'
        });
        assert.equal(_this4.controller.get('q'), 'haha');
        assert.equal(_this4.controller.get('z'), 123);
        assert.equal(_this4.$link1.getAttribute('href'), urlPrefix + "/a-1?q=haha");
        assert.equal(_this4.$link2.getAttribute('href'), urlPrefix + "/a-2?q=haha");
        assert.equal(_this4.$link3.getAttribute('href'), urlPrefix + "/a-3?q=haha&z=123");

        _this4.setAndFlush(_this4.controller, 'q', 'woot');

        assert.equal(_this4.$link1.getAttribute('href'), urlPrefix + "/a-1?q=woot");
        assert.equal(_this4.$link2.getAttribute('href'), urlPrefix + "/a-2?q=woot");
        assert.equal(_this4.$link3.getAttribute('href'), urlPrefix + "/a-3?q=woot&z=123");
      });
    };

    _proto.queryParamsStickyTest5 = function queryParamsStickyTest5(urlPrefix, commentsLookupKey) {
      var _this5 = this;

      var assert = this.assert;
      assert.expect(12);
      return this.boot().then(function () {
        _this5.transitionTo(commentsLookupKey, 'a-1');

        var commentsCtrl = _this5.getController(commentsLookupKey);

        assert.equal(commentsCtrl.get('page'), 1);

        _this5.assertCurrentPath(urlPrefix + "/a-1/comments");

        _this5.setAndFlush(commentsCtrl, 'page', 2);

        _this5.assertCurrentPath(urlPrefix + "/a-1/comments?page=2");

        _this5.setAndFlush(commentsCtrl, 'page', 3);

        _this5.assertCurrentPath(urlPrefix + "/a-1/comments?page=3");

        _this5.transitionTo(commentsLookupKey, 'a-2');

        assert.equal(commentsCtrl.get('page'), 1);

        _this5.assertCurrentPath(urlPrefix + "/a-2/comments");

        _this5.transitionTo(commentsLookupKey, 'a-1');

        assert.equal(commentsCtrl.get('page'), 3);

        _this5.assertCurrentPath(urlPrefix + "/a-1/comments?page=3");
      });
    };

    _proto.queryParamsStickyTest6 = function queryParamsStickyTest6(urlPrefix, articleLookup, commentsLookup) {
      var _this6 = this;

      var assert = this.assert;
      assert.expect(13);
      this.setupApplication();
      this.reopenRoute(articleLookup, {
        resetController: function (controller, isExiting) {
          this.controllerFor(commentsLookup).set('page', 1);

          if (isExiting) {
            controller.set('q', 'imdone');
          }
        }
      });
      this.addTemplate('about', "{{link-to 'A' '" + commentsLookup + "' 'a-1' id='one'}} {{link-to 'B' '" + commentsLookup + "' 'a-2' id='two'}}");
      return this.visitApplication().then(function () {
        _this6.transitionTo(commentsLookup, 'a-1');

        var commentsCtrl = _this6.getController(commentsLookup);

        assert.equal(commentsCtrl.get('page'), 1);

        _this6.assertCurrentPath(urlPrefix + "/a-1/comments");

        _this6.setAndFlush(commentsCtrl, 'page', 2);

        _this6.assertCurrentPath(urlPrefix + "/a-1/comments?page=2");

        _this6.transitionTo(commentsLookup, 'a-2');

        assert.equal(commentsCtrl.get('page'), 1);
        assert.equal(_this6.controller.get('q'), 'wat');

        _this6.transitionTo(commentsLookup, 'a-1');

        _this6.assertCurrentPath(urlPrefix + "/a-1/comments");

        assert.equal(commentsCtrl.get('page'), 1);

        _this6.transitionTo('about');

        assert.equal(document.getElementById('one').getAttribute('href'), urlPrefix + "/a-1/comments?q=imdone");
        assert.equal(document.getElementById('two').getAttribute('href'), urlPrefix + "/a-2/comments");
      });
    };

    return ModelDependentQPTestCase;
  }(_internalTestHelpers.QueryParamTestCase);

  (0, _internalTestHelpers.moduleFor)('Query Params - model-dependent state',
  /*#__PURE__*/
  function (_ModelDependentQPTest) {
    (0, _emberBabel.inheritsLoose)(_class, _ModelDependentQPTest);

    function _class() {
      return _ModelDependentQPTest.apply(this, arguments) || this;
    }

    var _proto2 = _class.prototype;

    _proto2.setupApplication = function setupApplication() {
      this.router.map(function () {
        this.route('article', {
          path: '/a/:id'
        }, function () {
          this.route('comments', {
            resetNamespace: true
          });
        });
        this.route('about');
      });
      var articles = (0, _runtime.A)([{
        id: 'a-1'
      }, {
        id: 'a-2'
      }, {
        id: 'a-3'
      }]);
      this.add('controller:application', _controller.default.extend({
        articles: articles
      }));
      var self = this;
      var assert = this.assert;
      this.add('route:article', _routing.Route.extend({
        model: function (params) {
          if (self.expectedModelHookParams) {
            assert.deepEqual(params, self.expectedModelHookParams, 'the ArticleRoute model hook received the expected merged dynamic segment + query params hash');
            self.expectedModelHookParams = null;
          }

          return articles.findBy('id', params.id);
        }
      }));
      this.add('controller:article', _controller.default.extend({
        queryParams: ['q', 'z'],
        q: 'wat',
        z: 0
      }));
      this.add('controller:comments', _controller.default.extend({
        queryParams: 'page',
        page: 1
      }));
      this.addTemplate('application', "{{#each articles as |a|}} 1{{link-to 'Article' 'article' a id=a.id}} {{/each}} {{outlet}}");
    };

    _proto2.visitApplication = function visitApplication() {
      var _this7 = this;

      return this.visit('/').then(function () {
        var assert = _this7.assert;
        _this7.$link1 = document.getElementById('a-1');
        _this7.$link2 = document.getElementById('a-2');
        _this7.$link3 = document.getElementById('a-3');
        assert.equal(_this7.$link1.getAttribute('href'), '/a/a-1');
        assert.equal(_this7.$link2.getAttribute('href'), '/a/a-2');
        assert.equal(_this7.$link3.getAttribute('href'), '/a/a-3');
        _this7.controller = _this7.getController('article');
      });
    };

    _proto2["@test query params have 'model' stickiness by default"] = function testQueryParamsHaveModelStickinessByDefault() {
      return this.queryParamsStickyTest1('/a');
    };

    _proto2["@test query params have 'model' stickiness by default (url changes)"] = function testQueryParamsHaveModelStickinessByDefaultUrlChanges() {
      return this.queryParamsStickyTest2('/a');
    };

    _proto2["@test query params have 'model' stickiness by default (params-based transitions)"] = function testQueryParamsHaveModelStickinessByDefaultParamsBasedTransitions() {
      return this.queryParamsStickyTest3('/a', 'article');
    };

    _proto2["@test 'controller' stickiness shares QP state between models"] = function testControllerStickinessSharesQPStateBetweenModels() {
      return this.queryParamsStickyTest4('/a', 'article');
    };

    _proto2["@test 'model' stickiness is scoped to current or first dynamic parent route"] = function testModelStickinessIsScopedToCurrentOrFirstDynamicParentRoute() {
      return this.queryParamsStickyTest5('/a', 'comments');
    };

    _proto2['@test can reset query params using the resetController hook'] = function testCanResetQueryParamsUsingTheResetControllerHook() {
      return this.queryParamsStickyTest6('/a', 'article', 'comments');
    };

    return _class;
  }(ModelDependentQPTestCase));
  (0, _internalTestHelpers.moduleFor)('Query Params - model-dependent state (nested)',
  /*#__PURE__*/
  function (_ModelDependentQPTest2) {
    (0, _emberBabel.inheritsLoose)(_class2, _ModelDependentQPTest2);

    function _class2() {
      return _ModelDependentQPTest2.apply(this, arguments) || this;
    }

    var _proto3 = _class2.prototype;

    _proto3.setupApplication = function setupApplication() {
      this.router.map(function () {
        this.route('site', function () {
          this.route('article', {
            path: '/a/:id'
          }, function () {
            this.route('comments');
          });
        });
        this.route('about');
      });
      var site_articles = (0, _runtime.A)([{
        id: 'a-1'
      }, {
        id: 'a-2'
      }, {
        id: 'a-3'
      }]);
      this.add('controller:application', _controller.default.extend({
        articles: site_articles
      }));
      var self = this;
      var assert = this.assert;
      this.add('route:site.article', _routing.Route.extend({
        model: function (params) {
          if (self.expectedModelHookParams) {
            assert.deepEqual(params, self.expectedModelHookParams, 'the ArticleRoute model hook received the expected merged dynamic segment + query params hash');
            self.expectedModelHookParams = null;
          }

          return site_articles.findBy('id', params.id);
        }
      }));
      this.add('controller:site.article', _controller.default.extend({
        queryParams: ['q', 'z'],
        q: 'wat',
        z: 0
      }));
      this.add('controller:site.article.comments', _controller.default.extend({
        queryParams: 'page',
        page: 1
      }));
      this.addTemplate('application', "{{#each articles as |a|}} {{link-to 'Article' 'site.article' a id=a.id}} {{/each}} {{outlet}}");
    };

    _proto3.visitApplication = function visitApplication() {
      var _this8 = this;

      return this.visit('/').then(function () {
        var assert = _this8.assert;
        _this8.$link1 = document.getElementById('a-1');
        _this8.$link2 = document.getElementById('a-2');
        _this8.$link3 = document.getElementById('a-3');
        assert.equal(_this8.$link1.getAttribute('href'), '/site/a/a-1');
        assert.equal(_this8.$link2.getAttribute('href'), '/site/a/a-2');
        assert.equal(_this8.$link3.getAttribute('href'), '/site/a/a-3');
        _this8.controller = _this8.getController('site.article');
      });
    };

    _proto3["@test query params have 'model' stickiness by default"] = function testQueryParamsHaveModelStickinessByDefault() {
      return this.queryParamsStickyTest1('/site/a');
    };

    _proto3["@test query params have 'model' stickiness by default (url changes)"] = function testQueryParamsHaveModelStickinessByDefaultUrlChanges() {
      return this.queryParamsStickyTest2('/site/a');
    };

    _proto3["@test query params have 'model' stickiness by default (params-based transitions)"] = function testQueryParamsHaveModelStickinessByDefaultParamsBasedTransitions() {
      return this.queryParamsStickyTest3('/site/a', 'site.article');
    };

    _proto3["@test 'controller' stickiness shares QP state between models"] = function testControllerStickinessSharesQPStateBetweenModels() {
      return this.queryParamsStickyTest4('/site/a', 'site.article');
    };

    _proto3["@test 'model' stickiness is scoped to current or first dynamic parent route"] = function testModelStickinessIsScopedToCurrentOrFirstDynamicParentRoute() {
      return this.queryParamsStickyTest5('/site/a', 'site.article.comments');
    };

    _proto3['@test can reset query params using the resetController hook'] = function testCanResetQueryParamsUsingTheResetControllerHook() {
      return this.queryParamsStickyTest6('/site/a', 'site.article', 'site.article.comments');
    };

    return _class2;
  }(ModelDependentQPTestCase));
  (0, _internalTestHelpers.moduleFor)('Query Params - model-dependent state (nested & more than 1 dynamic segment)',
  /*#__PURE__*/
  function (_ModelDependentQPTest3) {
    (0, _emberBabel.inheritsLoose)(_class3, _ModelDependentQPTest3);

    function _class3() {
      return _ModelDependentQPTest3.apply(this, arguments) || this;
    }

    var _proto4 = _class3.prototype;

    _proto4.setupApplication = function setupApplication() {
      this.router.map(function () {
        this.route('site', {
          path: '/site/:site_id'
        }, function () {
          this.route('article', {
            path: '/a/:article_id'
          }, function () {
            this.route('comments');
          });
        });
      });
      var sites = (0, _runtime.A)([{
        id: 's-1'
      }, {
        id: 's-2'
      }, {
        id: 's-3'
      }]);
      var site_articles = (0, _runtime.A)([{
        id: 'a-1'
      }, {
        id: 'a-2'
      }, {
        id: 'a-3'
      }]);
      this.add('controller:application', _controller.default.extend({
        siteArticles: site_articles,
        sites: sites,
        allSitesAllArticles: (0, _metal.computed)({
          get: function () {
            var ret = [];
            var siteArticles = this.siteArticles;
            var sites = this.sites;
            sites.forEach(function (site) {
              ret = ret.concat(siteArticles.map(function (article) {
                return {
                  id: site.id + "-" + article.id,
                  site_id: site.id,
                  article_id: article.id
                };
              }));
            });
            return ret;
          }
        })
      }));
      var self = this;
      var assert = this.assert;
      this.add('route:site', _routing.Route.extend({
        model: function (params) {
          if (self.expectedSiteModelHookParams) {
            assert.deepEqual(params, self.expectedSiteModelHookParams, 'the SiteRoute model hook received the expected merged dynamic segment + query params hash');
            self.expectedSiteModelHookParams = null;
          }

          return sites.findBy('id', params.site_id);
        }
      }));
      this.add('route:site.article', _routing.Route.extend({
        model: function (params) {
          if (self.expectedArticleModelHookParams) {
            assert.deepEqual(params, self.expectedArticleModelHookParams, 'the SiteArticleRoute model hook received the expected merged dynamic segment + query params hash');
            self.expectedArticleModelHookParams = null;
          }

          return site_articles.findBy('id', params.article_id);
        }
      }));
      this.add('controller:site', _controller.default.extend({
        queryParams: ['country'],
        country: 'au'
      }));
      this.add('controller:site.article', _controller.default.extend({
        queryParams: ['q', 'z'],
        q: 'wat',
        z: 0
      }));
      this.add('controller:site.article.comments', _controller.default.extend({
        queryParams: ['page'],
        page: 1
      }));
      this.addTemplate('application', "{{#each allSitesAllArticles as |a|}} {{#link-to 'site.article' a.site_id a.article_id id=a.id}}Article [{{a.site_id}}] [{{a.article_id}}]{{/link-to}} {{/each}} {{outlet}}");
    };

    _proto4.visitApplication = function visitApplication() {
      var _this9 = this;

      return this.visit('/').then(function () {
        var assert = _this9.assert;
        _this9.links = {};
        _this9.links['s-1-a-1'] = document.getElementById('s-1-a-1');
        _this9.links['s-1-a-2'] = document.getElementById('s-1-a-2');
        _this9.links['s-1-a-3'] = document.getElementById('s-1-a-3');
        _this9.links['s-2-a-1'] = document.getElementById('s-2-a-1');
        _this9.links['s-2-a-2'] = document.getElementById('s-2-a-2');
        _this9.links['s-2-a-3'] = document.getElementById('s-2-a-3');
        _this9.links['s-3-a-1'] = document.getElementById('s-3-a-1');
        _this9.links['s-3-a-2'] = document.getElementById('s-3-a-2');
        _this9.links['s-3-a-3'] = document.getElementById('s-3-a-3');
        assert.equal(_this9.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
        assert.equal(_this9.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2');
        assert.equal(_this9.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
        assert.equal(_this9.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1');
        assert.equal(_this9.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
        assert.equal(_this9.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
        assert.equal(_this9.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
        assert.equal(_this9.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
        assert.equal(_this9.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
        _this9.site_controller = _this9.getController('site');
        _this9.article_controller = _this9.getController('site.article');
      });
    };

    _proto4["@test query params have 'model' stickiness by default"] = function testQueryParamsHaveModelStickinessByDefault(assert) {
      var _this10 = this;

      assert.expect(59);
      return this.boot().then(function () {
        (0, _runloop.run)(_this10.links['s-1-a-1'], 'click');
        assert.deepEqual(_this10.site_controller.get('model'), {
          id: 's-1'
        });
        assert.deepEqual(_this10.article_controller.get('model'), {
          id: 'a-1'
        });

        _this10.assertCurrentPath('/site/s-1/a/a-1');

        _this10.setAndFlush(_this10.article_controller, 'q', 'lol');

        assert.equal(_this10.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
        assert.equal(_this10.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2');
        assert.equal(_this10.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
        assert.equal(_this10.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?q=lol');
        assert.equal(_this10.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
        assert.equal(_this10.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
        assert.equal(_this10.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
        assert.equal(_this10.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
        assert.equal(_this10.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');

        _this10.setAndFlush(_this10.site_controller, 'country', 'us');

        assert.equal(_this10.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?country=us&q=lol');
        assert.equal(_this10.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?country=us');
        assert.equal(_this10.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?country=us');
        assert.equal(_this10.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?q=lol');
        assert.equal(_this10.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
        assert.equal(_this10.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
        assert.equal(_this10.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
        assert.equal(_this10.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
        assert.equal(_this10.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
        (0, _runloop.run)(_this10.links['s-1-a-2'], 'click');
        assert.equal(_this10.site_controller.get('country'), 'us');
        assert.equal(_this10.article_controller.get('q'), 'wat');
        assert.equal(_this10.article_controller.get('z'), 0);
        assert.deepEqual(_this10.site_controller.get('model'), {
          id: 's-1'
        });
        assert.deepEqual(_this10.article_controller.get('model'), {
          id: 'a-2'
        });
        assert.equal(_this10.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?country=us&q=lol');
        assert.equal(_this10.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?country=us');
        assert.equal(_this10.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?country=us');
        assert.equal(_this10.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?q=lol');
        assert.equal(_this10.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
        assert.equal(_this10.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
        assert.equal(_this10.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
        assert.equal(_this10.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
        assert.equal(_this10.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
        (0, _runloop.run)(_this10.links['s-2-a-2'], 'click');
        assert.equal(_this10.site_controller.get('country'), 'au');
        assert.equal(_this10.article_controller.get('q'), 'wat');
        assert.equal(_this10.article_controller.get('z'), 0);
        assert.deepEqual(_this10.site_controller.get('model'), {
          id: 's-2'
        });
        assert.deepEqual(_this10.article_controller.get('model'), {
          id: 'a-2'
        });
        assert.equal(_this10.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?country=us&q=lol');
        assert.equal(_this10.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?country=us');
        assert.equal(_this10.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?country=us');
        assert.equal(_this10.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?q=lol');
        assert.equal(_this10.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
        assert.equal(_this10.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
        assert.equal(_this10.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
        assert.equal(_this10.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
        assert.equal(_this10.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
      });
    };

    _proto4["@test query params have 'model' stickiness by default (url changes)"] = function testQueryParamsHaveModelStickinessByDefaultUrlChanges(assert) {
      var _this11 = this;

      assert.expect(88);
      return this.boot().then(function () {
        _this11.expectedSiteModelHookParams = {
          site_id: 's-1',
          country: 'au'
        };
        _this11.expectedArticleModelHookParams = {
          article_id: 'a-1',
          q: 'lol',
          z: 0
        };

        _this11.transitionTo('/site/s-1/a/a-1?q=lol');

        assert.deepEqual(_this11.site_controller.get('model'), {
          id: 's-1'
        }, "site controller's model is s-1");
        assert.deepEqual(_this11.article_controller.get('model'), {
          id: 'a-1'
        }, "article controller's model is a-1");
        assert.equal(_this11.site_controller.get('country'), 'au');
        assert.equal(_this11.article_controller.get('q'), 'lol');
        assert.equal(_this11.article_controller.get('z'), 0);
        assert.equal(_this11.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
        assert.equal(_this11.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2');
        assert.equal(_this11.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
        assert.equal(_this11.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?q=lol');
        assert.equal(_this11.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
        assert.equal(_this11.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
        assert.equal(_this11.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
        assert.equal(_this11.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
        assert.equal(_this11.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
        _this11.expectedSiteModelHookParams = {
          site_id: 's-2',
          country: 'us'
        };
        _this11.expectedArticleModelHookParams = {
          article_id: 'a-1',
          q: 'lol',
          z: 0
        };

        _this11.transitionTo('/site/s-2/a/a-1?country=us&q=lol');

        assert.deepEqual(_this11.site_controller.get('model'), {
          id: 's-2'
        }, "site controller's model is s-2");
        assert.deepEqual(_this11.article_controller.get('model'), {
          id: 'a-1'
        }, "article controller's model is a-1");
        assert.equal(_this11.site_controller.get('country'), 'us');
        assert.equal(_this11.article_controller.get('q'), 'lol');
        assert.equal(_this11.article_controller.get('z'), 0);
        assert.equal(_this11.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
        assert.equal(_this11.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2');
        assert.equal(_this11.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
        assert.equal(_this11.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=lol');
        assert.equal(_this11.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us');
        assert.equal(_this11.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us');
        assert.equal(_this11.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
        assert.equal(_this11.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
        assert.equal(_this11.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
        _this11.expectedSiteModelHookParams = {
          site_id: 's-2',
          country: 'us'
        };
        _this11.expectedArticleModelHookParams = {
          article_id: 'a-2',
          q: 'lol',
          z: 0
        };

        _this11.transitionTo('/site/s-2/a/a-2?country=us&q=lol');

        assert.deepEqual(_this11.site_controller.get('model'), {
          id: 's-2'
        }, "site controller's model is s-2");
        assert.deepEqual(_this11.article_controller.get('model'), {
          id: 'a-2'
        }, "article controller's model is a-2");
        assert.equal(_this11.site_controller.get('country'), 'us');
        assert.equal(_this11.article_controller.get('q'), 'lol');
        assert.equal(_this11.article_controller.get('z'), 0);
        assert.equal(_this11.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
        assert.equal(_this11.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol');
        assert.equal(_this11.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
        assert.equal(_this11.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=lol');
        assert.equal(_this11.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol');
        assert.equal(_this11.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us');
        assert.equal(_this11.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
        assert.equal(_this11.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol');
        assert.equal(_this11.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
        _this11.expectedSiteModelHookParams = {
          site_id: 's-2',
          country: 'us'
        };
        _this11.expectedArticleModelHookParams = {
          article_id: 'a-3',
          q: 'lol',
          z: 123
        };

        _this11.transitionTo('/site/s-2/a/a-3?country=us&q=lol&z=123');

        assert.deepEqual(_this11.site_controller.get('model'), {
          id: 's-2'
        }, "site controller's model is s-2");
        assert.deepEqual(_this11.article_controller.get('model'), {
          id: 'a-3'
        }, "article controller's model is a-3");
        assert.equal(_this11.site_controller.get('country'), 'us');
        assert.equal(_this11.article_controller.get('q'), 'lol');
        assert.equal(_this11.article_controller.get('z'), 123);
        assert.equal(_this11.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
        assert.equal(_this11.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol');
        assert.equal(_this11.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=lol&z=123');
        assert.equal(_this11.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=lol');
        assert.equal(_this11.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol');
        assert.equal(_this11.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us&q=lol&z=123');
        assert.equal(_this11.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
        assert.equal(_this11.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol');
        assert.equal(_this11.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?q=lol&z=123');
        _this11.expectedSiteModelHookParams = {
          site_id: 's-3',
          country: 'nz'
        };
        _this11.expectedArticleModelHookParams = {
          article_id: 'a-3',
          q: 'lol',
          z: 123
        };

        _this11.transitionTo('/site/s-3/a/a-3?country=nz&q=lol&z=123');

        assert.deepEqual(_this11.site_controller.get('model'), {
          id: 's-3'
        }, "site controller's model is s-3");
        assert.deepEqual(_this11.article_controller.get('model'), {
          id: 'a-3'
        }, "article controller's model is a-3");
        assert.equal(_this11.site_controller.get('country'), 'nz');
        assert.equal(_this11.article_controller.get('q'), 'lol');
        assert.equal(_this11.article_controller.get('z'), 123);
        assert.equal(_this11.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
        assert.equal(_this11.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol');
        assert.equal(_this11.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=lol&z=123');
        assert.equal(_this11.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=lol');
        assert.equal(_this11.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol');
        assert.equal(_this11.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us&q=lol&z=123');
        assert.equal(_this11.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?country=nz&q=lol');
        assert.equal(_this11.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?country=nz&q=lol');
        assert.equal(_this11.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?country=nz&q=lol&z=123');
      });
    };

    _proto4["@test query params have 'model' stickiness by default (params-based transitions)"] = function testQueryParamsHaveModelStickinessByDefaultParamsBasedTransitions(assert) {
      var _this12 = this;

      assert.expect(118);
      return this.boot().then(function () {
        _this12.expectedSiteModelHookParams = {
          site_id: 's-1',
          country: 'au'
        };
        _this12.expectedArticleModelHookParams = {
          article_id: 'a-1',
          q: 'wat',
          z: 0
        };

        _this12.transitionTo('site.article', 's-1', 'a-1');

        assert.deepEqual(_this12.site_controller.get('model'), {
          id: 's-1'
        });
        assert.deepEqual(_this12.article_controller.get('model'), {
          id: 'a-1'
        });
        assert.equal(_this12.site_controller.get('country'), 'au');
        assert.equal(_this12.article_controller.get('q'), 'wat');
        assert.equal(_this12.article_controller.get('z'), 0);
        assert.equal(_this12.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
        assert.equal(_this12.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2');
        assert.equal(_this12.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
        assert.equal(_this12.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1');
        assert.equal(_this12.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
        assert.equal(_this12.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
        assert.equal(_this12.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
        assert.equal(_this12.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
        assert.equal(_this12.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
        _this12.expectedSiteModelHookParams = {
          site_id: 's-1',
          country: 'au'
        };
        _this12.expectedArticleModelHookParams = {
          article_id: 'a-2',
          q: 'lol',
          z: 0
        };

        _this12.transitionTo('site.article', 's-1', 'a-2', {
          queryParams: {
            q: 'lol'
          }
        });

        assert.deepEqual(_this12.site_controller.get('model'), {
          id: 's-1'
        });
        assert.deepEqual(_this12.article_controller.get('model'), {
          id: 'a-2'
        });
        assert.equal(_this12.site_controller.get('country'), 'au');
        assert.equal(_this12.article_controller.get('q'), 'lol');
        assert.equal(_this12.article_controller.get('z'), 0);
        assert.equal(_this12.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
        assert.equal(_this12.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol');
        assert.equal(_this12.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
        assert.equal(_this12.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1');
        assert.equal(_this12.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?q=lol');
        assert.equal(_this12.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
        assert.equal(_this12.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
        assert.equal(_this12.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol');
        assert.equal(_this12.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
        _this12.expectedSiteModelHookParams = {
          site_id: 's-1',
          country: 'au'
        };
        _this12.expectedArticleModelHookParams = {
          article_id: 'a-3',
          q: 'hay',
          z: 0
        };

        _this12.transitionTo('site.article', 's-1', 'a-3', {
          queryParams: {
            q: 'hay'
          }
        });

        assert.deepEqual(_this12.site_controller.get('model'), {
          id: 's-1'
        });
        assert.deepEqual(_this12.article_controller.get('model'), {
          id: 'a-3'
        });
        assert.equal(_this12.site_controller.get('country'), 'au');
        assert.equal(_this12.article_controller.get('q'), 'hay');
        assert.equal(_this12.article_controller.get('z'), 0);
        assert.equal(_this12.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
        assert.equal(_this12.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol');
        assert.equal(_this12.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=hay');
        assert.equal(_this12.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1');
        assert.equal(_this12.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?q=lol');
        assert.equal(_this12.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?q=hay');
        assert.equal(_this12.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
        assert.equal(_this12.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol');
        assert.equal(_this12.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?q=hay');
        _this12.expectedSiteModelHookParams = {
          site_id: 's-1',
          country: 'au'
        };
        _this12.expectedArticleModelHookParams = {
          article_id: 'a-2',
          q: 'lol',
          z: 1
        };

        _this12.transitionTo('site.article', 's-1', 'a-2', {
          queryParams: {
            z: 1
          }
        });

        assert.deepEqual(_this12.site_controller.get('model'), {
          id: 's-1'
        });
        assert.deepEqual(_this12.article_controller.get('model'), {
          id: 'a-2'
        });
        assert.equal(_this12.site_controller.get('country'), 'au');
        assert.equal(_this12.article_controller.get('q'), 'lol');
        assert.equal(_this12.article_controller.get('z'), 1);
        assert.equal(_this12.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
        assert.equal(_this12.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol&z=1');
        assert.equal(_this12.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=hay');
        assert.equal(_this12.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1');
        assert.equal(_this12.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?q=lol&z=1');
        assert.equal(_this12.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?q=hay');
        assert.equal(_this12.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
        assert.equal(_this12.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol&z=1');
        assert.equal(_this12.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?q=hay');
        _this12.expectedSiteModelHookParams = {
          site_id: 's-2',
          country: 'us'
        };
        _this12.expectedArticleModelHookParams = {
          article_id: 'a-2',
          q: 'lol',
          z: 1
        };

        _this12.transitionTo('site.article', 's-2', 'a-2', {
          queryParams: {
            country: 'us'
          }
        });

        assert.deepEqual(_this12.site_controller.get('model'), {
          id: 's-2'
        });
        assert.deepEqual(_this12.article_controller.get('model'), {
          id: 'a-2'
        });
        assert.equal(_this12.site_controller.get('country'), 'us');
        assert.equal(_this12.article_controller.get('q'), 'lol');
        assert.equal(_this12.article_controller.get('z'), 1);
        assert.equal(_this12.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
        assert.equal(_this12.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol&z=1');
        assert.equal(_this12.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=hay');
        assert.equal(_this12.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us');
        assert.equal(_this12.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol&z=1');
        assert.equal(_this12.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us&q=hay');
        assert.equal(_this12.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
        assert.equal(_this12.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol&z=1');
        assert.equal(_this12.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?q=hay');
        _this12.expectedSiteModelHookParams = {
          site_id: 's-2',
          country: 'us'
        };
        _this12.expectedArticleModelHookParams = {
          article_id: 'a-1',
          q: 'yeah',
          z: 0
        };

        _this12.transitionTo('site.article', 's-2', 'a-1', {
          queryParams: {
            q: 'yeah'
          }
        });

        assert.deepEqual(_this12.site_controller.get('model'), {
          id: 's-2'
        });
        assert.deepEqual(_this12.article_controller.get('model'), {
          id: 'a-1'
        });
        assert.equal(_this12.site_controller.get('country'), 'us');
        assert.equal(_this12.article_controller.get('q'), 'yeah');
        assert.equal(_this12.article_controller.get('z'), 0);
        assert.equal(_this12.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=yeah');
        assert.equal(_this12.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol&z=1');
        assert.equal(_this12.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=hay');
        assert.equal(_this12.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=yeah');
        assert.equal(_this12.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol&z=1');
        assert.equal(_this12.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us&q=hay');
        assert.equal(_this12.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=yeah');
        assert.equal(_this12.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol&z=1');
        assert.equal(_this12.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?q=hay');
        _this12.expectedSiteModelHookParams = {
          site_id: 's-3',
          country: 'nz'
        };
        _this12.expectedArticleModelHookParams = {
          article_id: 'a-3',
          q: 'hay',
          z: 3
        };

        _this12.transitionTo('site.article', 's-3', 'a-3', {
          queryParams: {
            country: 'nz',
            z: 3
          }
        });

        assert.deepEqual(_this12.site_controller.get('model'), {
          id: 's-3'
        });
        assert.deepEqual(_this12.article_controller.get('model'), {
          id: 'a-3'
        });
        assert.equal(_this12.site_controller.get('country'), 'nz');
        assert.equal(_this12.article_controller.get('q'), 'hay');
        assert.equal(_this12.article_controller.get('z'), 3);
        assert.equal(_this12.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=yeah');
        assert.equal(_this12.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol&z=1');
        assert.equal(_this12.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=hay&z=3');
        assert.equal(_this12.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=yeah');
        assert.equal(_this12.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol&z=1');
        assert.equal(_this12.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us&q=hay&z=3');
        assert.equal(_this12.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?country=nz&q=yeah');
        assert.equal(_this12.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?country=nz&q=lol&z=1');
        assert.equal(_this12.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?country=nz&q=hay&z=3');
      });
    };

    return _class3;
  }(ModelDependentQPTestCase));
});
enifed("ember/tests/routing/query_params_test/overlapping_query_params_test", ["ember-babel", "@ember/controller", "@ember/-internals/routing", "@ember/runloop", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _controller, _routing, _runloop, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Query Params - overlapping query param property names',
  /*#__PURE__*/
  function (_QueryParamTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _QueryParamTestCase);

    function _class() {
      return _QueryParamTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.setupBase = function setupBase() {
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });
      return this.visit('/parent/child');
    };

    _proto['@test can remap same-named qp props'] = function testCanRemapSameNamedQpProps(assert) {
      var _this = this;

      assert.expect(7);
      this.setMappedQPController('parent');
      this.setMappedQPController('parent.child', 'page', 'childPage');
      return this.setupBase().then(function () {
        _this.assertCurrentPath('/parent/child');

        var parentController = _this.getController('parent');

        var parentChildController = _this.getController('parent.child');

        _this.setAndFlush(parentController, 'page', 2);

        _this.assertCurrentPath('/parent/child?parentPage=2');

        _this.setAndFlush(parentController, 'page', 1);

        _this.assertCurrentPath('/parent/child');

        _this.setAndFlush(parentChildController, 'page', 2);

        _this.assertCurrentPath('/parent/child?childPage=2');

        _this.setAndFlush(parentChildController, 'page', 1);

        _this.assertCurrentPath('/parent/child');

        (0, _runloop.run)(function () {
          parentController.set('page', 2);
          parentChildController.set('page', 2);
        });

        _this.assertCurrentPath('/parent/child?childPage=2&parentPage=2');

        (0, _runloop.run)(function () {
          parentController.set('page', 1);
          parentChildController.set('page', 1);
        });

        _this.assertCurrentPath('/parent/child');
      });
    };

    _proto['@test query params can be either controller property or url key'] = function testQueryParamsCanBeEitherControllerPropertyOrUrlKey(assert) {
      var _this2 = this;

      assert.expect(3);
      this.setMappedQPController('parent');
      return this.setupBase().then(function () {
        _this2.assertCurrentPath('/parent/child');

        _this2.transitionTo('parent.child', {
          queryParams: {
            page: 2
          }
        });

        _this2.assertCurrentPath('/parent/child?parentPage=2');

        _this2.transitionTo('parent.child', {
          queryParams: {
            parentPage: 3
          }
        });

        _this2.assertCurrentPath('/parent/child?parentPage=3');
      });
    };

    _proto['@test query param matching a url key and controller property'] = function testQueryParamMatchingAUrlKeyAndControllerProperty(assert) {
      var _this3 = this;

      assert.expect(3);
      this.setMappedQPController('parent', 'page', 'parentPage');
      this.setMappedQPController('parent.child', 'index', 'page');
      return this.setupBase().then(function () {
        _this3.transitionTo('parent.child', {
          queryParams: {
            page: 2
          }
        });

        _this3.assertCurrentPath('/parent/child?parentPage=2');

        _this3.transitionTo('parent.child', {
          queryParams: {
            parentPage: 3
          }
        });

        _this3.assertCurrentPath('/parent/child?parentPage=3');

        _this3.transitionTo('parent.child', {
          queryParams: {
            index: 2,
            page: 2
          }
        });

        _this3.assertCurrentPath('/parent/child?page=2&parentPage=2');
      });
    };

    _proto['@test query param matching same property on two controllers use the urlKey higher in the chain'] = function testQueryParamMatchingSamePropertyOnTwoControllersUseTheUrlKeyHigherInTheChain(assert) {
      var _this4 = this;

      assert.expect(4);
      this.setMappedQPController('parent', 'page', 'parentPage');
      this.setMappedQPController('parent.child', 'page', 'childPage');
      return this.setupBase().then(function () {
        _this4.transitionTo('parent.child', {
          queryParams: {
            page: 2
          }
        });

        _this4.assertCurrentPath('/parent/child?parentPage=2');

        _this4.transitionTo('parent.child', {
          queryParams: {
            parentPage: 3
          }
        });

        _this4.assertCurrentPath('/parent/child?parentPage=3');

        _this4.transitionTo('parent.child', {
          queryParams: {
            childPage: 2,
            page: 2
          }
        });

        _this4.assertCurrentPath('/parent/child?childPage=2&parentPage=2');

        _this4.transitionTo('parent.child', {
          queryParams: {
            childPage: 3,
            parentPage: 4
          }
        });

        _this4.assertCurrentPath('/parent/child?childPage=3&parentPage=4');
      });
    };

    _proto['@test query params does not error when a query parameter exists for route instances that share a controller'] = function testQueryParamsDoesNotErrorWhenAQueryParameterExistsForRouteInstancesThatShareAController(assert) {
      var _this5 = this;

      assert.expect(1);

      var parentController = _controller.default.extend({
        queryParams: {
          page: 'page'
        }
      });

      this.add('controller:parent', parentController);
      this.add('route:parent.child', _routing.Route.extend({
        controllerName: 'parent'
      }));
      return this.setupBase('/parent').then(function () {
        _this5.transitionTo('parent.child', {
          queryParams: {
            page: 2
          }
        });

        _this5.assertCurrentPath('/parent/child?page=2');
      });
    };

    _proto['@test query params in the same route hierarchy with the same url key get auto-scoped'] = function testQueryParamsInTheSameRouteHierarchyWithTheSameUrlKeyGetAutoScoped(assert) {
      var _this6 = this;

      assert.expect(1);
      this.setMappedQPController('parent');
      this.setMappedQPController('parent.child');
      expectAssertion(function () {
        _this6.setupBase();
      }, "You're not allowed to have more than one controller property map to the same query param key, but both `parent:page` and `parent.child:page` map to `parentPage`. You can fix this by mapping one of the controller properties to a different query param key via the `as` config option, e.g. `page: { as: 'other-page' }`");
    };

    _proto['@test Support shared but overridable mixin pattern'] = function testSupportSharedButOverridableMixinPattern(assert) {
      var _this7 = this;

      assert.expect(7);

      var HasPage = _metal.Mixin.create({
        queryParams: 'page',
        page: 1
      });

      this.add('controller:parent', _controller.default.extend(HasPage, {
        queryParams: {
          page: 'yespage'
        }
      }));
      this.add('controller:parent.child', _controller.default.extend(HasPage));
      return this.setupBase().then(function () {
        _this7.assertCurrentPath('/parent/child');

        var parentController = _this7.getController('parent');

        var parentChildController = _this7.getController('parent.child');

        _this7.setAndFlush(parentChildController, 'page', 2);

        _this7.assertCurrentPath('/parent/child?page=2');

        assert.equal(parentController.get('page'), 1);
        assert.equal(parentChildController.get('page'), 2);

        _this7.setAndFlush(parentController, 'page', 2);

        _this7.assertCurrentPath('/parent/child?page=2&yespage=2');

        assert.equal(parentController.get('page'), 2);
        assert.equal(parentChildController.get('page'), 2);
      });
    };

    return _class;
  }(_internalTestHelpers.QueryParamTestCase));
});
enifed("ember/tests/routing/query_params_test/query_param_async_get_handler_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/runtime", "@ember/-internals/routing", "internal-test-helpers"], function (_emberBabel, _metal, _runtime, _routing, _internalTestHelpers) {
  "use strict";

  // These tests mimic what happens with lazily loaded Engines.
  (0, _internalTestHelpers.moduleFor)('Query Params - async get handler',
  /*#__PURE__*/
  function (_QueryParamTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _QueryParamTestCase);

    function _class() {
      return _QueryParamTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test can render a link to an asynchronously loaded route without fetching the route'] = function testCanRenderALinkToAnAsynchronouslyLoadedRouteWithoutFetchingTheRoute(assert) {
      var _this = this;

      assert.expect(4);
      this.router.map(function () {
        this.route('post', {
          path: '/post/:id'
        });
      });
      this.setSingleQPController('post');

      var setupAppTemplate = function () {
        _this.addTemplate('application', "\n        {{link-to 'Post' 'post' 1337 (query-params foo='bar') class='post-link is-1337'}}\n        {{link-to 'Post' 'post' 7331 (query-params foo='boo') class='post-link is-7331'}}\n        {{outlet}}\n      ");
      };

      setupAppTemplate();
      return this.visitAndAssert('/').then(function () {
        assert.equal(_this.$('.post-link.is-1337').attr('href'), '/post/1337?foo=bar', 'renders correctly with default QP value');
        assert.equal(_this.$('.post-link.is-7331').attr('href'), '/post/7331?foo=boo', 'renders correctly with non-default QP value');
        assert.deepEqual(_this.fetchedHandlers, ['application', 'index'], "only fetched the handlers for the route we're on");
      });
    };

    _proto['@test can transitionTo to an asynchronously loaded route with simple query params'] = function testCanTransitionToToAnAsynchronouslyLoadedRouteWithSimpleQueryParams(assert) {
      var _this2 = this;

      assert.expect(6);
      this.router.map(function () {
        this.route('post', {
          path: '/post/:id'
        });
        this.route('posts');
      });
      this.setSingleQPController('post');
      var postController;
      return this.visitAndAssert('/').then(function () {
        postController = _this2.getController('post');
        return _this2.transitionTo('posts').then(function () {
          _this2.assertCurrentPath('/posts');
        });
      }).then(function () {
        return _this2.transitionTo('post', 1337, {
          queryParams: {
            foo: 'boo'
          }
        }).then(function () {
          assert.equal(postController.get('foo'), 'boo', 'simple QP is correctly set on controller');

          _this2.assertCurrentPath('/post/1337?foo=boo');
        });
      }).then(function () {
        return _this2.transitionTo('post', 1337, {
          queryParams: {
            foo: 'bar'
          }
        }).then(function () {
          assert.equal(postController.get('foo'), 'bar', 'simple QP is correctly set with default value');

          _this2.assertCurrentPath('/post/1337');
        });
      });
    };

    _proto['@test can transitionTo to an asynchronously loaded route with array query params'] = function testCanTransitionToToAnAsynchronouslyLoadedRouteWithArrayQueryParams(assert) {
      var _this3 = this;

      assert.expect(5);
      this.router.map(function () {
        this.route('post', {
          path: '/post/:id'
        });
      });
      this.setSingleQPController('post', 'comments', []);
      var postController;
      return this.visitAndAssert('/').then(function () {
        postController = _this3.getController('post');
        return _this3.transitionTo('post', 1337, {
          queryParams: {
            comments: [1, 2]
          }
        }).then(function () {
          assert.deepEqual(postController.get('comments'), [1, 2], 'array QP is correctly set with default value');

          _this3.assertCurrentPath('/post/1337?comments=%5B1%2C2%5D');
        });
      }).then(function () {
        return _this3.transitionTo('post', 1338).then(function () {
          assert.deepEqual(postController.get('comments'), [], 'array QP is correctly set on controller');

          _this3.assertCurrentPath('/post/1338');
        });
      });
    };

    _proto['@test can transitionTo to an asynchronously loaded route with mapped query params'] = function testCanTransitionToToAnAsynchronouslyLoadedRouteWithMappedQueryParams(assert) {
      var _this4 = this;

      assert.expect(7);
      this.router.map(function () {
        this.route('post', {
          path: '/post/:id'
        }, function () {
          this.route('index', {
            path: '/'
          });
        });
      });
      this.setSingleQPController('post');
      this.setMappedQPController('post.index', 'comment', 'note');
      var postController;
      var postIndexController;
      return this.visitAndAssert('/').then(function () {
        postController = _this4.getController('post');
        postIndexController = _this4.getController('post.index');
        return _this4.transitionTo('post.index', 1337, {
          queryParams: {
            note: 6,
            foo: 'boo'
          }
        }).then(function () {
          assert.equal(postController.get('foo'), 'boo', 'simple QP is correctly set on controller');
          assert.equal(postIndexController.get('comment'), 6, 'mapped QP is correctly set on controller');

          _this4.assertCurrentPath('/post/1337?foo=boo&note=6');
        });
      }).then(function () {
        return _this4.transitionTo('post', 1337, {
          queryParams: {
            foo: 'bar'
          }
        }).then(function () {
          assert.equal(postController.get('foo'), 'bar', 'simple QP is correctly set with default value');
          assert.equal(postIndexController.get('comment'), 6, 'mapped QP retains value scoped to model');

          _this4.assertCurrentPath('/post/1337?note=6');
        });
      });
    };

    _proto['@test can transitionTo with a URL'] = function testCanTransitionToWithAURL(assert) {
      var _this5 = this;

      assert.expect(7);
      this.router.map(function () {
        this.route('post', {
          path: '/post/:id'
        }, function () {
          this.route('index', {
            path: '/'
          });
        });
      });
      this.setSingleQPController('post');
      this.setMappedQPController('post.index', 'comment', 'note');
      var postController;
      var postIndexController;
      return this.visitAndAssert('/').then(function () {
        postController = _this5.getController('post');
        postIndexController = _this5.getController('post.index');
        return _this5.transitionTo('/post/1337?foo=boo&note=6').then(function () {
          assert.equal(postController.get('foo'), 'boo', 'simple QP is correctly deserialized on controller');
          assert.equal(postIndexController.get('comment'), 6, 'mapped QP is correctly deserialized on controller');

          _this5.assertCurrentPath('/post/1337?foo=boo&note=6');
        });
      }).then(function () {
        return _this5.transitionTo('/post/1337?note=6').then(function () {
          assert.equal(postController.get('foo'), 'bar', 'simple QP is correctly deserialized with default value');
          assert.equal(postIndexController.get('comment'), 6, 'mapped QP retains value scoped to model');

          _this5.assertCurrentPath('/post/1337?note=6');
        });
      });
    };

    _proto["@test undefined isn't serialized or deserialized into a string"] = function testUndefinedIsnTSerializedOrDeserializedIntoAString(assert) {
      var _this6 = this;

      assert.expect(4);
      this.router.map(function () {
        this.route('example');
      });
      this.addTemplate('application', "{{link-to 'Example' 'example' (query-params foo=undefined) id='the-link'}}");
      this.setSingleQPController('example', 'foo', undefined, {
        foo: undefined
      });
      this.add('route:example', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            foo: undefined
          });
        }
      }));
      return this.visitAndAssert('/').then(function () {
        assert.equal(_this6.$('#the-link').attr('href'), '/example', 'renders without undefined qp serialized');
        return _this6.transitionTo('example', {
          queryParams: {
            foo: undefined
          }
        }).then(function () {
          _this6.assertCurrentPath('/example');
        });
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "routerOptions",
      get: function () {
        var fetchedHandlers = this.fetchedHandlers = [];
        return {
          location: 'test',
          init: function () {
            this._super.apply(this, arguments);

            this._seenHandlers = Object.create(null);
            this._handlerPromises = Object.create(null);
          },
          setupRouter: function () {
            this._super.apply(this, arguments);

            var handlerPromises = this._handlerPromises,
                seenHandlers = this._seenHandlers;
            var getRoute = this._routerMicrolib.getRoute;

            this._routerMicrolib.getRoute = function (routeName) {
              fetchedHandlers.push(routeName); // Cache the returns so we don't have more than one Promise for a
              // given handler.

              return handlerPromises[routeName] || (handlerPromises[routeName] = new _runtime.RSVP.Promise(function (resolve) {
                setTimeout(function () {
                  var handler = getRoute(routeName);
                  seenHandlers[routeName] = handler;
                  resolve(handler);
                }, 10);
              }));
            };
          },
          _getQPMeta: function (routeInfo) {
            var handler = this._seenHandlers[routeInfo.name];

            if (handler) {
              return (0, _metal.get)(handler, '_qp');
            }
          }
        };
      }
    }]);
    return _class;
  }(_internalTestHelpers.QueryParamTestCase));
});
enifed("ember/tests/routing/query_params_test/query_params_paramless_link_to_test", ["ember-babel", "@ember/controller", "internal-test-helpers"], function (_emberBabel, _controller, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Query Params - paramless link-to',
  /*#__PURE__*/
  function (_QueryParamTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _QueryParamTestCase);

    function _class() {
      return _QueryParamTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.testParamlessLinks = function testParamlessLinks(assert, routeName) {
      assert.expect(1);
      this.addTemplate(routeName, "{{link-to 'index' 'index' id='index-link'}}");
      this.add("controller:" + routeName, _controller.default.extend({
        queryParams: ['foo'],
        foo: 'wat'
      }));
      return this.visit('/?foo=YEAH').then(function () {
        assert.equal(document.getElementById('index-link').getAttribute('href'), '/?foo=YEAH');
      });
    };

    _proto["@test param-less links in an app booted with query params in the URL don't reset the query params: application"] = function testParamLessLinksInAnAppBootedWithQueryParamsInTheURLDonTResetTheQueryParamsApplication(assert) {
      return this.testParamlessLinks(assert, 'application');
    };

    _proto["@test param-less links in an app booted with query params in the URL don't reset the query params: index"] = function testParamLessLinksInAnAppBootedWithQueryParamsInTheURLDonTResetTheQueryParamsIndex(assert) {
      return this.testParamlessLinks(assert, 'index');
    };

    return _class;
  }(_internalTestHelpers.QueryParamTestCase));
});
enifed("ember/tests/routing/query_params_test/shared_state_test", ["ember-babel", "@ember/controller", "@ember/service", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _controller, _service, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Query Params - shared service state',
  /*#__PURE__*/
  function (_QueryParamTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _QueryParamTestCase);

    function _class() {
      return _QueryParamTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.boot = function boot() {
      this.setupApplication();
      return this.visitApplication();
    };

    _proto.setupApplication = function setupApplication() {
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('dashboard');
      });
      this.add('service:filters', _service.default.extend({
        shared: true
      }));
      this.add('controller:home', _controller.default.extend({
        filters: (0, _service.inject)()
      }));
      this.add('controller:dashboard', _controller.default.extend({
        filters: (0, _service.inject)(),
        queryParams: [{
          'filters.shared': 'shared'
        }]
      }));
      this.addTemplate('application', "{{link-to 'Home' 'home' }} <div> {{outlet}} </div>");
      this.addTemplate('home', "{{link-to 'Dashboard' 'dashboard' }}{{input type=\"checkbox\" id='filters-checkbox' checked=(mut filters.shared) }}");
      this.addTemplate('dashboard', "{{link-to 'Home' 'home' }}");
    };

    _proto.visitApplication = function visitApplication() {
      return this.visit('/');
    };

    _proto['@test can modify shared state before transition'] = function testCanModifySharedStateBeforeTransition(assert) {
      var _this = this;

      assert.expect(1);
      return this.boot().then(function () {
        _this.$input = document.getElementById('filters-checkbox'); // click the checkbox once to set filters.shared to false

        (0, _runloop.run)(_this.$input, 'click');
        return _this.visit('/dashboard').then(function () {
          assert.ok(true, 'expecting navigating to dashboard to succeed');
        });
      });
    };

    _proto['@test can modify shared state back to the default value before transition'] = function testCanModifySharedStateBackToTheDefaultValueBeforeTransition(assert) {
      var _this2 = this;

      assert.expect(1);
      return this.boot().then(function () {
        _this2.$input = document.getElementById('filters-checkbox'); // click the checkbox twice to set filters.shared to false and back to true

        (0, _runloop.run)(_this2.$input, 'click');
        (0, _runloop.run)(_this2.$input, 'click');
        return _this2.visit('/dashboard').then(function () {
          assert.ok(true, 'expecting navigating to dashboard to succeed');
        });
      });
    };

    return _class;
  }(_internalTestHelpers.QueryParamTestCase));
});
enifed("ember/tests/routing/router_map_test", ["ember-babel", "internal-test-helpers", "@ember/runloop", "@ember/-internals/routing"], function (_emberBabel, _internalTestHelpers, _runloop, _routing) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router.map',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Router.map returns an Ember Router class'] = function testRouterMapReturnsAnEmberRouterClass(assert) {
      assert.expect(1);
      var ret = this.router.map(function () {
        this.route('hello');
      });
      assert.ok(_routing.Router.detect(ret));
    };

    _proto['@test Router.map can be called multiple times'] = function testRouterMapCanBeCalledMultipleTimes(assert) {
      var _this = this;

      assert.expect(2);
      this.addTemplate('hello', 'Hello!');
      this.addTemplate('goodbye', 'Goodbye!');
      this.router.map(function () {
        this.route('hello');
      });
      this.router.map(function () {
        this.route('goodbye');
      });
      return (0, _runloop.run)(function () {
        return _this.visit('/hello').then(function () {
          _this.assertText('Hello!');
        }).then(function () {
          return _this.visit('/goodbye');
        }).then(function () {
          _this.assertText('Goodbye!');
        });
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/routing/router_service_test/basic_test", ["ember-babel", "@ember/-internals/routing", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _routing, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router Service - main',
  /*#__PURE__*/
  function (_RouterTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

    function _class() {
      return _RouterTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test RouterService#currentRouteName is correctly set for top level route'] = function testRouterServiceCurrentRouteNameIsCorrectlySetForTopLevelRoute(assert) {
      var _this = this;

      if (true
      /* EMBER_ROUTING_ROUTER_SERVICE */
      ) {
          assert.expect(6);
        } else {
        assert.expect(1);
      }

      return this.visit('/').then(function () {
        if (true
        /* EMBER_ROUTING_ROUTER_SERVICE */
        ) {
            var currentRoute = _this.routerService.currentRoute;
            var name = currentRoute.name,
                localName = currentRoute.localName,
                params = currentRoute.params,
                paramNames = currentRoute.paramNames,
                queryParams = currentRoute.queryParams;
            assert.equal(name, 'parent.index');
            assert.equal(localName, 'index');
            assert.deepEqual(params, {});
            assert.deepEqual(queryParams, {});
            assert.deepEqual(paramNames, []);
          }

        assert.equal(_this.routerService.get('currentRouteName'), 'parent.index');
      });
    };

    _proto['@test RouterService#currentRouteName is correctly set for child route'] = function testRouterServiceCurrentRouteNameIsCorrectlySetForChildRoute(assert) {
      var _this2 = this;

      if (true
      /* EMBER_ROUTING_ROUTER_SERVICE */
      ) {
          assert.expect(6);
        } else {
        assert.expect(1);
      }

      return this.visit('/child').then(function () {
        if (true
        /* EMBER_ROUTING_ROUTER_SERVICE */
        ) {
            var currentRoute = _this2.routerService.currentRoute;
            var name = currentRoute.name,
                localName = currentRoute.localName,
                params = currentRoute.params,
                paramNames = currentRoute.paramNames,
                queryParams = currentRoute.queryParams;
            assert.equal(name, 'parent.child');
            assert.equal(localName, 'child');
            assert.deepEqual(params, {});
            assert.deepEqual(queryParams, {});
            assert.deepEqual(paramNames, []);
          }

        assert.equal(_this2.routerService.get('currentRouteName'), 'parent.child');
      });
    };

    _proto['@test RouterService#currentRouteName is correctly set after transition'] = function testRouterServiceCurrentRouteNameIsCorrectlySetAfterTransition(assert) {
      var _this3 = this;

      if (true
      /* EMBER_ROUTING_ROUTER_SERVICE */
      ) {
          assert.expect(5);
        } else {
        assert.expect(1);
      }

      return this.visit('/child').then(function () {
        if (true
        /* EMBER_ROUTING_ROUTER_SERVICE */
        ) {
            var currentRoute = _this3.routerService.currentRoute;
            var name = currentRoute.name,
                localName = currentRoute.localName;
            assert.equal(name, 'parent.child');
            assert.equal(localName, 'child');
          }

        return _this3.routerService.transitionTo('parent.sister');
      }).then(function () {
        if (true
        /* EMBER_ROUTING_ROUTER_SERVICE */
        ) {
            var currentRoute = _this3.routerService.currentRoute;
            var name = currentRoute.name,
                localName = currentRoute.localName;
            assert.equal(name, 'parent.sister');
            assert.equal(localName, 'sister');
          }

        assert.equal(_this3.routerService.get('currentRouteName'), 'parent.sister');
      });
    };

    _proto['@test substates survive aborts GH#17430'] = function testSubstatesSurviveAbortsGH17430(assert) {
      var _this4 = this;

      assert.expect(2);
      this.add("route:parent.child", _routing.Route.extend({
        beforeModel: function (transition) {
          transition.abort();
          this.intermediateTransitionTo('parent.sister');
        }
      }));
      return this.visit('/').then(function () {
        return _this4.routerService.transitionTo('/child');
      }).catch(function (e) {
        assert.equal(_this4.routerService.currentRouteName, 'parent.sister');
        assert.equal(e.message, 'TransitionAborted');
      });
    };

    _proto['@test RouterService#currentRouteName is correctly set on each transition'] = function testRouterServiceCurrentRouteNameIsCorrectlySetOnEachTransition(assert) {
      var _this5 = this;

      if (true
      /* EMBER_ROUTING_ROUTER_SERVICE */
      ) {
          assert.expect(9);
        } else {
        assert.expect(3);
      }

      return this.visit('/child').then(function () {
        if (true
        /* EMBER_ROUTING_ROUTER_SERVICE */
        ) {
            var currentRoute = _this5.routerService.currentRoute;
            var name = currentRoute.name,
                localName = currentRoute.localName;
            assert.equal(name, 'parent.child');
            assert.equal(localName, 'child');
          }

        assert.equal(_this5.routerService.get('currentRouteName'), 'parent.child');
        return _this5.visit('/sister');
      }).then(function () {
        if (true
        /* EMBER_ROUTING_ROUTER_SERVICE */
        ) {
            var currentRoute = _this5.routerService.currentRoute;
            var name = currentRoute.name,
                localName = currentRoute.localName;
            assert.equal(name, 'parent.sister');
            assert.equal(localName, 'sister');
          }

        assert.equal(_this5.routerService.get('currentRouteName'), 'parent.sister');
        return _this5.visit('/brother');
      }).then(function () {
        if (true
        /* EMBER_ROUTING_ROUTER_SERVICE */
        ) {
            var currentRoute = _this5.routerService.currentRoute;
            var name = currentRoute.name,
                localName = currentRoute.localName;
            assert.equal(name, 'parent.brother');
            assert.equal(localName, 'brother');
          }

        assert.equal(_this5.routerService.get('currentRouteName'), 'parent.brother');
      });
    };

    _proto['@test RouterService#rootURL is correctly set to the default value'] = function testRouterServiceRootURLIsCorrectlySetToTheDefaultValue(assert) {
      var _this6 = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        assert.equal(_this6.routerService.get('rootURL'), '/');
      });
    };

    _proto['@test RouterService#rootURL is correctly set to a custom value'] = function testRouterServiceRootURLIsCorrectlySetToACustomValue(assert) {
      var _this7 = this;

      assert.expect(1);
      this.add('route:parent.index', _routing.Route.extend({
        init: function () {
          this._super();

          (0, _metal.set)(this._router, 'rootURL', '/homepage');
        }
      }));
      return this.visit('/').then(function () {
        assert.equal(_this7.routerService.get('rootURL'), '/homepage');
      });
    };

    _proto['@test RouterService#location is correctly delegated from router:main'] = function testRouterServiceLocationIsCorrectlyDelegatedFromRouterMain(assert) {
      var _this8 = this;

      assert.expect(2);
      return this.visit('/').then(function () {
        var location = _this8.routerService.get('location');

        assert.ok(location);
        assert.ok(location instanceof _routing.NoneLocation);
      });
    };

    return _class;
  }(_internalTestHelpers.RouterTestCase));
});
enifed("ember/tests/routing/router_service_test/build_routeinfo_metadata_test", ["ember-babel", "internal-test-helpers", "@ember/service", "@ember/-internals/routing"], function (_emberBabel, _internalTestHelpers, _service, _routing) {
  "use strict";

  if (false
  /* EMBER_ROUTING_BUILD_ROUTEINFO_METADATA */
  && true
  /* EMBER_ROUTING_ROUTER_SERVICE */
  ) {
      (0, _internalTestHelpers.moduleFor)('buildRouteInfoMetadata',
      /*#__PURE__*/
      function (_RouterTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

        function _class() {
          return _RouterTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto['@test basic metadata'] = function testBasicMetadata(assert) {
          assert.expect(4);
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                assert.equal(transition.to.name, 'parent.index');
                assert.equal(transition.to.metadata, 'parent-index-page');
              });
              this.router.on('routeDidChange', function (transition) {
                assert.equal(transition.to.name, 'parent.index');
                assert.equal(transition.to.metadata, 'parent-index-page');
              });
            }
          }));
          this.add("route:parent.index", _routing.Route.extend({
            buildRouteInfoMetadata: function () {
              return 'parent-index-page';
            }
          }));
          return this.visit('/');
        };

        _proto['@test hierarchical metadata'] = function testHierarchicalMetadata(assert) {
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            buildRouteInfoMetadata: function () {
              return 'application-shell';
            },
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                assert.equal(transition.to.name, 'parent.index');
                assert.equal(transition.to.metadata, 'parent-index-page');
                assert.equal(transition.to.parent.name, 'parent');
                assert.equal(transition.to.parent.metadata, 'parent-page');
                assert.equal(transition.to.parent.parent.name, 'application');
                assert.equal(transition.to.parent.parent.metadata, 'application-shell');
              });
              this.router.on('routeDidChange', function (transition) {
                assert.equal(transition.to.name, 'parent.index');
                assert.equal(transition.to.metadata, 'parent-index-page');
                assert.equal(transition.to.parent.name, 'parent');
                assert.equal(transition.to.parent.metadata, 'parent-page');
                assert.equal(transition.to.parent.parent.name, 'application');
                assert.equal(transition.to.parent.parent.metadata, 'application-shell');
              });
            }
          }));
          this.add("route:parent", _routing.Route.extend({
            buildRouteInfoMetadata: function () {
              return 'parent-page';
            }
          }));
          this.add("route:parent.index", _routing.Route.extend({
            buildRouteInfoMetadata: function () {
              return 'parent-index-page';
            }
          }));
          return this.visit('/');
        };

        _proto['@test metadata can be complex objects'] = function testMetadataCanBeComplexObjects(assert) {
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                assert.equal(transition.to.name, 'parent.index');
                assert.equal(transition.to.metadata.name, 'parent-index-page');
                assert.equal(transition.to.metadata.title('PARENT'), 'My Name is PARENT');
              });
              this.router.on('routeDidChange', function (transition) {
                assert.equal(transition.to.name, 'parent.index');
                assert.equal(transition.to.metadata.name, 'parent-index-page');
                assert.equal(transition.to.metadata.title('PARENT'), 'My Name is PARENT');
              });
            }
          }));
          this.add("route:parent", _routing.Route.extend({}));
          this.add("route:parent.index", _routing.Route.extend({
            buildRouteInfoMetadata: function () {
              return {
                name: 'parent-index-page',
                title: function (name) {
                  return "My Name is " + name;
                }
              };
            }
          }));
          return this.visit('/');
        };

        _proto['@test metadata is placed on the `from`'] = function testMetadataIsPlacedOnTheFrom(assert) {
          var _this = this;

          assert.expect(12);
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                if (transition.to.name === 'parent.index') {
                  assert.equal(transition.to.metadata.name, 'parent-index-page');
                  assert.equal(transition.to.metadata.title('INDEX'), 'My Name is INDEX');
                } else {
                  assert.equal(transition.from.metadata.name, 'parent-index-page');
                  assert.equal(transition.from.metadata.title('INDEX'), 'My Name is INDEX');
                  assert.equal(transition.to.metadata.name, 'parent-child-page');
                  assert.equal(transition.to.metadata.title('CHILD'), 'My Name is CHILD!!');
                }
              });
              this.router.on('routeDidChange', function (transition) {
                if (transition.to.name === 'parent.index') {
                  assert.equal(transition.to.metadata.name, 'parent-index-page');
                  assert.equal(transition.to.metadata.title('INDEX'), 'My Name is INDEX');
                } else {
                  assert.equal(transition.from.metadata.name, 'parent-index-page');
                  assert.equal(transition.from.metadata.title('INDEX'), 'My Name is INDEX');
                  assert.equal(transition.to.metadata.name, 'parent-child-page');
                  assert.equal(transition.to.metadata.title('CHILD'), 'My Name is CHILD!!');
                }
              });
            }
          }));
          this.add("route:parent", _routing.Route.extend({}));
          this.add("route:parent.index", _routing.Route.extend({
            buildRouteInfoMetadata: function () {
              return {
                name: 'parent-index-page',
                title: function (name) {
                  return "My Name is " + name;
                }
              };
            }
          }));
          this.add("route:parent.child", _routing.Route.extend({
            buildRouteInfoMetadata: function () {
              return {
                name: 'parent-child-page',
                title: function (name) {
                  return "My Name is " + name + "!!";
                }
              };
            }
          }));
          return this.visit('/').then(function () {
            return _this.visit('/child');
          });
        };

        _proto['@test can be used with model data from `attributes`'] = function testCanBeUsedWithModelDataFromAttributes(assert) {
          var _this2 = this;

          assert.expect(6);
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeDidChange', function (transition) {
                if (transition.to.name === 'parent.index') {
                  assert.equal(transition.to.metadata.name, 'parent-index-page');
                  assert.equal(transition.to.metadata.title(transition.to.attributes), 'My Name is INDEX');
                } else {
                  assert.equal(transition.from.metadata.name, 'parent-index-page');
                  assert.equal(transition.from.metadata.title(transition.from.attributes), 'My Name is INDEX');
                  assert.equal(transition.to.metadata.name, 'parent-child-page');
                  assert.equal(transition.to.metadata.title(transition.to.attributes), 'My Name is CHILD!!');
                }
              });
            }
          }));
          this.add("route:parent", _routing.Route.extend({}));
          this.add("route:parent.index", _routing.Route.extend({
            model: function () {
              return {
                name: 'INDEX'
              };
            },
            buildRouteInfoMetadata: function () {
              return {
                name: 'parent-index-page',
                title: function (model) {
                  return "My Name is " + model.name;
                }
              };
            }
          }));
          this.add("route:parent.child", _routing.Route.extend({
            model: function () {
              return {
                name: 'CHILD'
              };
            },
            buildRouteInfoMetadata: function () {
              return {
                name: 'parent-child-page',
                title: function (model) {
                  return "My Name is " + model.name + "!!";
                }
              };
            }
          }));
          return this.visit('/').then(function () {
            return _this2.visit('/child');
          });
        };

        return _class;
      }(_internalTestHelpers.RouterTestCase));
    }
});
enifed("ember/tests/routing/router_service_test/currenturl_lifecycle_test", ["ember-babel", "@ember/service", "@ember/object/computed", "@ember/-internals/glimmer", "@ember/-internals/routing", "@ember/-internals/metal", "internal-test-helpers", "@ember/-internals/runtime"], function (_emberBabel, _service, _computed, _glimmer, _routing, _metal, _internalTestHelpers, _runtime) {
  "use strict";

  var results = [];
  var ROUTE_NAMES = ['index', 'child', 'sister', 'brother', 'loading'];

  var InstrumentedRoute = _routing.Route.extend({
    routerService: (0, _service.inject)('router'),
    beforeModel: function () {
      var service = (0, _metal.get)(this, 'routerService');
      results.push([service.get('currentRouteName'), 'beforeModel', service.get('currentURL')]);
    },
    model: function () {
      var service = (0, _metal.get)(this, 'routerService');
      results.push([service.get('currentRouteName'), 'model', service.get('currentURL')]);
      return new _runtime.RSVP.Promise(function (resolve) {
        setTimeout(resolve, 200);
      });
    },
    afterModel: function () {
      var service = (0, _metal.get)(this, 'routerService');
      results.push([service.get('currentRouteName'), 'afterModel', service.get('currentURL')]);
    }
  });

  (0, _internalTestHelpers.moduleFor)('Router Service - currentURL | currentRouteName',
  /*#__PURE__*/
  function (_RouterTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

    function _class() {
      var _this;

      _this = _RouterTestCase.apply(this, arguments) || this;
      results = [];
      ROUTE_NAMES.forEach(function (name) {
        var routeName = "parent." + name;

        _this.add("route:" + routeName, InstrumentedRoute.extend());

        _this.addTemplate(routeName, '{{current-url}}');
      });

      var CurrenURLComponent = _glimmer.Component.extend({
        routerService: (0, _service.inject)('router'),
        currentURL: (0, _computed.readOnly)('routerService.currentURL'),
        currentRouteName: (0, _computed.readOnly)('routerService.currentRouteName')
      });

      if (true
      /* EMBER_ROUTING_ROUTER_SERVICE */
      ) {
          CurrenURLComponent.reopen({
            currentRoute: (0, _computed.readOnly)('routerService.currentRoute')
          });
        }

      _this.addComponent('current-url', {
        ComponentClass: CurrenURLComponent,
        template: true
        /* EMBER_ROUTING_ROUTER_SERVICE */
        ? '{{currentURL}}-{{currentRouteName}}-{{currentRoute.name}}' : '{{currentURL}}-{{currentRouteName}}'
      });

      return _this;
    }

    var _proto = _class.prototype;

    _proto['@test RouterService#currentURL is correctly set for top level route'] = function testRouterServiceCurrentURLIsCorrectlySetForTopLevelRoute(assert) {
      var _this2 = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        assert.equal(_this2.routerService.get('currentURL'), '/');
      });
    };

    _proto['@test RouterService#currentURL is correctly set for child route'] = function testRouterServiceCurrentURLIsCorrectlySetForChildRoute(assert) {
      var _this3 = this;

      assert.expect(1);
      return this.visit('/child').then(function () {
        assert.equal(_this3.routerService.get('currentURL'), '/child');
      });
    };

    _proto['@test RouterService#currentURL is correctly set after transition'] = function testRouterServiceCurrentURLIsCorrectlySetAfterTransition(assert) {
      var _this4 = this;

      assert.expect(1);
      return this.visit('/child').then(function () {
        return _this4.routerService.transitionTo('parent.sister');
      }).then(function () {
        assert.equal(_this4.routerService.get('currentURL'), '/sister');
      });
    };

    _proto['@test RouterService#currentURL is correctly set on each transition'] = function testRouterServiceCurrentURLIsCorrectlySetOnEachTransition(assert) {
      var _this5 = this;

      assert.expect(3);
      return this.visit('/child').then(function () {
        assert.equal(_this5.routerService.get('currentURL'), '/child');
        return _this5.visit('/sister');
      }).then(function () {
        assert.equal(_this5.routerService.get('currentURL'), '/sister');
        return _this5.visit('/brother');
      }).then(function () {
        assert.equal(_this5.routerService.get('currentURL'), '/brother');
      });
    };

    _proto['@test RouterService#currentURL is not set during lifecycle hooks'] = function testRouterServiceCurrentURLIsNotSetDuringLifecycleHooks(assert) {
      var _this6 = this;

      assert.expect(2);
      return this.visit('/').then(function () {
        assert.deepEqual(results, [[null, 'beforeModel', null], [null, 'model', null], ['parent.loading', 'afterModel', '/']]);
        results = [];
        return _this6.visit('/child');
      }).then(function () {
        assert.deepEqual(results, [['parent.index', 'beforeModel', '/'], ['parent.index', 'model', '/'], ['parent.loading', 'afterModel', '/child']]);
      });
    };

    _proto['@test RouterService#currentURL is correctly set with component after consecutive visits'] = function testRouterServiceCurrentURLIsCorrectlySetWithComponentAfterConsecutiveVisits(assert) {
      var _this7 = this;

      assert.expect(3);
      return this.visit('/').then(function () {
        var text = '/-parent.index';

        if (true
        /* EMBER_ROUTING_ROUTER_SERVICE */
        ) {
            text = '/-parent.index-parent.index';
          }

        _this7.assertText(text);

        return _this7.visit('/child');
      }).then(function () {
        var text = '/child-parent.child';

        if (true
        /* EMBER_ROUTING_ROUTER_SERVICE */
        ) {
            text = '/child-parent.child-parent.child';
          }

        _this7.assertText(text);

        return _this7.visit('/');
      }).then(function () {
        var text = '/-parent.index';

        if (true
        /* EMBER_ROUTING_ROUTER_SERVICE */
        ) {
            text = '/-parent.index-parent.index';
          }

        _this7.assertText(text);
      });
    };

    return _class;
  }(_internalTestHelpers.RouterTestCase));
});
enifed("ember/tests/routing/router_service_test/events_test", ["ember-babel", "internal-test-helpers", "@ember/service", "@ember/-internals/routing", "@ember/runloop"], function (_emberBabel, _internalTestHelpers, _service, _routing, _runloop) {
  "use strict";

  if (true
  /* EMBER_ROUTING_ROUTER_SERVICE */
  ) {
      (0, _internalTestHelpers.moduleFor)('Router Service - events',
      /*#__PURE__*/
      function (_RouterTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

        function _class() {
          return _RouterTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto['@test initial render'] = function testInitialRender(assert) {
          assert.expect(12);
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              var _this = this;

              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                assert.ok(transition);
                assert.equal(transition.from, undefined);
                assert.equal(transition.to.name, 'parent.index');
                assert.equal(transition.to.localName, 'index');
              });
              this.router.on('routeDidChange', function (transition) {
                assert.ok(transition);
                assert.ok(_this.router.currentURL, "has URL " + _this.router.currentURL);
                assert.equal(_this.router.currentURL, '/');
                assert.ok(_this.router.currentRouteName, "has route name " + _this.router.currentRouteName);
                assert.equal(_this.router.currentRouteName, 'parent.index');
                assert.equal(transition.from, undefined);
                assert.equal(transition.to.name, 'parent.index');
                assert.equal(transition.to.localName, 'index');
              });
            }
          }));
          return this.visit('/');
        };

        _proto['@test subsequent visits'] = function testSubsequentVisits(assert) {
          var _this3 = this;

          assert.expect(24);
          var toParent = true;
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              var _this2 = this;

              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                if (toParent) {
                  assert.equal(_this2.router.currentURL, null, 'starts as null');
                  assert.equal(transition.from, undefined);
                  assert.equal(transition.to.name, 'parent.child');
                  assert.equal(transition.to.localName, 'child');
                  assert.equal(transition.to.parent.name, 'parent', 'parent node');
                  assert.equal(transition.to.parent.child, transition.to, 'parents child node is the `to`');
                  assert.equal(transition.to.parent.parent.name, 'application', 'top level');
                  assert.equal(transition.to.parent.parent.parent, null, 'top level');
                } else {
                  assert.equal(_this2.router.currentURL, '/child', 'not changed until transition');
                  assert.notEqual(transition.from, undefined);
                  assert.equal(transition.from.name, 'parent.child');
                  assert.equal(transition.from.localName, 'child');
                  assert.equal(transition.to.localName, 'sister');
                  assert.equal(transition.to.name, 'parent.sister');
                }
              });
              this.router.on('routeDidChange', function (transition) {
                if (toParent) {
                  assert.equal(_this2.router.currentURL, '/child');
                  assert.equal(transition.from, undefined);
                  assert.equal(transition.to.name, 'parent.child');
                  assert.equal(transition.to.localName, 'child');
                } else {
                  assert.equal(_this2.router.currentURL, '/sister');
                  assert.notEqual(transition.from, undefined);
                  assert.equal(transition.from.name, 'parent.child');
                  assert.equal(transition.from.localName, 'child');
                  assert.equal(transition.to.localName, 'sister');
                  assert.equal(transition.to.name, 'parent.sister');
                }
              });
            }
          }));
          return this.visit('/child').then(function () {
            toParent = false;
            return _this3.routerService.transitionTo('parent.sister');
          });
        };

        _proto['@test transitions can be retried async'] = function testTransitionsCanBeRetriedAsync(assert) {
          var _this4 = this;

          var done = assert.async();
          this.add("route:parent.child", _routing.Route.extend({
            actions: {
              willTransition: function (transition) {
                transition.abort();
                this.intermediateTransitionTo('parent.sister');
                (0, _runloop.later)(function () {
                  transition.retry();
                  done();
                }, 500);
              }
            }
          }));
          return this.visit('/child').then(function () {
            return _this4.visit('/');
          }).catch(function (e) {
            assert.equal(e.message, 'TransitionAborted');
          });
        };

        _proto['@test redirection with `transitionTo`'] = function testRedirectionWithTransitionTo(assert) {
          assert.expect(8);
          var toChild = false;
          var toSister = false;
          this.add("route:parent", _routing.Route.extend({
            model: function () {
              this.transitionTo('parent.child');
            }
          }));
          this.add("route:parent.child", _routing.Route.extend({
            model: function () {
              this.transitionTo('parent.sister');
            }
          }));
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                assert.equal(transition.from, undefined, 'initial');

                if (toChild) {
                  if (toSister) {
                    assert.equal(transition.to.name, 'parent.sister', 'going to /sister');
                  } else {
                    assert.equal(transition.to.name, 'parent.child', 'going to /child');
                    toSister = true;
                  }
                } else {
                  // Going to `/`
                  assert.equal(transition.to.name, 'parent.index', 'going to /');
                  toChild = true;
                }
              });
              this.router.on('routeDidChange', function (transition) {
                assert.equal(transition.from, undefined, 'initial');
                assert.equal(transition.to.name, 'parent.sister', 'landed on /sister');
              });
            }
          }));
          return this.visit('/');
        };

        _proto['@test redirection with `replaceWith`'] = function testRedirectionWithReplaceWith(assert) {
          assert.expect(8);
          var toChild = false;
          var toSister = false;
          this.add("route:parent", _routing.Route.extend({
            model: function () {
              this.replaceWith('parent.child');
            }
          }));
          this.add("route:parent.child", _routing.Route.extend({
            model: function () {
              this.replaceWith('parent.sister');
            }
          }));
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                assert.equal(transition.from, undefined, 'initial');

                if (toChild) {
                  if (toSister) {
                    assert.equal(transition.to.name, 'parent.sister', 'going to /sister');
                  } else {
                    assert.equal(transition.to.name, 'parent.child', 'going to /child');
                    toSister = true;
                  }
                } else {
                  // Going to `/`
                  assert.equal(transition.to.name, 'parent.index', 'going to /');
                  toChild = true;
                }
              });
              this.router.on('routeDidChange', function (transition) {
                assert.equal(transition.from, undefined, 'initial');
                assert.equal(transition.to.name, 'parent.sister', 'landed on /sister');
              });
            }
          }));
          return this.visit('/');
        };

        _proto['@test nested redirection with `transitionTo`'] = function testNestedRedirectionWithTransitionTo(assert) {
          var _this5 = this;

          assert.expect(11);
          var toChild = false;
          var toSister = false;
          this.add("route:parent.child", _routing.Route.extend({
            model: function () {
              this.transitionTo('parent.sister');
            }
          }));
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                if (toChild) {
                  assert.equal(transition.from.name, 'parent.index');

                  if (toSister) {
                    assert.equal(transition.to.name, 'parent.sister', 'going to /sister');
                  } else {
                    assert.equal(transition.to.name, 'parent.child', 'going to /child');
                    toSister = true;
                  }
                } else {
                  // Going to `/`
                  assert.equal(transition.to.name, 'parent.index', 'going to /');
                  assert.equal(transition.from, undefined, 'initial');
                }
              });
              this.router.on('routeDidChange', function (transition) {
                if (toSister) {
                  assert.equal(transition.from.name, 'parent.index', 'initial');
                  assert.equal(transition.to.name, 'parent.sister', 'landed on /sister');
                } else {
                  assert.equal(transition.from, undefined, 'initial');
                  assert.equal(transition.to.name, 'parent.index', 'landed on /');
                }
              });
            }
          }));
          return this.visit('/').then(function () {
            toChild = true;
            return _this5.routerService.transitionTo('/child').catch(function (e) {
              assert.equal(e.name, 'TransitionAborted', 'Transition aborted');
            });
          });
        };

        _proto['@test nested redirection with `replaceWith`'] = function testNestedRedirectionWithReplaceWith(assert) {
          var _this6 = this;

          assert.expect(11);
          var toChild = false;
          var toSister = false;
          this.add("route:parent.child", _routing.Route.extend({
            model: function () {
              this.replaceWith('parent.sister');
            }
          }));
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                if (toChild) {
                  assert.equal(transition.from.name, 'parent.index');

                  if (toSister) {
                    assert.equal(transition.to.name, 'parent.sister', 'going to /sister');
                  } else {
                    assert.equal(transition.to.name, 'parent.child', 'going to /child');
                    toSister = true;
                  }
                } else {
                  // Going to `/`
                  assert.equal(transition.to.name, 'parent.index', 'going to /');
                  assert.equal(transition.from, undefined, 'initial');
                }
              });
              this.router.on('routeDidChange', function (transition) {
                if (toSister) {
                  assert.equal(transition.from.name, 'parent.index', 'initial');
                  assert.equal(transition.to.name, 'parent.sister', 'landed on /sister');
                } else {
                  assert.equal(transition.from, undefined, 'initial');
                  assert.equal(transition.to.name, 'parent.index', 'landed on /');
                }
              });
            }
          }));
          return this.visit('/').then(function () {
            toChild = true;
            return _this6.routerService.transitionTo('/child').catch(function (e) {
              assert.equal(e.name, 'TransitionAborted', 'Transition aborted');
            });
          });
        };

        _proto['@test aborted transition'] = function testAbortedTransition(assert) {
          var _this7 = this;

          assert.expect(11);
          var didAbort = false;
          var toChild = false;
          this.add("route:parent.child", _routing.Route.extend({
            model: function (_model, transition) {
              didAbort = true;
              transition.abort();
            }
          }));
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                if (didAbort) {
                  assert.equal(transition.to.name, 'parent.index', 'transition aborted');
                  assert.equal(transition.from.name, 'parent.index', 'transition aborted');
                } else if (toChild) {
                  assert.equal(transition.from.name, 'parent.index', 'from /');
                  assert.equal(transition.to.name, 'parent.child', 'to /child');
                } else {
                  assert.equal(transition.to.name, 'parent.index', 'going to /');
                  assert.equal(transition.from, undefined, 'initial');
                }
              });
              this.router.on('routeDidChange', function (transition) {
                if (didAbort) {
                  assert.equal(transition.to.name, 'parent.index', 'landed on /');
                  assert.equal(transition.from.name, 'parent.index', 'initial');
                } else {
                  assert.equal(transition.to.name, 'parent.index', 'transition aborted');
                  assert.equal(transition.from, undefined, 'transition aborted');
                }
              });
            }
          }));
          return this.visit('/').then(function () {
            toChild = true;
            return _this7.routerService.transitionTo('/child').catch(function (e) {
              assert.equal(e.name, 'TransitionAborted', 'Transition aborted');
            });
          });
        };

        _proto['@test query param transitions'] = function testQueryParamTransitions(assert) {
          var _this8 = this;

          assert.expect(15);
          var initial = true;
          var addQP = false;
          var removeQP = false;
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                assert.equal(transition.to.name, 'parent.index');

                if (initial) {
                  assert.equal(transition.from, null);
                  assert.deepEqual(transition.to.queryParams, {
                    a: 'true'
                  });
                } else if (addQP) {
                  assert.deepEqual(transition.from.queryParams, {
                    a: 'true'
                  });
                  assert.deepEqual(transition.to.queryParams, {
                    a: 'false',
                    b: 'b'
                  });
                } else if (removeQP) {
                  assert.deepEqual(transition.from.queryParams, {
                    a: 'false',
                    b: 'b'
                  });
                  assert.deepEqual(transition.to.queryParams, {
                    a: 'false'
                  });
                } else {
                  assert.ok(false, 'never');
                }
              });
              this.router.on('routeDidChange', function (transition) {
                if (initial) {
                  assert.equal(transition.from, null);
                  assert.deepEqual(transition.to.queryParams, {
                    a: 'true'
                  });
                } else if (addQP) {
                  assert.deepEqual(transition.from.queryParams, {
                    a: 'true'
                  });
                  assert.deepEqual(transition.to.queryParams, {
                    a: 'false',
                    b: 'b'
                  });
                } else if (removeQP) {
                  assert.deepEqual(transition.from.queryParams, {
                    a: 'false',
                    b: 'b'
                  });
                  assert.deepEqual(transition.to.queryParams, {
                    a: 'false'
                  });
                } else {
                  assert.ok(false, 'never');
                }
              });
            }
          }));
          return this.visit('/?a=true').then(function () {
            addQP = true;
            initial = false;
            return _this8.routerService.transitionTo('/?a=false&b=b');
          }).then(function () {
            removeQP = true;
            addQP = false;
            return _this8.routerService.transitionTo('/?a=false');
          });
        };

        _proto['@test query param redirects with `transitionTo`'] = function testQueryParamRedirectsWithTransitionTo(assert) {
          assert.expect(6);
          var toSister = false;
          this.add("route:parent.child", _routing.Route.extend({
            model: function () {
              toSister = true;
              this.transitionTo('/sister?a=a');
            }
          }));
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                if (toSister) {
                  assert.equal(transition.to.name, 'parent.sister');
                  assert.deepEqual(transition.to.queryParams, {
                    a: 'a'
                  });
                } else {
                  assert.equal(transition.to.name, 'parent.child');
                  assert.deepEqual(transition.to.queryParams, {});
                }
              });
              this.router.on('routeDidChange', function (transition) {
                assert.equal(transition.to.name, 'parent.sister');
                assert.deepEqual(transition.to.queryParams, {
                  a: 'a'
                });
              });
            }
          }));
          return this.visit('/child');
        };

        _proto['@test query param redirects with `replaceWith`'] = function testQueryParamRedirectsWithReplaceWith(assert) {
          assert.expect(6);
          var toSister = false;
          this.add("route:parent.child", _routing.Route.extend({
            model: function () {
              toSister = true;
              this.replaceWith('/sister?a=a');
            }
          }));
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                if (toSister) {
                  assert.equal(transition.to.name, 'parent.sister');
                  assert.deepEqual(transition.to.queryParams, {
                    a: 'a'
                  });
                } else {
                  assert.equal(transition.to.name, 'parent.child');
                  assert.deepEqual(transition.to.queryParams, {});
                }
              });
              this.router.on('routeDidChange', function (transition) {
                assert.equal(transition.to.name, 'parent.sister');
                assert.deepEqual(transition.to.queryParams, {
                  a: 'a'
                });
              });
            }
          }));
          return this.visit('/child');
        };

        _proto['@test params'] = function testParams(assert) {
          var _this9 = this;

          assert.expect(14);
          var inital = true;
          this.add('route:dynamic', _routing.Route.extend({
            model: function (params) {
              if (inital) {
                assert.deepEqual(params, {
                  dynamic_id: '123'
                });
              } else {
                assert.deepEqual(params, {
                  dynamic_id: '1'
                });
              }

              return params;
            }
          }));
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                assert.equal(transition.to.name, 'dynamic');

                if (inital) {
                  assert.deepEqual(transition.to.paramNames, ['dynamic_id']);
                  assert.deepEqual(transition.to.params, {
                    dynamic_id: '123'
                  });
                } else {
                  assert.deepEqual(transition.to.paramNames, ['dynamic_id']);
                  assert.deepEqual(transition.to.params, {
                    dynamic_id: '1'
                  });
                }
              });
              this.router.on('routeDidChange', function (transition) {
                assert.equal(transition.to.name, 'dynamic');
                assert.deepEqual(transition.to.paramNames, ['dynamic_id']);

                if (inital) {
                  assert.deepEqual(transition.to.params, {
                    dynamic_id: '123'
                  });
                } else {
                  assert.deepEqual(transition.to.params, {
                    dynamic_id: '1'
                  });
                }
              });
            }
          }));
          return this.visit('/dynamic/123').then(function () {
            inital = false;
            return _this9.routerService.transitionTo('dynamic', 1);
          });
        };

        _proto['@test nested params'] = function testNestedParams(assert) {
          var _this10 = this;

          assert.expect(30);
          var initial = true;
          this.add('route:dynamicWithChild', _routing.Route.extend({
            model: function (params) {
              if (initial) {
                assert.deepEqual(params, {
                  dynamic_id: '123'
                });
              } else {
                assert.deepEqual(params, {
                  dynamic_id: '456'
                });
              }

              return params.dynamic_id;
            }
          }));
          this.add('route:dynamicWithChild.child', _routing.Route.extend({
            model: function (params) {
              assert.deepEqual(params, {
                child_id: '456'
              });
              return params.child_id;
            }
          }));
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                assert.equal(transition.to.name, 'dynamicWithChild.child');
                assert.deepEqual(transition.to.paramNames, ['child_id']);
                assert.deepEqual(transition.to.params, {
                  child_id: '456'
                });
                assert.deepEqual(transition.to.parent.paramNames, ['dynamic_id']);

                if (initial) {
                  assert.deepEqual(transition.to.parent.params, {
                    dynamic_id: '123'
                  });
                } else {
                  assert.deepEqual(transition.from.attributes, '456');
                  assert.deepEqual(transition.from.parent.attributes, '123');
                  assert.deepEqual(transition.to.parent.params, {
                    dynamic_id: '456'
                  });
                }
              });
              this.router.on('routeDidChange', function (transition) {
                assert.equal(transition.to.name, 'dynamicWithChild.child');
                assert.deepEqual(transition.to.paramNames, ['child_id']);
                assert.deepEqual(transition.to.params, {
                  child_id: '456'
                });
                assert.deepEqual(transition.to.parent.paramNames, ['dynamic_id']);

                if (initial) {
                  assert.deepEqual(transition.to.parent.params, {
                    dynamic_id: '123'
                  });
                } else {
                  assert.deepEqual(transition.from.attributes, '456');
                  assert.deepEqual(transition.from.parent.attributes, '123');
                  assert.deepEqual(transition.to.attributes, '456');
                  assert.deepEqual(transition.to.parent.attributes, '456');
                  assert.deepEqual(transition.to.parent.params, {
                    dynamic_id: '456'
                  });
                }
              });
            }
          }));
          return this.visit('/dynamic-with-child/123/456').then(function () {
            initial = false;
            return _this10.routerService.transitionTo('/dynamic-with-child/456/456');
          });
        };

        return _class;
      }(_internalTestHelpers.RouterTestCase));
      (0, _internalTestHelpers.moduleFor)('Router Service - deprecated events',
      /*#__PURE__*/
      function (_RouterTestCase2) {
        (0, _emberBabel.inheritsLoose)(_class2, _RouterTestCase2);

        function _class2() {
          return _RouterTestCase2.apply(this, arguments) || this;
        }

        var _proto2 = _class2.prototype;

        _proto2['@test willTransition events are deprecated'] = function testWillTransitionEventsAreDeprecated() {
          var _this11 = this;

          return this.visit('/').then(function () {
            expectDeprecation(function () {
              _this11.routerService['_router'].on('willTransition', function () {});
            }, 'You attempted to listen to the "willTransition" event which is deprecated. Please inject the router service and listen to the "routeWillChange" event.');
          });
        };

        _proto2['@test willTransition events are deprecated on routes'] = function testWillTransitionEventsAreDeprecatedOnRoutes() {
          var _this12 = this;

          this.add('route:application', _routing.Route.extend({
            init: function () {
              this._super.apply(this, arguments);

              this.on('willTransition', function () {});
            }
          }));
          expectDeprecation(function () {
            return _this12.visit('/');
          }, 'You attempted to listen to the "willTransition" event which is deprecated. Please inject the router service and listen to the "routeWillChange" event.');
        };

        _proto2['@test didTransition events are deprecated on routes'] = function testDidTransitionEventsAreDeprecatedOnRoutes() {
          var _this13 = this;

          this.add('route:application', _routing.Route.extend({
            init: function () {
              this._super.apply(this, arguments);

              this.on('didTransition', function () {});
            }
          }));
          expectDeprecation(function () {
            return _this13.visit('/');
          }, 'You attempted to listen to the "didTransition" event which is deprecated. Please inject the router service and listen to the "routeDidChange" event.');
        };

        _proto2['@test other events are not deprecated on routes'] = function testOtherEventsAreNotDeprecatedOnRoutes() {
          var _this14 = this;

          this.add('route:application', _routing.Route.extend({
            init: function () {
              this._super.apply(this, arguments);

              this.on('fixx', function () {});
            }
          }));
          expectNoDeprecation(function () {
            return _this14.visit('/');
          });
        };

        _proto2['@test didTransition events are deprecated'] = function testDidTransitionEventsAreDeprecated() {
          var _this15 = this;

          return this.visit('/').then(function () {
            expectDeprecation(function () {
              _this15.routerService['_router'].on('didTransition', function () {});
            }, 'You attempted to listen to the "didTransition" event which is deprecated. Please inject the router service and listen to the "routeDidChange" event.');
          });
        };

        _proto2['@test other events are not deprecated'] = function testOtherEventsAreNotDeprecated() {
          var _this16 = this;

          return this.visit('/').then(function () {
            expectNoDeprecation(function () {
              _this16.routerService['_router'].on('wat', function () {});
            });
          });
        };

        return _class2;
      }(_internalTestHelpers.RouterTestCase));
      (0, _internalTestHelpers.moduleFor)('Router Service: deprecated willTransition hook',
      /*#__PURE__*/
      function (_RouterTestCase3) {
        (0, _emberBabel.inheritsLoose)(_class3, _RouterTestCase3);

        function _class3() {
          return _RouterTestCase3.apply(this, arguments) || this;
        }

        var _proto3 = _class3.prototype;

        _proto3['@test willTransition hook is deprecated'] = function testWillTransitionHookIsDeprecated() {
          var _this17 = this;

          expectDeprecation(function () {
            return _this17.visit('/');
          }, 'You attempted to override the "willTransition" method which is deprecated. Please inject the router service and listen to the "routeWillChange" event.');
        };

        (0, _emberBabel.createClass)(_class3, [{
          key: "routerOptions",
          get: function () {
            return {
              willTransition: function () {
                this._super.apply(this, arguments); // Overrides

              }
            };
          }
        }]);
        return _class3;
      }(_internalTestHelpers.RouterTestCase));
      (0, _internalTestHelpers.moduleFor)('Router Service: deprecated didTransition hook',
      /*#__PURE__*/
      function (_RouterTestCase4) {
        (0, _emberBabel.inheritsLoose)(_class4, _RouterTestCase4);

        function _class4() {
          return _RouterTestCase4.apply(this, arguments) || this;
        }

        var _proto4 = _class4.prototype;

        _proto4['@test didTransition hook is deprecated'] = function testDidTransitionHookIsDeprecated() {
          var _this18 = this;

          expectDeprecation(function () {
            return _this18.visit('/');
          }, 'You attempted to override the "didTransition" method which is deprecated. Please inject the router service and listen to the "routeDidChange" event.');
        };

        (0, _emberBabel.createClass)(_class4, [{
          key: "routerOptions",
          get: function () {
            return {
              didTransition: function () {
                this._super.apply(this, arguments); // Overrides

              }
            };
          }
        }]);
        return _class4;
      }(_internalTestHelpers.RouterTestCase));
    }
});
enifed("ember/tests/routing/router_service_test/isActive_test", ["ember-babel", "@ember/controller", "internal-test-helpers"], function (_emberBabel, _controller, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router Service - isActive',
  /*#__PURE__*/
  function (_RouterTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

    function _class() {
      return _RouterTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test RouterService#isActive returns true for simple route'] = function testRouterServiceIsActiveReturnsTrueForSimpleRoute(assert) {
      var _this = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        return _this.routerService.transitionTo('parent.child');
      }).then(function () {
        return _this.routerService.transitionTo('parent.sister');
      }).then(function () {
        assert.ok(_this.routerService.isActive('parent.sister'));
      });
    };

    _proto['@test RouterService#isActive returns true for simple route with dynamic segments'] = function testRouterServiceIsActiveReturnsTrueForSimpleRouteWithDynamicSegments(assert) {
      var _this2 = this;

      assert.expect(1);
      var dynamicModel = {
        id: 1
      };
      return this.visit('/').then(function () {
        return _this2.routerService.transitionTo('dynamic', dynamicModel);
      }).then(function () {
        assert.ok(_this2.routerService.isActive('dynamic', dynamicModel));
      });
    };

    _proto['@test RouterService#isActive does not eagerly instantiate controller for query params'] = function testRouterServiceIsActiveDoesNotEagerlyInstantiateControllerForQueryParams(assert) {
      var _this3 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      this.add('controller:parent.sister', _controller.default.extend({
        queryParams: ['sort'],
        sort: 'ASC',
        init: function () {
          assert.ok(false, 'should never create');

          this._super.apply(this, arguments);
        }
      }));
      return this.visit('/').then(function () {
        return _this3.routerService.transitionTo('parent.brother');
      }).then(function () {
        assert.notOk(_this3.routerService.isActive('parent.sister', queryParams));
      });
    };

    _proto['@test RouterService#isActive is correct for simple route with basic query params'] = function testRouterServiceIsActiveIsCorrectForSimpleRouteWithBasicQueryParams(assert) {
      var _this4 = this;

      assert.expect(2);
      var queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort'],
        sort: 'ASC'
      }));
      return this.visit('/').then(function () {
        return _this4.routerService.transitionTo('parent.child', queryParams);
      }).then(function () {
        assert.ok(_this4.routerService.isActive('parent.child', queryParams));
        assert.notOk(_this4.routerService.isActive('parent.child', _this4.buildQueryParams({
          sort: 'DESC'
        })));
      });
    };

    _proto['@test RouterService#isActive for simple route with array as query params'] = function testRouterServiceIsActiveForSimpleRouteWithArrayAsQueryParams(assert) {
      var _this5 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        sort: ['ascending']
      });
      return this.visit('/').then(function () {
        return _this5.routerService.transitionTo('parent.child', queryParams);
      }).then(function () {
        assert.notOk(_this5.routerService.isActive('parent.child', _this5.buildQueryParams({
          sort: 'descending'
        })));
      });
    };

    return _class;
  }(_internalTestHelpers.RouterTestCase));
});
enifed("ember/tests/routing/router_service_test/recognize_test", ["ember-babel", "internal-test-helpers", "@ember/-internals/routing"], function (_emberBabel, _internalTestHelpers, _routing) {
  "use strict";

  if (true
  /* EMBER_ROUTING_ROUTER_SERVICE */
  ) {
      (0, _internalTestHelpers.moduleFor)('Router Service - recognize',
      /*#__PURE__*/
      function (_RouterTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

        function _class() {
          return _RouterTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto['@test returns a RouteInfo for recognized URL'] = function testReturnsARouteInfoForRecognizedURL(assert) {
          var _this = this;

          return this.visit('/').then(function () {
            var routeInfo = _this.routerService.recognize('/dynamic-with-child/123/1?a=b');

            assert.ok(routeInfo);
            var name = routeInfo.name,
                localName = routeInfo.localName,
                parent = routeInfo.parent,
                child = routeInfo.child,
                params = routeInfo.params,
                queryParams = routeInfo.queryParams,
                paramNames = routeInfo.paramNames;
            assert.equal(name, 'dynamicWithChild.child');
            assert.equal(localName, 'child');
            assert.ok(parent);
            assert.equal(parent.name, 'dynamicWithChild');
            assert.notOk(child);
            assert.deepEqual(params, {
              child_id: '1'
            });
            assert.deepEqual(queryParams, {
              a: 'b'
            });
            assert.deepEqual(paramNames, ['child_id']);
          });
        };

        _proto['@test does not transition'] = function testDoesNotTransition(assert) {
          var _this2 = this;

          this.addTemplate('parent', 'Parent');
          this.addTemplate('dynamic-with-child.child', 'Dynamic Child');
          return this.visit('/').then(function () {
            _this2.routerService.recognize('/dynamic-with-child/123/1?a=b');

            _this2.assertText('Parent', 'Did not transition and cause render');

            assert.equal(_this2.routerService.currentURL, '/', 'Did not transition');
          });
        };

        _proto['@test respects the usage of a different rootURL'] = function testRespectsTheUsageOfADifferentRootURL(assert) {
          var _this3 = this;

          this.router.reopen({
            rootURL: '/app/'
          });
          return this.visit('/app').then(function () {
            var routeInfo = _this3.routerService.recognize('/app/child/');

            assert.ok(routeInfo);
            var name = routeInfo.name,
                localName = routeInfo.localName,
                parent = routeInfo.parent;
            assert.equal(name, 'parent.child');
            assert.equal(localName, 'child');
            assert.equal(parent.name, 'parent');
          });
        };

        _proto['@test must include rootURL'] = function testMustIncludeRootURL() {
          var _this4 = this;

          this.addTemplate('parent', 'Parent');
          this.addTemplate('dynamic-with-child.child', 'Dynamic Child');
          this.router.reopen({
            rootURL: '/app/'
          });
          return this.visit('/app').then(function () {
            expectAssertion(function () {
              _this4.routerService.recognize('/dynamic-with-child/123/1?a=b');
            }, 'You must pass a url that begins with the application\'s rootURL "/app/"');
          });
        };

        _proto['@test returns `null` if URL is not recognized'] = function testReturnsNullIfURLIsNotRecognized(assert) {
          var _this5 = this;

          return this.visit('/').then(function () {
            var routeInfo = _this5.routerService.recognize('/foo');

            assert.equal(routeInfo, null);
          });
        };

        return _class;
      }(_internalTestHelpers.RouterTestCase));
      (0, _internalTestHelpers.moduleFor)('Router Service - recognizeAndLoad',
      /*#__PURE__*/
      function (_RouterTestCase2) {
        (0, _emberBabel.inheritsLoose)(_class2, _RouterTestCase2);

        function _class2() {
          return _RouterTestCase2.apply(this, arguments) || this;
        }

        var _proto2 = _class2.prototype;

        _proto2['@test returns a RouteInfoWithAttributes for recognized URL'] = function testReturnsARouteInfoWithAttributesForRecognizedURL(assert) {
          var _this6 = this;

          this.add('route:dynamicWithChild', _routing.Route.extend({
            model: function (params) {
              return {
                name: 'dynamicWithChild',
                data: params.dynamic_id
              };
            }
          }));
          this.add('route:dynamicWithChild.child', _routing.Route.extend({
            model: function (params) {
              return {
                name: 'dynamicWithChild.child',
                data: params.child_id
              };
            }
          }));
          return this.visit('/').then(function () {
            return _this6.routerService.recognizeAndLoad('/dynamic-with-child/123/1?a=b');
          }).then(function (routeInfoWithAttributes) {
            assert.ok(routeInfoWithAttributes);
            var name = routeInfoWithAttributes.name,
                localName = routeInfoWithAttributes.localName,
                parent = routeInfoWithAttributes.parent,
                attributes = routeInfoWithAttributes.attributes,
                paramNames = routeInfoWithAttributes.paramNames,
                params = routeInfoWithAttributes.params,
                queryParams = routeInfoWithAttributes.queryParams;
            assert.equal(name, 'dynamicWithChild.child');
            assert.equal(localName, 'child');
            assert.equal(parent.name, 'dynamicWithChild');
            assert.deepEqual(params, {
              child_id: '1'
            });
            assert.deepEqual(queryParams, {
              a: 'b'
            });
            assert.deepEqual(paramNames, ['child_id']);
            assert.deepEqual(attributes, {
              name: 'dynamicWithChild.child',
              data: '1'
            });
            assert.deepEqual(parent.attributes, {
              name: 'dynamicWithChild',
              data: '123'
            });
            assert.deepEqual(parent.paramNames, ['dynamic_id']);
            assert.deepEqual(parent.params, {
              dynamic_id: '123'
            });
          });
        };

        _proto2['@test does not transition'] = function testDoesNotTransition(assert) {
          var _this7 = this;

          this.addTemplate('parent', 'Parent{{outlet}}');
          this.addTemplate('parent.child', 'Child');
          this.add('route:parent.child', _routing.Route.extend({
            model: function () {
              return {
                name: 'child',
                data: ['stuff']
              };
            }
          }));
          return this.visit('/').then(function () {
            _this7.routerService.on('routeWillChange', function () {
              return assert.ok(false);
            });

            _this7.routerService.on('routeDidChange', function () {
              return assert.ok(false);
            });

            return _this7.routerService.recognizeAndLoad('/child');
          }).then(function () {
            assert.equal(_this7.routerService.currentURL, '/');

            _this7.assertText('Parent');
          });
        };

        _proto2['@test respects the usage of a different rootURL'] = function testRespectsTheUsageOfADifferentRootURL(assert) {
          var _this8 = this;

          this.router.reopen({
            rootURL: '/app/'
          });
          return this.visit('/app').then(function () {
            return _this8.routerService.recognizeAndLoad('/app/child/');
          }).then(function (routeInfoWithAttributes) {
            assert.ok(routeInfoWithAttributes);
            var name = routeInfoWithAttributes.name,
                localName = routeInfoWithAttributes.localName,
                parent = routeInfoWithAttributes.parent;
            assert.equal(name, 'parent.child');
            assert.equal(localName, 'child');
            assert.equal(parent.name, 'parent');
          });
        };

        _proto2['@test must include rootURL'] = function testMustIncludeRootURL() {
          var _this9 = this;

          this.router.reopen({
            rootURL: '/app/'
          });
          return this.visit('/app').then(function () {
            expectAssertion(function () {
              _this9.routerService.recognizeAndLoad('/dynamic-with-child/123/1?a=b');
            }, 'You must pass a url that begins with the application\'s rootURL "/app/"');
          });
        };

        _proto2['@test rejects if url is not recognized'] = function testRejectsIfUrlIsNotRecognized(assert) {
          var _this10 = this;

          this.addTemplate('parent', 'Parent{{outlet}}');
          this.addTemplate('parent.child', 'Child');
          this.add('route:parent.child', _routing.Route.extend({
            model: function () {
              return {
                name: 'child',
                data: ['stuff']
              };
            }
          }));
          return this.visit('/').then(function () {
            return _this10.routerService.recognizeAndLoad('/foo');
          }).then(function () {
            assert.ok(false, 'never');
          }, function (reason) {
            assert.equal(reason, 'URL /foo was not recognized');
          });
        };

        _proto2['@test rejects if there is an unhandled error'] = function testRejectsIfThereIsAnUnhandledError(assert) {
          var _this11 = this;

          this.addTemplate('parent', 'Parent{{outlet}}');
          this.addTemplate('parent.child', 'Child');
          this.add('route:parent.child', _routing.Route.extend({
            model: function () {
              throw Error('Unhandled');
            }
          }));
          return this.visit('/').then(function () {
            return _this11.routerService.recognizeAndLoad('/child');
          }).then(function () {
            assert.ok(false, 'never');
          }, function (err) {
            assert.equal(err.message, 'Unhandled');
          });
        };

        return _class2;
      }(_internalTestHelpers.RouterTestCase));
    }
});
enifed("ember/tests/routing/router_service_test/replaceWith_test", ["ember-babel", "@ember/-internals/routing", "internal-test-helpers", "router_js", "@ember/controller"], function (_emberBabel, _routing, _internalTestHelpers, _router_js, _controller) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router Service - replaceWith',
  /*#__PURE__*/
  function (_RouterTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

    function _class() {
      var _this;

      _this = _RouterTestCase.apply(this, arguments) || this;
      var testCase = (0, _emberBabel.assertThisInitialized)((0, _emberBabel.assertThisInitialized)(_this));
      testCase.state = [];

      _this.add('location:test', _routing.NoneLocation.extend({
        setURL: function (path) {
          testCase.state.push(path);
          this.set('path', path);
        },
        replaceURL: function (path) {
          testCase.state.splice(testCase.state.length - 1, 1, path);
          this.set('path', path);
        }
      }));

      return _this;
    }

    var _proto = _class.prototype;

    _proto['@test RouterService#replaceWith returns a Transition'] = function testRouterServiceReplaceWithReturnsATransition(assert) {
      var _this2 = this;

      assert.expect(1);
      var transition;
      return this.visit('/').then(function () {
        transition = _this2.routerService.replaceWith('parent.child');
        assert.ok(transition instanceof _router_js.InternalTransition);
        return transition;
      });
    };

    _proto['@test RouterService#replaceWith with basic route replaces location'] = function testRouterServiceReplaceWithWithBasicRouteReplacesLocation(assert) {
      var _this3 = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        return _this3.routerService.transitionTo('parent.child');
      }).then(function () {
        return _this3.routerService.transitionTo('parent.sister');
      }).then(function () {
        return _this3.routerService.replaceWith('parent.brother');
      }).then(function () {
        assert.deepEqual(_this3.state, ['/', '/child', '/brother']);
      });
    };

    _proto['@test RouterService#replaceWith with basic route using URLs replaces location'] = function testRouterServiceReplaceWithWithBasicRouteUsingURLsReplacesLocation(assert) {
      var _this4 = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        return _this4.routerService.transitionTo('/child');
      }).then(function () {
        return _this4.routerService.transitionTo('/sister');
      }).then(function () {
        return _this4.routerService.replaceWith('/brother');
      }).then(function () {
        assert.deepEqual(_this4.state, ['/', '/child', '/brother']);
      });
    };

    _proto['@test RouterService#replaceWith transitioning back to previously visited route replaces location'] = function testRouterServiceReplaceWithTransitioningBackToPreviouslyVisitedRouteReplacesLocation(assert) {
      var _this5 = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        return _this5.routerService.transitionTo('parent.child');
      }).then(function () {
        return _this5.routerService.transitionTo('parent.sister');
      }).then(function () {
        return _this5.routerService.transitionTo('parent.brother');
      }).then(function () {
        return _this5.routerService.replaceWith('parent.sister');
      }).then(function () {
        assert.deepEqual(_this5.state, ['/', '/child', '/sister', '/sister']);
      });
    };

    _proto['@test RouterService#replaceWith with basic query params does not remove query param defaults'] = function testRouterServiceReplaceWithWithBasicQueryParamsDoesNotRemoveQueryParamDefaults(assert) {
      var _this6 = this;

      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort'],
        sort: 'ASC'
      }));
      var queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      return this.visit('/').then(function () {
        return _this6.routerService.transitionTo('parent.brother');
      }).then(function () {
        return _this6.routerService.replaceWith('parent.sister');
      }).then(function () {
        return _this6.routerService.replaceWith('parent.child', queryParams);
      }).then(function () {
        assert.deepEqual(_this6.state, ['/', '/child?sort=ASC']);
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "routerOptions",
      get: function () {
        return {
          location: 'test'
        };
      }
    }]);
    return _class;
  }(_internalTestHelpers.RouterTestCase));
});
enifed("ember/tests/routing/router_service_test/transitionTo_test", ["ember-babel", "@ember/service", "@ember/-internals/glimmer", "@ember/-internals/routing", "@ember/controller", "@ember/runloop", "@ember/-internals/metal", "internal-test-helpers", "router_js"], function (_emberBabel, _service, _glimmer, _routing, _controller, _runloop, _metal, _internalTestHelpers, _router_js) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router Service - transitionTo',
  /*#__PURE__*/
  function (_RouterTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

    function _class() {
      var _this;

      _this = _RouterTestCase.apply(this, arguments) || this;
      var testCase = (0, _emberBabel.assertThisInitialized)((0, _emberBabel.assertThisInitialized)(_this));
      testCase.state = [];

      _this.add('location:test', _routing.NoneLocation.extend({
        setURL: function (path) {
          testCase.state.push(path);
          this.set('path', path);
        },
        replaceURL: function (path) {
          testCase.state.splice(testCase.state.length - 1, 1, path);
          this.set('path', path);
        }
      }));

      return _this;
    }

    var _proto = _class.prototype;

    _proto['@test RouterService#transitionTo returns a Transition'] = function testRouterServiceTransitionToReturnsATransition(assert) {
      var _this2 = this;

      assert.expect(1);
      var transition;
      return this.visit('/').then(function () {
        transition = _this2.routerService.transitionTo('parent.child');
        assert.ok(transition instanceof _router_js.InternalTransition);
        return transition;
      });
    };

    _proto['@test RouterService#transitionTo with basic route updates location'] = function testRouterServiceTransitionToWithBasicRouteUpdatesLocation(assert) {
      var _this3 = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        return _this3.routerService.transitionTo('parent.child');
      }).then(function () {
        return _this3.routerService.transitionTo('parent.sister');
      }).then(function () {
        return _this3.routerService.transitionTo('parent.brother');
      }).then(function () {
        assert.deepEqual(_this3.state, ['/', '/child', '/sister', '/brother']);
      });
    };

    _proto['@test RouterService#transitionTo transitioning back to previously visited route updates location'] = function testRouterServiceTransitionToTransitioningBackToPreviouslyVisitedRouteUpdatesLocation(assert) {
      var _this4 = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        return _this4.routerService.transitionTo('parent.child');
      }).then(function () {
        return _this4.routerService.transitionTo('parent.sister');
      }).then(function () {
        return _this4.routerService.transitionTo('parent.brother');
      }).then(function () {
        return _this4.routerService.transitionTo('parent.sister');
      }).then(function () {
        assert.deepEqual(_this4.state, ['/', '/child', '/sister', '/brother', '/sister']);
      });
    };

    _proto['@test RouterService#transitionTo with basic route'] = function testRouterServiceTransitionToWithBasicRoute(assert) {
      var _this5 = this;

      assert.expect(1);
      var componentInstance;
      this.addTemplate('parent.index', '{{foo-bar}}');
      this.addComponent('foo-bar', {
        ComponentClass: _glimmer.Component.extend({
          routerService: (0, _service.inject)('router'),
          init: function () {
            this._super();

            componentInstance = this;
          },
          actions: {
            transitionToSister: function () {
              (0, _metal.get)(this, 'routerService').transitionTo('parent.sister');
            }
          }
        }),
        template: "foo-bar"
      });
      return this.visit('/').then(function () {
        (0, _runloop.run)(function () {
          componentInstance.send('transitionToSister');
        });
        assert.equal(_this5.routerService.get('currentRouteName'), 'parent.sister');
      });
    };

    _proto['@test RouterService#transitionTo with basic route using URL'] = function testRouterServiceTransitionToWithBasicRouteUsingURL(assert) {
      var _this6 = this;

      assert.expect(1);
      var componentInstance;
      this.addTemplate('parent.index', '{{foo-bar}}');
      this.addComponent('foo-bar', {
        ComponentClass: _glimmer.Component.extend({
          routerService: (0, _service.inject)('router'),
          init: function () {
            this._super();

            componentInstance = this;
          },
          actions: {
            transitionToSister: function () {
              (0, _metal.get)(this, 'routerService').transitionTo('/sister');
            }
          }
        }),
        template: "foo-bar"
      });
      return this.visit('/').then(function () {
        (0, _runloop.run)(function () {
          componentInstance.send('transitionToSister');
        });
        assert.equal(_this6.routerService.get('currentRouteName'), 'parent.sister');
      });
    };

    _proto['@test RouterService#transitionTo with dynamic segment'] = function testRouterServiceTransitionToWithDynamicSegment(assert) {
      var _this7 = this;

      assert.expect(3);
      var componentInstance;
      var dynamicModel = {
        id: 1,
        contents: 'much dynamicism'
      };
      this.addTemplate('parent.index', '{{foo-bar}}');
      this.addTemplate('dynamic', '{{model.contents}}');
      this.addComponent('foo-bar', {
        ComponentClass: _glimmer.Component.extend({
          routerService: (0, _service.inject)('router'),
          init: function () {
            this._super();

            componentInstance = this;
          },
          actions: {
            transitionToDynamic: function () {
              (0, _metal.get)(this, 'routerService').transitionTo('dynamic', dynamicModel);
            }
          }
        }),
        template: "foo-bar"
      });
      return this.visit('/').then(function () {
        (0, _runloop.run)(function () {
          componentInstance.send('transitionToDynamic');
        });
        assert.equal(_this7.routerService.get('currentRouteName'), 'dynamic');
        assert.equal(_this7.routerService.get('currentURL'), '/dynamic/1');

        _this7.assertText('much dynamicism');
      });
    };

    _proto['@test RouterService#transitionTo with dynamic segment and model hook'] = function testRouterServiceTransitionToWithDynamicSegmentAndModelHook(assert) {
      var _this8 = this;

      assert.expect(3);
      var componentInstance;
      var dynamicModel = {
        id: 1,
        contents: 'much dynamicism'
      };
      this.add('route:dynamic', _routing.Route.extend({
        model: function () {
          return dynamicModel;
        }
      }));
      this.addTemplate('parent.index', '{{foo-bar}}');
      this.addTemplate('dynamic', '{{model.contents}}');
      this.addComponent('foo-bar', {
        ComponentClass: _glimmer.Component.extend({
          routerService: (0, _service.inject)('router'),
          init: function () {
            this._super();

            componentInstance = this;
          },
          actions: {
            transitionToDynamic: function () {
              (0, _metal.get)(this, 'routerService').transitionTo('dynamic', 1);
            }
          }
        }),
        template: "foo-bar"
      });
      return this.visit('/').then(function () {
        (0, _runloop.run)(function () {
          componentInstance.send('transitionToDynamic');
        });
        assert.equal(_this8.routerService.get('currentRouteName'), 'dynamic');
        assert.equal(_this8.routerService.get('currentURL'), '/dynamic/1');

        _this8.assertText('much dynamicism');
      });
    };

    _proto['@test RouterService#transitionTo with basic query params does not remove query param defaults'] = function testRouterServiceTransitionToWithBasicQueryParamsDoesNotRemoveQueryParamDefaults(assert) {
      var _this9 = this;

      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort'],
        sort: 'ASC'
      }));
      var queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      return this.visit('/').then(function () {
        return _this9.routerService.transitionTo('parent.child', queryParams);
      }).then(function () {
        assert.equal(_this9.routerService.get('currentURL'), '/child?sort=ASC');
      });
    };

    _proto['@test RouterService#transitionTo passing only queryParams works'] = function testRouterServiceTransitionToPassingOnlyQueryParamsWorks(assert) {
      var _this10 = this;

      assert.expect(2);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort']
      }));
      var queryParams = this.buildQueryParams({
        sort: 'DESC'
      });
      return this.visit('/').then(function () {
        return _this10.routerService.transitionTo('parent.child');
      }).then(function () {
        assert.equal(_this10.routerService.get('currentURL'), '/child');
      }).then(function () {
        return _this10.routerService.transitionTo(queryParams);
      }).then(function () {
        assert.equal(_this10.routerService.get('currentURL'), '/child?sort=DESC');
      });
    };

    _proto['@test RouterService#transitionTo with unspecified query params'] = function testRouterServiceTransitionToWithUnspecifiedQueryParams(assert) {
      var _this11 = this;

      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort', 'page', 'category', 'extra'],
        sort: 'ASC',
        page: null,
        category: undefined
      }));
      var queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      return this.visit('/').then(function () {
        return _this11.routerService.transitionTo('parent.child', queryParams);
      }).then(function () {
        assert.equal(_this11.routerService.get('currentURL'), '/child?sort=ASC');
      });
    };

    _proto['@test RouterService#transitionTo with aliased query params uses the original provided key'] = function testRouterServiceTransitionToWithAliasedQueryParamsUsesTheOriginalProvidedKey(assert) {
      var _this12 = this;

      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: {
          cont_sort: 'url_sort'
        },
        cont_sort: 'ASC'
      }));
      var queryParams = this.buildQueryParams({
        url_sort: 'ASC'
      });
      return this.visit('/').then(function () {
        return _this12.routerService.transitionTo('parent.child', queryParams);
      }).then(function () {
        assert.equal(_this12.routerService.get('currentURL'), '/child?url_sort=ASC');
      });
    };

    _proto['@test RouterService#transitionTo with aliased query params uses the original provided key when controller property name'] = function testRouterServiceTransitionToWithAliasedQueryParamsUsesTheOriginalProvidedKeyWhenControllerPropertyName(assert) {
      var _this13 = this;

      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: {
          cont_sort: 'url_sort'
        },
        cont_sort: 'ASC'
      }));
      var queryParams = this.buildQueryParams({
        cont_sort: 'ASC'
      });
      return this.visit('/').then(function () {
        expectAssertion(function () {
          return _this13.routerService.transitionTo('parent.child', queryParams);
        }, 'You passed the `cont_sort` query parameter during a transition into parent.child, please update to url_sort');
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "routerOptions",
      get: function () {
        return {
          location: 'test'
        };
      }
    }]);
    return _class;
  }(_internalTestHelpers.RouterTestCase));
});
enifed("ember/tests/routing/router_service_test/urlFor_test", ["ember-babel", "@ember/controller", "@ember/string", "@ember/-internals/routing", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _controller, _string, _routing, _metal, _internalTestHelpers) {
  "use strict";

  function setupController(app, name) {
    var controllerName = (0, _string.capitalize)(name) + "Controller";
    Object.defineProperty(app, controllerName, {
      get: function () {
        throw new Error("Generating a URL should not require instantiation of a " + controllerName + ".");
      }
    });
  }

  (0, _internalTestHelpers.moduleFor)('Router Service - urlFor',
  /*#__PURE__*/
  function (_RouterTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

    function _class() {
      return _RouterTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test RouterService#urlFor returns URL for simple route'] = function testRouterServiceUrlForReturnsURLForSimpleRoute(assert) {
      var _this = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        var expectedURL = _this.routerService.urlFor('parent.child');

        assert.equal('/child', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with dynamic segments'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithDynamicSegments(assert) {
      var _this2 = this;

      assert.expect(1);
      setupController(this.application, 'dynamic');
      var dynamicModel = {
        id: 1,
        contents: 'much dynamicism'
      };
      return this.visit('/').then(function () {
        var expectedURL = _this2.routerService.urlFor('dynamic', dynamicModel);

        assert.equal('/dynamic/1', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with basic query params'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithBasicQueryParams(assert) {
      var _this3 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        foo: 'bar'
      });
      return this.visit('/').then(function () {
        var expectedURL = _this3.routerService.urlFor('parent.child', queryParams);

        assert.equal('/child?foo=bar', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with basic query params and default value'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithBasicQueryParamsAndDefaultValue(assert) {
      var _this4 = this;

      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort'],
        sort: 'ASC'
      }));
      var queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      return this.visit('/').then(function () {
        var expectedURL = _this4.routerService.urlFor('parent.child', queryParams);

        assert.equal('/child?sort=ASC', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with basic query params and default value with stickyness'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithBasicQueryParamsAndDefaultValueWithStickyness(assert) {
      var _this5 = this;

      assert.expect(2);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort', 'foo'],
        sort: 'ASC'
      }));
      return this.visit('/child/?sort=DESC').then(function () {
        var controller = _this5.applicationInstance.lookup('controller:parent.child');

        assert.equal((0, _metal.get)(controller, 'sort'), 'DESC', 'sticky is set');

        var queryParams = _this5.buildQueryParams({
          foo: 'derp'
        });

        var actual = _this5.routerService.urlFor('parent.child', queryParams);

        assert.equal(actual, '/child?foo=derp', 'does not use "stickiness"');
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with array as query params'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithArrayAsQueryParams(assert) {
      var _this6 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        selectedItems: ['a', 'b', 'c']
      });
      return this.visit('/').then(function () {
        var expectedURL = _this6.routerService.urlFor('parent.child', queryParams);

        assert.equal('/child?selectedItems[]=a&selectedItems[]=b&selectedItems[]=c', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with null query params'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithNullQueryParams(assert) {
      var _this7 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        foo: null
      });
      return this.visit('/').then(function () {
        var expectedURL = _this7.routerService.urlFor('parent.child', queryParams);

        assert.equal('/child', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with undefined query params'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithUndefinedQueryParams(assert) {
      var _this8 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        foo: undefined
      });
      return this.visit('/').then(function () {
        var expectedURL = _this8.routerService.urlFor('parent.child', queryParams);

        assert.equal('/child', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with dynamic segments and basic query params'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithDynamicSegmentsAndBasicQueryParams(assert) {
      var _this9 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        foo: 'bar'
      });
      return this.visit('/').then(function () {
        var expectedURL = _this9.routerService.urlFor('dynamic', {
          id: 1
        }, queryParams);

        assert.equal('/dynamic/1?foo=bar', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with dynamic segments and array as query params'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithDynamicSegmentsAndArrayAsQueryParams(assert) {
      var _this10 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        selectedItems: ['a', 'b', 'c']
      });
      return this.visit('/').then(function () {
        var expectedURL = _this10.routerService.urlFor('dynamic', {
          id: 1
        }, queryParams);

        assert.equal('/dynamic/1?selectedItems[]=a&selectedItems[]=b&selectedItems[]=c', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with dynamic segments and null query params'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithDynamicSegmentsAndNullQueryParams(assert) {
      var _this11 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        foo: null
      });
      return this.visit('/').then(function () {
        var expectedURL = _this11.routerService.urlFor('dynamic', {
          id: 1
        }, queryParams);

        assert.equal('/dynamic/1', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with dynamic segments and undefined query params'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithDynamicSegmentsAndUndefinedQueryParams(assert) {
      var _this12 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        foo: undefined
      });
      return this.visit('/').then(function () {
        var expectedURL = _this12.routerService.urlFor('dynamic', {
          id: 1
        }, queryParams);

        assert.equal('/dynamic/1', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor correctly transitions to route via generated path'] = function testRouterServiceUrlForCorrectlyTransitionsToRouteViaGeneratedPath(assert) {
      var _this13 = this;

      assert.expect(1);
      var expectedURL;
      return this.visit('/').then(function () {
        expectedURL = _this13.routerService.urlFor('parent.child');
        return _this13.routerService.transitionTo(expectedURL);
      }).then(function () {
        assert.equal(expectedURL, _this13.routerService.get('currentURL'));
      });
    };

    _proto['@test RouterService#urlFor correctly transitions to route via generated path with dynamic segments'] = function testRouterServiceUrlForCorrectlyTransitionsToRouteViaGeneratedPathWithDynamicSegments(assert) {
      var _this14 = this;

      assert.expect(1);
      var expectedURL;
      var dynamicModel = {
        id: 1
      };
      this.add('route:dynamic', _routing.Route.extend({
        model: function () {
          return dynamicModel;
        }
      }));
      return this.visit('/').then(function () {
        expectedURL = _this14.routerService.urlFor('dynamic', dynamicModel);
        return _this14.routerService.transitionTo(expectedURL);
      }).then(function () {
        assert.equal(expectedURL, _this14.routerService.get('currentURL'));
      });
    };

    _proto['@test RouterService#urlFor correctly transitions to route via generated path with query params'] = function testRouterServiceUrlForCorrectlyTransitionsToRouteViaGeneratedPathWithQueryParams(assert) {
      var _this15 = this;

      assert.expect(1);
      var expectedURL;
      var actualURL;
      var queryParams = this.buildQueryParams({
        foo: 'bar'
      });
      return this.visit('/').then(function () {
        expectedURL = _this15.routerService.urlFor('parent.child', queryParams);
        return _this15.routerService.transitionTo(expectedURL);
      }).then(function () {
        actualURL = _this15.routerService.get('currentURL') + "?foo=bar";
        assert.equal(expectedURL, actualURL);
      });
    };

    _proto['@test RouterService#urlFor correctly transitions to route via generated path with dynamic segments and query params'] = function testRouterServiceUrlForCorrectlyTransitionsToRouteViaGeneratedPathWithDynamicSegmentsAndQueryParams(assert) {
      var _this16 = this;

      assert.expect(1);
      var expectedURL;
      var actualURL;
      var queryParams = this.buildQueryParams({
        foo: 'bar'
      });
      var dynamicModel = {
        id: 1
      };
      this.add('route:dynamic', _routing.Route.extend({
        model: function () {
          return dynamicModel;
        }
      }));
      return this.visit('/').then(function () {
        expectedURL = _this16.routerService.urlFor('dynamic', dynamicModel, queryParams);
        return _this16.routerService.transitionTo(expectedURL);
      }).then(function () {
        actualURL = _this16.routerService.get('currentURL') + "?foo=bar";
        assert.equal(expectedURL, actualURL);
      });
    };

    return _class;
  }(_internalTestHelpers.RouterTestCase));
});
enifed("ember/tests/routing/substates_test", ["ember-babel", "@ember/-internals/runtime", "@ember/-internals/routing", "internal-test-helpers"], function (_emberBabel, _runtime, _routing, _internalTestHelpers) {
  "use strict";

  var counter;

  function step(assert, expectedValue, description) {
    assert.equal(counter, expectedValue, 'Step ' + expectedValue + ': ' + description);
    counter++;
  }

  (0, _internalTestHelpers.moduleFor)('Loading/Error Substates',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.apply(this, arguments) || this;
      counter = 1;

      _this.addTemplate('application', "<div id=\"app\">{{outlet}}</div>");

      _this.addTemplate('index', 'INDEX');

      return _this;
    }

    var _proto = _class.prototype;

    _proto.getController = function getController(name) {
      return this.applicationInstance.lookup("controller:" + name);
    };

    _proto['@test Slow promise from a child route of application enters nested loading state'] = function testSlowPromiseFromAChildRouteOfApplicationEntersNestedLoadingState(assert) {
      var _this2 = this;

      var turtleDeferred = _runtime.RSVP.defer();

      this.router.map(function () {
        this.route('turtle');
      });
      this.add('route:application', _routing.Route.extend({
        setupController: function () {
          step(assert, 2, 'ApplicationRoute#setupController');
        }
      }));
      this.add('route:turtle', _routing.Route.extend({
        model: function () {
          step(assert, 1, 'TurtleRoute#model');
          return turtleDeferred.promise;
        }
      }));
      this.addTemplate('turtle', 'TURTLE');
      this.addTemplate('loading', 'LOADING');
      var promise = this.visit('/turtle').then(function () {
        text = _this2.$('#app').text();
        assert.equal(text, 'TURTLE', "turtle template has loaded and replaced the loading template");
      });
      var text = this.$('#app').text();
      assert.equal(text, 'LOADING', "The Loading template is nested in application template's outlet");
      turtleDeferred.resolve();
      return promise;
    };

    _proto["@test Slow promises returned from ApplicationRoute#model don't enter LoadingRoute"] = function (assert) {
      var _this3 = this;

      var appDeferred = _runtime.RSVP.defer();

      this.add('route:application', _routing.Route.extend({
        model: function () {
          return appDeferred.promise;
        }
      }));
      this.add('route:loading', _routing.Route.extend({
        setupController: function () {
          assert.ok(false, "shouldn't get here");
        }
      }));
      var promise = this.visit('/').then(function () {
        var text = _this3.$('#app').text();

        assert.equal(text, 'INDEX', "index template has been rendered");
      });

      if (this.element) {
        assert.equal(this.element.textContent, '');
      }

      appDeferred.resolve();
      return promise;
    };

    _proto["@test Don't enter loading route unless either route or template defined"] = function (assert) {
      var _this4 = this;

      var deferred = _runtime.RSVP.defer();

      this.router.map(function () {
        this.route('dummy');
      });
      this.add('route:dummy', _routing.Route.extend({
        model: function () {
          return deferred.promise;
        }
      }));
      this.addTemplate('dummy', 'DUMMY');
      return this.visit('/').then(function () {
        var promise = _this4.visit('/dummy').then(function () {
          var text = _this4.$('#app').text();

          assert.equal(text, 'DUMMY', "dummy template has been rendered");
        });

        assert.ok(_this4.currentPath !== 'loading', "\n        loading state not entered\n      ");
        deferred.resolve();
        return promise;
      });
    };

    _proto['@test Enter loading route only if loadingRoute is defined'] = function testEnterLoadingRouteOnlyIfLoadingRouteIsDefined(assert) {
      var _this5 = this;

      var deferred = _runtime.RSVP.defer();

      this.router.map(function () {
        this.route('dummy');
      });
      this.add('route:dummy', _routing.Route.extend({
        model: function () {
          step(assert, 1, 'DummyRoute#model');
          return deferred.promise;
        }
      }));
      this.add('route:loading', _routing.Route.extend({
        setupController: function () {
          step(assert, 2, 'LoadingRoute#setupController');
        }
      }));
      this.addTemplate('dummy', 'DUMMY');
      return this.visit('/').then(function () {
        var promise = _this5.visit('/dummy').then(function () {
          var text = _this5.$('#app').text();

          assert.equal(text, 'DUMMY', "dummy template has been rendered");
        });

        assert.equal(_this5.currentPath, 'loading', "loading state entered");
        deferred.resolve();
        return promise;
      });
    };

    _proto['@test Slow promises returned from ApplicationRoute#model enter ApplicationLoadingRoute if present'] = function testSlowPromisesReturnedFromApplicationRouteModelEnterApplicationLoadingRouteIfPresent(assert) {
      var _this6 = this;

      var appDeferred = _runtime.RSVP.defer();

      this.add('route:application', _routing.Route.extend({
        model: function () {
          return appDeferred.promise;
        }
      }));
      var loadingRouteEntered = false;
      this.add('route:application_loading', _routing.Route.extend({
        setupController: function () {
          loadingRouteEntered = true;
        }
      }));
      var promise = this.visit('/').then(function () {
        assert.equal(_this6.$('#app').text(), 'INDEX', 'index route loaded');
      });
      assert.ok(loadingRouteEntered, 'ApplicationLoadingRoute was entered');
      appDeferred.resolve();
      return promise;
    };

    _proto['@test Slow promises returned from ApplicationRoute#model enter application_loading if template present'] = function testSlowPromisesReturnedFromApplicationRouteModelEnterApplication_loadingIfTemplatePresent(assert) {
      var _this7 = this;

      var appDeferred = _runtime.RSVP.defer();

      this.addTemplate('application_loading', "\n      <div id=\"toplevel-loading\">TOPLEVEL LOADING</div>\n    ");
      this.add('route:application', _routing.Route.extend({
        model: function () {
          return appDeferred.promise;
        }
      }));
      var promise = this.visit('/').then(function () {
        var length = _this7.$('#toplevel-loading').length;

        text = _this7.$('#app').text();
        assert.equal(length, 0, "top-level loading view has been entirely removed from the DOM");
        assert.equal(text, 'INDEX', 'index has fully rendered');
      });
      var text = this.$('#toplevel-loading').text();
      assert.equal(text, 'TOPLEVEL LOADING', 'still loading the top level');
      appDeferred.resolve();
      return promise;
    };

    _proto['@test Prioritized substate entry works with preserved-namespace nested routes'] = function testPrioritizedSubstateEntryWorksWithPreservedNamespaceNestedRoutes(assert) {
      var _this8 = this;

      var deferred = _runtime.RSVP.defer();

      this.addTemplate('foo.bar_loading', 'FOOBAR LOADING');
      this.addTemplate('foo.bar.index', 'YAY');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar', {
            path: '/bar'
          }, function () {});
        });
      });
      this.add('route:foo.bar', _routing.Route.extend({
        model: function () {
          return deferred.promise;
        }
      }));
      return this.visit('/').then(function () {
        var promise = _this8.visit('/foo/bar').then(function () {
          text = _this8.$('#app').text();
          assert.equal(text, 'YAY', 'foo.bar.index fully loaded');
        });

        var text = _this8.$('#app').text();

        assert.equal(text, 'FOOBAR LOADING', "foo.bar_loading was entered (as opposed to something like foo/foo/bar_loading)");
        deferred.resolve();
        return promise;
      });
    };

    _proto['@test Prioritized substate entry works with reset-namespace nested routes'] = function testPrioritizedSubstateEntryWorksWithResetNamespaceNestedRoutes(assert) {
      var _this9 = this;

      var deferred = _runtime.RSVP.defer();

      this.addTemplate('bar_loading', 'BAR LOADING');
      this.addTemplate('bar.index', 'YAY');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar', {
            path: '/bar',
            resetNamespace: true
          }, function () {});
        });
      });
      this.add('route:bar', _routing.Route.extend({
        model: function () {
          return deferred.promise;
        }
      }));
      return this.visit('/').then(function () {
        var promise = _this9.visit('/foo/bar').then(function () {
          text = _this9.$('#app').text();
          assert.equal(text, 'YAY', 'bar.index fully loaded');
        });

        var text = _this9.$('#app').text();

        assert.equal(text, 'BAR LOADING', "foo.bar_loading was entered (as opposed to something likefoo/foo/bar_loading)");
        deferred.resolve();
        return promise;
      });
    };

    _proto['@test Prioritized loading substate entry works with preserved-namespace nested routes'] = function testPrioritizedLoadingSubstateEntryWorksWithPreservedNamespaceNestedRoutes(assert) {
      var _this10 = this;

      var deferred = _runtime.RSVP.defer();

      this.addTemplate('foo.bar_loading', 'FOOBAR LOADING');
      this.addTemplate('foo.bar', 'YAY');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar');
        });
      });
      this.add('route:foo.bar', _routing.Route.extend({
        model: function () {
          return deferred.promise;
        }
      }));
      var promise = this.visit('/foo/bar').then(function () {
        text = _this10.$('#app').text();
        assert.equal(text, 'YAY', 'foo.bar has rendered');
      });
      var text = this.$('#app').text();
      assert.equal(text, 'FOOBAR LOADING', "foo.bar_loading was entered (as opposed to something like foo/foo/bar_loading)");
      deferred.resolve();
      return promise;
    };

    _proto['@test Prioritized error substate entry works with preserved-namespaec nested routes'] = function testPrioritizedErrorSubstateEntryWorksWithPreservedNamespaecNestedRoutes(assert) {
      var _this11 = this;

      this.addTemplate('foo.bar_error', 'FOOBAR ERROR: {{model.msg}}');
      this.addTemplate('foo.bar', 'YAY');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar');
        });
      });
      this.add('route:foo.bar', _routing.Route.extend({
        model: function () {
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        }
      }));
      return this.visit('/').then(function () {
        return _this11.visit('/foo/bar').then(function () {
          var text = _this11.$('#app').text();

          assert.equal(text, 'FOOBAR ERROR: did it broke?', "foo.bar_error was entered (as opposed to something like foo/foo/bar_error)");
        });
      });
    };

    _proto['@test Prioritized loading substate entry works with auto-generated index routes'] = function testPrioritizedLoadingSubstateEntryWorksWithAutoGeneratedIndexRoutes(assert) {
      var _this12 = this;

      var deferred = _runtime.RSVP.defer();

      this.addTemplate('foo.index_loading', 'FOO LOADING');
      this.addTemplate('foo.index', 'YAY');
      this.addTemplate('foo', '{{outlet}}');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar');
        });
      });
      this.add('route:foo.index', _routing.Route.extend({
        model: function () {
          return deferred.promise;
        }
      }));
      this.add('route:foo', _routing.Route.extend({
        model: function () {
          return true;
        }
      }));
      var promise = this.visit('/foo').then(function () {
        text = _this12.$('#app').text();
        assert.equal(text, 'YAY', 'foo.index was rendered');
      });
      var text = this.$('#app').text();
      assert.equal(text, 'FOO LOADING', 'foo.index_loading was entered');
      deferred.resolve();
      return promise;
    };

    _proto['@test Prioritized error substate entry works with auto-generated index routes'] = function testPrioritizedErrorSubstateEntryWorksWithAutoGeneratedIndexRoutes(assert) {
      var _this13 = this;

      this.addTemplate('foo.index_error', 'FOO ERROR: {{model.msg}}');
      this.addTemplate('foo.index', 'YAY');
      this.addTemplate('foo', '{{outlet}}');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar');
        });
      });
      this.add('route:foo.index', _routing.Route.extend({
        model: function () {
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        }
      }));
      this.add('route:foo', _routing.Route.extend({
        model: function () {
          return true;
        }
      }));
      return this.visit('/').then(function () {
        return _this13.visit('/foo').then(function () {
          var text = _this13.$('#app').text();

          assert.equal(text, 'FOO ERROR: did it broke?', 'foo.index_error was entered');
        });
      });
    };

    _proto['@test Rejected promises returned from ApplicationRoute transition into top-level application_error'] = function testRejectedPromisesReturnedFromApplicationRouteTransitionIntoTopLevelApplication_error(assert) {
      var _this14 = this;

      var reject = true;
      this.addTemplate('index', '<div id="index">INDEX</div>');
      this.add('route:application', _routing.Route.extend({
        init: function () {
          this._super.apply(this, arguments);
        },
        model: function () {
          if (reject) {
            return _runtime.RSVP.reject({
              msg: 'BAD NEWS BEARS'
            });
          } else {
            return {};
          }
        }
      }));
      this.addTemplate('application_error', "\n      <p id=\"toplevel-error\">TOPLEVEL ERROR: {{model.msg}}</p>\n    ");
      return this.visit('/').then(function () {
        var text = _this14.$('#toplevel-error').text();

        assert.equal(text, 'TOPLEVEL ERROR: BAD NEWS BEARS', 'toplevel error rendered');
        reject = false;
      }).then(function () {
        return _this14.visit('/');
      }).then(function () {
        var text = _this14.$('#index').text();

        assert.equal(text, 'INDEX', 'the index route resolved');
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "currentPath",
      get: function () {
        return this.getController('application').get('currentPath');
      }
    }]);
    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Loading/Error Substates - nested routes',
  /*#__PURE__*/
  function (_ApplicationTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase2);

    function _class2() {
      var _this15;

      _this15 = _ApplicationTestCase2.apply(this, arguments) || this;
      counter = 1;

      _this15.addTemplate('application', "<div id=\"app\">{{outlet}}</div>");

      _this15.addTemplate('index', 'INDEX');

      _this15.addTemplate('grandma', 'GRANDMA {{outlet}}');

      _this15.addTemplate('mom', 'MOM');

      _this15.router.map(function () {
        this.route('grandma', function () {
          this.route('mom', {
            resetNamespace: true
          }, function () {
            this.route('sally');
            this.route('this-route-throws');
          });
          this.route('puppies');
        });
        this.route('memere', {
          path: '/memere/:seg'
        }, function () {});
      });

      _this15.visit('/');

      return _this15;
    }

    var _proto2 = _class2.prototype;

    _proto2.getController = function getController(name) {
      return this.applicationInstance.lookup("controller:" + name);
    };

    _proto2['@test ApplicationRoute#currentPath reflects loading state path'] = function testApplicationRouteCurrentPathReflectsLoadingStatePath(assert) {
      var _this16 = this;

      var momDeferred = _runtime.RSVP.defer();

      this.addTemplate('grandma.loading', 'GRANDMALOADING');
      this.add('route:mom', _routing.Route.extend({
        model: function () {
          return momDeferred.promise;
        }
      }));
      var promise = this.visit('/grandma/mom').then(function () {
        text = _this16.$('#app').text();
        assert.equal(text, 'GRANDMA MOM', "Grandma.mom loaded text is displayed");
        assert.equal(_this16.currentPath, 'grandma.mom.index', "currentPath reflects final state");
      });
      var text = this.$('#app').text();
      assert.equal(text, 'GRANDMA GRANDMALOADING', "Grandma.mom loading text displayed");
      assert.equal(this.currentPath, 'grandma.loading', "currentPath reflects loading state");
      momDeferred.resolve();
      return promise;
    };

    _proto2["@test Loading actions bubble to root but don't enter substates above pivot "] = function (assert) {
      var _this17 = this;

      var sallyDeferred = _runtime.RSVP.defer();

      var puppiesDeferred = _runtime.RSVP.defer();

      this.add('route:application', _routing.Route.extend({
        actions: {
          loading: function () {
            assert.ok(true, 'loading action received on ApplicationRoute');
          }
        }
      }));
      this.add('route:mom.sally', _routing.Route.extend({
        model: function () {
          return sallyDeferred.promise;
        }
      }));
      this.add('route:grandma.puppies', _routing.Route.extend({
        model: function () {
          return puppiesDeferred.promise;
        }
      }));
      var promise = this.visit('/grandma/mom/sally');
      assert.equal(this.currentPath, 'index', 'Initial route fully loaded');
      sallyDeferred.resolve();
      promise.then(function () {
        assert.equal(_this17.currentPath, 'grandma.mom.sally', 'transition completed');

        var visit = _this17.visit('/grandma/puppies');

        assert.equal(_this17.currentPath, 'grandma.mom.sally', 'still in initial state because the only loading state is above the pivot route');
        return visit;
      }).then(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return puppiesDeferred.resolve();
        });
        assert.equal(_this17.currentPath, 'grandma.puppies', 'Finished transition');
      });
      return promise;
    };

    _proto2['@test Default error event moves into nested route'] = function testDefaultErrorEventMovesIntoNestedRoute(assert) {
      var _this18 = this;

      this.addTemplate('grandma.error', 'ERROR: {{model.msg}}');
      this.add('route:mom.sally', _routing.Route.extend({
        model: function () {
          step(assert, 1, 'MomSallyRoute#model');
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error: function () {
            step(assert, 2, 'MomSallyRoute#actions.error');
            return true;
          }
        }
      }));
      return this.visit('/grandma/mom/sally').then(function () {
        step(assert, 3, 'App finished loading');

        var text = _this18.$('#app').text();

        assert.equal(text, 'GRANDMA ERROR: did it broke?', 'error bubbles');
        assert.equal(_this18.currentPath, 'grandma.error', 'Initial route fully loaded');
      });
    };

    _proto2["@test Non-bubbled errors that re-throw aren't swallowed"] = function (assert) {
      var _this19 = this;

      this.add('route:mom.sally', _routing.Route.extend({
        model: function () {
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error: function (err) {
            // returns undefined which is falsey
            throw err;
          }
        }
      }));
      assert.throws(function () {
        _this19.visit('/grandma/mom/sally');
      }, function (err) {
        return err.msg === 'did it broke?';
      }, 'it broke');
      return (0, _internalTestHelpers.runLoopSettled)();
    };

    _proto2["@test Handled errors that re-throw aren't swallowed"] = function (assert) {
      var _this20 = this;

      var handledError;
      this.add('route:mom.sally', _routing.Route.extend({
        model: function () {
          step(assert, 1, 'MomSallyRoute#model');
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error: function (err) {
            step(assert, 2, 'MomSallyRoute#actions.error');
            handledError = err;
            this.transitionTo('mom.this-route-throws');
            return false;
          }
        }
      }));
      this.add('route:mom.this-route-throws', _routing.Route.extend({
        model: function () {
          step(assert, 3, 'MomThisRouteThrows#model');
          throw handledError;
        }
      }));
      assert.throws(function () {
        _this20.visit('/grandma/mom/sally');
      }, function (err) {
        return err.msg === 'did it broke?';
      }, "it broke");
      return (0, _internalTestHelpers.runLoopSettled)();
    };

    _proto2['@test errors that are bubbled are thrown at a higher level if not handled'] = function testErrorsThatAreBubbledAreThrownAtAHigherLevelIfNotHandled(assert) {
      var _this21 = this;

      this.add('route:mom.sally', _routing.Route.extend({
        model: function () {
          step(assert, 1, 'MomSallyRoute#model');
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error: function () {
            step(assert, 2, 'MomSallyRoute#actions.error');
            return true;
          }
        }
      }));
      assert.throws(function () {
        _this21.visit('/grandma/mom/sally');
      }, function (err) {
        return err.msg == 'did it broke?';
      }, 'Correct error was thrown');
      return (0, _internalTestHelpers.runLoopSettled)();
    };

    _proto2["@test Handled errors that are thrown through rejection aren't swallowed"] = function (assert) {
      var _this22 = this;

      var handledError;
      this.add('route:mom.sally', _routing.Route.extend({
        model: function () {
          step(assert, 1, 'MomSallyRoute#model');
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error: function (err) {
            step(assert, 2, 'MomSallyRoute#actions.error');
            handledError = err;
            this.transitionTo('mom.this-route-throws');
            return false;
          }
        }
      }));
      this.add('route:mom.this-route-throws', _routing.Route.extend({
        model: function () {
          step(assert, 3, 'MomThisRouteThrows#model');
          return _runtime.RSVP.reject(handledError);
        }
      }));
      assert.throws(function () {
        _this22.visit('/grandma/mom/sally');
      }, function (err) {
        return err.msg === 'did it broke?';
      }, 'it broke');
      return (0, _internalTestHelpers.runLoopSettled)();
    };

    _proto2['@test Default error events move into nested route, prioritizing more specifically named error routes - NEW'] = function testDefaultErrorEventsMoveIntoNestedRoutePrioritizingMoreSpecificallyNamedErrorRoutesNEW(assert) {
      var _this23 = this;

      this.addTemplate('grandma.error', 'ERROR: {{model.msg}}');
      this.addTemplate('mom_error', 'MOM ERROR: {{model.msg}}');
      this.add('route:mom.sally', _routing.Route.extend({
        model: function () {
          step(assert, 1, 'MomSallyRoute#model');
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error: function () {
            step(assert, 2, 'MomSallyRoute#actions.error');
            return true;
          }
        }
      }));
      return this.visit('/grandma/mom/sally').then(function () {
        step(assert, 3, 'Application finished booting');
        assert.equal(_this23.$('#app').text(), 'GRANDMA MOM ERROR: did it broke?', 'the more specifically named mome error substate was entered over the other error route');
        assert.equal(_this23.currentPath, 'grandma.mom_error', 'Initial route fully loaded');
      });
    };

    _proto2['@test Slow promises waterfall on startup'] = function testSlowPromisesWaterfallOnStartup(assert) {
      var _this24 = this;

      var grandmaDeferred = _runtime.RSVP.defer();

      var sallyDeferred = _runtime.RSVP.defer();

      this.addTemplate('loading', 'LOADING');
      this.addTemplate('mom', 'MOM {{outlet}}');
      this.addTemplate('mom.loading', 'MOMLOADING');
      this.addTemplate('mom.sally', 'SALLY');
      this.add('route:grandma', _routing.Route.extend({
        model: function () {
          step(assert, 1, 'GrandmaRoute#model');
          return grandmaDeferred.promise;
        }
      }));
      this.add('route:mom', _routing.Route.extend({
        model: function () {
          step(assert, 2, 'MomRoute#model');
          return {};
        }
      }));
      this.add('route:mom.sally', _routing.Route.extend({
        model: function () {
          step(assert, 3, 'SallyRoute#model');
          return sallyDeferred.promise;
        },
        setupController: function () {
          step(assert, 4, 'SallyRoute#setupController');
        }
      }));
      var promise = this.visit('/grandma/mom/sally').then(function () {
        text = _this24.$('#app').text();
        assert.equal(text, 'GRANDMA MOM SALLY', "Sally template displayed");
      });
      var text = this.$('#app').text();
      assert.equal(text, 'LOADING', "The loading template is nested in application template's outlet");
      (0, _internalTestHelpers.runTask)(function () {
        return grandmaDeferred.resolve();
      });
      text = this.$('#app').text();
      assert.equal(text, 'GRANDMA MOM MOMLOADING', "Mom's child loading route is displayed due to sally's slow promise");
      sallyDeferred.resolve();
      return promise;
    };

    _proto2['@test Enter child loading state of pivot route'] = function testEnterChildLoadingStateOfPivotRoute(assert) {
      var _this25 = this;

      var deferred = _runtime.RSVP.defer();

      this.addTemplate('grandma.loading', 'GMONEYLOADING');
      this.add('route:mom.sally', _routing.Route.extend({
        setupController: function () {
          step(assert, 1, 'SallyRoute#setupController');
        }
      }));
      this.add('route:grandma.puppies', _routing.Route.extend({
        model: function () {
          return deferred.promise;
        }
      }));
      return this.visit('/grandma/mom/sally').then(function () {
        assert.equal(_this25.currentPath, 'grandma.mom.sally', 'Initial route fully loaded');

        var promise = _this25.visit('/grandma/puppies').then(function () {
          assert.equal(_this25.currentPath, 'grandma.puppies', 'Finished transition');
        });

        assert.equal(_this25.currentPath, 'grandma.loading', "in pivot route's child loading state");
        deferred.resolve();
        return promise;
      });
    };

    _proto2["@test Error events that aren't bubbled don't throw application assertions"] = function (assert) {
      this.add('route:mom.sally', _routing.Route.extend({
        model: function () {
          step(assert, 1, 'MomSallyRoute#model');
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error: function (err) {
            step(assert, 2, 'MomSallyRoute#actions.error');
            assert.equal(err.msg, 'did it broke?', "it didn't break");
            return false;
          }
        }
      }));
      return this.visit('/grandma/mom/sally');
    };

    _proto2['@test Handled errors that bubble can be handled at a higher level'] = function testHandledErrorsThatBubbleCanBeHandledAtAHigherLevel(assert) {
      var handledError;
      this.add('route:mom', _routing.Route.extend({
        actions: {
          error: function (err) {
            step(assert, 3, 'MomRoute#actions.error');
            assert.equal(err, handledError, "error handled and rebubbled is handleable at higher route");
          }
        }
      }));
      this.add('route:mom.sally', _routing.Route.extend({
        model: function () {
          step(assert, 1, 'MomSallyRoute#model');
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error: function (err) {
            step(assert, 2, 'MomSallyRoute#actions.error');
            handledError = err;
            return true;
          }
        }
      }));
      return this.visit('/grandma/mom/sally');
    };

    _proto2['@test Setting a query param during a slow transition should work'] = function testSettingAQueryParamDuringASlowTransitionShouldWork(assert) {
      var _this26 = this;

      var deferred = _runtime.RSVP.defer();

      this.addTemplate('memere.loading', 'MMONEYLOADING');
      this.add('route:grandma', _routing.Route.extend({
        beforeModel: function () {
          this.transitionTo('memere', 1);
        }
      }));
      this.add('route:memere', _routing.Route.extend({
        queryParams: {
          test: {
            defaultValue: 1
          }
        }
      }));
      this.add('route:memere.index', _routing.Route.extend({
        model: function () {
          return deferred.promise;
        }
      }));
      var promise = this.visit('/grandma').then(function () {
        assert.equal(_this26.currentPath, 'memere.index', 'Transition should be complete');
      });
      var memereController = this.getController('memere');
      assert.equal(this.currentPath, 'memere.loading', 'Initial route should be loading');
      memereController.set('test', 3);
      assert.equal(this.currentPath, 'memere.loading', 'Initial route should still be loading');
      assert.equal(memereController.get('test'), 3, 'Controller query param value should have changed');
      deferred.resolve();
      return promise;
    };

    (0, _emberBabel.createClass)(_class2, [{
      key: "currentPath",
      get: function () {
        return this.getController('application').get('currentPath');
      }
    }]);
    return _class2;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/routing/toplevel_dom_test", ["ember-babel", "@ember/-internals/environment", "internal-test-helpers"], function (_emberBabel, _environment, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Top Level DOM Structure',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.apply(this, arguments) || this;
      _this._APPLICATION_TEMPLATE_WRAPPER = _environment.ENV._APPLICATION_TEMPLATE_WRAPPER;
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _ApplicationTestCase.prototype.teardown.call(this);

      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = this._APPLICATION_TEMPLATE_WRAPPER;
    };

    _proto['@test topmost template with wrapper'] = function testTopmostTemplateWithWrapper() {
      var _this2 = this;

      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = true;
      this.addTemplate('application', 'hello world');
      return this.visit('/').then(function () {
        _this2.assertComponentElement(_this2.element, {
          content: 'hello world'
        });
      });
    };

    _proto['@test topmost template without wrapper'] = function testTopmostTemplateWithoutWrapper() {
      var _this3 = this;

      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = false;
      this.addTemplate('application', 'hello world');
      return this.visit('/').then(function () {
        _this3.assertInnerHTML('hello world');
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/service_injection_test", ["ember-babel", "@ember/-internals/owner", "@ember/controller", "@ember/service", "@ember/-internals/runtime", "internal-test-helpers", "@ember/-internals/metal"], function (_emberBabel, _owner, _controller, _service, _runtime, _internalTestHelpers, _metal) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Service Injection',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Service can be injected and is resolved'] = function testServiceCanBeInjectedAndIsResolved(assert) {
      var _this = this;

      this.add('controller:application', _controller.default.extend({
        myService: (0, _service.inject)('my-service')
      }));

      var MyService = _service.default.extend();

      this.add('service:my-service', MyService);
      this.addTemplate('application', '');
      this.visit('/').then(function () {
        var controller = _this.applicationInstance.lookup('controller:application');

        assert.ok(controller.get('myService') instanceof MyService);
      });
    };

    _proto['@test Service can be an object proxy and access owner in init GH#16484'] = function testServiceCanBeAnObjectProxyAndAccessOwnerInInitGH16484(assert) {
      var _this2 = this;

      var serviceOwner;
      this.add('controller:application', _controller.default.extend({
        myService: (0, _service.inject)('my-service')
      }));

      var MyService = _service.default.extend(_runtime._ProxyMixin, {
        init: function () {
          this._super.apply(this, arguments);

          serviceOwner = (0, _owner.getOwner)(this);
        }
      });

      this.add('service:my-service', MyService);
      this.addTemplate('application', '');
      this.visit('/').then(function (instance) {
        var controller = _this2.applicationInstance.lookup('controller:application');

        assert.ok(controller.get('myService') instanceof MyService);
        assert.equal(serviceOwner, instance, 'should be able to `getOwner` in init');
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Service Injection with ES5 Getters',
  /*#__PURE__*/
  function (_ApplicationTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase2);

    function _class2() {
      return _ApplicationTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test Service can be injected and is resolved without calling `get`'] = function testServiceCanBeInjectedAndIsResolvedWithoutCallingGet(assert) {
      var _this3 = this;

      this.add('controller:application', _controller.default.extend({
        myService: (0, _service.inject)('my-service')
      }));

      var MyService = _service.default.extend({
        name: (0, _metal.computed)(function () {
          return 'The service name';
        })
      });

      this.add('service:my-service', MyService);
      this.addTemplate('application', '');
      this.visit('/').then(function () {
        var controller = _this3.applicationInstance.lookup('controller:application');

        assert.ok(controller.myService instanceof MyService);
        assert.equal(controller.myService.name, 'The service name', 'service property accessible');
      });
    };

    return _class2;
  }(_internalTestHelpers.ApplicationTestCase));

  if (false
  /* EMBER_MODULE_UNIFICATION */
  ) {
      (0, _internalTestHelpers.moduleFor)('Service Injection (MU)',
      /*#__PURE__*/
      function (_ApplicationTestCase3) {
        (0, _emberBabel.inheritsLoose)(_class3, _ApplicationTestCase3);

        function _class3() {
          return _ApplicationTestCase3.apply(this, arguments) || this;
        }

        var _proto3 = _class3.prototype;

        _proto3['@test Service can be injected with source and is resolved'] = function testServiceCanBeInjectedWithSourceAndIsResolved(assert) {
          var _this4 = this;

          var source = 'controller:src/ui/routes/application/controller';
          this.add('controller:application', _controller.default.extend({
            myService: (0, _service.inject)('my-service', {
              source: source
            })
          }));

          var MyService = _service.default.extend();

          this.add({
            specifier: 'service:my-service',
            source: source
          }, MyService);
          return this.visit('/').then(function () {
            var controller = _this4.applicationInstance.lookup('controller:application');

            assert.ok(controller.get('myService') instanceof MyService);
          });
        };

        _proto3['@test Services can be injected with same name, different source, and resolve different instances'] = function testServicesCanBeInjectedWithSameNameDifferentSourceAndResolveDifferentInstances(assert) {
          var _this5 = this; // This test implies that there is a file src/ui/routes/route-a/-services/my-service


          var routeASource = 'controller:src/ui/routes/route-a/controller'; // This test implies that there is a file src/ui/routes/route-b/-services/my-service

          var routeBSource = 'controller:src/ui/routes/route-b/controller';
          this.add('controller:route-a', _controller.default.extend({
            myService: (0, _service.inject)('my-service', {
              source: routeASource
            })
          }));
          this.add('controller:route-b', _controller.default.extend({
            myService: (0, _service.inject)('my-service', {
              source: routeBSource
            })
          }));

          var LocalLookupService = _service.default.extend();

          this.add({
            specifier: 'service:my-service',
            source: routeASource
          }, LocalLookupService);

          var MyService = _service.default.extend();

          this.add({
            specifier: 'service:my-service',
            source: routeBSource
          }, MyService);
          return this.visit('/').then(function () {
            var controllerA = _this5.applicationInstance.lookup('controller:route-a');

            var serviceFromControllerA = controllerA.get('myService');
            assert.ok(serviceFromControllerA instanceof LocalLookupService, 'local lookup service is returned');

            var controllerB = _this5.applicationInstance.lookup('controller:route-b');

            var serviceFromControllerB = controllerB.get('myService');
            assert.ok(serviceFromControllerB instanceof MyService, 'global service is returned');
            assert.notStrictEqual(serviceFromControllerA, serviceFromControllerB);
          });
        };

        _proto3['@test Services can be injected with same name, different source, but same resolution result, and share an instance'] = function testServicesCanBeInjectedWithSameNameDifferentSourceButSameResolutionResultAndShareAnInstance(assert) {
          var _this6 = this;

          var routeASource = 'controller:src/ui/routes/route-a/controller';
          var routeBSource = 'controller:src/ui/routes/route-b/controller';
          this.add('controller:route-a', _controller.default.extend({
            myService: (0, _service.inject)('my-service', {
              source: routeASource
            })
          }));
          this.add('controller:route-b', _controller.default.extend({
            myService: (0, _service.inject)('my-service', {
              source: routeBSource
            })
          }));

          var MyService = _service.default.extend();

          this.add({
            specifier: 'service:my-service'
          }, MyService);
          return this.visit('/').then(function () {
            var controllerA = _this6.applicationInstance.lookup('controller:route-a');

            var serviceFromControllerA = controllerA.get('myService');
            assert.ok(serviceFromControllerA instanceof MyService);

            var controllerB = _this6.applicationInstance.lookup('controller:route-b');

            assert.strictEqual(serviceFromControllerA, controllerB.get('myService'));
          });
        }
        /*
         * This test demonstrates a failure in the caching system of ember's
         * container around singletons and and local lookup. The local lookup
         * is cached and the global injection is then looked up incorrectly.
         *
         * The paractical rules of Ember's module unification config are such
         * that services cannot be locally looked up, thus this case is really
         * just a demonstration of what could go wrong if we permit arbitrary
         * configuration (such as a singleton type that has local lookup).
         */
        ;

        _proto3['@test Services can be injected with same name, one with source one without, and share an instance'] = function testServicesCanBeInjectedWithSameNameOneWithSourceOneWithoutAndShareAnInstance(assert) {
          var _this7 = this;

          var routeASource = 'controller:src/ui/routes/route-a/controller';
          this.add('controller:route-a', _controller.default.extend({
            myService: (0, _service.inject)('my-service', {
              source: routeASource
            })
          }));
          this.add('controller:route-b', _controller.default.extend({
            myService: (0, _service.inject)('my-service')
          }));

          var MyService = _service.default.extend();

          this.add({
            specifier: 'service:my-service'
          }, MyService);
          return this.visit('/').then(function () {
            var controllerA = _this7.applicationInstance.lookup('controller:route-a');

            var serviceFromControllerA = controllerA.get('myService');
            assert.ok(serviceFromControllerA instanceof MyService, 'global service is returned');

            var controllerB = _this7.applicationInstance.lookup('controller:route-b');

            var serviceFromControllerB = controllerB.get('myService');
            assert.ok(serviceFromControllerB instanceof MyService, 'global service is returned');
            assert.strictEqual(serviceFromControllerA, serviceFromControllerB);
          });
        };

        _proto3['@test Service with namespace can be injected and is resolved'] = function testServiceWithNamespaceCanBeInjectedAndIsResolved(assert) {
          var _this8 = this;

          this.add('controller:application', _controller.default.extend({
            myService: (0, _service.inject)('my-namespace::my-service')
          }));

          var MyService = _service.default.extend();

          this.add({
            specifier: 'service:my-service',
            namespace: 'my-namespace'
          }, MyService);
          this.visit('/').then(function () {
            var controller = _this8.applicationInstance.lookup('controller:application');

            assert.ok(controller.get('myService') instanceof MyService);
          });
        };

        return _class3;
      }(_internalTestHelpers.ApplicationTestCase));
    }
});
enifed("ember/tests/view_instrumentation_test", ["ember-babel", "@ember/instrumentation", "internal-test-helpers"], function (_emberBabel, _instrumentation, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('View Instrumentation',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.call(this) || this;

      _this.addTemplate('application', "{{outlet}}");

      _this.addTemplate('index', "<h1>Index</h1>");

      _this.addTemplate('posts', "<h1>Posts</h1>");

      _this.router.map(function () {
        this.route('posts');
      });

      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _instrumentation.reset)();

      _ApplicationTestCase.prototype.teardown.call(this);
    };

    _proto['@test Nodes without view instances are instrumented'] = function testNodesWithoutViewInstancesAreInstrumented(assert) {
      var _this2 = this;

      var called = false;
      (0, _instrumentation.subscribe)('render', {
        before: function () {
          called = true;
        },
        after: function () {}
      });
      return this.visit('/').then(function () {
        assert.equal(_this2.textValue(), 'Index', 'It rendered the correct template');
        assert.ok(called, 'Instrumentation called on first render');
        called = false;
        return _this2.visit('/posts');
      }).then(function () {
        assert.equal(_this2.textValue(), 'Posts', 'It rendered the correct template');
        assert.ok(called, 'Instrumentation called on transition to non-view backed route');
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("internal-test-helpers/index", ["exports", "internal-test-helpers/lib/factory", "internal-test-helpers/lib/build-owner", "internal-test-helpers/lib/confirm-export", "internal-test-helpers/lib/equal-inner-html", "internal-test-helpers/lib/equal-tokens", "internal-test-helpers/lib/module-for", "internal-test-helpers/lib/strip", "internal-test-helpers/lib/apply-mixins", "internal-test-helpers/lib/get-text-of", "internal-test-helpers/lib/matchers", "internal-test-helpers/lib/run", "internal-test-helpers/lib/test-context", "internal-test-helpers/lib/test-cases/abstract", "internal-test-helpers/lib/test-cases/abstract-application", "internal-test-helpers/lib/test-cases/application", "internal-test-helpers/lib/test-cases/query-param", "internal-test-helpers/lib/test-cases/abstract-rendering", "internal-test-helpers/lib/test-cases/rendering", "internal-test-helpers/lib/test-cases/router", "internal-test-helpers/lib/test-cases/autoboot-application", "internal-test-helpers/lib/test-cases/default-resolver-application", "internal-test-helpers/lib/test-resolver", "internal-test-helpers/lib/browser-detect", "internal-test-helpers/lib/registry-check"], function (_exports, _factory, _buildOwner, _confirmExport, _equalInnerHtml, _equalTokens, _moduleFor, _strip, _applyMixins, _getTextOf, _matchers, _run, _testContext, _abstract, _abstractApplication, _application, _queryParam, _abstractRendering, _rendering, _router, _autobootApplication, _defaultResolverApplication, _testResolver, _browserDetect, _registryCheck) {
  "use strict";

  Object.defineProperty(_exports, "factory", {
    enumerable: true,
    get: function () {
      return _factory.default;
    }
  });
  Object.defineProperty(_exports, "buildOwner", {
    enumerable: true,
    get: function () {
      return _buildOwner.default;
    }
  });
  Object.defineProperty(_exports, "confirmExport", {
    enumerable: true,
    get: function () {
      return _confirmExport.default;
    }
  });
  Object.defineProperty(_exports, "equalInnerHTML", {
    enumerable: true,
    get: function () {
      return _equalInnerHtml.default;
    }
  });
  Object.defineProperty(_exports, "equalTokens", {
    enumerable: true,
    get: function () {
      return _equalTokens.default;
    }
  });
  Object.defineProperty(_exports, "moduleFor", {
    enumerable: true,
    get: function () {
      return _moduleFor.default;
    }
  });
  Object.defineProperty(_exports, "setupTestClass", {
    enumerable: true,
    get: function () {
      return _moduleFor.setupTestClass;
    }
  });
  Object.defineProperty(_exports, "strip", {
    enumerable: true,
    get: function () {
      return _strip.default;
    }
  });
  Object.defineProperty(_exports, "applyMixins", {
    enumerable: true,
    get: function () {
      return _applyMixins.default;
    }
  });
  Object.defineProperty(_exports, "getTextOf", {
    enumerable: true,
    get: function () {
      return _getTextOf.default;
    }
  });
  Object.defineProperty(_exports, "equalsElement", {
    enumerable: true,
    get: function () {
      return _matchers.equalsElement;
    }
  });
  Object.defineProperty(_exports, "classes", {
    enumerable: true,
    get: function () {
      return _matchers.classes;
    }
  });
  Object.defineProperty(_exports, "styles", {
    enumerable: true,
    get: function () {
      return _matchers.styles;
    }
  });
  Object.defineProperty(_exports, "regex", {
    enumerable: true,
    get: function () {
      return _matchers.regex;
    }
  });
  Object.defineProperty(_exports, "runAppend", {
    enumerable: true,
    get: function () {
      return _run.runAppend;
    }
  });
  Object.defineProperty(_exports, "runDestroy", {
    enumerable: true,
    get: function () {
      return _run.runDestroy;
    }
  });
  Object.defineProperty(_exports, "runTask", {
    enumerable: true,
    get: function () {
      return _run.runTask;
    }
  });
  Object.defineProperty(_exports, "runTaskNext", {
    enumerable: true,
    get: function () {
      return _run.runTaskNext;
    }
  });
  Object.defineProperty(_exports, "runLoopSettled", {
    enumerable: true,
    get: function () {
      return _run.runLoopSettled;
    }
  });
  Object.defineProperty(_exports, "getContext", {
    enumerable: true,
    get: function () {
      return _testContext.getContext;
    }
  });
  Object.defineProperty(_exports, "setContext", {
    enumerable: true,
    get: function () {
      return _testContext.setContext;
    }
  });
  Object.defineProperty(_exports, "unsetContext", {
    enumerable: true,
    get: function () {
      return _testContext.unsetContext;
    }
  });
  Object.defineProperty(_exports, "AbstractTestCase", {
    enumerable: true,
    get: function () {
      return _abstract.default;
    }
  });
  Object.defineProperty(_exports, "AbstractApplicationTestCase", {
    enumerable: true,
    get: function () {
      return _abstractApplication.default;
    }
  });
  Object.defineProperty(_exports, "ApplicationTestCase", {
    enumerable: true,
    get: function () {
      return _application.default;
    }
  });
  Object.defineProperty(_exports, "QueryParamTestCase", {
    enumerable: true,
    get: function () {
      return _queryParam.default;
    }
  });
  Object.defineProperty(_exports, "AbstractRenderingTestCase", {
    enumerable: true,
    get: function () {
      return _abstractRendering.default;
    }
  });
  Object.defineProperty(_exports, "RenderingTestCase", {
    enumerable: true,
    get: function () {
      return _rendering.default;
    }
  });
  Object.defineProperty(_exports, "RouterTestCase", {
    enumerable: true,
    get: function () {
      return _router.default;
    }
  });
  Object.defineProperty(_exports, "AutobootApplicationTestCase", {
    enumerable: true,
    get: function () {
      return _autobootApplication.default;
    }
  });
  Object.defineProperty(_exports, "DefaultResolverApplicationTestCase", {
    enumerable: true,
    get: function () {
      return _defaultResolverApplication.default;
    }
  });
  Object.defineProperty(_exports, "TestResolver", {
    enumerable: true,
    get: function () {
      return _testResolver.default;
    }
  });
  Object.defineProperty(_exports, "ModuleBasedTestResolver", {
    enumerable: true,
    get: function () {
      return _testResolver.ModuleBasedResolver;
    }
  });
  Object.defineProperty(_exports, "isIE11", {
    enumerable: true,
    get: function () {
      return _browserDetect.isIE11;
    }
  });
  Object.defineProperty(_exports, "isEdge", {
    enumerable: true,
    get: function () {
      return _browserDetect.isEdge;
    }
  });
  Object.defineProperty(_exports, "verifyInjection", {
    enumerable: true,
    get: function () {
      return _registryCheck.verifyInjection;
    }
  });
  Object.defineProperty(_exports, "verifyRegistration", {
    enumerable: true,
    get: function () {
      return _registryCheck.verifyRegistration;
    }
  });
});
enifed("internal-test-helpers/lib/apply-mixins", ["exports", "@ember/polyfills", "internal-test-helpers/lib/get-all-property-names"], function (_exports, _polyfills, _getAllPropertyNames) {
  "use strict";

  _exports.default = applyMixins;

  function isGenerator(mixin) {
    return Array.isArray(mixin.cases) && typeof mixin.generate === 'function';
  }

  function applyMixins(TestClass) {
    for (var _len = arguments.length, mixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      mixins[_key - 1] = arguments[_key];
    }

    mixins.forEach(function (mixinOrGenerator) {
      var mixin;

      if (isGenerator(mixinOrGenerator)) {
        var generator = mixinOrGenerator;
        mixin = {};
        generator.cases.forEach(function (value, idx) {
          (0, _polyfills.assign)(mixin, generator.generate(value, idx));
        });
        (0, _polyfills.assign)(TestClass.prototype, mixin);
      } else if (typeof mixinOrGenerator === 'function') {
        var properties = (0, _getAllPropertyNames.default)(mixinOrGenerator);
        mixin = new mixinOrGenerator();
        properties.forEach(function (name) {
          TestClass.prototype[name] = function () {
            return mixin[name].apply(mixin, arguments);
          };
        });
      } else {
        mixin = mixinOrGenerator;
        (0, _polyfills.assign)(TestClass.prototype, mixin);
      }
    });
    return TestClass;
  }
});
enifed("internal-test-helpers/lib/browser-detect", ["exports"], function (_exports) {
  "use strict";

  _exports.isEdge = _exports.isIE11 = void 0;
  // `window.ActiveXObject` is "falsey" in IE11 (but not `undefined` or `false`)
  // `"ActiveXObject" in window` returns `true` in all IE versions
  // only IE11 will pass _both_ of these conditions
  var isIE11 = !window.ActiveXObject && 'ActiveXObject' in window;
  _exports.isIE11 = isIE11;
  var isEdge = /Edge/.test(navigator.userAgent);
  _exports.isEdge = isEdge;
});
enifed("internal-test-helpers/lib/build-owner", ["exports", "@ember/-internals/container", "@ember/-internals/routing", "@ember/application/instance", "@ember/application", "@ember/-internals/runtime"], function (_exports, _container, _routing, _instance, _application, _runtime) {
  "use strict";

  _exports.default = buildOwner;

  var ResolverWrapper =
  /*#__PURE__*/
  function () {
    function ResolverWrapper(resolver) {
      this.resolver = resolver;
    }

    var _proto = ResolverWrapper.prototype;

    _proto.create = function create() {
      return this.resolver;
    };

    return ResolverWrapper;
  }();

  function buildOwner() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var ownerOptions = options.ownerOptions || {};
    var resolver = options.resolver;
    var bootOptions = options.bootOptions || {};

    var Owner = _runtime.Object.extend(_runtime.RegistryProxyMixin, _runtime.ContainerProxyMixin);

    var namespace = _runtime.Object.create({
      Resolver: new ResolverWrapper(resolver)
    });

    var fallbackRegistry = _application.default.buildRegistry(namespace);

    fallbackRegistry.register('router:main', _routing.Router);
    var registry = new _container.Registry({
      fallback: fallbackRegistry
    });

    _instance.default.setupRegistry(registry, bootOptions);

    var owner = Owner.create({
      __registry__: registry,
      __container__: null
    }, ownerOptions);
    var container = registry.container({
      owner: owner
    });
    owner.__container__ = container;
    return owner;
  }
});
enifed("internal-test-helpers/lib/confirm-export", ["exports", "require"], function (_exports, _require) {
  "use strict";

  _exports.default = confirmExport;

  function getDescriptor(obj, path) {
    var parts = path.split('.');
    var value = obj;

    for (var i = 0; i < parts.length - 1; i++) {
      var part = parts[i];
      value = value[part];

      if (!value) {
        return undefined;
      }
    }

    var last = parts[parts.length - 1];
    return Object.getOwnPropertyDescriptor(value, last);
  }

  function confirmExport(Ember, assert, path, moduleId, exportName) {
    try {
      var desc = getDescriptor(Ember, path);
      assert.ok(desc, "the " + path + " property exists on the Ember global");

      if (typeof exportName === 'string') {
        var mod = (0, _require.default)(moduleId);
        assert.equal(desc.value, mod[exportName], "Ember." + path + " is exported correctly");
        assert.notEqual(mod[exportName], undefined, "Ember." + path + " is not `undefined`");
      } else if ('value' in desc) {
        assert.equal(desc.value, exportName.value, "Ember." + path + " is exported correctly");
      } else {
        var _mod = (0, _require.default)(moduleId);

        assert.equal(desc.get, _mod[exportName.get], "Ember." + path + " getter is exported correctly");
        assert.notEqual(desc.get, undefined, "Ember." + path + " getter is not undefined");

        if (exportName.set) {
          assert.equal(desc.set, _mod[exportName.set], "Ember." + path + " setter is exported correctly");
          assert.notEqual(desc.set, undefined, "Ember." + path + " setter is not undefined");
        }
      }
    } catch (error) {
      assert.pushResult({
        result: false,
        message: "An error occured while testing " + path + " is exported from " + moduleId + ".",
        source: error
      });
    }
  }
});
enifed("internal-test-helpers/lib/element-helpers", ["exports", "internal-test-helpers/lib/test-context"], function (_exports, _testContext) {
  "use strict";

  _exports.getElement = getElement;

  function getElement() {
    var context = (0, _testContext.getContext)();

    if (!context) {
      throw new Error('Test context is not set up.');
    }

    var element = context.element;

    if (!element) {
      throw new Error('`element` property on test context is not set up.');
    }

    return element;
  }
});
enifed("internal-test-helpers/lib/ember-dev/assertion", ["exports", "internal-test-helpers/lib/ember-dev/utils"], function (_exports, _utils) {
  "use strict";

  _exports.setupAssertionHelpers = setupAssertionHelpers;
  var BREAK = {};
  /*
    This assertion helper is used to test assertions made using Ember.assert.
    It injects two helpers onto `window`:
  
    - expectAssertion(func: Function, [expectedMessage: String | RegExp])
  
    This function calls `func` and asserts that `Ember.assert` is invoked during
    the execution. Moreover, it takes a String or a RegExp as a second optional
    argument that can be used to test if a specific assertion message was
    generated.
  
    - ignoreAssertion(func: Function)
  
    This function calls `func` and disables `Ember.assert` during the execution.
    In particular, this prevents `Ember.assert` from throw errors that would
    disrupt the control flow.
  */

  function setupAssertionHelpers(hooks, env) {
    hooks.beforeEach(function (assert) {
      var expectAssertion = function (func, expectedMessage) {
        if (env.runningProdBuild) {
          assert.ok(true, 'Assertions disabled in production builds.');
          return;
        }

        var sawCall = false;
        var actualMessage = undefined; // The try-catch statement is used to "exit" `func` as soon as
        // the first useful assertion has been produced.

        try {
          (0, _utils.callWithStub)(env, 'assert', func, function (message, test) {
            sawCall = true;

            if ((0, _utils.checkTest)(test)) {
              return;
            }

            actualMessage = message;
            throw BREAK;
          });
        } catch (e) {
          if (e !== BREAK) {
            throw e;
          }
        }

        check(assert, sawCall, actualMessage, expectedMessage);
      };

      var ignoreAssertion = function (func) {
        (0, _utils.callWithStub)(env, 'assert', func);
      };

      window.expectAssertion = expectAssertion;
      window.ignoreAssertion = ignoreAssertion;
    });
    hooks.afterEach(function () {
      window.expectAssertion = null;
      window.ignoreAssertion = null;
    });
  }

  function check(assert, sawCall, actualMessage, expectedMessage) {
    // Run assertions in an order that is useful when debugging a test failure.
    if (!sawCall) {
      assert.ok(false, "Expected Ember.assert to be called (Not called with any value).");
    } else if (!actualMessage) {
      assert.ok(false, "Expected a failing Ember.assert (Ember.assert called, but without a failing test).");
    } else {
      if (expectedMessage) {
        if (expectedMessage instanceof RegExp) {
          assert.ok(expectedMessage.test(actualMessage), "Expected failing Ember.assert: '" + expectedMessage + "', but got '" + actualMessage + "'.");
        } else {
          assert.equal(actualMessage, expectedMessage, "Expected failing Ember.assert: '" + expectedMessage + "', but got '" + actualMessage + "'.");
        }
      } else {
        // Positive assertion that assert was called
        assert.ok(true, 'Expected a failing Ember.assert.');
      }
    }
  }
});
enifed("internal-test-helpers/lib/ember-dev/containers", ["exports", "@ember/-internals/container"], function (_exports, _container) {
  "use strict";

  _exports.setupContainersCheck = setupContainersCheck;
  var containerLeakTracking = _container.Container._leakTracking;

  function setupContainersCheck(hooks) {
    hooks.afterEach(function () {
      if (containerLeakTracking === undefined) return;
      var _QUnit = QUnit,
          config = _QUnit.config;
      var _config$current = config.current,
          testName = _config$current.testName,
          testId = _config$current.testId,
          moduleName = _config$current.module.name,
          originalFinish = _config$current.finish;

      config.current.finish = function () {
        originalFinish.call(this);
        originalFinish = undefined;
        config.queue.unshift(function () {
          if (containerLeakTracking.hasContainers()) {
            containerLeakTracking.reset(); // eslint-disable-next-line no-console

            console.assert(false, "Leaked container after test " + moduleName + ": " + testName + " testId=" + testId);
          }
        });
      };
    });
  }
});
enifed("internal-test-helpers/lib/ember-dev/debug", ["exports", "internal-test-helpers/lib/ember-dev/method-call-tracker"], function (_exports, _methodCallTracker) {
  "use strict";

  _exports.default = void 0;

  var DebugAssert =
  /*#__PURE__*/
  function () {
    function DebugAssert(methodName, env) {
      this.methodName = methodName;
      this.env = env;
      this.tracker = null;
    }

    var _proto = DebugAssert.prototype;

    _proto.inject = function inject() {};

    _proto.restore = function restore() {
      this.reset();
    };

    _proto.reset = function reset() {
      if (this.tracker) {
        this.tracker.restoreMethod();
      }

      this.tracker = null;
    };

    _proto.assert = function assert() {
      if (this.tracker) {
        this.tracker.assert();
      }
    } // Run an expectation callback within the context of a new tracker, optionally
    // accepting a function to run, which asserts immediately
    ;

    _proto.runExpectation = function runExpectation(func, callback) {
      var originalTracker = null; // When helpers are passed a callback, they get a new tracker context

      if (func) {
        originalTracker = this.tracker;
        this.tracker = null;
      }

      if (!this.tracker) {
        this.tracker = new _methodCallTracker.default(this.env, this.methodName);
      } // Yield to caller with tracker instance


      callback(this.tracker); // Once the given callback is invoked, the pending assertions should be
      // flushed immediately

      if (func) {
        func();
        this.assert();
        this.reset();
        this.tracker = originalTracker;
      }
    };

    return DebugAssert;
  }();

  var _default = DebugAssert;
  _exports.default = _default;
});
enifed("internal-test-helpers/lib/ember-dev/deprecation", ["exports", "ember-babel", "internal-test-helpers/lib/ember-dev/debug", "internal-test-helpers/lib/ember-dev/utils"], function (_exports, _emberBabel, _debug, _utils) {
  "use strict";

  _exports.setupDeprecationHelpers = setupDeprecationHelpers;
  _exports.default = void 0;

  function setupDeprecationHelpers(hooks, env) {
    var assertion = new DeprecationAssert(env);
    hooks.beforeEach(function () {
      assertion.reset();
      assertion.inject();
    });
    hooks.afterEach(function () {
      assertion.assert();
      assertion.restore();
    });
  }

  var DeprecationAssert =
  /*#__PURE__*/
  function (_DebugAssert) {
    (0, _emberBabel.inheritsLoose)(DeprecationAssert, _DebugAssert);

    function DeprecationAssert(env) {
      return _DebugAssert.call(this, 'deprecate', env) || this;
    }

    var _proto = DeprecationAssert.prototype;

    _proto.inject = function inject() {
      var _this = this; // Expects no deprecation to happen within a function, or if no function is
      // passed, from the time of calling until the end of the test.
      //
      // expectNoDeprecation(function() {
      //   fancyNewThing();
      // });
      //
      // expectNoDeprecation();
      // Ember.deprecate("Old And Busted");
      //


      var expectNoDeprecation = function (func) {
        if (typeof func !== 'function') {
          func = undefined;
        }

        _this.runExpectation(func, function (tracker) {
          if (tracker.isExpectingCalls()) {
            throw new Error('expectNoDeprecation was called after expectDeprecation was called!');
          }

          tracker.expectNoCalls();
        });
      }; // Expect a deprecation to happen within a function, or if no function
      // is pass, from the time of calling until the end of the test. Can be called
      // multiple times to assert deprecations with different specific messages
      // were fired.
      //
      // expectDeprecation(function() {
      //   Ember.deprecate("Old And Busted");
      // }, /* optionalStringOrRegex */);
      //
      // expectDeprecation(/* optionalStringOrRegex */);
      // Ember.deprecate("Old And Busted");
      //


      var expectDeprecation = function (func, message) {
        var actualFunc;

        if (typeof func !== 'function') {
          message = func;
          actualFunc = undefined;
        } else {
          actualFunc = func;
        }

        _this.runExpectation(actualFunc, function (tracker) {
          if (tracker.isExpectingNoCalls()) {
            throw new Error('expectDeprecation was called after expectNoDeprecation was called!');
          }

          tracker.expectCall(message, ['id', 'until']);
        });
      };

      var ignoreDeprecation = function (func) {
        (0, _utils.callWithStub)(_this.env, 'deprecate', func);
      };

      window.expectNoDeprecation = expectNoDeprecation;
      window.expectDeprecation = expectDeprecation;
      window.ignoreDeprecation = ignoreDeprecation;
    };

    _proto.restore = function restore() {
      _DebugAssert.prototype.restore.call(this);

      window.expectDeprecation = null;
      window.expectNoDeprecation = null;
      window.ignoreDeprecation = null;
    };

    return DeprecationAssert;
  }(_debug.default);

  var _default = DeprecationAssert;
  _exports.default = _default;
});
enifed("internal-test-helpers/lib/ember-dev/method-call-tracker", ["exports", "internal-test-helpers/lib/ember-dev/utils"], function (_exports, _utils) {
  "use strict";

  _exports.default = void 0;

  var MethodCallTracker =
  /*#__PURE__*/
  function () {
    function MethodCallTracker(env, methodName) {
      this._env = env;
      this._methodName = methodName;
      this._isExpectingNoCalls = false;
      this._expectedMessages = [];
      this._expectedOptionLists = [];
      this._actuals = [];
      this._originalMethod = undefined;
    }

    var _proto = MethodCallTracker.prototype;

    _proto.stubMethod = function stubMethod() {
      var _this = this;

      if (this._originalMethod) {
        // Method is already stubbed
        return;
      }

      var env = this._env;
      var methodName = this._methodName;
      this._originalMethod = env.getDebugFunction(methodName);
      env.setDebugFunction(methodName, function (message, test, options) {
        var resultOfTest = (0, _utils.checkTest)(test);

        _this._actuals.push([message, resultOfTest, options]);
      });
    };

    _proto.restoreMethod = function restoreMethod() {
      if (this._originalMethod) {
        this._env.setDebugFunction(this._methodName, this._originalMethod);
      }
    };

    _proto.expectCall = function expectCall(message, options) {
      this.stubMethod();

      this._expectedMessages.push(message || /.*/);

      this._expectedOptionLists.push(options);
    };

    _proto.expectNoCalls = function expectNoCalls() {
      this.stubMethod();
      this._isExpectingNoCalls = true;
    };

    _proto.isExpectingNoCalls = function isExpectingNoCalls() {
      return this._isExpectingNoCalls;
    };

    _proto.isExpectingCalls = function isExpectingCalls() {
      return !this._isExpectingNoCalls && this._expectedMessages.length;
    };

    _proto.assert = function assert() {
      var assert = QUnit.config.current.assert;
      var env = this._env;
      var methodName = this._methodName;
      var isExpectingNoCalls = this._isExpectingNoCalls;
      var expectedMessages = this._expectedMessages;
      var expectedOptionLists = this._expectedOptionLists;
      var actuals = this._actuals;
      var o, i, j;

      if (!isExpectingNoCalls && expectedMessages.length === 0 && actuals.length === 0) {
        return;
      }

      if (env.runningProdBuild) {
        assert.ok(true, "calls to Ember." + methodName + " disabled in production builds.");
        return;
      }

      if (isExpectingNoCalls) {
        var actualMessages = [];

        for (i = 0; i < actuals.length; i++) {
          if (!actuals[i][1]) {
            actualMessages.push(actuals[i][0]);
          }
        }

        assert.ok(actualMessages.length === 0, "Expected no Ember." + methodName + " calls, got " + actuals.length + ": " + actualMessages.join(', '));
        return;
      }

      var actual;
      var match = undefined;

      for (o = 0; o < expectedMessages.length; o++) {
        var expectedMessage = expectedMessages[o];
        var expectedOptionList = expectedOptionLists[o];

        for (i = 0; i < actuals.length; i++) {
          var matchesMessage = false;
          var matchesOptionList = false;
          actual = actuals[i];

          if (actual[1] === true) {
            continue;
          }

          if (expectedMessage instanceof RegExp && expectedMessage.test(actual[0])) {
            matchesMessage = true;
          } else if (expectedMessage === actual[0]) {
            matchesMessage = true;
          }

          if (expectedOptionList === undefined) {
            matchesOptionList = true;
          } else if (actual[2]) {
            matchesOptionList = true;

            for (j = 0; j < expectedOptionList.length; j++) {
              matchesOptionList = matchesOptionList && actual[2].hasOwnProperty(expectedOptionList[j]);
            }
          }

          if (matchesMessage && matchesOptionList) {
            match = actual;
            break;
          }
        }

        var expectedOptionsMessage = expectedOptionList ? "and options: { " + expectedOptionList.join(', ') + " }" : 'and no options';
        var actualOptionsMessage = actual && actual[2] ? "and options: { " + Object.keys(actual[2]).join(', ') + " }" : 'and no options';

        if (!actual) {
          assert.ok(false, "Received no Ember." + methodName + " calls at all, expecting: " + expectedMessage);
        } else if (match && !match[1]) {
          assert.ok(true, "Received failing Ember." + methodName + " call with message: " + match[0]);
        } else if (match && match[1]) {
          assert.ok(false, "Expected failing Ember." + methodName + " call, got succeeding with message: " + match[0]);
        } else if (actual[1]) {
          assert.ok(false, "Did not receive failing Ember." + methodName + " call matching '" + expectedMessage + "' " + expectedOptionsMessage + ", last was success with '" + actual[0] + "' " + actualOptionsMessage);
        } else if (!actual[1]) {
          assert.ok(false, "Did not receive failing Ember." + methodName + " call matching '" + expectedMessage + "' " + expectedOptionsMessage + ", last was failure with '" + actual[0] + "' " + actualOptionsMessage);
        }
      }
    };

    return MethodCallTracker;
  }();

  _exports.default = MethodCallTracker;
});
enifed("internal-test-helpers/lib/ember-dev/namespaces", ["exports", "@ember/-internals/metal", "@ember/runloop"], function (_exports, _metal, _runloop) {
  "use strict";

  _exports.setupNamespacesCheck = setupNamespacesCheck;

  function setupNamespacesCheck(hooks) {
    hooks.afterEach(function () {
      var assert = QUnit.config.current.assert;

      if (_metal.NAMESPACES.length > 0) {
        assert.ok(false, 'Should not have any NAMESPACES after tests');
        (0, _runloop.run)(function () {
          var namespaces = _metal.NAMESPACES.slice();

          for (var i = 0; i < namespaces.length; i++) {
            namespaces[i].destroy();
          }
        });
      }

      var keys = Object.keys(_metal.NAMESPACES_BY_ID);

      if (keys.length > 0) {
        assert.ok(false, 'Should not have any NAMESPACES_BY_ID after tests');

        for (var i = 0; i < keys.length; i++) {
          delete _metal.NAMESPACES_BY_ID[keys[i]];
        }
      }
    });
  }
});
enifed("internal-test-helpers/lib/ember-dev/run-loop", ["exports", "@ember/runloop"], function (_exports, _runloop) {
  "use strict";

  _exports.setupRunLoopCheck = setupRunLoopCheck;

  // @ts-ignore
  function setupRunLoopCheck(hooks) {
    hooks.afterEach(function () {
      var assert = QUnit.config.current.assert;

      if ((0, _runloop.getCurrentRunLoop)()) {
        assert.ok(false, 'Should not be in a run loop at end of test');

        while ((0, _runloop.getCurrentRunLoop)()) {
          (0, _runloop.end)();
        }
      }

      if ((0, _runloop.hasScheduledTimers)()) {
        assert.ok(false, 'Ember run should not have scheduled timers at end of test');
        (0, _runloop.cancelTimers)();
      }
    });
  }
});
enifed("internal-test-helpers/lib/ember-dev/setup-qunit", ["exports", "@ember/debug", "internal-test-helpers/lib/ember-dev/assertion", "internal-test-helpers/lib/ember-dev/containers", "internal-test-helpers/lib/ember-dev/deprecation", "internal-test-helpers/lib/ember-dev/namespaces", "internal-test-helpers/lib/ember-dev/run-loop", "internal-test-helpers/lib/ember-dev/warning"], function (_exports, _debug, _assertion, _containers, _deprecation, _namespaces, _runLoop, _warning) {
  "use strict";

  _exports.default = setupQUnit;

  function setupQUnit(_ref) {
    var runningProdBuild = _ref.runningProdBuild;
    var env = {
      runningProdBuild: runningProdBuild,
      getDebugFunction: _debug.getDebugFunction,
      setDebugFunction: _debug.setDebugFunction
    };
    var originalModule = QUnit.module;

    QUnit.module = function (name, callback) {
      return originalModule(name, function (hooks) {
        (0, _containers.setupContainersCheck)(hooks);
        (0, _namespaces.setupNamespacesCheck)(hooks);
        (0, _runLoop.setupRunLoopCheck)(hooks);
        (0, _assertion.setupAssertionHelpers)(hooks, env);
        (0, _deprecation.setupDeprecationHelpers)(hooks, env);
        (0, _warning.setupWarningHelpers)(hooks, env);
        callback(hooks);
      });
    };
  }
});
enifed("internal-test-helpers/lib/ember-dev/utils", ["exports"], function (_exports) {
  "use strict";

  _exports.callWithStub = callWithStub;
  _exports.checkTest = checkTest;

  function noop() {}

  function callWithStub(env, name, func) {
    var debugStub = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;
    var originalFunc = env.getDebugFunction(name);

    try {
      env.setDebugFunction(name, debugStub);
      func();
    } finally {
      env.setDebugFunction(name, originalFunc);
    }
  }

  function checkTest(test) {
    return typeof test === 'function' ? test() : test;
  }
});
enifed("internal-test-helpers/lib/ember-dev/warning", ["exports", "ember-babel", "internal-test-helpers/lib/ember-dev/debug", "internal-test-helpers/lib/ember-dev/utils"], function (_exports, _emberBabel, _debug, _utils) {
  "use strict";

  _exports.setupWarningHelpers = setupWarningHelpers;
  _exports.default = void 0;

  function setupWarningHelpers(hooks, env) {
    var assertion = new WarningAssert(env);
    hooks.beforeEach(function () {
      assertion.reset();
      assertion.inject();
    });
    hooks.afterEach(function () {
      assertion.assert();
      assertion.restore();
    });
  }

  var WarningAssert =
  /*#__PURE__*/
  function (_DebugAssert) {
    (0, _emberBabel.inheritsLoose)(WarningAssert, _DebugAssert);

    function WarningAssert(env) {
      return _DebugAssert.call(this, 'warn', env) || this;
    }

    var _proto = WarningAssert.prototype;

    _proto.inject = function inject() {
      var _this = this; // Expects no warning to happen within a function, or if no function is
      // passed, from the time of calling until the end of the test.
      //
      // expectNoWarning(function() {
      //   fancyNewThing();
      // });
      //
      // expectNoWarning();
      // Ember.warn("Oh snap, didn't expect that");
      //


      var expectNoWarning = function (func) {
        if (typeof func !== 'function') {
          func = undefined;
        }

        _this.runExpectation(func, function (tracker) {
          if (tracker.isExpectingCalls()) {
            throw new Error('expectNoWarning was called after expectWarning was called!');
          }

          tracker.expectNoCalls();
        });
      }; // Expect a warning to happen within a function, or if no function is
      // passed, from the time of calling until the end of the test. Can be called
      // multiple times to assert warnings with different specific messages
      // happened.
      //
      // expectWarning(function() {
      //   Ember.warn("Times they are a-changin'");
      // }, /* optionalStringOrRegex */);
      //
      // expectWarning(/* optionalStringOrRegex */);
      // Ember.warn("Times definitely be changin'");
      //


      var expectWarning = function (func, message) {
        var actualFunc;

        if (typeof func !== 'function') {
          message = func;
          actualFunc = undefined;
        } else {
          actualFunc = func;
        }

        _this.runExpectation(actualFunc, function (tracker) {
          if (tracker.isExpectingNoCalls()) {
            throw new Error('expectWarning was called after expectNoWarning was called!');
          }

          tracker.expectCall(message);
        });
      };

      var ignoreWarning = function (func) {
        (0, _utils.callWithStub)(_this.env, 'warn', func);
      };

      window.expectNoWarning = expectNoWarning;
      window.expectWarning = expectWarning;
      window.ignoreWarning = ignoreWarning;
    };

    _proto.restore = function restore() {
      _DebugAssert.prototype.restore.call(this);

      window.expectWarning = null;
      window.expectNoWarning = null;
      window.ignoreWarning = null;
    };

    return WarningAssert;
  }(_debug.default);

  var _default = WarningAssert;
  _exports.default = _default;
});
enifed("internal-test-helpers/lib/equal-inner-html", ["exports"], function (_exports) {
  "use strict";

  _exports.default = equalInnerHTML;

  // detect side-effects of cloning svg elements in IE9-11
  var ieSVGInnerHTML = function () {
    if (!document.createElementNS) {
      return false;
    }

    var div = document.createElement('div');
    var node = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    div.appendChild(node);
    var clone = div.cloneNode(true);
    return clone.innerHTML === '<svg xmlns="http://www.w3.org/2000/svg" />';
  }();

  function normalizeInnerHTML(actualHTML) {
    if (ieSVGInnerHTML) {
      // Replace `<svg xmlns="http://www.w3.org/2000/svg" height="50%" />` with `<svg height="50%"></svg>`, etc.
      // drop namespace attribute
      // replace self-closing elements
      actualHTML = actualHTML.replace(/ xmlns="[^"]+"/, '').replace(/<([^ >]+) [^\/>]*\/>/gi, function (tag, tagName) {
        return tag.slice(0, tag.length - 3) + "></" + tagName + ">";
      });
    }

    return actualHTML;
  }

  function equalInnerHTML(assert, fragment, html) {
    var actualHTML = normalizeInnerHTML(fragment.innerHTML);
    assert.pushResult({
      result: actualHTML === html,
      actual: actualHTML,
      expected: html
    });
  }
});
enifed("internal-test-helpers/lib/equal-tokens", ["exports", "simple-html-tokenizer"], function (_exports, _simpleHtmlTokenizer) {
  "use strict";

  _exports.default = equalTokens;

  function generateTokens(containerOrHTML) {
    if (typeof containerOrHTML === 'string') {
      return {
        tokens: (0, _simpleHtmlTokenizer.tokenize)(containerOrHTML),
        html: containerOrHTML
      };
    } else {
      return {
        tokens: (0, _simpleHtmlTokenizer.tokenize)(containerOrHTML.innerHTML),
        html: containerOrHTML.innerHTML
      };
    }
  }

  function normalizeTokens(tokens) {
    tokens.forEach(function (token) {
      if (token.type === 'StartTag') {
        token.attributes = token.attributes.sort(function (a, b) {
          if (a[0] > b[0]) {
            return 1;
          }

          if (a[0] < b[0]) {
            return -1;
          }

          return 0;
        });
      }
    });
  }

  function equalTokens(actualContainer, expectedHTML) {
    var message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var actual = generateTokens(actualContainer);
    var expected = generateTokens(expectedHTML);
    normalizeTokens(actual.tokens);
    normalizeTokens(expected.tokens);
    var assert = QUnit.config.current.assert;
    var equiv = QUnit.equiv(actual.tokens, expected.tokens);

    if (equiv && expected.html !== actual.html) {
      assert.deepEqual(actual.tokens, expected.tokens, message);
    } else {
      assert.pushResult({
        result: QUnit.equiv(actual.tokens, expected.tokens),
        actual: actual.html,
        expected: expected.html,
        message: message
      });
    }
  }
});
enifed("internal-test-helpers/lib/factory", ["exports"], function (_exports) {
  "use strict";

  _exports.default = factory;

  function setProperties(object, properties) {
    for (var key in properties) {
      if (properties.hasOwnProperty(key)) {
        object[key] = properties[key];
      }
    }
  }

  var guids = 0;

  function factory() {
    function Klass(options) {
      setProperties(this, options);
      this._guid = guids++;
      this.isDestroyed = false;
    }

    Klass.prototype.constructor = Klass;

    Klass.prototype.destroy = function () {
      this.isDestroyed = true;
    };

    Klass.prototype.toString = function () {
      return '<Factory:' + this._guid + '>';
    };

    Klass.create = create;
    Klass.extend = extend;
    Klass.reopen = extend;
    Klass.reopenClass = reopenClass;
    return Klass;

    function create(options) {
      return new this.prototype.constructor(options);
    }

    function reopenClass(options) {
      setProperties(this, options);
    }

    function extend(options) {
      function Child(options) {
        Klass.call(this, options);
      }

      var Parent = this;
      Child.prototype = new Parent();
      Child.prototype.constructor = Child;
      setProperties(Child, Klass);
      setProperties(Child.prototype, options);
      Child.create = create;
      Child.extend = extend;
      Child.reopen = extend;
      Child.reopenClass = reopenClass;
      return Child;
    }
  }
});
enifed("internal-test-helpers/lib/get-all-property-names", ["exports"], function (_exports) {
  "use strict";

  _exports.default = getAllPropertyNames;

  function getAllPropertyNames(Klass) {
    var proto = Klass.prototype;
    var properties = new Set();

    while (proto !== Object.prototype) {
      var names = Object.getOwnPropertyNames(proto);
      names.forEach(function (name) {
        return properties.add(name);
      });
      proto = Object.getPrototypeOf(proto);
    }

    return properties;
  }
});
enifed("internal-test-helpers/lib/get-text-of", ["exports"], function (_exports) {
  "use strict";

  _exports.default = getTextOf;

  function getTextOf(elem) {
    return elem.textContent.trim();
  }
});
enifed("internal-test-helpers/lib/matchers", ["exports"], function (_exports) {
  "use strict";

  _exports.regex = regex;
  _exports.classes = classes;
  _exports.styles = styles;
  _exports.equalsElement = equalsElement;
  var HTMLElement = window.HTMLElement;
  var MATCHER_BRAND = '3d4ef194-13be-4ccf-8dc7-862eea02c93e';

  function isMatcher(obj) {
    return typeof obj === 'object' && obj !== null && MATCHER_BRAND in obj;
  }

  function equalsAttr(expected) {
    var _ref;

    return _ref = {}, _ref[MATCHER_BRAND] = true, _ref.match = function (actual) {
      return expected === actual;
    }, _ref.expected = function () {
      return expected;
    }, _ref.message = function () {
      return "should equal " + this.expected();
    }, _ref;
  }

  function regex(r) {
    var _ref2;

    return _ref2 = {}, _ref2[MATCHER_BRAND] = true, _ref2.match = function (v) {
      return r.test(v);
    }, _ref2.expected = function () {
      return r.toString();
    }, _ref2.message = function () {
      return "should match " + this.expected();
    }, _ref2;
  }

  function classes(expected) {
    var _ref3;

    return _ref3 = {}, _ref3[MATCHER_BRAND] = true, _ref3.match = function (actual) {
      actual = actual.trim();
      return actual && expected.split(/\s+/).sort().join(' ') === actual.trim().split(/\s+/).sort().join(' ');
    }, _ref3.expected = function () {
      return expected;
    }, _ref3.message = function () {
      return "should match " + this.expected();
    }, _ref3;
  }

  function styles(expected) {
    var _ref4;

    return _ref4 = {}, _ref4[MATCHER_BRAND] = true, _ref4.match = function (actual) {
      // coerce `null` or `undefined` to an empty string
      // needed for matching empty styles on IE9 - IE11
      actual = actual || '';
      actual = actual.trim();
      return expected.split(';').map(function (s) {
        return s.trim();
      }).filter(function (s) {
        return s;
      }).sort().join('; ') === actual.split(';').map(function (s) {
        return s.trim();
      }).filter(function (s) {
        return s;
      }).sort().join('; ');
    }, _ref4.expected = function () {
      return expected;
    }, _ref4.message = function () {
      return "should match " + this.expected();
    }, _ref4;
  }

  function equalsElement(assert, element, tagName, attributes, content) {
    assert.pushResult({
      result: element.tagName === tagName.toUpperCase(),
      actual: element.tagName.toLowerCase(),
      expected: tagName,
      message: "expect tagName to be " + tagName
    });
    var expectedAttrs = {};
    var expectedCount = 0;

    for (var name in attributes) {
      var expected = attributes[name];

      if (expected !== null) {
        expectedCount++;
      }

      var matcher = isMatcher(expected) ? expected : equalsAttr(expected);
      expectedAttrs[name] = matcher;
      assert.pushResult({
        result: expectedAttrs[name].match(element.getAttribute(name)),
        actual: element.getAttribute(name),
        expected: matcher.expected(),
        message: "Element's " + name + " attribute " + matcher.message()
      });
    }

    var actualAttributes = {};

    for (var i = 0, l = element.attributes.length; i < l; i++) {
      actualAttributes[element.attributes[i].name] = element.attributes[i].value;
    }

    if (!(element instanceof HTMLElement)) {
      assert.pushResult({
        result: element instanceof HTMLElement,
        message: 'Element must be an HTML Element, not an SVG Element'
      });
    } else {
      assert.pushResult({
        result: element.attributes.length === expectedCount || !attributes,
        actual: element.attributes.length,
        expected: expectedCount,
        message: "Expected " + expectedCount + " attributes; got " + element.outerHTML
      });

      if (content !== null) {
        assert.pushResult({
          result: element.innerHTML === content,
          actual: element.innerHTML,
          expected: content,
          message: "The element had '" + content + "' as its content"
        });
      }
    }
  }
});
enifed("internal-test-helpers/lib/module-for", ["exports", "@ember/canary-features", "internal-test-helpers/lib/apply-mixins", "internal-test-helpers/lib/get-all-property-names", "internal-test-helpers/lib/test-context", "rsvp"], function (_exports, _canaryFeatures, _applyMixins, _getAllPropertyNames, _testContext, _rsvp) {
  "use strict";

  _exports.default = moduleFor;
  _exports.setupTestClass = setupTestClass;

  function moduleFor(description, TestClass) {
    for (var _len = arguments.length, mixins = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      mixins[_key - 2] = arguments[_key];
    }

    QUnit.module(description, function (hooks) {
      setupTestClass.apply(void 0, [hooks, TestClass].concat(mixins));
    });
  }

  function setupTestClass(hooks, TestClass) {
    hooks.beforeEach(function (assert) {
      var instance = new TestClass(assert);
      this.instance = instance;
      (0, _testContext.setContext)(instance);

      if (instance.beforeEach) {
        return instance.beforeEach(assert);
      }
    });
    hooks.afterEach(function () {
      var promises = [];
      var instance = this.instance;
      this.instance = null;

      if (instance.teardown) {
        promises.push(instance.teardown());
      }

      if (instance.afterEach) {
        promises.push(instance.afterEach());
      } // this seems odd, but actually saves significant time
      // in the test suite
      //
      // returning a promise from a QUnit test always adds a 13ms
      // delay to the test, this filtering prevents returning a
      // promise when it is not needed


      var filteredPromises = promises.filter(Boolean);

      if (filteredPromises.length > 0) {
        return (0, _rsvp.all)(filteredPromises).finally(function () {
          return (0, _testContext.unsetContext)();
        });
      }

      (0, _testContext.unsetContext)();
    });

    for (var _len2 = arguments.length, mixins = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      mixins[_key2 - 2] = arguments[_key2];
    }

    if (mixins.length > 0) {
      _applyMixins.default.apply(void 0, [TestClass].concat(mixins));
    }

    var properties = (0, _getAllPropertyNames.default)(TestClass);
    properties.forEach(generateTest);

    function shouldTest(features) {
      return features.every(function (feature) {
        if (feature[0] === '!' && (0, _canaryFeatures.isEnabled)(feature.slice(1))) {
          return false;
        } else if (!(0, _canaryFeatures.isEnabled)(feature)) {
          return false;
        } else {
          return true;
        }
      });
    }

    function generateTest(name) {
      if (name.indexOf('@test ') === 0) {
        QUnit.test(name.slice(5), function (assert) {
          return this.instance[name](assert);
        });
      } else if (name.indexOf('@only ') === 0) {
        // eslint-disable-next-line qunit/no-only
        QUnit.only(name.slice(5), function (assert) {
          return this.instance[name](assert);
        });
      } else if (name.indexOf('@skip ') === 0) {
        QUnit.skip(name.slice(5), function (assert) {
          return this.instance[name](assert);
        });
      } else {
        var match = /^@feature\(([A-Z_a-z-!]+)\) /.exec(name);

        if (match) {
          var features = match[1].replace(/ /g, '').split(',');

          if (shouldTest(features)) {
            QUnit.test(name.slice(match[0].length), function (assert) {
              return this.instance[name](assert);
            });
          }
        }
      }
    }
  }
});
enifed("internal-test-helpers/lib/node-query", ["exports", "@ember/debug", "internal-test-helpers/lib/system/synthetic-events"], function (_exports, _debug, _syntheticEvents) {
  "use strict";

  _exports.default = void 0;

  /* global Node */
  var NodeQuery =
  /*#__PURE__*/
  function () {
    NodeQuery.query = function query(selector) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
      false && !(context && context instanceof Node) && (0, _debug.assert)("Invalid second parameter to NodeQuery.query", context && context instanceof Node);
      return new NodeQuery(toArray(context.querySelectorAll(selector)));
    };

    NodeQuery.element = function element(_element) {
      return new NodeQuery([_element]);
    };

    function NodeQuery(nodes) {
      false && !Array.isArray(nodes) && (0, _debug.assert)('NodeQuery must be initialized with a literal array', Array.isArray(nodes));
      this.nodes = nodes;

      for (var i = 0; i < nodes.length; i++) {
        this[i] = nodes[i];
      }

      this.length = nodes.length;
      Object.freeze(this);
    }

    var _proto = NodeQuery.prototype;

    _proto.find = function find(selector) {
      assertSingle(this);
      return this[0].querySelector(selector);
    };

    _proto.findAll = function findAll(selector) {
      var nodes = [];
      this.nodes.forEach(function (node) {
        nodes.push.apply(nodes, node.querySelectorAll(selector));
      });
      return new NodeQuery(nodes);
    };

    _proto.trigger = function trigger(eventName, options) {
      return this.nodes.map(function (node) {
        return (0, _syntheticEvents.fireEvent)(node, eventName, options);
      });
    };

    _proto.click = function click() {
      return this.trigger('click');
    };

    _proto.focus = function focus() {
      this.nodes.forEach(_syntheticEvents.focus);
    };

    _proto.text = function text() {
      return this.nodes.map(function (node) {
        return node.textContent;
      }).join('');
    };

    _proto.attr = function attr(name) {
      if (arguments.length !== 1) {
        throw new Error('not implemented');
      }

      assertSingle(this);
      return this.nodes[0].getAttribute(name);
    };

    _proto.prop = function prop(name, value) {
      if (arguments.length > 1) {
        return this.setProp(name, value);
      }

      assertSingle(this);
      return this.nodes[0][name];
    };

    _proto.setProp = function setProp(name, value) {
      this.nodes.forEach(function (node) {
        return node[name] = value;
      });
      return this;
    };

    _proto.val = function val(value) {
      if (arguments.length === 1) {
        return this.setProp('value', value);
      }

      return this.prop('value');
    };

    _proto.is = function is(selector) {
      return this.nodes.every(function (node) {
        return (0, _syntheticEvents.matches)(node, selector);
      });
    };

    _proto.hasClass = function hasClass(className) {
      return this.is("." + className);
    };

    return NodeQuery;
  }();

  _exports.default = NodeQuery;

  function assertSingle(nodeQuery) {
    if (nodeQuery.length !== 1) {
      throw new Error("attr(name) called on a NodeQuery with " + this.nodes.length + " elements. Expected one element.");
    }
  }

  function toArray(nodes) {
    var out = [];

    for (var i = 0; i < nodes.length; i++) {
      out.push(nodes[i]);
    }

    return out;
  }
});
enifed("internal-test-helpers/lib/registry-check", ["exports"], function (_exports) {
  "use strict";

  _exports.verifyRegistration = verifyRegistration;
  _exports.verifyInjection = verifyInjection;

  function verifyRegistration(assert, owner, fullName) {
    assert.ok(owner.resolveRegistration(fullName), "has registration: " + fullName);
  }

  function verifyInjection(assert, owner, fullName, property, injectionName) {
    var registry = owner.__registry__;
    var injections;

    if (fullName.indexOf(':') === -1) {
      injections = registry.getTypeInjections(fullName);
    } else {
      injections = registry.getInjections(registry.normalize(fullName));
    }

    var normalizedName = registry.normalize(injectionName);
    var hasInjection = false;
    var injection;

    for (var i = 0, l = injections.length; i < l; i++) {
      injection = injections[i];

      if (injection.property === property && injection.specifier === normalizedName) {
        hasInjection = true;
        break;
      }
    }

    assert.ok(hasInjection, "has injection: " + fullName + "." + property + " = " + injectionName);
  }
});
enifed("internal-test-helpers/lib/run", ["exports", "@ember/runloop", "rsvp"], function (_exports, _runloop, _rsvp) {
  "use strict";

  _exports.runAppend = runAppend;
  _exports.runDestroy = runDestroy;
  _exports.runTask = runTask;
  _exports.runTaskNext = runTaskNext;
  _exports.runLoopSettled = runLoopSettled;

  function runAppend(view) {
    (0, _runloop.run)(view, 'appendTo', document.getElementById('qunit-fixture'));
  }

  function runDestroy(toDestroy) {
    if (toDestroy) {
      (0, _runloop.run)(toDestroy, 'destroy');
    }
  }

  function runTask(callback) {
    return (0, _runloop.run)(callback);
  }

  function runTaskNext() {
    return new _rsvp.Promise(function (resolve) {
      return (0, _runloop.next)(resolve);
    });
  } // TODO: Find a better name 


  function runLoopSettled(event) {
    return new _rsvp.Promise(function (resolve) {
      // Every 5ms, poll for the async thing to have finished
      var watcher = setInterval(function () {
        // If there are scheduled timers or we are inside of a run loop, keep polling
        if ((0, _runloop.hasScheduledTimers)() || (0, _runloop.getCurrentRunLoop)()) {
          return;
        } // Stop polling


        clearInterval(watcher); // Synchronously resolve the promise

        resolve(event);
      }, 5);
    });
  }
});
enifed("internal-test-helpers/lib/strip", ["exports"], function (_exports) {
  "use strict";

  _exports.default = strip;

  function strip(_ref) {
    var strings = _ref.slice(0);

    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }

    var str = strings.map(function (string, index) {
      var interpolated = values[index];
      return string + (interpolated !== undefined ? interpolated : '');
    }).join('');
    return str.split('\n').map(function (s) {
      return s.trim();
    }).join('');
  }
});
enifed("internal-test-helpers/lib/system/synthetic-events", ["exports", "@ember/runloop", "@ember/polyfills"], function (_exports, _runloop, _polyfills) {
  "use strict";

  _exports.matches = matches;
  _exports.click = click;
  _exports.focus = focus;
  _exports.blur = blur;
  _exports.fireEvent = fireEvent;
  _exports.elMatches = void 0;

  /* globals Element */
  var DEFAULT_EVENT_OPTIONS = {
    canBubble: true,
    cancelable: true
  };
  var KEYBOARD_EVENT_TYPES = ['keydown', 'keypress', 'keyup'];
  var MOUSE_EVENT_TYPES = ['click', 'mousedown', 'mouseup', 'dblclick', 'mouseenter', 'mouseleave', 'mousemove', 'mouseout', 'mouseover'];
  var elMatches = typeof Element !== 'undefined' && (Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector);
  _exports.elMatches = elMatches;

  function matches(el, selector) {
    return elMatches.call(el, selector);
  }

  function isFocusable(el) {
    var focusableTags = ['INPUT', 'BUTTON', 'LINK', 'SELECT', 'A', 'TEXTAREA'];
    var tagName = el.tagName,
        type = el.type;

    if (type === 'hidden') {
      return false;
    }

    return focusableTags.indexOf(tagName) > -1 || el.contentEditable === 'true';
  }

  function click(el) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _runloop.run)(function () {
      return fireEvent(el, 'mousedown', options);
    });
    focus(el);
    (0, _runloop.run)(function () {
      return fireEvent(el, 'mouseup', options);
    });
    (0, _runloop.run)(function () {
      return fireEvent(el, 'click', options);
    });
  }

  function focus(el) {
    if (!el) {
      return;
    }

    if (isFocusable(el)) {
      (0, _runloop.run)(null, function () {
        var browserIsNotFocused = document.hasFocus && !document.hasFocus(); // Firefox does not trigger the `focusin` event if the window
        // does not have focus. If the document doesn't have focus just
        // use trigger('focusin') instead.

        if (browserIsNotFocused) {
          fireEvent(el, 'focusin');
        } // makes `document.activeElement` be `el`. If the browser is focused, it also fires a focus event


        el.focus(); // if the browser is not focused the previous `el.focus()` didn't fire an event, so we simulate it

        if (browserIsNotFocused) {
          fireEvent(el, 'focus');
        }
      });
    }
  }

  function blur(el) {
    if (isFocusable(el)) {
      (0, _runloop.run)(null, function () {
        var browserIsNotFocused = document.hasFocus && !document.hasFocus();
        fireEvent(el, 'focusout'); // makes `document.activeElement` be `body`.
        // If the browser is focused, it also fires a blur event

        el.blur(); // Chrome/Firefox does not trigger the `blur` event if the window
        // does not have focus. If the document does not have focus then
        // fire `blur` event via native event.

        if (browserIsNotFocused) {
          fireEvent(el, 'blur');
        }
      });
    }
  }

  function fireEvent(element, type) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (!element) {
      return;
    }

    var event;

    if (KEYBOARD_EVENT_TYPES.indexOf(type) > -1) {
      event = buildKeyboardEvent(type, options);
    } else if (MOUSE_EVENT_TYPES.indexOf(type) > -1) {
      var rect = element.getBoundingClientRect();
      var x = rect.left + 1;
      var y = rect.top + 1;
      var simulatedCoordinates = {
        screenX: x + 5,
        screenY: y + 95,
        clientX: x,
        clientY: y
      };
      event = buildMouseEvent(type, (0, _polyfills.assign)(simulatedCoordinates, options));
    } else {
      event = buildBasicEvent(type, options);
    }

    element.dispatchEvent(event);
    return event;
  }

  function buildBasicEvent(type) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var event = document.createEvent('Events');
    event.initEvent(type, true, true);
    (0, _polyfills.assign)(event, options);
    return event;
  }

  function buildMouseEvent(type) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var event;

    try {
      event = document.createEvent('MouseEvents');
      var eventOpts = (0, _polyfills.assign)({}, DEFAULT_EVENT_OPTIONS, options);
      event.initMouseEvent(type, eventOpts.canBubble, eventOpts.cancelable, window, eventOpts.detail, eventOpts.screenX, eventOpts.screenY, eventOpts.clientX, eventOpts.clientY, eventOpts.ctrlKey, eventOpts.altKey, eventOpts.shiftKey, eventOpts.metaKey, eventOpts.button, eventOpts.relatedTarget);
    } catch (e) {
      event = buildBasicEvent(type, options);
    }

    return event;
  }

  function buildKeyboardEvent(type) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var event;

    try {
      event = document.createEvent('KeyEvents');
      var eventOpts = (0, _polyfills.assign)({}, DEFAULT_EVENT_OPTIONS, options);
      event.initKeyEvent(type, eventOpts.canBubble, eventOpts.cancelable, window, eventOpts.ctrlKey, eventOpts.altKey, eventOpts.shiftKey, eventOpts.metaKey, eventOpts.keyCode, eventOpts.charCode);
    } catch (e) {
      event = buildBasicEvent(type, options);
    }

    return event;
  }
});
enifed("internal-test-helpers/lib/test-cases/abstract-application", ["exports", "ember-babel", "ember-template-compiler", "@ember/-internals/environment", "internal-test-helpers/lib/test-cases/abstract", "internal-test-helpers/lib/run"], function (_exports, _emberBabel, _emberTemplateCompiler, _environment, _abstract, _run) {
  "use strict";

  _exports.default = void 0;

  var AbstractApplicationTestCase =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(AbstractApplicationTestCase, _AbstractTestCase);

    function AbstractApplicationTestCase() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = AbstractApplicationTestCase.prototype;

    _proto._ensureInstance = function _ensureInstance(bootOptions) {
      var _this = this;

      if (this._applicationInstancePromise) {
        return this._applicationInstancePromise;
      }

      return this._applicationInstancePromise = (0, _run.runTask)(function () {
        return _this.application.boot();
      }).then(function (app) {
        _this.applicationInstance = app.buildInstance();
        return _this.applicationInstance.boot(bootOptions);
      });
    };

    _proto.visit = function visit(url, options) {
      var _this2 = this; // TODO: THIS IS HORRIBLE
      // the promise returned by `ApplicationInstance.protoype.visit` does **not**
      // currently guarantee rendering is completed


      return (0, _run.runTask)(function () {
        return _this2._ensureInstance(options).then(function (instance) {
          return instance.visit(url);
        });
      });
    };

    _proto.afterEach = function afterEach() {
      (0, _run.runDestroy)(this.applicationInstance);
      (0, _run.runDestroy)(this.application);

      _AbstractTestCase.prototype.teardown.call(this);
    };

    _proto.compile = function compile()
    /* string, options */
    {
      return _emberTemplateCompiler.compile.apply(void 0, arguments);
    };

    (0, _emberBabel.createClass)(AbstractApplicationTestCase, [{
      key: "element",
      get: function () {
        if (this._element) {
          return this._element;
        } else if (_environment.ENV._APPLICATION_TEMPLATE_WRAPPER) {
          return this._element = document.querySelector('#qunit-fixture > div.ember-view');
        } else {
          return this._element = document.querySelector('#qunit-fixture');
        }
      },
      set: function (element) {
        this._element = element;
      }
    }, {
      key: "applicationOptions",
      get: function () {
        return {
          rootElement: '#qunit-fixture'
        };
      }
    }, {
      key: "routerOptions",
      get: function () {
        return {
          location: 'none'
        };
      }
    }, {
      key: "router",
      get: function () {
        return this.application.resolveRegistration('router:main');
      }
    }]);
    return AbstractApplicationTestCase;
  }(_abstract.default);

  _exports.default = AbstractApplicationTestCase;
});
enifed("internal-test-helpers/lib/test-cases/abstract-rendering", ["exports", "ember-babel", "@ember/polyfills", "ember-template-compiler", "@ember/-internals/views", "@ember/-internals/glimmer", "internal-test-helpers/lib/test-resolver", "internal-test-helpers/lib/test-cases/abstract", "internal-test-helpers/lib/build-owner", "internal-test-helpers/lib/run"], function (_exports, _emberBabel, _polyfills, _emberTemplateCompiler, _views, _glimmer, _testResolver, _abstract, _buildOwner, _run) {
  "use strict";

  _exports.default = void 0;
  var TextNode = window.Text;

  var AbstractRenderingTestCase =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(AbstractRenderingTestCase, _AbstractTestCase);

    function AbstractRenderingTestCase() {
      var _this;

      _this = _AbstractTestCase.apply(this, arguments) || this;

      var bootOptions = _this.getBootOptions();

      var owner = _this.owner = (0, _buildOwner.default)({
        ownerOptions: _this.getOwnerOptions(),
        resolver: _this.getResolver(),
        bootOptions: bootOptions
      });
      _this.renderer = _this.owner.lookup('renderer:-dom');
      _this.element = document.querySelector('#qunit-fixture');
      _this.component = null;
      owner.register('event_dispatcher:main', _views.EventDispatcher);
      owner.inject('event_dispatcher:main', '_viewRegistry', '-view-registry:main');

      if (!bootOptions || bootOptions.isInteractive !== false) {
        owner.lookup('event_dispatcher:main').setup(_this.getCustomDispatcherEvents(), _this.element);
      }

      return _this;
    }

    var _proto = AbstractRenderingTestCase.prototype;

    _proto.compile = function compile() {
      return _emberTemplateCompiler.compile.apply(void 0, arguments);
    };

    _proto.getCustomDispatcherEvents = function getCustomDispatcherEvents() {
      return {};
    };

    _proto.getOwnerOptions = function getOwnerOptions() {};

    _proto.getBootOptions = function getBootOptions() {};

    _proto.getResolver = function getResolver() {
      return new _testResolver.ModuleBasedResolver();
    };

    _proto.add = function add(specifier, factory) {
      this.resolver.add(specifier, factory);
    };

    _proto.addTemplate = function addTemplate(templateName, templateString) {
      if (typeof templateName === 'string') {
        this.resolver.add("template:" + templateName, this.compile(templateString, {
          moduleName: templateName
        }));
      } else {
        this.resolver.add(templateName, this.compile(templateString, {
          moduleName: templateName.moduleName
        }));
      }
    };

    _proto.addComponent = function addComponent(name, _ref) {
      var _ref$ComponentClass = _ref.ComponentClass,
          ComponentClass = _ref$ComponentClass === void 0 ? null : _ref$ComponentClass,
          _ref$template = _ref.template,
          template = _ref$template === void 0 ? null : _ref$template;

      if (ComponentClass) {
        this.resolver.add("component:" + name, ComponentClass);
      }

      if (typeof template === 'string') {
        this.resolver.add("template:components/" + name, this.compile(template, {
          moduleName: "components/" + name
        }));
      }
    };

    _proto.afterEach = function afterEach() {
      try {
        if (this.component) {
          (0, _run.runDestroy)(this.component);
        }

        if (this.owner) {
          (0, _run.runDestroy)(this.owner);
        }
      } finally {
        (0, _glimmer._resetRenderers)();
      }
    };

    _proto.render = function render(templateStr) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var owner = this.owner;
      owner.register('template:-top-level', this.compile(templateStr, {
        moduleName: '-top-level'
      }));
      var attrs = (0, _polyfills.assign)({}, context, {
        tagName: '',
        layoutName: '-top-level'
      });
      owner.register('component:-top-level', _glimmer.Component.extend(attrs));
      this.component = owner.lookup('component:-top-level');
      (0, _run.runAppend)(this.component);
    };

    _proto.rerender = function rerender() {
      this.component.rerender();
    };

    _proto.registerHelper = function registerHelper(name, funcOrClassBody) {
      var type = typeof funcOrClassBody;

      if (type === 'function') {
        this.owner.register("helper:" + name, (0, _glimmer.helper)(funcOrClassBody));
      } else if (type === 'object' && type !== null) {
        this.owner.register("helper:" + name, _glimmer.Helper.extend(funcOrClassBody));
      } else {
        throw new Error("Cannot register " + funcOrClassBody + " as a helper");
      }
    };

    _proto.registerPartial = function registerPartial(name, template) {
      var owner = this.env.owner || this.owner;

      if (typeof template === 'string') {
        owner.register("template:" + name, this.compile(template, {
          moduleName: "my-app/templates/-" + name + ".hbs"
        }));
      }
    };

    _proto.registerComponent = function registerComponent(name, _ref2) {
      var _ref2$ComponentClass = _ref2.ComponentClass,
          ComponentClass = _ref2$ComponentClass === void 0 ? _glimmer.Component : _ref2$ComponentClass,
          _ref2$template = _ref2.template,
          template = _ref2$template === void 0 ? null : _ref2$template;
      var owner = this.owner;

      if (ComponentClass) {
        owner.register("component:" + name, ComponentClass);
      }

      if (typeof template === 'string') {
        owner.register("template:components/" + name, this.compile(template, {
          moduleName: "my-app/templates/components/" + name + ".hbs"
        }));
      }
    };

    _proto.registerModifier = function registerModifier(name, ModifierClass) {
      var owner = this.owner;
      owner.register("modifier:" + name, ModifierClass);
    };

    _proto.registerComponentManager = function registerComponentManager(name, manager) {
      var owner = this.env.owner || this.owner;
      owner.register("component-manager:" + name, manager);
    };

    _proto.registerTemplate = function registerTemplate(name, template) {
      var owner = this.owner;

      if (typeof template === 'string') {
        owner.register("template:" + name, this.compile(template, {
          moduleName: "my-app/templates/" + name + ".hbs"
        }));
      } else {
        throw new Error("Registered template \"" + name + "\" must be a string");
      }
    };

    _proto.registerService = function registerService(name, klass) {
      this.owner.register("service:" + name, klass);
    };

    _proto.assertTextNode = function assertTextNode(node, text) {
      if (!(node instanceof TextNode)) {
        throw new Error("Expecting a text node, but got " + node);
      }

      this.assert.strictEqual(node.textContent, text, 'node.textContent');
    };

    (0, _emberBabel.createClass)(AbstractRenderingTestCase, [{
      key: "resolver",
      get: function () {
        return this.owner.__registry__.fallback.resolver;
      }
    }, {
      key: "context",
      get: function () {
        return this.component;
      }
    }]);
    return AbstractRenderingTestCase;
  }(_abstract.default);

  _exports.default = AbstractRenderingTestCase;
});
enifed("internal-test-helpers/lib/test-cases/abstract", ["exports", "ember-babel", "@ember/polyfills", "internal-test-helpers/lib/node-query", "internal-test-helpers/lib/equal-inner-html", "internal-test-helpers/lib/equal-tokens", "internal-test-helpers/lib/element-helpers", "internal-test-helpers/lib/matchers", "internal-test-helpers/lib/run"], function (_exports, _emberBabel, _polyfills, _nodeQuery, _equalInnerHtml, _equalTokens, _elementHelpers, _matchers, _run) {
  "use strict";

  _exports.default = void 0;

  /* global Element */
  var TextNode = window.Text;
  var HTMLElement = window.HTMLElement;
  var Comment = window.Comment;

  function isMarker(node) {
    if (node instanceof Comment && node.textContent === '') {
      return true;
    }

    if (node instanceof TextNode && node.textContent === '') {
      return true;
    }

    return false;
  }

  var AbstractTestCase =
  /*#__PURE__*/
  function () {
    function AbstractTestCase(assert) {
      this.element = null;
      this.snapshot = null;
      this.assert = assert;
      var fixture = this.fixture;

      if (fixture) {
        this.setupFixture(fixture);
      }
    }

    var _proto = AbstractTestCase.prototype;

    _proto.teardown = function teardown() {};

    _proto.afterEach = function afterEach() {};

    _proto.setupFixture = function setupFixture(innerHTML) {
      var fixture = document.getElementById('qunit-fixture');
      fixture.innerHTML = innerHTML;
    } // The following methods require `this.element` to work
    ;

    _proto.nthChild = function nthChild(n) {
      var i = 0;
      var node = (0, _elementHelpers.getElement)().firstChild;

      while (node) {
        if (!isMarker(node)) {
          i++;
        }

        if (i > n) {
          break;
        } else {
          node = node.nextSibling;
        }
      }

      return node;
    };

    _proto.$ = function $(sel) {
      if (sel instanceof Element) {
        return _nodeQuery.default.element(sel);
      } else if (typeof sel === 'string') {
        return _nodeQuery.default.query(sel, (0, _elementHelpers.getElement)());
      } else if (sel !== undefined) {
        throw new Error("Invalid this.$(" + sel + ")");
      } else {
        return _nodeQuery.default.element((0, _elementHelpers.getElement)());
      }
    };

    _proto.wrap = function wrap(element) {
      return _nodeQuery.default.element(element);
    };

    _proto.click = function click(selector) {
      var element;

      if (typeof selector === 'string') {
        element = (0, _elementHelpers.getElement)().querySelector(selector);
      } else {
        element = selector;
      }

      var event = element.click();
      return (0, _run.runLoopSettled)(event);
    };

    _proto.textValue = function textValue() {
      return (0, _elementHelpers.getElement)().textContent;
    };

    _proto.takeSnapshot = function takeSnapshot() {
      var snapshot = this.snapshot = [];
      var node = (0, _elementHelpers.getElement)().firstChild;

      while (node) {
        if (!isMarker(node)) {
          snapshot.push(node);
        }

        node = node.nextSibling;
      }

      return snapshot;
    };

    _proto.assertText = function assertText(text) {
      this.assert.strictEqual(this.textValue(), text, "#qunit-fixture content should be: `" + text + "`");
    };

    _proto.assertInnerHTML = function assertInnerHTML(html) {
      (0, _equalInnerHtml.default)(this.assert, (0, _elementHelpers.getElement)(), html);
    };

    _proto.assertHTML = function assertHTML(html) {
      (0, _equalTokens.default)((0, _elementHelpers.getElement)(), html, "#qunit-fixture content should be: `" + html + "`");
    };

    _proto.assertElement = function assertElement(node, _ref) {
      var _ref$ElementType = _ref.ElementType,
          ElementType = _ref$ElementType === void 0 ? HTMLElement : _ref$ElementType,
          tagName = _ref.tagName,
          _ref$attrs = _ref.attrs,
          attrs = _ref$attrs === void 0 ? null : _ref$attrs,
          _ref$content = _ref.content,
          content = _ref$content === void 0 ? null : _ref$content;

      if (!(node instanceof ElementType)) {
        throw new Error("Expecting a " + ElementType.name + ", but got " + node);
      }

      (0, _matchers.equalsElement)(this.assert, node, tagName, attrs, content);
    };

    _proto.assertComponentElement = function assertComponentElement(node, _ref2) {
      var _ref2$ElementType = _ref2.ElementType,
          ElementType = _ref2$ElementType === void 0 ? HTMLElement : _ref2$ElementType,
          _ref2$tagName = _ref2.tagName,
          tagName = _ref2$tagName === void 0 ? 'div' : _ref2$tagName,
          _ref2$attrs = _ref2.attrs,
          attrs = _ref2$attrs === void 0 ? null : _ref2$attrs,
          _ref2$content = _ref2.content,
          content = _ref2$content === void 0 ? null : _ref2$content;
      attrs = (0, _polyfills.assign)({}, {
        id: (0, _matchers.regex)(/^ember\d*$/),
        class: (0, _matchers.classes)('ember-view')
      }, attrs || {});
      this.assertElement(node, {
        ElementType: ElementType,
        tagName: tagName,
        attrs: attrs,
        content: content
      });
    };

    _proto.assertSameNode = function assertSameNode(actual, expected) {
      this.assert.strictEqual(actual, expected, 'DOM node stability');
    };

    _proto.assertInvariants = function assertInvariants(oldSnapshot, newSnapshot) {
      oldSnapshot = oldSnapshot || this.snapshot;
      newSnapshot = newSnapshot || this.takeSnapshot();
      this.assert.strictEqual(newSnapshot.length, oldSnapshot.length, 'Same number of nodes');

      for (var i = 0; i < oldSnapshot.length; i++) {
        this.assertSameNode(newSnapshot[i], oldSnapshot[i]);
      }
    };

    _proto.assertPartialInvariants = function assertPartialInvariants(start, end) {
      this.assertInvariants(this.snapshot, this.takeSnapshot().slice(start, end));
    };

    _proto.assertStableRerender = function assertStableRerender() {
      var _this = this;

      this.takeSnapshot();
      (0, _run.runTask)(function () {
        return _this.rerender();
      });
      this.assertInvariants();
    };

    (0, _emberBabel.createClass)(AbstractTestCase, [{
      key: "firstChild",
      get: function () {
        return this.nthChild(0);
      }
    }, {
      key: "nodesCount",
      get: function () {
        var count = 0;
        var node = (0, _elementHelpers.getElement)().firstChild;

        while (node) {
          if (!isMarker(node)) {
            count++;
          }

          node = node.nextSibling;
        }

        return count;
      }
    }]);
    return AbstractTestCase;
  }();

  _exports.default = AbstractTestCase;
});
enifed("internal-test-helpers/lib/test-cases/application", ["exports", "ember-babel", "internal-test-helpers/lib/test-cases/test-resolver-application", "@ember/application", "@ember/-internals/routing", "@ember/polyfills", "internal-test-helpers/lib/run"], function (_exports, _emberBabel, _testResolverApplication, _application, _routing, _polyfills, _run) {
  "use strict";

  _exports.default = void 0;

  var ApplicationTestCase =
  /*#__PURE__*/
  function (_TestResolverApplicat) {
    (0, _emberBabel.inheritsLoose)(ApplicationTestCase, _TestResolverApplicat);

    function ApplicationTestCase() {
      var _this;

      _this = _TestResolverApplicat.apply(this, arguments) || this;

      var _assertThisInitialize = (0, _emberBabel.assertThisInitialized)((0, _emberBabel.assertThisInitialized)(_this)),
          applicationOptions = _assertThisInitialize.applicationOptions;

      _this.application = (0, _run.runTask)(_this.createApplication.bind((0, _emberBabel.assertThisInitialized)((0, _emberBabel.assertThisInitialized)(_this)), applicationOptions));
      _this.resolver = _this.application.__registry__.resolver;

      if (_this.resolver) {
        _this.resolver.add('router:main', _routing.Router.extend(_this.routerOptions));
      }

      return _this;
    }

    var _proto = ApplicationTestCase.prototype;

    _proto.createApplication = function createApplication() {
      var myOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var MyApplication = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _application.default;
      return MyApplication.create(myOptions);
    };

    _proto.transitionTo = function transitionTo() {
      var _this2 = this,
          _arguments = arguments;

      return (0, _run.runTask)(function () {
        var _this2$appRouter;

        return (_this2$appRouter = _this2.appRouter).transitionTo.apply(_this2$appRouter, _arguments);
      });
    };

    (0, _emberBabel.createClass)(ApplicationTestCase, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_TestResolverApplicat.prototype.applicationOptions, {
          autoboot: false
        });
      }
    }, {
      key: "appRouter",
      get: function () {
        return this.applicationInstance.lookup('router:main');
      }
    }]);
    return ApplicationTestCase;
  }(_testResolverApplication.default);

  _exports.default = ApplicationTestCase;
});
enifed("internal-test-helpers/lib/test-cases/autoboot-application", ["exports", "ember-babel", "internal-test-helpers/lib/test-cases/test-resolver-application", "@ember/application", "@ember/polyfills", "@ember/-internals/routing"], function (_exports, _emberBabel, _testResolverApplication, _application, _polyfills, _routing) {
  "use strict";

  _exports.default = void 0;

  var AutobootApplicationTestCase =
  /*#__PURE__*/
  function (_TestResolverApplicat) {
    (0, _emberBabel.inheritsLoose)(AutobootApplicationTestCase, _TestResolverApplicat);

    function AutobootApplicationTestCase() {
      return _TestResolverApplicat.apply(this, arguments) || this;
    }

    var _proto = AutobootApplicationTestCase.prototype;

    _proto.createApplication = function createApplication(options) {
      var MyApplication = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _application.default;
      var myOptions = (0, _polyfills.assign)(this.applicationOptions, options);
      var application = this.application = MyApplication.create(myOptions);
      this.resolver = application.__registry__.resolver;

      if (this.resolver) {
        this.resolver.add('router:main', _routing.Router.extend(this.routerOptions));
      }

      return application;
    };

    _proto.visit = function visit(url) {
      var _this = this;

      return this.application.boot().then(function () {
        return _this.applicationInstance.visit(url);
      });
    };

    (0, _emberBabel.createClass)(AutobootApplicationTestCase, [{
      key: "applicationInstance",
      get: function () {
        var application = this.application;

        if (!application) {
          return undefined;
        }

        return application.__deprecatedInstance__;
      }
    }]);
    return AutobootApplicationTestCase;
  }(_testResolverApplication.default);

  _exports.default = AutobootApplicationTestCase;
});
enifed("internal-test-helpers/lib/test-cases/default-resolver-application", ["exports", "ember-babel", "internal-test-helpers/lib/test-cases/abstract-application", "@ember/application/globals-resolver", "@ember/application", "@ember/-internals/glimmer", "@ember/polyfills", "@ember/-internals/routing", "internal-test-helpers/lib/run"], function (_exports, _emberBabel, _abstractApplication, _globalsResolver, _application, _glimmer, _polyfills, _routing, _run) {
  "use strict";

  _exports.default = void 0;

  var DefaultResolverApplicationTestCase =
  /*#__PURE__*/
  function (_AbstractApplicationT) {
    (0, _emberBabel.inheritsLoose)(DefaultResolverApplicationTestCase, _AbstractApplicationT);

    function DefaultResolverApplicationTestCase() {
      return _AbstractApplicationT.apply(this, arguments) || this;
    }

    var _proto = DefaultResolverApplicationTestCase.prototype;

    _proto.createApplication = function createApplication() {
      var application = this.application = _application.default.create(this.applicationOptions);

      application.Router = _routing.Router.extend(this.routerOptions);
      return application;
    };

    _proto.afterEach = function afterEach() {
      (0, _glimmer.setTemplates)({});
      return _AbstractApplicationT.prototype.afterEach.call(this);
    };

    _proto.transitionTo = function transitionTo() {
      var _this = this,
          _arguments = arguments;

      return (0, _run.runTask)(function () {
        var _this$appRouter;

        return (_this$appRouter = _this.appRouter).transitionTo.apply(_this$appRouter, _arguments);
      });
    };

    _proto.addTemplate = function addTemplate(name, templateString) {
      var compiled = this.compile(templateString);
      (0, _glimmer.setTemplate)(name, compiled);
      return compiled;
    };

    (0, _emberBabel.createClass)(DefaultResolverApplicationTestCase, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_AbstractApplicationT.prototype.applicationOptions, {
          name: 'TestApp',
          autoboot: false,
          Resolver: _globalsResolver.default
        });
      }
    }, {
      key: "appRouter",
      get: function () {
        return this.applicationInstance.lookup('router:main');
      }
    }]);
    return DefaultResolverApplicationTestCase;
  }(_abstractApplication.default);

  _exports.default = DefaultResolverApplicationTestCase;
});
enifed("internal-test-helpers/lib/test-cases/query-param", ["exports", "ember-babel", "@ember/controller", "@ember/-internals/routing", "@ember/runloop", "internal-test-helpers/lib/test-cases/application"], function (_exports, _emberBabel, _controller, _routing, _runloop, _application) {
  "use strict";

  _exports.default = void 0;

  var QueryParamTestCase =
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(QueryParamTestCase, _ApplicationTestCase);

    function QueryParamTestCase() {
      var _this;

      _this = _ApplicationTestCase.apply(this, arguments) || this;
      var testCase = (0, _emberBabel.assertThisInitialized)((0, _emberBabel.assertThisInitialized)(_this));
      testCase.expectedPushURL = null;
      testCase.expectedReplaceURL = null;

      _this.add('location:test', _routing.NoneLocation.extend({
        setURL: function (path) {
          if (testCase.expectedReplaceURL) {
            testCase.assert.ok(false, 'pushState occurred but a replaceState was expected');
          }

          if (testCase.expectedPushURL) {
            testCase.assert.equal(path, testCase.expectedPushURL, 'an expected pushState occurred');
            testCase.expectedPushURL = null;
          }

          this.set('path', path);
        },
        replaceURL: function (path) {
          if (testCase.expectedPushURL) {
            testCase.assert.ok(false, 'replaceState occurred but a pushState was expected');
          }

          if (testCase.expectedReplaceURL) {
            testCase.assert.equal(path, testCase.expectedReplaceURL, 'an expected replaceState occurred');
            testCase.expectedReplaceURL = null;
          }

          this.set('path', path);
        }
      }));

      return _this;
    }

    var _proto = QueryParamTestCase.prototype;

    _proto.visitAndAssert = function visitAndAssert(path) {
      var _this2 = this;

      return this.visit.apply(this, arguments).then(function () {
        _this2.assertCurrentPath(path);
      });
    };

    _proto.getController = function getController(name) {
      return this.applicationInstance.lookup("controller:" + name);
    };

    _proto.getRoute = function getRoute(name) {
      return this.applicationInstance.lookup("route:" + name);
    };

    _proto.setAndFlush = function setAndFlush(obj, prop, value) {
      return (0, _runloop.run)(obj, 'set', prop, value);
    };

    _proto.assertCurrentPath = function assertCurrentPath(path) {
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "current path equals '" + path + "'";
      this.assert.equal(this.appRouter.get('location.path'), path, message);
    }
    /**
      Sets up a Controller for a given route with a single query param and default
      value. Can optionally extend the controller with an object.
       @public
      @method setSingleQPController
    */
    ;

    _proto.setSingleQPController = function setSingleQPController(routeName) {
      var _Controller$extend;

      var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'foo';
      var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'bar';
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      this.add("controller:" + routeName, _controller.default.extend((_Controller$extend = {
        queryParams: [param]
      }, _Controller$extend[param] = defaultValue, _Controller$extend), options));
    }
    /**
      Sets up a Controller for a given route with a custom property/url key mapping.
       @public
      @method setMappedQPController
    */
    ;

    _proto.setMappedQPController = function setMappedQPController(routeName) {
      var _queryParams, _Controller$extend2;

      var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'page';
      var urlKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'parentPage';
      var defaultValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      this.add("controller:" + routeName, _controller.default.extend((_Controller$extend2 = {
        queryParams: (_queryParams = {}, _queryParams[prop] = urlKey, _queryParams)
      }, _Controller$extend2[prop] = defaultValue, _Controller$extend2), options));
    };

    (0, _emberBabel.createClass)(QueryParamTestCase, [{
      key: "routerOptions",
      get: function () {
        return {
          location: 'test'
        };
      }
    }]);
    return QueryParamTestCase;
  }(_application.default);

  _exports.default = QueryParamTestCase;
});
enifed("internal-test-helpers/lib/test-cases/rendering", ["exports", "ember-babel", "internal-test-helpers/lib/test-cases/abstract-rendering", "@ember/-internals/container"], function (_exports, _emberBabel, _abstractRendering, _container) {
  "use strict";

  _exports.default = void 0;

  function _templateObject() {
    var data = (0, _emberBabel.taggedTemplateLiteralLoose)(["template-compiler:main"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  var RenderingTestCase =
  /*#__PURE__*/
  function (_AbstractRenderingTes) {
    (0, _emberBabel.inheritsLoose)(RenderingTestCase, _AbstractRenderingTes);

    function RenderingTestCase() {
      var _this;

      _this = _AbstractRenderingTes.apply(this, arguments) || this;

      var _assertThisInitialize = (0, _emberBabel.assertThisInitialized)((0, _emberBabel.assertThisInitialized)(_this)),
          owner = _assertThisInitialize.owner;

      _this.env = owner.lookup('service:-glimmer-environment');
      _this.templateOptions = owner.lookup((0, _container.privatize)(_templateObject()));
      _this.compileTimeLookup = _this.templateOptions.resolver;
      _this.runtimeResolver = _this.compileTimeLookup.resolver;
      return _this;
    }

    return RenderingTestCase;
  }(_abstractRendering.default);

  _exports.default = RenderingTestCase;
});
enifed("internal-test-helpers/lib/test-cases/router", ["exports", "ember-babel", "internal-test-helpers/lib/test-cases/application"], function (_exports, _emberBabel, _application) {
  "use strict";

  _exports.default = void 0;

  var RouterTestCase =
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(RouterTestCase, _ApplicationTestCase);

    function RouterTestCase() {
      var _this;

      _this = _ApplicationTestCase.apply(this, arguments) || this;

      _this.router.map(function () {
        this.route('parent', {
          path: '/'
        }, function () {
          this.route('child');
          this.route('sister');
          this.route('brother');
        });
        this.route('dynamic', {
          path: '/dynamic/:dynamic_id'
        });
        this.route('dynamicWithChild', {
          path: '/dynamic-with-child/:dynamic_id'
        }, function () {
          this.route('child', {
            path: '/:child_id'
          });
        });
      });

      return _this;
    }

    var _proto = RouterTestCase.prototype;

    _proto.buildQueryParams = function buildQueryParams(queryParams) {
      return {
        queryParams: queryParams
      };
    };

    (0, _emberBabel.createClass)(RouterTestCase, [{
      key: "routerService",
      get: function () {
        return this.applicationInstance.lookup('service:router');
      }
    }]);
    return RouterTestCase;
  }(_application.default);

  _exports.default = RouterTestCase;
});
enifed("internal-test-helpers/lib/test-cases/test-resolver-application", ["exports", "ember-babel", "internal-test-helpers/lib/test-cases/abstract-application", "internal-test-helpers/lib/test-resolver", "@ember/-internals/glimmer", "@ember/polyfills"], function (_exports, _emberBabel, _abstractApplication, _testResolver, _glimmer, _polyfills) {
  "use strict";

  _exports.default = void 0;

  var TestResolverApplicationTestCase =
  /*#__PURE__*/
  function (_AbstractApplicationT) {
    (0, _emberBabel.inheritsLoose)(TestResolverApplicationTestCase, _AbstractApplicationT);

    function TestResolverApplicationTestCase() {
      return _AbstractApplicationT.apply(this, arguments) || this;
    }

    var _proto = TestResolverApplicationTestCase.prototype;

    _proto.add = function add(specifier, factory) {
      this.resolver.add(specifier, factory);
    };

    _proto.addTemplate = function addTemplate(templateName, templateString) {
      this.resolver.add("template:" + templateName, this.compile(templateString, {
        moduleName: "my-app/templates/" + templateName + ".hbs"
      }));
    };

    _proto.addComponent = function addComponent(name, _ref) {
      var _ref$ComponentClass = _ref.ComponentClass,
          ComponentClass = _ref$ComponentClass === void 0 ? _glimmer.Component : _ref$ComponentClass,
          _ref$template = _ref.template,
          template = _ref$template === void 0 ? null : _ref$template;

      if (ComponentClass) {
        this.resolver.add("component:" + name, ComponentClass);
      }

      if (typeof template === 'string') {
        this.resolver.add("template:components/" + name, this.compile(template, {
          moduleName: "my-app/templates/components/" + name + ".hbs"
        }));
      }
    };

    (0, _emberBabel.createClass)(TestResolverApplicationTestCase, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_AbstractApplicationT.prototype.applicationOptions, {
          Resolver: _testResolver.ModuleBasedResolver
        });
      }
    }]);
    return TestResolverApplicationTestCase;
  }(_abstractApplication.default);

  _exports.default = TestResolverApplicationTestCase;
});
enifed("internal-test-helpers/lib/test-context", ["exports"], function (_exports) {
  "use strict";

  _exports.setContext = setContext;
  _exports.getContext = getContext;
  _exports.unsetContext = unsetContext;

  var __test_context__;
  /**
   * Stores the provided context as the "global testing context".
   *
   * @param {Object} context the context to use
   */


  function setContext(context) {
    __test_context__ = context;
  }
  /**
   * Retrive the "global testing context" as stored by `setContext`.
   *
   * @returns {Object} the previously stored testing context
   */


  function getContext() {
    return __test_context__;
  }
  /**
   * Clear the "global testing context".
   */


  function unsetContext() {
    __test_context__ = undefined;
  }
});
enifed("internal-test-helpers/lib/test-resolver", ["exports", "ember-babel", "ember-template-compiler"], function (_exports, _emberBabel, _emberTemplateCompiler) {
  "use strict";

  _exports.ModuleBasedResolver = _exports.default = void 0;
  var DELIMITER = '%';

  function serializeKey(specifier, source, namespace) {
    var _specifier$split = specifier.split(':'),
        type = _specifier$split[0],
        name = _specifier$split[1];

    return type + "://" + [name, namespace ? '[source invalid due to namespace]' : source, namespace].join(DELIMITER);
  }

  var Resolver =
  /*#__PURE__*/
  function () {
    function Resolver() {
      this._registered = {};
    }

    var _proto = Resolver.prototype;

    _proto.resolve = function resolve(specifier) {
      return this._registered[specifier] || this._registered[serializeKey(specifier)];
    };

    _proto.expandLocalLookup = function expandLocalLookup(specifier, source, namespace) {
      if (specifier.indexOf('://') !== -1) {
        return specifier; // an already expanded specifier
      }

      if (source || namespace) {
        var key = serializeKey(specifier, source, namespace);

        if (this._registered[key]) {
          return key; // like local lookup
        }

        key = serializeKey(specifier);

        if (this._registered[key]) {
          return specifier; // top level resolution despite source/namespace
        }
      }

      return specifier; // didn't know how to expand it
    };

    _proto.add = function add(lookup, factory) {
      var key;

      switch (typeof lookup) {
        case 'string':
          if (lookup.indexOf(':') === -1) {
            throw new Error('Specifiers added to the resolver must be in the format of type:name');
          }

          key = serializeKey(lookup);
          break;

        case 'object':
          key = serializeKey(lookup.specifier, lookup.source, lookup.namespace);
          break;

        default:
          throw new Error('Specifier string has an unknown type');
      }

      return this._registered[key] = factory;
    };

    _proto.addTemplate = function addTemplate(templateName, template) {
      var templateType = typeof template;

      if (templateType !== 'string') {
        throw new Error("You called addTemplate for \"" + templateName + "\" with a template argument of type of '" + templateType + "'. addTemplate expects an argument of an uncompiled template as a string.");
      }

      return this._registered[serializeKey("template:" + templateName)] = (0, _emberTemplateCompiler.compile)(template, {
        moduleName: "my-app/templates/" + templateName + ".hbs"
      });
    };

    Resolver.create = function create() {
      return new this();
    };

    return Resolver;
  }();

  var _default = Resolver;
  /*
   * A resolver with moduleBasedResolver = true handles error and loading
   * substates differently than a standard resolver.
   */

  _exports.default = _default;

  var ModuleBasedResolver =
  /*#__PURE__*/
  function (_Resolver) {
    (0, _emberBabel.inheritsLoose)(ModuleBasedResolver, _Resolver);

    function ModuleBasedResolver() {
      return _Resolver.apply(this, arguments) || this;
    }

    (0, _emberBabel.createClass)(ModuleBasedResolver, [{
      key: "moduleBasedResolver",
      get: function () {
        return true;
      }
    }]);
    return ModuleBasedResolver;
  }(Resolver);

  _exports.ModuleBasedResolver = ModuleBasedResolver;
});
enifed("internal-test-helpers/tests/index-test", ["ember-babel", "internal-test-helpers"], function (_emberBabel, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('internal-test-helpers',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test module present'] = function testModulePresent(assert) {
      assert.ok(true, 'each package needs at least one test to be able to run through `npm test`');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
/*global enifed, module */
enifed('node-module', ['exports'], function(_exports) {
  var IS_NODE = typeof module === 'object' && typeof module.require === 'function';
  if (IS_NODE) {
    _exports.require = module.require;
    _exports.module = module;
    _exports.IS_NODE = IS_NODE;
  } else {
    _exports.require = null;
    _exports.module = null;
    _exports.IS_NODE = IS_NODE;
  }
});



}());
//# sourceMappingURL=ember-tests.prod.map
