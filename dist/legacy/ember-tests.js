(function() {
/*!
 * @overview  Ember - JavaScript Application Framework
 * @copyright Copyright 2011-2018 Tilde Inc. and contributors
 *            Portions Copyright 2006-2011 Strobe Inc.
 *            Portions Copyright 2008-2011 Apple Inc. All rights reserved.
 * @license   Licensed under MIT license
 *            See https://raw.github.com/emberjs/ember.js/master/LICENSE
 * @version   3.11.1
 */

/*globals process */
var enifed, requireModule, Ember;

// Used in @ember/-internals/environment/lib/global.js
mainContext = this; // eslint-disable-line no-undef

(function() {
  function missingModule(name, referrerName) {
    if (referrerName) {
      throw new Error('Could not find module ' + name + ' required by: ' + referrerName);
    } else {
      throw new Error('Could not find module ' + name);
    }
  }

  function internalRequire(_name, referrerName) {
    var name = _name;
    var mod = registry[name];

    if (!mod) {
      name = name + '/index';
      mod = registry[name];
    }

    var exports = seen[name];

    if (exports !== undefined) {
      return exports;
    }

    exports = seen[name] = {};

    if (!mod) {
      missingModule(_name, referrerName);
    }

    var deps = mod.deps;
    var callback = mod.callback;
    var reified = new Array(deps.length);

    for (var i = 0; i < deps.length; i++) {
      if (deps[i] === 'exports') {
        reified[i] = exports;
      } else if (deps[i] === 'require') {
        reified[i] = requireModule;
      } else {
        reified[i] = internalRequire(deps[i], name);
      }
    }

    callback.apply(this, reified);

    return exports;
  }

  var isNode =
    typeof window === 'undefined' &&
    typeof process !== 'undefined' &&
    {}.toString.call(process) === '[object process]';

  if (!isNode) {
    Ember = this.Ember = this.Ember || {};
  }

  if (typeof Ember === 'undefined') {
    Ember = {};
  }

  if (typeof Ember.__loader === 'undefined') {
    var registry = Object.create(null);
    var seen = Object.create(null);

    enifed = function(name, deps, callback) {
      var value = {};

      if (!callback) {
        value.deps = [];
        value.callback = deps;
      } else {
        value.deps = deps;
        value.callback = callback;
      }

      registry[name] = value;
    };

    requireModule = function(name) {
      return internalRequire(name, null);
    };

    // setup `require` module
    requireModule['default'] = requireModule;

    requireModule.has = function registryHas(moduleName) {
      return Boolean(registry[moduleName]) || Boolean(registry[moduleName + '/index']);
    };

    requireModule._eak_seen = registry;

    Ember.__loader = {
      define: enifed,
      require: requireModule,
      registry: registry,
    };
  } else {
    enifed = Ember.__loader.define;
    requireModule = Ember.__loader.require;
  }
})();

enifed("@ember/-internals/container/tests/container_test", ["ember-babel", "@ember/-internals/owner", "@ember/polyfills", "@ember/-internals/container", "internal-test-helpers"], function (_emberBabel, _owner, _polyfills, _container, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Container',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test A registered factory returns the same instance each time'] = function testARegisteredFactoryReturnsTheSameInstanceEachTime(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostController = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);
      var postController = container.lookup('controller:post');
      assert.ok(postController instanceof PostController, 'The lookup is an instance of the factory');
      assert.equal(postController, container.lookup('controller:post'));
    };

    _proto['@test uses create time injections if factory has no extend'] = function testUsesCreateTimeInjectionsIfFactoryHasNoExtend(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var AppleController = (0, _internalTestHelpers.factory)();
      var PostController = (0, _internalTestHelpers.factory)();
      PostController.extend = undefined; // remove extend

      registry.register('controller:apple', AppleController);
      registry.register('controller:post', PostController);
      registry.injection('controller:post', 'apple', 'controller:apple');
      var postController = container.lookup('controller:post');
      assert.ok(postController.apple instanceof AppleController, 'instance receives an apple of instance AppleController');
    };

    _proto['@test A registered factory returns a fresh instance if singleton: false is passed as an option'] = function testARegisteredFactoryReturnsAFreshInstanceIfSingletonFalseIsPassedAsAnOption(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostController = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);
      var postController1 = container.lookup('controller:post');
      var postController2 = container.lookup('controller:post', {
        singleton: false
      });
      var postController3 = container.lookup('controller:post', {
        singleton: false
      });
      var postController4 = container.lookup('controller:post');
      assert.equal(postController1.toString(), postController4.toString(), 'Singleton factories looked up normally return the same value');
      assert.notEqual(postController1.toString(), postController2.toString(), 'Singleton factories are not equal to factories looked up with singleton: false');
      assert.notEqual(postController2.toString(), postController3.toString(), 'Two factories looked up with singleton: false are not equal');
      assert.notEqual(postController3.toString(), postController4.toString(), 'A singleton factory looked up after a factory called with singleton: false is not equal');
      assert.ok(postController1 instanceof PostController, 'All instances are instances of the registered factory');
      assert.ok(postController2 instanceof PostController, 'All instances are instances of the registered factory');
      assert.ok(postController3 instanceof PostController, 'All instances are instances of the registered factory');
      assert.ok(postController4 instanceof PostController, 'All instances are instances of the registered factory');
    };

    _proto["@test A factory type with a registered injection's instances receive that injection"] = function testAFactoryTypeWithARegisteredInjectionSInstancesReceiveThatInjection(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostController = (0, _internalTestHelpers.factory)();
      var Store = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);
      registry.register('store:main', Store);
      registry.typeInjection('controller', 'store', 'store:main');
      var postController = container.lookup('controller:post');
      var store = container.lookup('store:main');
      assert.equal(postController.store, store);
    };

    _proto['@test An individual factory with a registered injection receives the injection'] = function testAnIndividualFactoryWithARegisteredInjectionReceivesTheInjection(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostController = (0, _internalTestHelpers.factory)();
      var Store = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);
      registry.register('store:main', Store);
      registry.injection('controller:post', 'store', 'store:main');
      var postController = container.lookup('controller:post');
      var store = container.lookup('store:main');
      assert.equal(postController.store, store, 'has the correct store injected');
    };

    _proto['@test A factory with both type and individual injections'] = function testAFactoryWithBothTypeAndIndividualInjections(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostController = (0, _internalTestHelpers.factory)();
      var Store = (0, _internalTestHelpers.factory)();
      var Router = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);
      registry.register('store:main', Store);
      registry.register('router:main', Router);
      registry.injection('controller:post', 'store', 'store:main');
      registry.typeInjection('controller', 'router', 'router:main');
      var postController = container.lookup('controller:post');
      var store = container.lookup('store:main');
      var router = container.lookup('router:main');
      assert.equal(postController.store, store);
      assert.equal(postController.router, router);
    };

    _proto['@test A non-singleton instance is never cached'] = function testANonSingletonInstanceIsNeverCached(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostView = (0, _internalTestHelpers.factory)();
      registry.register('view:post', PostView, {
        singleton: false
      });
      var postView1 = container.lookup('view:post');
      var postView2 = container.lookup('view:post');
      assert.ok(postView1 !== postView2, 'Non-singletons are not cached');
    };

    _proto['@test A non-instantiated property is not instantiated'] = function testANonInstantiatedPropertyIsNotInstantiated(assert) {
      var registry = new _container.Registry();
      var container = registry.container();

      var template = function () {};

      registry.register('template:foo', template, {
        instantiate: false
      });
      assert.equal(container.lookup('template:foo'), template);
    };

    _proto['@test A failed lookup returns undefined'] = function testAFailedLookupReturnsUndefined(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      assert.equal(container.lookup('doesnot:exist'), undefined);
    };

    _proto['@test An invalid factory throws an error'] = function testAnInvalidFactoryThrowsAnError(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      registry.register('controller:foo', {});
      assert.throws(function () {
        container.lookup('controller:foo');
      }, /Failed to create an instance of \'controller:foo\'/);
    };

    _proto['@test Injecting a failed lookup raises an error'] = function testInjectingAFailedLookupRaisesAnError() {
      var registry = new _container.Registry();
      var container = registry.container();
      var fooInstance = {};
      var fooFactory = {};
      var Foo = {
        create: function () {
          return fooInstance;
        },
        extend: function () {
          return fooFactory;
        }
      };
      registry.register('model:foo', Foo);
      registry.injection('model:foo', 'store', 'store:main');
      expectAssertion(function () {
        container.lookup('model:foo');
      });
    };

    _proto['@test Injecting a falsy value does not raise an error'] = function testInjectingAFalsyValueDoesNotRaiseAnError(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var ApplicationController = (0, _internalTestHelpers.factory)();
      registry.register('controller:application', ApplicationController);
      registry.register('user:current', null, {
        instantiate: false
      });
      registry.injection('controller:application', 'currentUser', 'user:current');
      assert.strictEqual(container.lookup('controller:application').currentUser, null);
    };

    _proto['@test The container returns same value each time even if the value is falsy'] = function testTheContainerReturnsSameValueEachTimeEvenIfTheValueIsFalsy(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      registry.register('falsy:value', null, {
        instantiate: false
      });
      assert.strictEqual(container.lookup('falsy:value'), container.lookup('falsy:value'));
    };

    _proto['@test Destroying the container destroys any cached singletons'] = function testDestroyingTheContainerDestroysAnyCachedSingletons(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostController = (0, _internalTestHelpers.factory)();
      var PostView = (0, _internalTestHelpers.factory)();

      var template = function () {};

      registry.register('controller:post', PostController);
      registry.register('view:post', PostView, {
        singleton: false
      });
      registry.register('template:post', template, {
        instantiate: false
      });
      registry.injection('controller:post', 'postView', 'view:post');
      var postController = container.lookup('controller:post');
      var postView = postController.postView;
      assert.ok(postView instanceof PostView, 'The non-singleton was injected');
      container.destroy();
      assert.ok(postController.isDestroyed, 'Singletons are destroyed');
      assert.ok(!postView.isDestroyed, 'Non-singletons are not destroyed');
    };

    _proto['@test The container can use a registry hook to resolve factories lazily'] = function testTheContainerCanUseARegistryHookToResolveFactoriesLazily(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostController = (0, _internalTestHelpers.factory)();
      registry.resolver = {
        resolve: function (fullName) {
          if (fullName === 'controller:post') {
            return PostController;
          }
        }
      };
      var postController = container.lookup('controller:post');
      assert.ok(postController instanceof PostController, 'The correct factory was provided');
    };

    _proto['@test The container normalizes names before resolving'] = function testTheContainerNormalizesNamesBeforeResolving(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostController = (0, _internalTestHelpers.factory)();

      registry.normalizeFullName = function () {
        return 'controller:post';
      };

      registry.register('controller:post', PostController);
      var postController = container.lookup('controller:normalized');
      assert.ok(postController instanceof PostController, 'Normalizes the name before resolving');
    };

    _proto['@test The container normalizes names when looking factory up'] = function testTheContainerNormalizesNamesWhenLookingFactoryUp(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostController = (0, _internalTestHelpers.factory)();

      registry.normalizeFullName = function () {
        return 'controller:post';
      };

      registry.register('controller:post', PostController);
      var fact = container.factoryFor('controller:normalized');
      var factInstance = fact.create();
      assert.ok(factInstance instanceof PostController, 'Normalizes the name');
    };

    _proto['@test Options can be registered that should be applied to a given factory'] = function testOptionsCanBeRegisteredThatShouldBeAppliedToAGivenFactory(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostView = (0, _internalTestHelpers.factory)();
      registry.resolver = {
        resolve: function (fullName) {
          if (fullName === 'view:post') {
            return PostView;
          }
        }
      };
      registry.options('view:post', {
        instantiate: true,
        singleton: false
      });
      var postView1 = container.lookup('view:post');
      var postView2 = container.lookup('view:post');
      assert.ok(postView1 instanceof PostView, 'The correct factory was provided');
      assert.ok(postView2 instanceof PostView, 'The correct factory was provided');
      assert.ok(postView1 !== postView2, 'The two lookups are different');
    };

    _proto['@test Options can be registered that should be applied to all factories for a given type'] = function testOptionsCanBeRegisteredThatShouldBeAppliedToAllFactoriesForAGivenType(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostView = (0, _internalTestHelpers.factory)();
      registry.resolver = {
        resolve: function (fullName) {
          if (fullName === 'view:post') {
            return PostView;
          }
        }
      };
      registry.optionsForType('view', {
        singleton: false
      });
      var postView1 = container.lookup('view:post');
      var postView2 = container.lookup('view:post');
      assert.ok(postView1 instanceof PostView, 'The correct factory was provided');
      assert.ok(postView2 instanceof PostView, 'The correct factory was provided');
      assert.ok(postView1 !== postView2, 'The two lookups are different');
    };

    _proto['@test An injected non-singleton instance is never cached'] = function testAnInjectedNonSingletonInstanceIsNeverCached(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostView = (0, _internalTestHelpers.factory)();
      var PostViewHelper = (0, _internalTestHelpers.factory)();
      registry.register('view:post', PostView, {
        singleton: false
      });
      registry.register('view_helper:post', PostViewHelper, {
        singleton: false
      });
      registry.injection('view:post', 'viewHelper', 'view_helper:post');
      var postView1 = container.lookup('view:post');
      var postView2 = container.lookup('view:post');
      assert.ok(postView1.viewHelper !== postView2.viewHelper, 'Injected non-singletons are not cached');
    };

    _proto['@test Factory resolves are cached'] = function testFactoryResolvesAreCached(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostController = (0, _internalTestHelpers.factory)();
      var resolveWasCalled = [];

      registry.resolve = function (fullName) {
        resolveWasCalled.push(fullName);
        return PostController;
      };

      assert.deepEqual(resolveWasCalled, []);
      container.factoryFor('controller:post');
      assert.deepEqual(resolveWasCalled, ['controller:post']);
      container.factoryFor('controller:post');
      assert.deepEqual(resolveWasCalled, ['controller:post']);
    };

    _proto['@test factory for non extendables (MODEL) resolves are cached'] = function testFactoryForNonExtendablesMODELResolvesAreCached(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostController = (0, _internalTestHelpers.factory)();
      var resolveWasCalled = [];

      registry.resolve = function (fullName) {
        resolveWasCalled.push(fullName);
        return PostController;
      };

      assert.deepEqual(resolveWasCalled, []);
      container.factoryFor('model:post');
      assert.deepEqual(resolveWasCalled, ['model:post']);
      container.factoryFor('model:post');
      assert.deepEqual(resolveWasCalled, ['model:post']);
    };

    _proto['@test factory for non extendables resolves are cached'] = function testFactoryForNonExtendablesResolvesAreCached(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostController = {};
      var resolveWasCalled = [];

      registry.resolve = function (fullName) {
        resolveWasCalled.push(fullName);
        return PostController;
      };

      assert.deepEqual(resolveWasCalled, []);
      container.factoryFor('foo:post');
      assert.deepEqual(resolveWasCalled, ['foo:post']);
      container.factoryFor('foo:post');
      assert.deepEqual(resolveWasCalled, ['foo:post']);
    };

    _proto["@test A factory's lazy injections are validated when first instantiated"] = function () {
      var registry = new _container.Registry();
      var container = registry.container();
      var Apple = (0, _internalTestHelpers.factory)();
      var Orange = (0, _internalTestHelpers.factory)();
      Apple.reopenClass({
        _lazyInjections: function () {
          return [{
            specifier: 'orange:main'
          }, {
            specifier: 'banana:main'
          }];
        }
      });
      registry.register('apple:main', Apple);
      registry.register('orange:main', Orange);
      expectAssertion(function () {
        container.lookup('apple:main');
      }, /Attempting to inject an unknown injection: 'banana:main'/);
    };

    _proto['@test Lazy injection validations are cached'] = function testLazyInjectionValidationsAreCached(assert) {
      if (!true
      /* DEBUG */
      ) {
          assert.expect(0);
          return;
        }

      assert.expect(1);
      var registry = new _container.Registry();
      var container = registry.container();
      var Apple = (0, _internalTestHelpers.factory)();
      var Orange = (0, _internalTestHelpers.factory)();
      Apple.reopenClass({
        _lazyInjections: function () {
          assert.ok(true, 'should call lazy injection method');
          return [{
            specifier: 'orange:main'
          }];
        }
      });
      registry.register('apple:main', Apple);
      registry.register('orange:main', Orange);
      container.lookup('apple:main');
      container.lookup('apple:main');
    };

    _proto['@test An object with its owner pre-set should be returned from ownerInjection'] = function testAnObjectWithItsOwnerPreSetShouldBeReturnedFromOwnerInjection(assert) {
      var owner = {};
      var registry = new _container.Registry();
      var container = registry.container({
        owner: owner
      });
      var result = container.ownerInjection();
      assert.equal(result[_owner.OWNER], owner, 'owner is properly included');
    };

    _proto['@test lookup passes options through to expandlocallookup'] = function testLookupPassesOptionsThroughToExpandlocallookup(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var PostController = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);

      registry.expandLocalLookup = function (fullName, options) {
        assert.ok(true, 'expandLocalLookup was called');
        assert.equal(fullName, 'foo:bar');
        assert.deepEqual(options, {
          source: 'baz:qux'
        });
        return 'controller:post';
      };

      var PostControllerLookupResult = container.lookup('foo:bar', {
        source: 'baz:qux'
      });
      assert.ok(PostControllerLookupResult instanceof PostController);
    };

    _proto['@test #factoryFor class is registered class'] = function testFactoryForClassIsRegisteredClass(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var Component = (0, _internalTestHelpers.factory)();
      registry.register('component:foo-bar', Component);
      var factoryManager = container.factoryFor('component:foo-bar');
      assert.deepEqual(factoryManager.class, Component, 'No double extend');
    };

    _proto['@test #factoryFor must supply a fullname'] = function testFactoryForMustSupplyAFullname() {
      var registry = new _container.Registry();
      var container = registry.container();
      expectAssertion(function () {
        container.factoryFor('chad-bar');
      }, /fullName must be a proper full name/);
    };

    _proto['@test #factoryFor returns a factory manager'] = function testFactoryForReturnsAFactoryManager(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var Component = (0, _internalTestHelpers.factory)();
      registry.register('component:foo-bar', Component);
      var factoryManager = container.factoryFor('component:foo-bar');
      assert.ok(factoryManager.create);
      assert.ok(factoryManager.class);
    };

    _proto['@test #factoryFor returns a cached factory manager for the same type'] = function testFactoryForReturnsACachedFactoryManagerForTheSameType(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var Component = (0, _internalTestHelpers.factory)();
      registry.register('component:foo-bar', Component);
      registry.register('component:baz-bar', Component);
      var factoryManager1 = container.factoryFor('component:foo-bar');
      var factoryManager2 = container.factoryFor('component:foo-bar');
      var factoryManager3 = container.factoryFor('component:baz-bar');
      assert.equal(factoryManager1, factoryManager2, 'cache hit');
      assert.notEqual(factoryManager1, factoryManager3, 'cache miss');
    };

    _proto['@test #factoryFor class returns the factory function'] = function testFactoryForClassReturnsTheFactoryFunction(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var Component = (0, _internalTestHelpers.factory)();
      registry.register('component:foo-bar', Component);
      var factoryManager = container.factoryFor('component:foo-bar');
      assert.deepEqual(factoryManager.class, Component, 'No double extend');
    };

    _proto['@test #factoryFor instance have a common parent'] = function testFactoryForInstanceHaveACommonParent(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var Component = (0, _internalTestHelpers.factory)();
      registry.register('component:foo-bar', Component);
      var factoryManager1 = container.factoryFor('component:foo-bar');
      var factoryManager2 = container.factoryFor('component:foo-bar');
      var instance1 = factoryManager1.create({
        foo: 'foo'
      });
      var instance2 = factoryManager2.create({
        bar: 'bar'
      });
      assert.deepEqual(instance1.constructor, instance2.constructor);
    };

    _proto['@test can properly reset cache'] = function testCanProperlyResetCache(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var Component = (0, _internalTestHelpers.factory)();
      registry.register('component:foo-bar', Component);
      var factory1 = container.factoryFor('component:foo-bar');
      var factory2 = container.factoryFor('component:foo-bar');
      var instance1 = container.lookup('component:foo-bar');
      var instance2 = container.lookup('component:foo-bar');
      assert.equal(instance1, instance2);
      assert.equal(factory1, factory2);
      container.reset();
      var factory3 = container.factoryFor('component:foo-bar');
      var instance3 = container.lookup('component:foo-bar');
      assert.notEqual(instance1, instance3);
      assert.notEqual(factory1, factory3);
    };

    _proto['@test #factoryFor created instances come with instance injections'] = function testFactoryForCreatedInstancesComeWithInstanceInjections(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var Component = (0, _internalTestHelpers.factory)();
      var Ajax = (0, _internalTestHelpers.factory)();
      registry.register('component:foo-bar', Component);
      registry.register('util:ajax', Ajax);
      registry.injection('component:foo-bar', 'ajax', 'util:ajax');
      var componentFactory = container.factoryFor('component:foo-bar');
      var component = componentFactory.create();
      assert.ok(component.ajax);
      assert.ok(component.ajax instanceof Ajax);
    };

    _proto['@test #factoryFor options passed to create clobber injections'] = function testFactoryForOptionsPassedToCreateClobberInjections(assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var Component = (0, _internalTestHelpers.factory)();
      var Ajax = (0, _internalTestHelpers.factory)();
      registry.register('component:foo-bar', Component);
      registry.register('util:ajax', Ajax);
      registry.injection('component:foo-bar', 'ajax', 'util:ajax');
      var componentFactory = container.factoryFor('component:foo-bar');
      var instrance = componentFactory.create({
        ajax: 'fetch'
      });
      assert.equal(instrance.ajax, 'fetch');
    };

    _proto['@test #factoryFor does not add properties to the object being instantiated when _initFactory is present'] = function testFactoryForDoesNotAddPropertiesToTheObjectBeingInstantiatedWhen_initFactoryIsPresent(assert) {
      var registry = new _container.Registry();
      var container = registry.container();

      var Component =
      /*#__PURE__*/
      function () {
        function Component() {}

        Component._initFactory = function _initFactory() {};

        Component.create = function create(options) {
          var instance = new this();
          (0, _polyfills.assign)(instance, options);
          return instance;
        };

        return Component;
      }();

      registry.register('component:foo-bar', Component);
      var componentFactory = container.factoryFor('component:foo-bar');
      var instance = componentFactory.create(); // note: _guid and isDestroyed are being set in the `factory` constructor
      // not via registry/container shenanigans

      assert.deepEqual(Object.keys(instance), []);
    };

    _proto["@test assert when calling lookup after destroy on a container"] = function (assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var Component = (0, _internalTestHelpers.factory)();
      registry.register('component:foo-bar', Component);
      var instance = container.lookup('component:foo-bar');
      assert.ok(instance, 'precond lookup successful');
      (0, _internalTestHelpers.runTask)(function () {
        container.destroy();
        container.finalizeDestroy();
      });
      expectAssertion(function () {
        container.lookup('component:foo-bar');
      });
    };

    _proto["@test assert when calling factoryFor after destroy on a container"] = function (assert) {
      var registry = new _container.Registry();
      var container = registry.container();
      var Component = (0, _internalTestHelpers.factory)();
      registry.register('component:foo-bar', Component);
      var instance = container.factoryFor('component:foo-bar');
      assert.ok(instance, 'precond lookup successful');
      (0, _internalTestHelpers.runTask)(function () {
        container.destroy();
        container.finalizeDestroy();
      });
      expectAssertion(function () {
        container.factoryFor('component:foo-bar');
      });
    } // this is skipped until templates and the glimmer environment do not require `OWNER` to be
    // passed in as constructor args
    ;

    _proto['@skip #factoryFor does not add properties to the object being instantiated'] = function skipFactoryForDoesNotAddPropertiesToTheObjectBeingInstantiated(assert) {
      var registry = new _container.Registry();
      var container = registry.container();

      var Component =
      /*#__PURE__*/
      function () {
        function Component() {}

        Component.create = function create(options) {
          var instance = new this();
          (0, _polyfills.assign)(instance, options);
          return instance;
        };

        return Component;
      }();

      registry.register('component:foo-bar', Component);
      var componentFactory = container.factoryFor('component:foo-bar');
      var instance = componentFactory.create(); // note: _guid and isDestroyed are being set in the `factory` constructor
      // not via registry/container shenanigans

      assert.deepEqual(Object.keys(instance), []);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));

  if (false
  /* EMBER_MODULE_UNIFICATION */
  ) {
      (0, _internalTestHelpers.moduleFor)('Container module unification',
      /*#__PURE__*/
      function (_AbstractTestCase2) {
        (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

        function _class2() {
          return _AbstractTestCase2.apply(this, arguments) || this;
        }

        var _proto2 = _class2.prototype;

        _proto2['@test The container can expand and resolve a source to factoryFor'] = function testTheContainerCanExpandAndResolveASourceToFactoryFor(assert) {
          var _this = this;

          var PrivateComponent = (0, _internalTestHelpers.factory)();
          var lookup = 'component:my-input';
          var expectedSource = 'template:routes/application';
          var registry = new _container.Registry();
          var resolveCount = 0;
          var expandedKey = 'boom, special expanded key';

          registry.expandLocalLookup = function (specifier, options) {
            _this.assert.strictEqual(specifier, lookup, 'specifier is expanded');

            _this.assert.strictEqual(options.source, expectedSource, 'source is expanded');

            return expandedKey;
          };

          registry.resolve = function (fullName) {
            resolveCount++;

            if (fullName === expandedKey) {
              return PrivateComponent;
            }
          };

          var container = registry.container();
          assert.strictEqual(container.factoryFor(lookup, {
            source: expectedSource
          }).class, PrivateComponent, 'The correct factory was provided');
          assert.strictEqual(container.factoryFor(lookup, {
            source: expectedSource
          }).class, PrivateComponent, 'The correct factory was provided again');
          assert.equal(resolveCount, 1, 'resolve called only once and a cached factory was returned the second time');
        };

        _proto2['@test The container can expand and resolve a source to lookup'] = function testTheContainerCanExpandAndResolveASourceToLookup() {
          var _this2 = this;

          var PrivateComponent = (0, _internalTestHelpers.factory)();
          var lookup = 'component:my-input';
          var expectedSource = 'template:routes/application';
          var registry = new _container.Registry();
          var expandedKey = 'boom, special expanded key';

          registry.expandLocalLookup = function (specifier, options) {
            _this2.assert.strictEqual(specifier, lookup, 'specifier is expanded');

            _this2.assert.strictEqual(options.source, expectedSource, 'source is expanded');

            return expandedKey;
          };

          registry.resolve = function (fullName) {
            if (fullName === expandedKey) {
              return PrivateComponent;
            }
          };

          var container = registry.container();
          var result = container.lookup(lookup, {
            source: expectedSource
          });
          this.assert.ok(result instanceof PrivateComponent, 'The correct factory was provided');
          this.assert.ok(container.cache[expandedKey] instanceof PrivateComponent, 'The correct factory was stored in the cache with the correct key which includes the source.');
        };

        _proto2['@test The container can expand and resolve a namespace to factoryFor'] = function testTheContainerCanExpandAndResolveANamespaceToFactoryFor(assert) {
          var _this3 = this;

          var PrivateComponent = (0, _internalTestHelpers.factory)();
          var lookup = 'component:my-input';
          var expectedNamespace = 'my-addon';
          var registry = new _container.Registry();
          var resolveCount = 0;
          var expandedKey = 'boom, special expanded key';

          registry.expandLocalLookup = function (specifier, options) {
            _this3.assert.strictEqual(specifier, lookup, 'specifier is expanded');

            _this3.assert.strictEqual(options.namespace, expectedNamespace, 'namespace is expanded');

            return expandedKey;
          };

          registry.resolve = function (fullName) {
            resolveCount++;

            if (fullName === expandedKey) {
              return PrivateComponent;
            }
          };

          var container = registry.container();
          assert.strictEqual(container.factoryFor(lookup, {
            namespace: expectedNamespace
          }).class, PrivateComponent, 'The correct factory was provided');
          assert.strictEqual(container.factoryFor(lookup, {
            namespace: expectedNamespace
          }).class, PrivateComponent, 'The correct factory was provided again');
          assert.equal(resolveCount, 1, 'resolve called only once and a cached factory was returned the second time');
        };

        _proto2['@test The container can expand and resolve a namespace to lookup'] = function testTheContainerCanExpandAndResolveANamespaceToLookup() {
          var _this4 = this;

          var PrivateComponent = (0, _internalTestHelpers.factory)();
          var lookup = 'component:my-input';
          var expectedNamespace = 'my-addon';
          var registry = new _container.Registry();
          var expandedKey = 'boom, special expanded key';

          registry.expandLocalLookup = function (specifier, options) {
            _this4.assert.strictEqual(specifier, lookup, 'specifier is expanded');

            _this4.assert.strictEqual(options.namespace, expectedNamespace, 'namespace is expanded');

            return expandedKey;
          };

          registry.resolve = function (fullName) {
            if (fullName === expandedKey) {
              return PrivateComponent;
            }
          };

          var container = registry.container();
          var result = container.lookup(lookup, {
            namespace: expectedNamespace
          });
          this.assert.ok(result instanceof PrivateComponent, 'The correct factory was provided');
          this.assert.ok(container.cache[expandedKey] instanceof PrivateComponent, 'The correct factory was stored in the cache with the correct key which includes the source.');
        };

        return _class2;
      }(_internalTestHelpers.AbstractTestCase));
    }
});
enifed("@ember/-internals/container/tests/owner_test", ["ember-babel", "@ember/-internals/owner", "internal-test-helpers"], function (_emberBabel, _owner, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Owner',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test An owner can be set with `setOwner` and retrieved with `getOwner`'] = function testAnOwnerCanBeSetWithSetOwnerAndRetrievedWithGetOwner(assert) {
      var owner = {};
      var obj = {};
      assert.strictEqual((0, _owner.getOwner)(obj), undefined, 'owner has not been set');
      (0, _owner.setOwner)(obj, owner);
      assert.strictEqual((0, _owner.getOwner)(obj), owner, 'owner has been set');
      assert.strictEqual(obj[_owner.OWNER], owner, 'owner has been set to the OWNER symbol');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/container/tests/registry_test", ["ember-babel", "@ember/-internals/container", "internal-test-helpers"], function (_emberBabel, _container, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Registry',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test A registered factory is returned from resolve'] = function testARegisteredFactoryIsReturnedFromResolve(assert) {
      var registry = new _container.Registry();
      var PostController = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);
      var PostControllerFactory = registry.resolve('controller:post');
      assert.ok(PostControllerFactory, 'factory is returned');
      assert.ok(PostControllerFactory.create() instanceof PostController, 'The return of factory.create is an instance of PostController');
    };

    _proto['@test The registered factory returned from resolve is the same factory each time'] = function testTheRegisteredFactoryReturnedFromResolveIsTheSameFactoryEachTime(assert) {
      var registry = new _container.Registry();
      var PostController = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);
      assert.deepEqual(registry.resolve('controller:post'), registry.resolve('controller:post'), 'The return of resolve is always the same');
    };

    _proto['@test The registered value returned from resolve is the same value each time even if the value is falsy'] = function testTheRegisteredValueReturnedFromResolveIsTheSameValueEachTimeEvenIfTheValueIsFalsy(assert) {
      var registry = new _container.Registry();
      registry.register('falsy:value', null, {
        instantiate: false
      });
      assert.strictEqual(registry.resolve('falsy:value'), registry.resolve('falsy:value'), 'The return of resolve is always the same');
    };

    _proto['@test The value returned from resolver is the same value as the original value even if the value is falsy'] = function testTheValueReturnedFromResolverIsTheSameValueAsTheOriginalValueEvenIfTheValueIsFalsy(assert) {
      var resolver = {
        resolve: function (fullName) {
          if (fullName === 'falsy:value') {
            return null;
          }
        }
      };
      var registry = new _container.Registry({
        resolver: resolver
      });
      assert.strictEqual(registry.resolve('falsy:value'), null);
    };

    _proto['@test A registered factory returns true for `has` if an item is registered'] = function testARegisteredFactoryReturnsTrueForHasIfAnItemIsRegistered(assert) {
      var registry = new _container.Registry();
      var PostController = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);
      assert.equal(registry.has('controller:post'), true, 'The `has` method returned true for registered factories');
      assert.equal(registry.has('controller:posts'), false, 'The `has` method returned false for unregistered factories');
    };

    _proto['@test Throw exception when trying to inject `type:thing` on all type(s)'] = function testThrowExceptionWhenTryingToInjectTypeThingOnAllTypeS() {
      var registry = new _container.Registry();
      var PostController = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);
      expectAssertion(function () {
        registry.typeInjection('controller', 'injected', 'controller:post');
      }, /Cannot inject a 'controller:post' on other controller\(s\)\./);
    };

    _proto['@test The registry can take a hook to resolve factories lazily'] = function testTheRegistryCanTakeAHookToResolveFactoriesLazily(assert) {
      var PostController = (0, _internalTestHelpers.factory)();
      var resolver = {
        resolve: function (fullName) {
          if (fullName === 'controller:post') {
            return PostController;
          }
        }
      };
      var registry = new _container.Registry({
        resolver: resolver
      });
      assert.strictEqual(registry.resolve('controller:post'), PostController, 'The correct factory was provided');
    };

    _proto['@test The registry respects the resolver hook for `has`'] = function testTheRegistryRespectsTheResolverHookForHas(assert) {
      var PostController = (0, _internalTestHelpers.factory)();
      var resolver = {
        resolve: function (fullName) {
          if (fullName === 'controller:post') {
            return PostController;
          }
        }
      };
      var registry = new _container.Registry({
        resolver: resolver
      });
      assert.ok(registry.has('controller:post'), 'the `has` method uses the resolver hook');
    };

    _proto['@test The registry normalizes names when resolving'] = function testTheRegistryNormalizesNamesWhenResolving(assert) {
      var registry = new _container.Registry();
      var PostController = (0, _internalTestHelpers.factory)();

      registry.normalizeFullName = function () {
        return 'controller:post';
      };

      registry.register('controller:post', PostController);
      var type = registry.resolve('controller:normalized');
      assert.strictEqual(type, PostController, 'Normalizes the name when resolving');
    };

    _proto['@test The registry normalizes names when checking if the factory is registered'] = function testTheRegistryNormalizesNamesWhenCheckingIfTheFactoryIsRegistered(assert) {
      var registry = new _container.Registry();
      var PostController = (0, _internalTestHelpers.factory)();

      registry.normalizeFullName = function (fullName) {
        return fullName === 'controller:normalized' ? 'controller:post' : fullName;
      };

      registry.register('controller:post', PostController);
      var isPresent = registry.has('controller:normalized');
      assert.equal(isPresent, true, 'Normalizes the name when checking if the factory or instance is present');
    };

    _proto['@test The registry normalizes names when injecting'] = function testTheRegistryNormalizesNamesWhenInjecting(assert) {
      var registry = new _container.Registry();
      var PostController = (0, _internalTestHelpers.factory)();
      var user = {
        name: 'Stef'
      };

      registry.normalize = function () {
        return 'controller:post';
      };

      registry.register('controller:post', PostController);
      registry.register('user:post', user, {
        instantiate: false
      });
      registry.injection('controller:post', 'user', 'controller:normalized');
      assert.deepEqual(registry.resolve('controller:post'), user, 'Normalizes the name when injecting');
    };

    _proto['@test cannot register an `undefined` factory'] = function testCannotRegisterAnUndefinedFactory() {
      var registry = new _container.Registry();
      expectAssertion(function () {
        registry.register('controller:apple', undefined);
      }, '');
    };

    _proto['@test can re-register a factory'] = function testCanReRegisterAFactory(assert) {
      var registry = new _container.Registry();
      var FirstApple = (0, _internalTestHelpers.factory)('first');
      var SecondApple = (0, _internalTestHelpers.factory)('second');
      registry.register('controller:apple', FirstApple);
      registry.register('controller:apple', SecondApple);
      assert.ok(registry.resolve('controller:apple').create() instanceof SecondApple);
    };

    _proto['@test cannot re-register a factory if it has been resolved'] = function testCannotReRegisterAFactoryIfItHasBeenResolved(assert) {
      var registry = new _container.Registry();
      var FirstApple = (0, _internalTestHelpers.factory)('first');
      var SecondApple = (0, _internalTestHelpers.factory)('second');
      registry.register('controller:apple', FirstApple);
      assert.strictEqual(registry.resolve('controller:apple'), FirstApple);
      expectAssertion(function () {
        registry.register('controller:apple', SecondApple);
      }, /Cannot re-register: 'controller:apple', as it has already been resolved\./);
      assert.strictEqual(registry.resolve('controller:apple'), FirstApple);
    };

    _proto['@test registry.has should not accidentally cause injections on that factory to be run. (Mitigate merely on observing)'] = function testRegistryHasShouldNotAccidentallyCauseInjectionsOnThatFactoryToBeRunMitigateMerelyOnObserving(assert) {
      assert.expect(1);
      var registry = new _container.Registry();
      var FirstApple = (0, _internalTestHelpers.factory)('first');
      var SecondApple = (0, _internalTestHelpers.factory)('second');

      SecondApple.extend = function () {
        assert.ok(false, 'should not extend or touch the injected model, merely to inspect existence of another');
      };

      registry.register('controller:apple', FirstApple);
      registry.register('controller:second-apple', SecondApple);
      registry.injection('controller:apple', 'badApple', 'controller:second-apple');
      assert.ok(registry.has('controller:apple'));
    };

    _proto['@test registry.has should not error for invalid fullNames'] = function testRegistryHasShouldNotErrorForInvalidFullNames(assert) {
      var registry = new _container.Registry();
      assert.ok(!registry.has('foo:bar:baz'));
    };

    _proto['@test once resolved, always return the same result'] = function testOnceResolvedAlwaysReturnTheSameResult(assert) {
      var registry = new _container.Registry();
      registry.resolver = {
        resolve: function () {
          return 'bar';
        }
      };
      var Bar = registry.resolve('models:bar');
      registry.resolver = {
        resolve: function () {
          return 'not bar';
        }
      };
      assert.equal(registry.resolve('models:bar'), Bar);
    };

    _proto['@test factory resolves are cached'] = function testFactoryResolvesAreCached(assert) {
      var registry = new _container.Registry();
      var PostController = (0, _internalTestHelpers.factory)();
      var resolveWasCalled = [];
      registry.resolver = {
        resolve: function (fullName) {
          resolveWasCalled.push(fullName);
          return PostController;
        }
      };
      assert.deepEqual(resolveWasCalled, []);
      registry.resolve('controller:post');
      assert.deepEqual(resolveWasCalled, ['controller:post']);
      registry.resolve('controller:post');
      assert.deepEqual(resolveWasCalled, ['controller:post']);
    };

    _proto['@test factory for non extendables (MODEL) resolves are cached'] = function testFactoryForNonExtendablesMODELResolvesAreCached(assert) {
      var registry = new _container.Registry();
      var PostController = (0, _internalTestHelpers.factory)();
      var resolveWasCalled = [];
      registry.resolver = {
        resolve: function (fullName) {
          resolveWasCalled.push(fullName);
          return PostController;
        }
      };
      assert.deepEqual(resolveWasCalled, []);
      registry.resolve('model:post');
      assert.deepEqual(resolveWasCalled, ['model:post']);
      registry.resolve('model:post');
      assert.deepEqual(resolveWasCalled, ['model:post']);
    };

    _proto['@test factory for non extendables resolves are cached'] = function testFactoryForNonExtendablesResolvesAreCached(assert) {
      var registry = new _container.Registry();
      var PostController = {};
      var resolveWasCalled = [];
      registry.resolver = {
        resolve: function (fullName) {
          resolveWasCalled.push(fullName);
          return PostController;
        }
      };
      assert.deepEqual(resolveWasCalled, []);
      registry.resolve('foo:post');
      assert.deepEqual(resolveWasCalled, ['foo:post']);
      registry.resolve('foo:post');
      assert.deepEqual(resolveWasCalled, ['foo:post']);
    };

    _proto['@test registry.container creates a container'] = function testRegistryContainerCreatesAContainer(assert) {
      var registry = new _container.Registry();
      var PostController = (0, _internalTestHelpers.factory)();
      registry.register('controller:post', PostController);
      var container = registry.container();
      var postController = container.lookup('controller:post');
      assert.ok(postController instanceof PostController, 'The lookup is an instance of the registered factory');
    };

    _proto['@test `describe` will be handled by the resolver, then by the fallback registry, if available'] = function testDescribeWillBeHandledByTheResolverThenByTheFallbackRegistryIfAvailable(assert) {
      var fallback = {
        describe: function (fullName) {
          return fullName + "-fallback";
        }
      };
      var resolver = {
        lookupDescription: function (fullName) {
          return fullName + "-resolver";
        }
      };
      var registry = new _container.Registry({
        fallback: fallback,
        resolver: resolver
      });
      assert.equal(registry.describe('controller:post'), 'controller:post-resolver', '`describe` handled by the resolver first.');
      registry.resolver = null;
      assert.equal(registry.describe('controller:post'), 'controller:post-fallback', '`describe` handled by fallback registry next.');
      registry.fallback = null;
      assert.equal(registry.describe('controller:post'), 'controller:post', '`describe` by default returns argument.');
    };

    _proto['@test `normalizeFullName` will be handled by the resolver, then by the fallback registry, if available'] = function testNormalizeFullNameWillBeHandledByTheResolverThenByTheFallbackRegistryIfAvailable(assert) {
      var fallback = {
        normalizeFullName: function (fullName) {
          return fullName + "-fallback";
        }
      };
      var resolver = {
        normalize: function (fullName) {
          return fullName + "-resolver";
        }
      };
      var registry = new _container.Registry({
        fallback: fallback,
        resolver: resolver
      });
      assert.equal(registry.normalizeFullName('controller:post'), 'controller:post-resolver', '`normalizeFullName` handled by the resolver first.');
      registry.resolver = null;
      assert.equal(registry.normalizeFullName('controller:post'), 'controller:post-fallback', '`normalizeFullName` handled by fallback registry next.');
      registry.fallback = null;
      assert.equal(registry.normalizeFullName('controller:post'), 'controller:post', '`normalizeFullName` by default returns argument.');
    };

    _proto['@test `makeToString` will be handled by the resolver, then by the fallback registry, if available'] = function testMakeToStringWillBeHandledByTheResolverThenByTheFallbackRegistryIfAvailable(assert) {
      var fallback = {
        makeToString: function (fullName) {
          return fullName + "-fallback";
        }
      };
      var resolver = {
        makeToString: function (fullName) {
          return fullName + "-resolver";
        }
      };
      var registry = new _container.Registry({
        fallback: fallback,
        resolver: resolver
      });
      assert.equal(registry.makeToString('controller:post'), 'controller:post-resolver', '`makeToString` handled by the resolver first.');
      registry.resolver = null;
      assert.equal(registry.makeToString('controller:post'), 'controller:post-fallback', '`makeToString` handled by fallback registry next.');
      registry.fallback = null;
      assert.equal(registry.makeToString('controller:post'), 'controller:post', '`makeToString` by default returns argument.');
    };

    _proto['@test `resolve` can be handled by a fallback registry'] = function testResolveCanBeHandledByAFallbackRegistry(assert) {
      var fallback = new _container.Registry();
      var registry = new _container.Registry({
        fallback: fallback
      });
      var PostController = (0, _internalTestHelpers.factory)();
      fallback.register('controller:post', PostController);
      var PostControllerFactory = registry.resolve('controller:post');
      assert.ok(PostControllerFactory, 'factory is returned');
      assert.ok(PostControllerFactory.create() instanceof PostController, 'The return of factory.create is an instance of PostController');
    };

    _proto['@test `has` can be handled by a fallback registry'] = function testHasCanBeHandledByAFallbackRegistry(assert) {
      var fallback = new _container.Registry();
      var registry = new _container.Registry({
        fallback: fallback
      });
      var PostController = (0, _internalTestHelpers.factory)();
      fallback.register('controller:post', PostController);
      assert.equal(registry.has('controller:post'), true, 'Fallback registry is checked for registration');
    };

    _proto['@test `getInjections` includes injections from a fallback registry'] = function testGetInjectionsIncludesInjectionsFromAFallbackRegistry(assert) {
      var fallback = new _container.Registry();
      var registry = new _container.Registry({
        fallback: fallback
      });
      assert.strictEqual(registry.getInjections('model:user'), undefined, 'No injections in the primary registry');
      fallback.injection('model:user', 'post', 'model:post');
      assert.equal(registry.getInjections('model:user').length, 1, 'Injections from the fallback registry are merged');
    };

    _proto['@test `getTypeInjections` includes type injections from a fallback registry'] = function testGetTypeInjectionsIncludesTypeInjectionsFromAFallbackRegistry(assert) {
      var fallback = new _container.Registry();
      var registry = new _container.Registry({
        fallback: fallback
      });
      assert.strictEqual(registry.getTypeInjections('model'), undefined, 'No injections in the primary registry');
      fallback.injection('model', 'source', 'source:main');
      assert.equal(registry.getTypeInjections('model').length, 1, 'Injections from the fallback registry are merged');
    };

    _proto['@test `knownForType` contains keys for each item of a given type'] = function testKnownForTypeContainsKeysForEachItemOfAGivenType(assert) {
      var registry = new _container.Registry();
      registry.register('foo:bar-baz', 'baz');
      registry.register('foo:qux-fez', 'fez');
      var found = registry.knownForType('foo');
      assert.deepEqual(found, {
        'foo:bar-baz': true,
        'foo:qux-fez': true
      });
    };

    _proto['@test `knownForType` includes fallback registry results'] = function testKnownForTypeIncludesFallbackRegistryResults(assert) {
      var fallback = new _container.Registry();
      var registry = new _container.Registry({
        fallback: fallback
      });
      registry.register('foo:bar-baz', 'baz');
      registry.register('foo:qux-fez', 'fez');
      fallback.register('foo:zurp-zorp', 'zorp');
      var found = registry.knownForType('foo');
      assert.deepEqual(found, {
        'foo:bar-baz': true,
        'foo:qux-fez': true,
        'foo:zurp-zorp': true
      });
    };

    _proto['@test `knownForType` is called on the resolver if present'] = function testKnownForTypeIsCalledOnTheResolverIfPresent(assert) {
      assert.expect(3);
      var resolver = {
        knownForType: function (type) {
          assert.ok(true, 'knownForType called on the resolver');
          assert.equal(type, 'foo', 'the type was passed through');
          return {
            'foo:yorp': true
          };
        }
      };
      var registry = new _container.Registry({
        resolver: resolver
      });
      registry.register('foo:bar-baz', 'baz');
      var found = registry.knownForType('foo');
      assert.deepEqual(found, {
        'foo:yorp': true,
        'foo:bar-baz': true
      });
    };

    _proto['@test resolver.expandLocalLookup is not required'] = function testResolverExpandLocalLookupIsNotRequired(assert) {
      var registry = new _container.Registry({
        resolver: {}
      });
      var result = registry.expandLocalLookup('foo:bar', {
        source: 'baz:qux'
      });
      assert.equal(result, null);
    };

    _proto['@test expandLocalLookup is called on the resolver if present'] = function testExpandLocalLookupIsCalledOnTheResolverIfPresent(assert) {
      assert.expect(4);
      var resolver = {
        expandLocalLookup: function (targetFullName, sourceFullName) {
          assert.ok(true, 'expandLocalLookup is called on the resolver');
          assert.equal(targetFullName, 'foo:bar', 'the targetFullName was passed through');
          assert.equal(sourceFullName, 'baz:qux', 'the sourceFullName was passed through');
          return 'foo:qux/bar';
        }
      };
      var registry = new _container.Registry({
        resolver: resolver
      });
      var result = registry.expandLocalLookup('foo:bar', {
        source: 'baz:qux'
      });
      assert.equal(result, 'foo:qux/bar');
    };

    _proto['@test `expandLocalLookup` is handled by the resolver, then by the fallback registry, if available'] = function testExpandLocalLookupIsHandledByTheResolverThenByTheFallbackRegistryIfAvailable(assert) {
      assert.expect(9);
      var fallbackResolver = {
        expandLocalLookup: function (targetFullName, sourceFullName) {
          assert.ok(true, 'expandLocalLookup is called on the fallback resolver');
          assert.equal(targetFullName, 'foo:bar', 'the targetFullName was passed through');
          assert.equal(sourceFullName, 'baz:qux', 'the sourceFullName was passed through');
          return 'foo:qux/bar-fallback';
        }
      };
      var resolver = {
        expandLocalLookup: function (targetFullName, sourceFullName) {
          assert.ok(true, 'expandLocalLookup is called on the resolver');
          assert.equal(targetFullName, 'foo:bar', 'the targetFullName was passed through');
          assert.equal(sourceFullName, 'baz:qux', 'the sourceFullName was passed through');
          return 'foo:qux/bar-resolver';
        }
      };
      var fallbackRegistry = new _container.Registry({
        resolver: fallbackResolver
      });
      var registry = new _container.Registry({
        fallback: fallbackRegistry,
        resolver: resolver
      });
      var result = registry.expandLocalLookup('foo:bar', {
        source: 'baz:qux'
      });
      assert.equal(result, 'foo:qux/bar-resolver', 'handled by the resolver');
      registry.resolver = null;
      result = registry.expandLocalLookup('foo:bar', {
        source: 'baz:qux'
      });
      assert.equal(result, 'foo:qux/bar-fallback', 'handled by the fallback registry');
      registry.fallback = null;
      result = registry.expandLocalLookup('foo:bar', {
        source: 'baz:qux'
      });
      assert.equal(result, null, 'null is returned by default when no resolver or fallback registry is present');
    };

    _proto['@test resolver.expandLocalLookup result is cached'] = function testResolverExpandLocalLookupResultIsCached(assert) {
      assert.expect(3);
      var result;
      var resolver = {
        expandLocalLookup: function () {
          assert.ok(true, 'expandLocalLookup is called on the resolver');
          return 'foo:qux/bar';
        }
      };
      var registry = new _container.Registry({
        resolver: resolver
      });
      result = registry.expandLocalLookup('foo:bar', {
        source: 'baz:qux'
      });
      assert.equal(result, 'foo:qux/bar');
      result = registry.expandLocalLookup('foo:bar', {
        source: 'baz:qux'
      });
      assert.equal(result, 'foo:qux/bar');
    };

    _proto['@test resolver.expandLocalLookup cache is busted when any unregister is called'] = function testResolverExpandLocalLookupCacheIsBustedWhenAnyUnregisterIsCalled(assert) {
      assert.expect(4);
      var result;
      var resolver = {
        expandLocalLookup: function () {
          assert.ok(true, 'expandLocalLookup is called on the resolver');
          return 'foo:qux/bar';
        }
      };
      var registry = new _container.Registry({
        resolver: resolver
      });
      result = registry.expandLocalLookup('foo:bar', {
        source: 'baz:qux'
      });
      assert.equal(result, 'foo:qux/bar');
      registry.unregister('foo:bar');
      result = registry.expandLocalLookup('foo:bar', {
        source: 'baz:qux'
      });
      assert.equal(result, 'foo:qux/bar');
    };

    _proto['@test resolve calls expandLocallookup when it receives options.source'] = function testResolveCallsExpandLocallookupWhenItReceivesOptionsSource(assert) {
      assert.expect(3);
      var resolver = {
        resolve: function () {},
        expandLocalLookup: function (targetFullName, sourceFullName) {
          assert.ok(true, 'expandLocalLookup is called on the resolver');
          assert.equal(targetFullName, 'foo:bar', 'the targetFullName was passed through');
          assert.equal(sourceFullName, 'baz:qux', 'the sourceFullName was passed through');
          return 'foo:qux/bar';
        }
      };
      var registry = new _container.Registry({
        resolver: resolver
      });
      registry.resolve('foo:bar', {
        source: 'baz:qux'
      });
    };

    _proto['@test has uses expandLocalLookup'] = function testHasUsesExpandLocalLookup(assert) {
      assert.expect(5);
      var resolvedFullNames = [];
      var result;
      var resolver = {
        resolve: function (name) {
          resolvedFullNames.push(name);
          return 'yippie!';
        },
        expandLocalLookup: function (targetFullName) {
          assert.ok(true, 'expandLocalLookup is called on the resolver');

          if (targetFullName === 'foo:bar') {
            return 'foo:qux/bar';
          } else {
            return null;
          }
        }
      };
      var registry = new _container.Registry({
        resolver: resolver
      });
      result = registry.has('foo:bar', {
        source: 'baz:qux'
      });
      assert.ok(result, 'found foo:bar/qux');
      result = registry.has('foo:baz', {
        source: 'baz:qux'
      });
      assert.ok(!result, 'foo:baz/qux not found');
      assert.deepEqual(['foo:qux/bar'], resolvedFullNames);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Registry privatize',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test valid format'] = function testValidFormat(assert) {
      var privatized = (0, _container.privatize)(['secret:factory']);
      var matched = privatized.match(/^([^:]+):([^:]+)-(\d+)$/);
      assert.ok(matched, 'privatized format was recognized');
      assert.equal(matched[1], 'secret');
      assert.equal(matched[2], 'factory');
      assert.ok(/^\d+$/.test(matched[3]));
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));

  if (false
  /* EMBER_MODULE_UNIFICATION */
  ) {
      (0, _internalTestHelpers.moduleFor)('Registry module unification',
      /*#__PURE__*/
      function (_AbstractTestCase3) {
        (0, _emberBabel.inheritsLoose)(_class3, _AbstractTestCase3);

        function _class3() {
          return _AbstractTestCase3.apply(this, arguments) || this;
        }

        var _proto3 = _class3.prototype;

        _proto3['@test The registry can pass a source to the resolver'] = function testTheRegistryCanPassASourceToTheResolver(assert) {
          var PrivateComponent = (0, _internalTestHelpers.factory)();
          var type = 'component';
          var name = 'my-input';
          var specifier = type + ":" + name;
          var source = 'template:routes/application';
          var resolver = new _internalTestHelpers.ModuleBasedTestResolver();
          resolver.add({
            specifier: specifier,
            source: source
          }, PrivateComponent);
          var registry = new _container.Registry({
            resolver: resolver
          });
          assert.strictEqual(registry.resolve(specifier), undefined, 'Not returned when specifier not scoped');
          assert.strictEqual(registry.resolve(specifier, {
            source: source
          }), PrivateComponent, 'The correct factory was provided');
          assert.strictEqual(registry.resolve(specifier, {
            source: source
          }), PrivateComponent, 'The correct factory was provided again');
        };

        _proto3['@test The registry can pass a namespace to the resolver'] = function testTheRegistryCanPassANamespaceToTheResolver(assert) {
          var PrivateComponent = (0, _internalTestHelpers.factory)();
          var type = 'component';
          var name = 'my-input';
          var specifier = type + ":" + name;
          var source = 'template:routes/application';
          var namespace = 'my-addon';
          var resolver = new _internalTestHelpers.ModuleBasedTestResolver();
          resolver.add({
            specifier: specifier,
            source: source,
            namespace: namespace
          }, PrivateComponent);
          var registry = new _container.Registry({
            resolver: resolver
          });
          assert.strictEqual(registry.resolve(specifier), undefined, 'Not returned when specifier not scoped');
          assert.strictEqual(registry.resolve(specifier, {
            source: source
          }), undefined, 'Not returned when specifier is missing namespace');
          assert.strictEqual(registry.resolve(specifier, {
            source: source,
            namespace: namespace
          }), PrivateComponent, 'The correct factory was provided');
          assert.strictEqual(registry.resolve(specifier, {
            source: source,
            namespace: namespace
          }), PrivateComponent, 'The correct factory was provided again');
        };

        return _class3;
      }(_internalTestHelpers.AbstractTestCase));
    }
});
enifed("@ember/-internals/extension-support/tests/container_debug_adapter_test", ["ember-babel", "internal-test-helpers", "@ember/polyfills", "@ember/runloop", "@ember/controller", "@ember/-internals/extension-support/index", "@ember/debug"], function (_emberBabel, _internalTestHelpers, _polyfills, _runloop, _controller, _index, _debug) {
  "use strict";

  // Must be required to export Ember.ContainerDebugAdapter.
  var originalDebug = (0, _debug.getDebugFunction)('debug');
  (0, _internalTestHelpers.moduleFor)('Container Debug Adapter',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      (0, _debug.setDebugFunction)('debug', function () {});
      _this = _ApplicationTestCase.call(this) || this;
      _this.adapter = _this.application.__deprecatedInstance__.lookup('container-debug-adapter:main');
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      var _this2 = this;

      (0, _debug.setDebugFunction)('debug', originalDebug);
      (0, _runloop.run)(function () {
        _this2.adapter.destroy();
      });

      _ApplicationTestCase.prototype.teardown.call(this);
    };

    _proto['@test default ContainerDebugAdapter cannot catalog certain entries by type'] = function testDefaultContainerDebugAdapterCannotCatalogCertainEntriesByType(assert) {
      assert.equal(this.adapter.canCatalogEntriesByType('model'), false, 'canCatalogEntriesByType should return false for model');
      assert.equal(this.adapter.canCatalogEntriesByType('template'), false, 'canCatalogEntriesByType should return false for template');
    };

    _proto['@test default ContainerDebugAdapter can catalog typical entries by type'] = function testDefaultContainerDebugAdapterCanCatalogTypicalEntriesByType(assert) {
      assert.equal(this.adapter.canCatalogEntriesByType('controller'), true, 'canCatalogEntriesByType should return true for controller');
      assert.equal(this.adapter.canCatalogEntriesByType('route'), true, 'canCatalogEntriesByType should return true for route');
      assert.equal(this.adapter.canCatalogEntriesByType('view'), true, 'canCatalogEntriesByType should return true for view');
    };

    _proto['@test default ContainerDebugAdapter catalogs controller entries'] = function testDefaultContainerDebugAdapterCatalogsControllerEntries(assert) {
      this.application.PostController = _controller.default.extend();
      var controllerClasses = this.adapter.catalogEntriesByType('controller');
      assert.equal(controllerClasses.length, 1, 'found 1 class');
      assert.equal(controllerClasses[0], 'post', 'found the right class');
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_ApplicationTestCase.prototype.applicationOptions, {
          autoboot: true
        });
      }
    }]);
    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/-internals/extension-support/tests/data_adapter_test", ["ember-babel", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/runtime", "@ember/-internals/extension-support/lib/data_adapter", "internal-test-helpers"], function (_emberBabel, _runloop, _metal, _runtime, _data_adapter, _internalTestHelpers) {
  "use strict";

  var adapter;

  var Model = _runtime.Object.extend();

  var PostClass = Model.extend();

  var DataAdapter = _data_adapter.default.extend({
    detect: function (klass) {
      return klass !== Model && Model.detect(klass);
    },
    init: function () {
      this._super.apply(this, arguments);

      this.set('containerDebugAdapter', {
        canCatalogEntriesByType: function () {
          return true;
        },
        catalogEntriesByType: function () {
          return (0, _runtime.A)(['post']);
        }
      });
    }
  });

  (0, _internalTestHelpers.moduleFor)('Data Adapter',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _ApplicationTestCase.prototype.teardown.call(this);

      adapter = undefined;
    };

    _proto['@test Model types added'] = function testModelTypesAdded(assert) {
      var _this = this;

      this.add('data-adapter:main', DataAdapter.extend({
        getRecords: function () {
          return (0, _runtime.A)([1, 2, 3]);
        },
        columnsForType: function () {
          return [{
            name: 'title',
            desc: 'Title'
          }];
        }
      }));
      this.add('model:post', PostClass);
      return this.visit('/').then(function () {
        var adapter = _this.applicationInstance.lookup('data-adapter:main');

        function modelTypesAdded(types) {
          assert.equal(types.length, 1);
          var postType = types[0];
          assert.equal(postType.name, 'post', 'Correctly sets the name');
          assert.equal(postType.count, 3, 'Correctly sets the record count');
          assert.strictEqual(postType.object, PostClass, 'Correctly sets the object');
          assert.deepEqual(postType.columns, [{
            name: 'title',
            desc: 'Title'
          }], 'Correctly sets the columns');
        }

        adapter.watchModelTypes(modelTypesAdded);
      });
    };

    _proto['@test getRecords gets a model name as second argument'] = function testGetRecordsGetsAModelNameAsSecondArgument(assert) {
      var _this2 = this;

      this.add('data-adapter:main', DataAdapter.extend({
        getRecords: function (klass, name) {
          assert.equal(name, 'post');
          return (0, _runtime.A)();
        }
      }));
      this.add('model:post', PostClass);
      return this.visit('/').then(function () {
        adapter = _this2.applicationInstance.lookup('data-adapter:main');
        adapter.watchModelTypes(function () {});
      });
    };

    _proto['@test Model types added with custom container-debug-adapter'] = function testModelTypesAddedWithCustomContainerDebugAdapter(assert) {
      var _this3 = this;

      var StubContainerDebugAdapter = _runtime.Object.extend({
        canCatalogEntriesByType: function () {
          return true;
        },
        catalogEntriesByType: function () {
          return (0, _runtime.A)(['post']);
        }
      });

      this.add('container-debug-adapter:main', StubContainerDebugAdapter);
      this.add('data-adapter:main', DataAdapter.extend({
        getRecords: function () {
          return (0, _runtime.A)([1, 2, 3]);
        },
        columnsForType: function () {
          return [{
            name: 'title',
            desc: 'Title'
          }];
        }
      }));
      this.add('model:post', PostClass);
      return this.visit('/').then(function () {
        var adapter = _this3.applicationInstance.lookup('data-adapter:main');

        function modelTypesAdded(types) {
          assert.equal(types.length, 1);
          var postType = types[0];
          assert.equal(postType.name, 'post', 'Correctly sets the name');
          assert.equal(postType.count, 3, 'Correctly sets the record count');
          assert.strictEqual(postType.object, PostClass, 'Correctly sets the object');
          assert.deepEqual(postType.columns, [{
            name: 'title',
            desc: 'Title'
          }], 'Correctly sets the columns');
        }

        adapter.watchModelTypes(modelTypesAdded);
      });
    };

    _proto['@test Model Types Updated'] = function testModelTypesUpdated(assert) {
      var _this4 = this;

      var records = (0, _runtime.A)([1, 2, 3]);
      this.add('data-adapter:main', DataAdapter.extend({
        getRecords: function () {
          return records;
        }
      }));
      this.add('model:post', PostClass);
      return this.visit('/').then(function () {
        adapter = _this4.applicationInstance.lookup('data-adapter:main');

        function modelTypesAdded() {
          (0, _runloop.run)(function () {
            records.pushObject(4);
          });
        }

        function modelTypesUpdated(types) {
          var postType = types[0];
          assert.equal(postType.count, 4, 'Correctly updates the count');
        }

        adapter.watchModelTypes(modelTypesAdded, modelTypesUpdated);
      });
    };

    _proto['@test Model Types Updated but Unchanged Do not Trigger Callbacks'] = function testModelTypesUpdatedButUnchangedDoNotTriggerCallbacks(assert) {
      var _this5 = this;

      assert.expect(0);
      var records = (0, _runtime.A)([1, 2, 3]);
      this.add('data-adapter:main', DataAdapter.extend({
        getRecords: function () {
          return records;
        }
      }));
      this.add('model:post', PostClass);
      return this.visit('/').then(function () {
        adapter = _this5.applicationInstance.lookup('data-adapter:main');

        function modelTypesAdded() {
          (0, _runloop.run)(function () {
            records.arrayContentDidChange(0, 0, 0);
          });
        }

        function modelTypesUpdated() {
          assert.ok(false, "modelTypesUpdated should not be triggered if the array didn't change");
        }

        adapter.watchModelTypes(modelTypesAdded, modelTypesUpdated);
      });
    };

    _proto['@test Records Added'] = function testRecordsAdded(assert) {
      var _this6 = this;

      var countAdded = 1;
      var post = PostClass.create();
      var recordList = (0, _runtime.A)([post]);
      this.add('data-adapter:main', DataAdapter.extend({
        getRecords: function () {
          return recordList;
        },
        getRecordColor: function () {
          return 'blue';
        },
        getRecordColumnValues: function () {
          return {
            title: 'Post ' + countAdded
          };
        },
        getRecordKeywords: function () {
          return ['Post ' + countAdded];
        }
      }));
      this.add('model:post', PostClass);
      return this.visit('/').then(function () {
        adapter = _this6.applicationInstance.lookup('data-adapter:main');

        function recordsAdded(records) {
          var record = records[0];
          assert.equal(record.color, 'blue', 'Sets the color correctly');
          assert.deepEqual(record.columnValues, {
            title: 'Post ' + countAdded
          }, 'Sets the column values correctly');
          assert.deepEqual(record.searchKeywords, ['Post ' + countAdded], 'Sets search keywords correctly');
          assert.strictEqual(record.object, post, 'Sets the object to the record instance');
        }

        adapter.watchRecords('post', recordsAdded);
        countAdded++;
        post = PostClass.create();
        recordList.pushObject(post);
      });
    };

    _proto['@test Observes and releases a record correctly'] = function testObservesAndReleasesARecordCorrectly(assert) {
      var _this7 = this;

      var updatesCalled = 0;
      var post = PostClass.create({
        title: 'Post'
      });
      var recordList = (0, _runtime.A)([post]);
      this.add('data-adapter:main', DataAdapter.extend({
        getRecords: function () {
          return recordList;
        },
        observeRecord: function (record, recordUpdated) {
          var self = this;

          function callback() {
            recordUpdated(self.wrapRecord(record));
          }

          (0, _metal.addObserver)(record, 'title', callback);
          return function () {
            (0, _metal.removeObserver)(record, 'title', callback);
          };
        },
        getRecordColumnValues: function (record) {
          return {
            title: (0, _metal.get)(record, 'title')
          };
        }
      }));
      this.add('model:post', PostClass);
      var release;
      return this.visit('/').then(function () {
        adapter = _this7.applicationInstance.lookup('data-adapter:main');

        function recordsAdded() {
          (0, _metal.set)(post, 'title', 'Post Modified');
        }

        function recordsUpdated(records) {
          updatesCalled++;
          assert.equal(records[0].columnValues.title, 'Post Modified');
        }

        release = adapter.watchRecords('post', recordsAdded, recordsUpdated);
        return (0, _internalTestHelpers.runLoopSettled)();
      }).then(function () {
        release();
        (0, _metal.set)(post, 'title', 'New Title');
        assert.equal(updatesCalled, 1, 'Release function removes observers');
      });
    };

    _proto['@test _nameToClass does not error when not found'] = function test_nameToClassDoesNotErrorWhenNotFound(assert) {
      var _this8 = this;

      this.add('data-adapter:main', DataAdapter);
      return this.visit('/').then(function () {
        adapter = _this8.applicationInstance.lookup('data-adapter:main');

        var klass = adapter._nameToClass('foo');

        assert.equal(klass, undefined, 'returns undefined');
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/application/actions-test", ["ember-babel", "internal-test-helpers", "@ember/controller", "@ember/debug", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _controller, _debug, _helpers) {
  "use strict";

  var originalDebug = (0, _debug.getDebugFunction)('debug');

  var noop = function () {};

  (0, _internalTestHelpers.moduleFor)('Application test: actions',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      (0, _debug.setDebugFunction)('debug', noop);
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _debug.setDebugFunction)('debug', originalDebug);
    };

    _proto['@test actions in top level template application template target application controller'] = function testActionsInTopLevelTemplateApplicationTemplateTargetApplicationController(assert) {
      var _this = this;

      assert.expect(1);
      this.add('controller:application', _controller.default.extend({
        actions: {
          handleIt: function () {
            assert.ok(true, 'controller received action properly');
          }
        }
      }));
      this.addTemplate('application', '<button id="handle-it" {{action "handleIt"}}>Click!</button>');
      return this.visit('/').then(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this.$('#handle-it').click();
        });
      });
    };

    _proto['@test actions in nested outlet template target their controller'] = function testActionsInNestedOutletTemplateTargetTheirController(assert) {
      var _this2 = this;

      assert.expect(1);
      this.add('controller:application', _controller.default.extend({
        actions: {
          handleIt: function () {
            assert.ok(false, 'application controller should not have received action!');
          }
        }
      }));
      this.add('controller:index', _controller.default.extend({
        actions: {
          handleIt: function () {
            assert.ok(true, 'controller received action properly');
          }
        }
      }));
      this.addTemplate('index', '<button id="handle-it" {{action "handleIt"}}>Click!</button>');
      return this.visit('/').then(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this2.$('#handle-it').click();
        });
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Rendering test: non-interactive actions',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class2, _RenderingTestCase);

    function _class2() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2.getBootOptions = function getBootOptions() {
      return {
        isInteractive: false
      };
    };

    _proto2["@test doesn't attatch actions"] = function (assert) {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          actions: {
            fire: function () {
              assert.ok(false);
            }
          }
        }),
        template: "<button {{action 'fire'}}>Fire!</button>"
      });
      this.render('{{foo-bar tagName=""}}');
      this.assertHTML('<button>Fire!</button>');
      this.$('button').click();
    };

    return _class2;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/application/engine-test", ["ember-babel", "internal-test-helpers", "@ember/controller", "@ember/-internals/runtime", "@ember/-internals/glimmer", "@ember/engine", "@ember/-internals/routing", "@ember/runloop", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _controller, _runtime, _glimmer, _engine, _routing, _runloop, _helpers) {
  "use strict";

  function _templateObject6() {
    const data = _taggedTemplateLiteralLoose(["\n          <p>Component!</p>\n        "]);

    _templateObject6 = function () {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    const data = _taggedTemplateLiteralLoose(["\n          <h1>Engine</h1>\n          {{my-component}}\n          {{outlet}}\n        "]);

    _templateObject5 = function () {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    const data = _taggedTemplateLiteralLoose(["\n      <h1>Application</h1>\n      {{my-component ambiguous-curlies=\"Local Data!\"}}\n      {{outlet}}\n    "]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["\n      {{ambiguous-curlies}}\n    "]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n        <p>Component!</p>\n      "]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      <h1>{{contextType}}</h1>\n      {{ambiguous-curlies}}\n\n      {{outlet}}\n    "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('Application test: engine rendering',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.setupAppAndRoutableEngine = function setupAppAndRoutableEngine() {
      var hooks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var self = this;
      this.addTemplate('application', 'Application{{outlet}}');
      this.router.map(function () {
        this.mount('blog');
      });
      this.add('route-map:blog', function () {
        this.route('post', function () {
          this.route('comments');
          this.route('likes');
        });
        this.route('category', {
          path: 'category/:id'
        });
        this.route('author', {
          path: 'author/:id'
        });
      });
      this.add('route:application', _routing.Route.extend({
        model: function () {
          hooks.push('application - application');
        }
      }));
      this.add('engine:blog', _engine.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.register('controller:application', _controller.default.extend({
            queryParams: ['lang'],
            lang: ''
          }));
          this.register('controller:category', _controller.default.extend({
            queryParams: ['type']
          }));
          this.register('controller:authorKtrl', _controller.default.extend({
            queryParams: ['official']
          }));
          this.register('template:application', (0, _helpers.compile)('Engine{{lang}}{{outlet}}'));
          this.register('route:application', _routing.Route.extend({
            model: function () {
              hooks.push('engine - application');
            }
          }));
          this.register('route:author', _routing.Route.extend({
            controllerName: 'authorKtrl'
          }));

          if (self._additionalEngineRegistrations) {
            self._additionalEngineRegistrations.call(this);
          }
        }
      }));
    };

    _proto.setupAppAndRoutelessEngine = function setupAppAndRoutelessEngine(hooks) {
      this.setupRoutelessEngine(hooks);
      this.add('engine:chat-engine', _engine.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.register('template:application', (0, _helpers.compile)('Engine'));
          this.register('controller:application', _controller.default.extend({
            init: function () {
              this._super.apply(this, arguments);

              hooks.push('engine - application');
            }
          }));
        }
      }));
    };

    _proto.setupAppAndRoutableEngineWithPartial = function setupAppAndRoutableEngineWithPartial(hooks) {
      this.addTemplate('application', 'Application{{outlet}}');
      this.router.map(function () {
        this.mount('blog');
      });
      this.add('route-map:blog', function () {});
      this.add('route:application', _routing.Route.extend({
        model: function () {
          hooks.push('application - application');
        }
      }));
      this.add('engine:blog', _engine.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.register('template:foo', (0, _helpers.compile)('foo partial'));
          this.register('template:application', (0, _helpers.compile)('Engine{{outlet}} {{partial "foo"}}'));
          this.register('route:application', _routing.Route.extend({
            model: function () {
              hooks.push('engine - application');
            }
          }));
        }
      }));
    };

    _proto.setupRoutelessEngine = function setupRoutelessEngine(hooks) {
      this.addTemplate('application', 'Application{{mount "chat-engine"}}');
      this.add('route:application', _routing.Route.extend({
        model: function () {
          hooks.push('application - application');
        }
      }));
    };

    _proto.setupAppAndRoutlessEngineWithPartial = function setupAppAndRoutlessEngineWithPartial(hooks) {
      this.setupRoutelessEngine(hooks);
      this.add('engine:chat-engine', _engine.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.register('template:foo', (0, _helpers.compile)('foo partial'));
          this.register('template:application', (0, _helpers.compile)('Engine {{partial "foo"}}'));
          this.register('controller:application', _controller.default.extend({
            init: function () {
              this._super.apply(this, arguments);

              hooks.push('engine - application');
            }
          }));
        }
      }));
    };

    _proto.additionalEngineRegistrations = function additionalEngineRegistrations(callback) {
      this._additionalEngineRegistrations = callback;
    };

    _proto.setupEngineWithAttrs = function setupEngineWithAttrs() {
      this.addTemplate('application', 'Application{{mount "chat-engine"}}');
      this.add('engine:chat-engine', _engine.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.register('template:components/foo-bar', (0, _helpers.compile)("{{partial \"troll\"}}"));
          this.register('template:troll', (0, _helpers.compile)('{{attrs.wat}}'));
          this.register('controller:application', _controller.default.extend({
            contextType: 'Engine'
          }));
          this.register('template:application', (0, _helpers.compile)('Engine {{foo-bar wat=contextType}}'));
        }
      }));
    };

    _proto.stringsEndWith = function stringsEndWith(str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    };

    _proto['@test attrs in an engine'] = function testAttrsInAnEngine() {
      var _this = this;

      this.setupEngineWithAttrs([]);
      return this.visit('/').then(function () {
        _this.assertText('ApplicationEngine Engine');
      });
    };

    _proto['@test sharing a template between engine and application has separate refinements'] = function testSharingATemplateBetweenEngineAndApplicationHasSeparateRefinements() {
      var _this2 = this;

      this.assert.expect(1);
      var sharedTemplate = (0, _helpers.compile)((0, _internalTestHelpers.strip)(_templateObject()));
      this.add('template:application', sharedTemplate);
      this.add('controller:application', _controller.default.extend({
        contextType: 'Application',
        'ambiguous-curlies': 'Controller Data!'
      }));
      this.router.map(function () {
        this.mount('blog');
      });
      this.add('route-map:blog', function () {});
      this.add('engine:blog', _engine.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.register('controller:application', _controller.default.extend({
            contextType: 'Engine'
          }));
          this.register('template:application', sharedTemplate);
          this.register('template:components/ambiguous-curlies', (0, _helpers.compile)((0, _internalTestHelpers.strip)(_templateObject2())));
        }
      }));
      return this.visit('/blog').then(function () {
        _this2.assertText('ApplicationController Data!EngineComponent!');
      });
    };

    _proto['@test sharing a layout between engine and application has separate refinements'] = function testSharingALayoutBetweenEngineAndApplicationHasSeparateRefinements() {
      var _this3 = this;

      this.assert.expect(1);
      var sharedLayout = (0, _helpers.compile)((0, _internalTestHelpers.strip)(_templateObject3()));

      var sharedComponent = _glimmer.Component.extend({
        layout: sharedLayout
      });

      this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject4()));
      this.add('component:my-component', sharedComponent);
      this.router.map(function () {
        this.mount('blog');
      });
      this.add('route-map:blog', function () {});
      this.add('engine:blog', _engine.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.register('template:application', (0, _helpers.compile)((0, _internalTestHelpers.strip)(_templateObject5())));
          this.register('component:my-component', sharedComponent);
          this.register('template:components/ambiguous-curlies', (0, _helpers.compile)((0, _internalTestHelpers.strip)(_templateObject6())));
        }
      }));
      return this.visit('/blog').then(function () {
        _this3.assertText('ApplicationLocal Data!EngineComponent!');
      });
    };

    _proto['@test visit() with `shouldRender: true` returns a promise that resolves when application and engine templates have rendered'] = function testVisitWithShouldRenderTrueReturnsAPromiseThatResolvesWhenApplicationAndEngineTemplatesHaveRendered(assert) {
      var _this4 = this;

      assert.expect(2);
      var hooks = [];
      this.setupAppAndRoutableEngine(hooks);
      return this.visit('/blog', {
        shouldRender: true
      }).then(function () {
        _this4.assertText('ApplicationEngine');

        _this4.assert.deepEqual(hooks, ['application - application', 'engine - application'], 'the expected model hooks were fired');
      });
    };

    _proto['@test visit() with `shouldRender: false` returns a promise that resolves without rendering'] = function testVisitWithShouldRenderFalseReturnsAPromiseThatResolvesWithoutRendering(assert) {
      var _this5 = this;

      assert.expect(2);
      var hooks = [];
      this.setupAppAndRoutableEngine(hooks);
      return this.visit('/blog', {
        shouldRender: false
      }).then(function () {
        assert.strictEqual(document.getElementById('qunit-fixture').children.length, 0, "there are no elements in the qunit-fixture element");

        _this5.assert.deepEqual(hooks, ['application - application', 'engine - application'], 'the expected model hooks were fired');
      });
    };

    _proto['@test visit() with `shouldRender: true` returns a promise that resolves when application and routeless engine templates have rendered'] = function testVisitWithShouldRenderTrueReturnsAPromiseThatResolvesWhenApplicationAndRoutelessEngineTemplatesHaveRendered(assert) {
      var _this6 = this;

      assert.expect(2);
      var hooks = [];
      this.setupAppAndRoutelessEngine(hooks);
      return this.visit('/', {
        shouldRender: true
      }).then(function () {
        _this6.assertText('ApplicationEngine');

        _this6.assert.deepEqual(hooks, ['application - application', 'engine - application'], 'the expected hooks were fired');
      });
    };

    _proto['@test visit() with partials in routable engine'] = function testVisitWithPartialsInRoutableEngine(assert) {
      var _this7 = this;

      assert.expect(2);
      var hooks = [];
      this.setupAppAndRoutableEngineWithPartial(hooks);
      return this.visit('/blog', {
        shouldRender: true
      }).then(function () {
        _this7.assertText('ApplicationEngine foo partial');

        _this7.assert.deepEqual(hooks, ['application - application', 'engine - application'], 'the expected hooks were fired');
      });
    };

    _proto['@test visit() with partials in non-routable engine'] = function testVisitWithPartialsInNonRoutableEngine(assert) {
      var _this8 = this;

      assert.expect(2);
      var hooks = [];
      this.setupAppAndRoutlessEngineWithPartial(hooks);
      return this.visit('/', {
        shouldRender: true
      }).then(function () {
        _this8.assertText('ApplicationEngine foo partial');

        _this8.assert.deepEqual(hooks, ['application - application', 'engine - application'], 'the expected hooks were fired');
      });
    };

    _proto['@test deactivate should be called on Engine Routes before destruction'] = function testDeactivateShouldBeCalledOnEngineRoutesBeforeDestruction(assert) {
      var _this9 = this;

      assert.expect(3);
      this.setupAppAndRoutableEngine();
      this.add('engine:blog', _engine.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.register('template:application', (0, _helpers.compile)('Engine{{outlet}}'));
          this.register('route:application', _routing.Route.extend({
            deactivate: function () {
              assert.notOk(this.isDestroyed, 'Route is not destroyed');
              assert.notOk(this.isDestroying, 'Route is not being destroyed');
            }
          }));
        }
      }));
      return this.visit('/blog').then(function () {
        _this9.assertText('ApplicationEngine');
      });
    };

    _proto['@test engine should lookup and use correct controller'] = function testEngineShouldLookupAndUseCorrectController() {
      var _this10 = this;

      this.setupAppAndRoutableEngine();
      return this.visit('/blog?lang=English').then(function () {
        _this10.assertText('ApplicationEngineEnglish');
      });
    };

    _proto['@test error substate route works for the application route of an Engine'] = function testErrorSubstateRouteWorksForTheApplicationRouteOfAnEngine(assert) {
      var _this11 = this;

      assert.expect(2);

      var errorEntered = _runtime.RSVP.defer();

      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('route:application_error', _routing.Route.extend({
          activate: function () {
            (0, _runloop.next)(errorEntered.resolve);
          }
        }));
        this.register('template:application_error', (0, _helpers.compile)('Error! {{model.message}}'));
        this.register('route:post', _routing.Route.extend({
          model: function () {
            return _runtime.RSVP.reject(new Error('Oh, noes!'));
          }
        }));
      });
      return this.visit('/').then(function () {
        _this11.assertText('Application');

        return _this11.transitionTo('blog.post');
      }).then(function () {
        return errorEntered.promise;
      }).then(function () {
        _this11.assertText('ApplicationError! Oh, noes!');
      });
    };

    _proto['@test error route works for the application route of an Engine'] = function testErrorRouteWorksForTheApplicationRouteOfAnEngine(assert) {
      var _this12 = this;

      assert.expect(2);

      var errorEntered = _runtime.RSVP.defer();

      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('route:error', _routing.Route.extend({
          activate: function () {
            (0, _runloop.next)(errorEntered.resolve);
          }
        }));
        this.register('template:error', (0, _helpers.compile)('Error! {{model.message}}'));
        this.register('route:post', _routing.Route.extend({
          model: function () {
            return _runtime.RSVP.reject(new Error('Oh, noes!'));
          }
        }));
      });
      return this.visit('/').then(function () {
        _this12.assertText('Application');

        return _this12.transitionTo('blog.post');
      }).then(function () {
        return errorEntered.promise;
      }).then(function () {
        _this12.assertText('ApplicationEngineError! Oh, noes!');
      });
    };

    _proto['@test error substate route works for a child route of an Engine'] = function testErrorSubstateRouteWorksForAChildRouteOfAnEngine(assert) {
      var _this13 = this;

      assert.expect(2);

      var errorEntered = _runtime.RSVP.defer();

      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('route:post_error', _routing.Route.extend({
          activate: function () {
            (0, _runloop.next)(errorEntered.resolve);
          }
        }));
        this.register('template:post_error', (0, _helpers.compile)('Error! {{model.message}}'));
        this.register('route:post', _routing.Route.extend({
          model: function () {
            return _runtime.RSVP.reject(new Error('Oh, noes!'));
          }
        }));
      });
      return this.visit('/').then(function () {
        _this13.assertText('Application');

        return _this13.transitionTo('blog.post');
      }).then(function () {
        return errorEntered.promise;
      }).then(function () {
        _this13.assertText('ApplicationEngineError! Oh, noes!');
      });
    };

    _proto['@test error route works for a child route of an Engine'] = function testErrorRouteWorksForAChildRouteOfAnEngine(assert) {
      var _this14 = this;

      assert.expect(2);

      var errorEntered = _runtime.RSVP.defer();

      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('route:post.error', _routing.Route.extend({
          activate: function () {
            (0, _runloop.next)(errorEntered.resolve);
          }
        }));
        this.register('template:post.error', (0, _helpers.compile)('Error! {{model.message}}'));
        this.register('route:post.comments', _routing.Route.extend({
          model: function () {
            return _runtime.RSVP.reject(new Error('Oh, noes!'));
          }
        }));
      });
      return this.visit('/').then(function () {
        _this14.assertText('Application');

        return _this14.transitionTo('blog.post.comments');
      }).then(function () {
        return errorEntered.promise;
      }).then(function () {
        _this14.assertText('ApplicationEngineError! Oh, noes!');
      });
    };

    _proto['@test loading substate route works for the application route of an Engine'] = function testLoadingSubstateRouteWorksForTheApplicationRouteOfAnEngine(assert) {
      var _this15 = this;

      assert.expect(3);
      var done = assert.async();

      var loadingEntered = _runtime.RSVP.defer();

      var resolveLoading = _runtime.RSVP.defer();

      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('route:application_loading', _routing.Route.extend({
          activate: function () {
            (0, _runloop.next)(loadingEntered.resolve);
          }
        }));
        this.register('template:application_loading', (0, _helpers.compile)('Loading'));
        this.register('template:post', (0, _helpers.compile)('Post'));
        this.register('route:post', _routing.Route.extend({
          model: function () {
            return resolveLoading.promise;
          }
        }));
      });
      return this.visit('/').then(function () {
        _this15.assertText('Application');

        var transition = _this15.transitionTo('blog.post');

        loadingEntered.promise.then(function () {
          _this15.assertText('ApplicationLoading');

          resolveLoading.resolve();
          return (0, _internalTestHelpers.runTaskNext)().then(function () {
            _this15.assertText('ApplicationEnginePost');

            done();
          });
        });
        return transition;
      });
    };

    _proto['@test loading route works for the application route of an Engine'] = function testLoadingRouteWorksForTheApplicationRouteOfAnEngine(assert) {
      var _this16 = this;

      assert.expect(3);
      var done = assert.async();

      var loadingEntered = _runtime.RSVP.defer();

      var resolveLoading = _runtime.RSVP.defer();

      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('route:loading', _routing.Route.extend({
          activate: function () {
            (0, _runloop.next)(loadingEntered.resolve);
          }
        }));
        this.register('template:loading', (0, _helpers.compile)('Loading'));
        this.register('template:post', (0, _helpers.compile)('Post'));
        this.register('route:post', _routing.Route.extend({
          model: function () {
            return resolveLoading.promise;
          }
        }));
      });
      return this.visit('/').then(function () {
        _this16.assertText('Application');

        var transition = _this16.transitionTo('blog.post');

        loadingEntered.promise.then(function () {
          _this16.assertText('ApplicationEngineLoading');

          resolveLoading.resolve();
          return (0, _internalTestHelpers.runTaskNext)().then(function () {
            _this16.assertText('ApplicationEnginePost');

            done();
          });
        });
        return transition;
      });
    };

    _proto['@test loading substate route works for a child route of an Engine'] = function testLoadingSubstateRouteWorksForAChildRouteOfAnEngine(assert) {
      var _this17 = this;

      assert.expect(3);
      var resolveLoading;
      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('template:post', (0, _helpers.compile)('{{outlet}}'));
        this.register('template:post.comments', (0, _helpers.compile)('Comments'));
        this.register('template:post.likes_loading', (0, _helpers.compile)('Loading'));
        this.register('template:post.likes', (0, _helpers.compile)('Likes'));
        this.register('route:post.likes', _routing.Route.extend({
          model: function () {
            return new _runtime.RSVP.Promise(function (resolve) {
              resolveLoading = resolve;
            });
          }
        }));
      });
      return this.visit('/blog/post/comments').then(function () {
        _this17.assertText('ApplicationEngineComments');

        var transition = _this17.transitionTo('blog.post.likes');

        (0, _internalTestHelpers.runTaskNext)().then(function () {
          _this17.assertText('ApplicationEngineLoading');

          resolveLoading();
        });
        return transition.then(function () {
          return (0, _internalTestHelpers.runTaskNext)();
        }).then(function () {
          return _this17.assertText('ApplicationEngineLikes');
        });
      });
    };

    _proto['@test loading route works for a child route of an Engine'] = function testLoadingRouteWorksForAChildRouteOfAnEngine(assert) {
      var _this18 = this;

      assert.expect(3);
      var done = assert.async();

      var loadingEntered = _runtime.RSVP.defer();

      var resolveLoading = _runtime.RSVP.defer();

      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('template:post', (0, _helpers.compile)('{{outlet}}'));
        this.register('template:post.comments', (0, _helpers.compile)('Comments'));
        this.register('route:post.loading', _routing.Route.extend({
          activate: function () {
            (0, _runloop.next)(loadingEntered.resolve);
          }
        }));
        this.register('template:post.loading', (0, _helpers.compile)('Loading'));
        this.register('template:post.likes', (0, _helpers.compile)('Likes'));
        this.register('route:post.likes', _routing.Route.extend({
          model: function () {
            return resolveLoading.promise;
          }
        }));
      });
      return this.visit('/blog/post/comments').then(function () {
        _this18.assertText('ApplicationEngineComments');

        var transition = _this18.transitionTo('blog.post.likes');

        loadingEntered.promise.then(function () {
          _this18.assertText('ApplicationEngineLoading');

          resolveLoading.resolve();
          return (0, _internalTestHelpers.runTaskNext)().then(function () {
            _this18.assertText('ApplicationEngineLikes');

            done();
          });
        });
        return transition;
      });
    };

    _proto["@test query params don't have stickiness by default between model"] = function testQueryParamsDonTHaveStickinessByDefaultBetweenModel(assert) {
      var _this19 = this;

      assert.expect(1);
      var tmpl = '{{#link-to "blog.category" 1337}}Category 1337{{/link-to}}';
      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('template:category', (0, _helpers.compile)(tmpl));
      });
      return this.visit('/blog/category/1?type=news').then(function () {
        var suffix = '/blog/category/1337';

        var href = _this19.element.querySelector('a').href; // check if link ends with the suffix


        assert.ok(_this19.stringsEndWith(href, suffix));
      });
    };

    _proto['@test query params in customized controllerName have stickiness by default between model'] =
    /*#__PURE__*/
    function () {
      var _testQueryParamsInCustomizedControllerNameHaveStickinessByDefaultBetweenModel = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var tmpl, suffix1, href1, suffix1337, href1337;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              assert.expect(2);
              tmpl = '{{#link-to "blog.author" 1337 class="author-1337"}}Author 1337{{/link-to}}{{#link-to "blog.author" 1 class="author-1"}}Author 1{{/link-to}}';
              this.setupAppAndRoutableEngine();
              this.additionalEngineRegistrations(function () {
                this.register('template:author', (0, _helpers.compile)(tmpl));
              });
              _context.next = 6;
              return this.visit('/blog/author/1?official=true');

            case 6:
              suffix1 = '/blog/author/1?official=true';
              href1 = this.element.querySelector('.author-1').href;
              suffix1337 = '/blog/author/1337';
              href1337 = this.element.querySelector('.author-1337').href; // check if link ends with the suffix

              assert.ok(this.stringsEndWith(href1, suffix1), href1 + " ends with " + suffix1);
              assert.ok(this.stringsEndWith(href1337, suffix1337), href1337 + " ends with " + suffix1337);

            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testQueryParamsInCustomizedControllerNameHaveStickinessByDefaultBetweenModel(_x) {
        return _testQueryParamsInCustomizedControllerNameHaveStickinessByDefaultBetweenModel.apply(this, arguments);
      }

      return testQueryParamsInCustomizedControllerNameHaveStickinessByDefaultBetweenModel;
    }();

    _proto['@test visit() routable engine which errors on init'] = function testVisitRoutableEngineWhichErrorsOnInit(assert) {
      var _this20 = this;

      assert.expect(1);
      var hooks = [];
      this.additionalEngineRegistrations(function () {
        this.register('route:application', _routing.Route.extend({
          init: function () {
            throw new Error('Whoops! Something went wrong...');
          }
        }));
      });
      this.setupAppAndRoutableEngine(hooks);
      return this.visit('/', {
        shouldRender: true
      }).then(function () {
        return _this20.visit('/blog');
      }).catch(function (error) {
        assert.equal(error.message, 'Whoops! Something went wrong...');
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "routerOptions",
      get: function () {
        return {
          location: 'none',
          setupRouter: function () {
            var _this21 = this;

            this._super.apply(this, arguments);

            var getRoute = this._routerMicrolib.getRoute;
            this._enginePromises = Object.create(null);
            this._resolvedEngines = Object.create(null);

            this._routerMicrolib.getRoute = function (name) {
              var engineInfo = _this21._engineInfoByRoute[name];

              if (!engineInfo) {
                return getRoute(name);
              }

              var engineName = engineInfo.name;

              if (_this21._resolvedEngines[engineName]) {
                return getRoute(name);
              }

              var enginePromise = _this21._enginePromises[engineName];

              if (!enginePromise) {
                enginePromise = new _runtime.RSVP.Promise(function (resolve) {
                  setTimeout(function () {
                    _this21._resolvedEngines[engineName] = true;
                    resolve();
                  }, 1);
                });
                _this21._enginePromises[engineName] = enginePromise;
              }

              return enginePromise.then(function () {
                return getRoute(name);
              });
            };
          }
        };
      }
    }]);
    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/application/helper-registration-test", ["ember-babel", "internal-test-helpers", "@ember/controller", "@ember/service", "@ember/-internals/glimmer"], function (_emberBabel, _internalTestHelpers, _controller, _service, _glimmer) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application Lifecycle - Helper Registration',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Unbound dashed helpers registered on the container can be late-invoked'] = function testUnboundDashedHelpersRegisteredOnTheContainerCanBeLateInvoked(assert) {
      var _this = this;

      this.addTemplate('application', "<div id='wrapper'>{{x-borf}} {{x-borf 'YES'}}</div>");
      var myHelper = (0, _glimmer.helper)(function (params) {
        return params[0] || 'BORF';
      });
      this.application.register('helper:x-borf', myHelper);
      return this.visit('/').then(function () {
        assert.equal(_this.$('#wrapper').text(), 'BORF YES', 'The helper was invoked from the container');
      });
    };

    _proto['@test Bound helpers registered on the container can be late-invoked'] = function testBoundHelpersRegisteredOnTheContainerCanBeLateInvoked(assert) {
      var _this2 = this;

      this.addTemplate('application', "<div id='wrapper'>{{x-reverse}} {{x-reverse foo}}</div>");
      this.add('controller:application', _controller.default.extend({
        foo: 'alex'
      }));
      this.application.register('helper:x-reverse', (0, _glimmer.helper)(function (_ref) {
        var value = _ref[0];
        return value ? value.split('').reverse().join('') : '--';
      }));
      return this.visit('/').then(function () {
        assert.equal(_this2.$('#wrapper').text(), '-- xela', 'The bound helper was invoked from the container');
      });
    };

    _proto['@test Undashed helpers registered on the container can be invoked'] = function testUndashedHelpersRegisteredOnTheContainerCanBeInvoked(assert) {
      var _this3 = this;

      this.addTemplate('application', "<div id='wrapper'>{{omg}}|{{yorp 'boo'}}|{{yorp 'ya'}}</div>");
      this.application.register('helper:omg', (0, _glimmer.helper)(function () {
        return 'OMG';
      }));
      this.application.register('helper:yorp', (0, _glimmer.helper)(function (_ref2) {
        var value = _ref2[0];
        return value;
      }));
      return this.visit('/').then(function () {
        assert.equal(_this3.$('#wrapper').text(), 'OMG|boo|ya', 'The helper was invoked from the container');
      });
    };

    _proto['@test Helpers can receive injections'] = function testHelpersCanReceiveInjections(assert) {
      this.addTemplate('application', "<div id='wrapper'>{{full-name}}</div>");
      var serviceCalled = false;
      this.add('service:name-builder', _service.default.extend({
        build: function () {
          serviceCalled = true;
        }
      }));
      this.add('helper:full-name', _glimmer.Helper.extend({
        nameBuilder: (0, _service.inject)('name-builder'),
        compute: function () {
          this.get('nameBuilder').build();
        }
      }));
      return this.visit('/').then(function () {
        assert.ok(serviceCalled, 'service was injected, method called');
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/application/hot-reload-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/environment", "@ember/service", "@ember/-internals/glimmer", "@glimmer/util"], function (_emberBabel, _internalTestHelpers, _environment, _service, _glimmer, _util) {
  "use strict";

  function _templateObject12() {
    const data = _taggedTemplateLiteralLoose(["\n          [x-foo: first (8)]\n          [x-foo: second (9)]\n          [x-bar (10)]\n        "]);

    _templateObject12 = function () {
      return data;
    };

    return data;
  }

  function _templateObject11() {
    const data = _taggedTemplateLiteralLoose(["\n          [<strong>x-foo</strong> <em>first (6)</em>]\n          [<strong>x-foo</strong> <em>second (7)</em>]\n          [<h2>wow (5)</h2>]\n        "]);

    _templateObject11 = function () {
      return data;
    };

    return data;
  }

  function _templateObject10() {
    const data = _taggedTemplateLiteralLoose(["\n          [<h1>first (3)</h1>]\n          [<h1>second (4)</h1>]\n          [<h2>wow (5)</h2>]\n        "]);

    _templateObject10 = function () {
      return data;
    };

    return data;
  }

  function _templateObject9() {
    const data = _taggedTemplateLiteralLoose(["\n          [<h1>first (3)</h1>]\n          [<h1>second (4)</h1>]\n          [x-bar (2)]\n        "]);

    _templateObject9 = function () {
      return data;
    };

    return data;
  }

  function _templateObject8() {
    const data = _taggedTemplateLiteralLoose(["\n          [x-foo: first (0)]\n          [x-foo: second (1)]\n          [x-bar (2)]\n        "]);

    _templateObject8 = function () {
      return data;
    };

    return data;
  }

  function _templateObject7() {
    const data = _taggedTemplateLiteralLoose(["\n          [{{component (hot-reload \"x-foo\") name=\"first\"}}]\n          [{{component (hot-reload \"x-foo\") name=\"second\"}}]\n          [{{component (hot-reload \"x-bar\")}}]\n        "]);

    _templateObject7 = function () {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    const data = _taggedTemplateLiteralLoose(["\n          [x-foo: first]\n          [x-foo: second]\n          [x-bar]\n        "]);

    _templateObject6 = function () {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    const data = _taggedTemplateLiteralLoose(["\n          [<strong>x-foo</strong> <em>first</em>]\n          [<strong>x-foo</strong> <em>second</em>]\n          [<h2>wow</h2>]\n        "]);

    _templateObject5 = function () {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    const data = _taggedTemplateLiteralLoose(["\n          [<h1>first</h1>]\n          [<h1>second</h1>]\n          [<h2>wow</h2>]\n        "]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["\n          [<h1>first</h1>]\n          [<h1>second</h1>]\n          [x-bar]\n        "]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n          [x-foo: first]\n          [x-foo: second]\n          [x-bar]\n        "]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n          [{{component (hot-reload \"x-foo\") name=\"first\"}}]\n          [{{component (hot-reload \"x-foo\") name=\"second\"}}]\n          [{{component (hot-reload \"x-bar\")}}]\n        "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  // This simuates what the template hot-reloading would do in development mode
  // to avoid regressions
  (0, _internalTestHelpers.moduleFor)('Appliation test: template hot reloading',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.apply(this, arguments) || this;
      _this._APPLICATION_TEMPLATE_WRAPPER = _environment.ENV._APPLICATION_TEMPLATE_WRAPPER;
      _this._TEMPLATE_ONLY_GLIMMER_COMPONENTS = _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS;
      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = false;
      _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = true;

      var didCreateReloader = function (reloader) {
        _this.reloader = reloader;
      };

      _this.add('service:reloader', _service.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.revisions = {};
          this.callbacks = [];
          didCreateReloader(this);
        },
        onReload: function (callback) {
          this.callbacks.push(callback);
        },
        revisionFor: function (name) {
          return this.revisions[name];
        },
        invalidate: function (name) {
          var revision = this.revisions[name];

          if (revision === undefined) {
            revision = 0;
          }

          this.revisions[name] = ++revision;
          this.callbacks.forEach(function (callback) {
            return callback();
          });
        }
      }));

      _this.add('helper:hot-reload', _glimmer.Helper.extend({
        reloader: (0, _service.inject)(),
        init: function () {
          var _this2 = this;

          this._super.apply(this, arguments);

          this.reloader.onReload(function () {
            return _this2.recompute();
          });
        },
        compute: function (_ref) {
          var name = _ref[0];
          var revision = this.reloader.revisionFor(name);

          if (revision === undefined) {
            return name;
          } else {
            return name + "--hot-reload-" + revision;
          }
        }
      }));

      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _ApplicationTestCase.prototype.teardown.call(this);

      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = this._APPLICATION_TEMPLATE_WRAPPER;
      _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = this._TEMPLATE_ONLY_GLIMMER_COMPONENTS;
    };

    _proto.hotReload = function hotReload(name, template) {
      var reloader = (0, _util.expect)(this.reloader);
      var revision = (reloader.revisionFor(name) || 0) + 1;
      var ComponentClass = this.applicationInstance.resolveRegistration("component:" + name) || null;
      this.addComponent(name + "--hot-reload-" + revision, {
        ComponentClass: ComponentClass,
        template: template
      });
      reloader.invalidate(name);
    };

    _proto['@test hot reloading template-only components'] = function testHotReloadingTemplateOnlyComponents() {
      var _this3 = this;

      this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject()));
      this.addComponent('x-foo', {
        ComponentClass: null,
        template: 'x-foo: {{@name}}'
      });
      this.addComponent('x-bar', {
        ComponentClass: null,
        template: 'x-bar'
      });
      return this.visit('/').then(function () {
        _this3.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject2()));

        (0, _internalTestHelpers.runTask)(function () {
          _this3.hotReload('x-foo', '<h1>{{@name}}</h1>');
        });

        _this3.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject3()));

        (0, _internalTestHelpers.runTask)(function () {
          _this3.hotReload('x-bar', '<h2>wow</h2>');
        });

        _this3.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject4()));

        (0, _internalTestHelpers.runTask)(function () {
          _this3.hotReload('x-foo', '<strong>x-foo</strong> <em>{{@name}}</em>');
        });

        _this3.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject5()));

        (0, _internalTestHelpers.runTask)(function () {
          _this3.hotReload('x-foo', 'x-foo: {{@name}}');

          _this3.hotReload('x-bar', 'x-bar');
        });

        _this3.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject6()));
      });
    };

    _proto['@test hot reloading class-based components'] = function testHotReloadingClassBasedComponents() {
      var _this4 = this;

      this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject7()));
      var id = 0;
      this.addComponent('x-foo', {
        ComponentClass: _glimmer.Component.extend({
          tagName: '',
          init: function () {
            this._super.apply(this, arguments);

            this.set('id', id++);
          }
        }),
        template: 'x-foo: {{@name}} ({{this.id}})'
      });
      this.addComponent('x-bar', {
        ComponentClass: _glimmer.Component.extend({
          tagName: '',
          init: function () {
            this._super.apply(this, arguments);

            this.set('id', id++);
          }
        }),
        template: 'x-bar ({{this.id}})'
      });
      return this.visit('/').then(function () {
        _this4.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject8()));

        (0, _internalTestHelpers.runTask)(function () {
          _this4.hotReload('x-foo', '<h1>{{@name}} ({{this.id}})</h1>');
        });

        _this4.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject9()));

        (0, _internalTestHelpers.runTask)(function () {
          _this4.hotReload('x-bar', '<h2>wow ({{this.id}})</h2>');
        });

        _this4.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject10()));

        (0, _internalTestHelpers.runTask)(function () {
          _this4.hotReload('x-foo', '<strong>x-foo</strong> <em>{{@name}} ({{this.id}})</em>');
        });

        _this4.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject11()));

        (0, _internalTestHelpers.runTask)(function () {
          _this4.hotReload('x-foo', 'x-foo: {{@name}} ({{this.id}})');

          _this4.hotReload('x-bar', 'x-bar ({{this.id}})');
        });

        _this4.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject12()));
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/application/rendering-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/environment", "@ember/controller", "@ember/-internals/routing", "@ember/-internals/glimmer"], function (_emberBabel, _internalTestHelpers, _environment, _controller, _routing, _glimmer) {
  "use strict";

  function _templateObject12() {
    const data = _taggedTemplateLiteralLoose(["\n        <nav>\n          <a href=\"https://emberjs.com/\">Ember</a>\n        </nav>\n        <main>\n          <ul>\n            <li>red</li>\n            <li>yellow</li>\n            <li>blue</li>\n          </ul>\n        </main>\n      "]);

    _templateObject12 = function () {
      return data;
    };

    return data;
  }

  function _templateObject11() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        {{#each model as |item|}}\n          <li>{{item}}</li>\n        {{/each}}\n      </ul>\n    "]);

    _templateObject11 = function () {
      return data;
    };

    return data;
  }

  function _templateObject10() {
    const data = _taggedTemplateLiteralLoose(["\n      <a href=\"https://emberjs.com/\">Ember</a>\n    "]);

    _templateObject10 = function () {
      return data;
    };

    return data;
  }

  function _templateObject9() {
    const data = _taggedTemplateLiteralLoose(["\n      <nav>{{outlet \"nav\"}}</nav>\n      <main>{{outlet}}</main>\n    "]);

    _templateObject9 = function () {
      return data;
    };

    return data;
  }

  function _templateObject8() {
    const data = _taggedTemplateLiteralLoose(["\n        <nav>\n          <a href=\"https://emberjs.com/\">Ember</a>\n        </nav>\n        <main>\n          <ul>\n            <li>red</li>\n            <li>yellow</li>\n            <li>blue</li>\n          </ul>\n        </main>\n      "]);

    _templateObject8 = function () {
      return data;
    };

    return data;
  }

  function _templateObject7() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        {{#each model as |item|}}\n          <li>{{item}}</li>\n        {{/each}}\n      </ul>\n    "]);

    _templateObject7 = function () {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    const data = _taggedTemplateLiteralLoose(["\n      <a href=\"https://emberjs.com/\">Ember</a>\n    "]);

    _templateObject6 = function () {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    const data = _taggedTemplateLiteralLoose(["\n      <nav>{{outlet \"nav\"}}</nav>\n      <main>{{outlet}}</main>\n    "]);

    _templateObject5 = function () {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    const data = _taggedTemplateLiteralLoose(["\n        <ul>\n          <li>red</li>\n          <li>yellow</li>\n          <li>blue</li>\n        </ul>\n      "]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        {{#each model as |item|}}\n          <li>{{item}}</li>\n        {{/each}}\n      </ul>\n    "]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n        <ul>\n          <li>red</li>\n          <li>yellow</li>\n          <li>blue</li>\n        </ul>\n      "]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        {{#each model as |item|}}\n          <li>{{item}}</li>\n        {{/each}}\n      </ul>\n    "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('Application test: rendering',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.apply(this, arguments) || this;
      _this._APPLICATION_TEMPLATE_WRAPPER = _environment.ENV._APPLICATION_TEMPLATE_WRAPPER;
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _ApplicationTestCase.prototype.teardown.call(this);

      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = this._APPLICATION_TEMPLATE_WRAPPER;
    };

    _proto['@test it can render the application template with a wrapper'] = function testItCanRenderTheApplicationTemplateWithAWrapper() {
      var _this2 = this;

      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = true;
      this.addTemplate('application', 'Hello world!');
      return this.visit('/').then(function () {
        _this2.assertComponentElement(_this2.element, {
          content: 'Hello world!'
        });
      });
    };

    _proto['@test it can render the application template without a wrapper'] = function testItCanRenderTheApplicationTemplateWithoutAWrapper() {
      var _this3 = this;

      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = false;
      this.addTemplate('application', 'Hello world!');
      return this.visit('/').then(function () {
        _this3.assertInnerHTML('Hello world!');
      });
    };

    _proto['@test it can access the model provided by the route'] = function testItCanAccessTheModelProvidedByTheRoute() {
      var _this4 = this;

      this.add('route:application', _routing.Route.extend({
        model: function () {
          return ['red', 'yellow', 'blue'];
        }
      }));
      this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject()));
      return this.visit('/').then(function () {
        _this4.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject2()));
      });
    };

    _proto['@test it can render a nested route'] = function testItCanRenderANestedRoute() {
      var _this5 = this;

      this.router.map(function () {
        this.route('lists', function () {
          this.route('colors', function () {
            this.route('favorite');
          });
        });
      }); // The "favorite" route will inherit the model

      this.add('route:lists.colors', _routing.Route.extend({
        model: function () {
          return ['red', 'yellow', 'blue'];
        }
      }));
      this.addTemplate('lists.colors.favorite', (0, _internalTestHelpers.strip)(_templateObject3()));
      return this.visit('/lists/colors/favorite').then(function () {
        _this5.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject4()));
      });
    };

    _proto['@test it can render into named outlets'] = function testItCanRenderIntoNamedOutlets() {
      var _this6 = this;

      this.router.map(function () {
        this.route('colors');
      });
      this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject5()));
      this.addTemplate('nav', (0, _internalTestHelpers.strip)(_templateObject6()));
      this.add('route:application', _routing.Route.extend({
        renderTemplate: function () {
          this.render();
          this.render('nav', {
            into: 'application',
            outlet: 'nav'
          });
        }
      }));
      this.add('route:colors', _routing.Route.extend({
        model: function () {
          return ['red', 'yellow', 'blue'];
        }
      }));
      this.addTemplate('colors', (0, _internalTestHelpers.strip)(_templateObject7()));
      return this.visit('/colors').then(function () {
        _this6.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject8()));
      });
    };

    _proto['@test it can render into named outlets'] = function testItCanRenderIntoNamedOutlets() {
      var _this7 = this;

      this.router.map(function () {
        this.route('colors');
      });
      this.addTemplate('application', (0, _internalTestHelpers.strip)(_templateObject9()));
      this.addTemplate('nav', (0, _internalTestHelpers.strip)(_templateObject10()));
      this.add('route:application', _routing.Route.extend({
        renderTemplate: function () {
          this.render();
          this.render('nav', {
            into: 'application',
            outlet: 'nav'
          });
        }
      }));
      this.add('route:colors', _routing.Route.extend({
        model: function () {
          return ['red', 'yellow', 'blue'];
        }
      }));
      this.addTemplate('colors', (0, _internalTestHelpers.strip)(_templateObject11()));
      return this.visit('/colors').then(function () {
        _this7.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject12()));
      });
    };

    _proto['@test it should update the outlets when switching between routes'] = function testItShouldUpdateTheOutletsWhenSwitchingBetweenRoutes() {
      var _this8 = this;

      this.router.map(function () {
        this.route('a');
        this.route('b', function () {
          this.route('c');
          this.route('d');
        });
      });
      this.addTemplate('a', 'A{{outlet}}');
      this.addTemplate('b', 'B{{outlet}}');
      this.addTemplate('b.c', 'C');
      this.addTemplate('b.d', 'D');
      return this.visit('/b/c').then(function () {
        // this.assertComponentElement(this.firstChild, { content: 'BC' });
        _this8.assertText('BC');

        return _this8.visit('/a');
      }).then(function () {
        // this.assertComponentElement(this.firstChild, { content: 'A' });
        _this8.assertText('A');

        return _this8.visit('/b/d');
      }).then(function () {
        _this8.assertText('BD'); // this.assertComponentElement(this.firstChild, { content: 'BD' });

      });
    };

    _proto['@test it should produce a stable DOM when the model changes'] = function testItShouldProduceAStableDOMWhenTheModelChanges() {
      var _this9 = this;

      this.router.map(function () {
        this.route('color', {
          path: '/colors/:color'
        });
      });
      this.add('route:color', _routing.Route.extend({
        model: function (params) {
          return params.color;
        }
      }));
      this.addTemplate('color', 'color: {{model}}');
      return this.visit('/colors/red').then(function () {
        _this9.assertInnerHTML('color: red');

        _this9.takeSnapshot();

        return _this9.visit('/colors/green');
      }).then(function () {
        _this9.assertInnerHTML('color: green');

        _this9.assertInvariants();
      });
    };

    _proto['@test it should have the right controller in scope for the route template'] = function testItShouldHaveTheRightControllerInScopeForTheRouteTemplate() {
      var _this10 = this;

      this.router.map(function () {
        this.route('a');
        this.route('b');
      });
      this.add('controller:a', _controller.default.extend({
        value: 'a'
      }));
      this.add('controller:b', _controller.default.extend({
        value: 'b'
      }));
      this.addTemplate('a', '{{value}}');
      this.addTemplate('b', '{{value}}');
      return this.visit('/a').then(function () {
        _this10.assertText('a');

        return _this10.visit('/b');
      }).then(function () {
        return _this10.assertText('b');
      });
    };

    _proto['@test it should update correctly when the controller changes'] = function testItShouldUpdateCorrectlyWhenTheControllerChanges() {
      var _this11 = this;

      this.router.map(function () {
        this.route('color', {
          path: '/colors/:color'
        });
      });
      this.add('route:color', _routing.Route.extend({
        model: function (params) {
          return {
            color: params.color
          };
        },
        renderTemplate: function (controller, model) {
          this.render({
            controller: model.color,
            model: model
          });
        }
      }));
      this.add('controller:red', _controller.default.extend({
        color: 'red'
      }));
      this.add('controller:green', _controller.default.extend({
        color: 'green'
      }));
      this.addTemplate('color', 'model color: {{model.color}}, controller color: {{color}}');
      return this.visit('/colors/red').then(function () {
        _this11.assertInnerHTML('model color: red, controller color: red');

        return _this11.visit('/colors/green');
      }).then(function () {
        _this11.assertInnerHTML('model color: green, controller color: green');
      });
    };

    _proto['@test it should produce a stable DOM when two routes render the same template'] = function testItShouldProduceAStableDOMWhenTwoRoutesRenderTheSameTemplate() {
      var _this12 = this;

      this.router.map(function () {
        this.route('a');
        this.route('b');
      });
      this.add('route:a', _routing.Route.extend({
        model: function () {
          return 'A';
        },
        renderTemplate: function (controller, model) {
          this.render('common', {
            controller: 'common',
            model: model
          });
        }
      }));
      this.add('route:b', _routing.Route.extend({
        model: function () {
          return 'B';
        },
        renderTemplate: function (controller, model) {
          this.render('common', {
            controller: 'common',
            model: model
          });
        }
      }));
      this.add('controller:common', _controller.default.extend({
        prefix: 'common'
      }));
      this.addTemplate('common', '{{prefix}} {{model}}');
      return this.visit('/a').then(function () {
        _this12.assertInnerHTML('common A');

        _this12.takeSnapshot();

        return _this12.visit('/b');
      }).then(function () {
        _this12.assertInnerHTML('common B');

        _this12.assertInvariants();
      });
    } // Regression test, glimmer child outlets tried to assume the first element.
    // but the if put-args clobbered the args used by did-create-element.
    // I wish there was a way to assert that the OutletComponentManager did not
    // receive a didCreateElement.
    ;

    _proto['@test a child outlet is always a fragment'] = function testAChildOutletIsAlwaysAFragment() {
      var _this13 = this;

      this.addTemplate('application', '{{outlet}}');
      this.addTemplate('index', '{{#if true}}1{{/if}}<div>2</div>');
      return this.visit('/').then(function () {
        _this13.assertInnerHTML('1<div>2</div>');
      });
    };

    _proto['@test it allows a transition during route activate'] = function testItAllowsATransitionDuringRouteActivate() {
      var _this14 = this;

      this.router.map(function () {
        this.route('a');
      });
      this.add('route:index', _routing.Route.extend({
        activate: function () {
          this.transitionTo('a');
        }
      }));
      this.addTemplate('a', 'Hello from A!');
      return this.visit('/').then(function () {
        _this14.assertInnerHTML('Hello from A!');
      });
    };

    _proto['@test it emits a useful backtracking re-render assertion message'] =
    /*#__PURE__*/
    function () {
      var _testItEmitsAUsefulBacktrackingReRenderAssertionMessage = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var _this15, expectedBacktrackingMessage;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _this15 = this;
              this.router.map(function () {
                this.route('routeWithError');
              });
              this.add('route:routeWithError', _routing.Route.extend({
                model: function () {
                  return {
                    name: 'Alex'
                  };
                }
              }));
              this.addTemplate('routeWithError', 'Hi {{model.name}} {{x-foo person=model}}');
              this.addComponent('x-foo', {
                ComponentClass: _glimmer.Component.extend({
                  init: function () {
                    this._super.apply(this, arguments);

                    this.set('person.name', 'Ben');
                  }
                }),
                template: 'Hi {{person.name}} from component'
              });
              expectedBacktrackingMessage = /modified "model\.name" twice on \[object Object\] in a single render\. It was rendered in "template:my-app\/templates\/routeWithError.hbs" and modified in "component:x-foo"/;
              _context.next = 8;
              return this.visit('/');

            case 8:
              assert.throwsAssertion(function () {
                return (0, _internalTestHelpers.runTask)(function () {
                  return _this15.visit('/routeWithError');
                });
              }, expectedBacktrackingMessage);
              _context.next = 11;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testItEmitsAUsefulBacktrackingReRenderAssertionMessage(_x) {
        return _testItEmitsAUsefulBacktrackingReRenderAssertionMessage.apply(this, arguments);
      }

      return testItEmitsAUsefulBacktrackingReRenderAssertionMessage;
    }();

    _proto['@test route templates with {{{undefined}}} [GH#14924] [GH#16172]'] = function testRouteTemplatesWithUndefinedGH14924GH16172() {
      var _this16 = this;

      this.router.map(function () {
        this.route('first');
        this.route('second');
      });
      this.addTemplate('first', 'first');
      this.addTemplate('second', '{{{undefined}}}second');
      return this.visit('/first').then(function () {
        _this16.assertText('first');

        return _this16.visit('/second');
      }).then(function () {
        _this16.assertText('second');

        return _this16.visit('/first');
      }).then(function () {
        _this16.assertText('first');
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/components/angle-bracket-invocation-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/environment", "@ember/-internals/glimmer", "@ember/-internals/runtime", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _environment, _glimmer, _runtime, _metal, _helpers) {
  "use strict";

  function _templateObject9() {
    const data = _taggedTemplateLiteralLoose(["\n          {{#let (component \"foo-bar/inner\") as |Inner|}}\n            <Inner ...attributes>{{yield}}</Inner>\n            <h2>Inside the let</h2>\n          {{/let}}\n          <h3>Outside the let</h3>\n        "]);

    _templateObject9 = function () {
      return data;
    };

    return data;
  }

  function _templateObject8() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#let (component 'x-outer') as |Thing|}}\n          <Thing data-foo>Hello!</Thing>\n        {{/let}}\n      "]);

    _templateObject8 = function () {
      return data;
    };

    return data;
  }

  function _templateObject7() {
    const data = _taggedTemplateLiteralLoose(["\n        <CheckBlock />\n        <CheckBlock></CheckBlock>"]);

    _templateObject7 = function () {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    const data = _taggedTemplateLiteralLoose(["\n          {{#if (has-block)}}\n            Yes\n          {{else}}\n            No\n          {{/if}}"]);

    _templateObject6 = function () {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    const data = _taggedTemplateLiteralLoose(["{{test-harness foo=(hash bar=(component 'foo-bar'))}}"]);

    _templateObject5 = function () {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    const data = _taggedTemplateLiteralLoose(["{{test-harness foo=(component 'foo-bar')}}"]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["{{test-harness foo=(component 'foo-bar')}}"]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#with (component 'foo-bar') as |Other|}}\n          <Other />\n        {{/with}}\n      "]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n        <FooBar @class=\"bar baz\" />\n        <FooBar @classNames=\"bar baz\" />\n        <FooBar />\n      "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  var CustomModifierManager =
  /*#__PURE__*/
  function () {
    function CustomModifierManager(owner) {
      this.owner = owner;
    }

    var _proto = CustomModifierManager.prototype;

    _proto.createModifier = function createModifier(factory, args) {
      return factory.create(args);
    };

    _proto.installModifier = function installModifier(instance, element, args) {
      instance.element = element;
      var positional = args.positional,
          named = args.named;
      instance.didInsertElement(positional, named);
    };

    _proto.updateModifier = function updateModifier(instance, args) {
      var positional = args.positional,
          named = args.named;
      instance.didUpdate(positional, named);
    };

    _proto.destroyModifier = function destroyModifier(instance) {
      instance.willDestroyElement();
    };

    return CustomModifierManager;
  }();

  var BaseModifier = (0, _glimmer.setModifierManager)(function (owner) {
    return new CustomModifierManager(owner);
  }, _runtime.Object.extend({
    didInsertElement: function () {},
    didUpdate: function () {},
    willDestroyElement: function () {}
  }));
  (0, _internalTestHelpers.moduleFor)('AngleBracket Invocation',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto2 = _class.prototype;

    _proto2['@test it can resolve <XBlah /> to x-blah'] = function testItCanResolveXBlahToXBlah() {
      var _this = this;

      this.registerComponent('x-blah', {
        template: 'hello'
      });
      this.render('<XBlah />');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    };

    _proto2['@test it can resolve <X-Blah /> to x-blah'] = function testItCanResolveXBlahToXBlah() {
      var _this2 = this;

      this.registerComponent('x-blah', {
        template: 'hello'
      });
      this.render('<X-Blah />');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    };

    _proto2['@test it can render a basic template only component'] = function testItCanRenderABasicTemplateOnlyComponent() {
      var _this3 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('<FooBar />');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    };

    _proto2['@test it can render a basic component with template and javascript'] = function testItCanRenderABasicComponentWithTemplateAndJavascript() {
      this.registerComponent('foo-bar', {
        template: 'FIZZ BAR {{local}}',
        ComponentClass: _helpers.Component.extend({
          local: 'hey'
        })
      });
      this.render('<FooBar />');
      this.assertComponentElement(this.firstChild, {
        content: 'FIZZ BAR hey'
      });
    };

    _proto2['@test it can render a single word component name'] = function testItCanRenderASingleWordComponentName() {
      var _this4 = this;

      this.registerComponent('foo', {
        template: 'hello'
      });
      this.render('<Foo />');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    };

    _proto2['@test it can not render a component name without initial capital letter'] = function testItCanNotRenderAComponentNameWithoutInitialCapitalLetter(assert) {
      this.registerComponent('div', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            assert.ok(false, 'should not have created component');
          }
        })
      });
      this.render('<div></div>');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: ''
      });
    };

    _proto2['@test it can have a custom id and it is not bound'] = function testItCanHaveACustomIdAndItIsNotBound() {
      var _this5 = this;

      this.registerComponent('foo-bar', {
        template: '{{id}} {{elementId}}'
      });
      this.render('<FooBar @id={{customId}} />', {
        customId: 'bizz'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'bizz bizz'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'customId', 'bar');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'bar bizz'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'customId', 'bizz');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'bizz bizz'
      });
    };

    _proto2['@test it can have a custom id attribute and it is bound'] = function testItCanHaveACustomIdAttributeAndItIsBound() {
      var _this6 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('<FooBar id={{customId}} />', {
        customId: 'bizz'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'hello'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'customId', 'bar');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'customId', 'bizz');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'hello'
      });
    };

    _proto2['@test it can have a custom tagName'] = function testItCanHaveACustomTagName() {
      var _this7 = this;

      var FooBarComponent = _helpers.Component.extend({
        tagName: 'foo-bar'
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('<FooBar></FooBar>');
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
    };

    _proto2['@test it can have a custom tagName from the invocation'] = function testItCanHaveACustomTagNameFromTheInvocation() {
      var _this8 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('<FooBar @tagName="foo-bar" />');
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
    };

    _proto2['@test it can have custom classNames'] = function testItCanHaveCustomClassNames() {
      var _this9 = this;

      var FooBarComponent = _helpers.Component.extend({
        classNames: ['foo', 'bar']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('<FooBar />');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar')
        },
        content: 'hello'
      });
    };

    _proto2['@test class property on components can be dynamic'] = function testClassPropertyOnComponentsCanBeDynamic() {
      var _this10 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('<FooBar @class={{if fooBar "foo-bar"}} />', {
        fooBar: true
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'fooBar', false);
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'fooBar', true);
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        }
      });
    };

    _proto2['@test it can set custom classNames from the invocation'] = function testItCanSetCustomClassNamesFromTheInvocation() {
      var _this11 = this;

      var FooBarComponent = _helpers.Component.extend({
        classNames: ['foo']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject()));
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar baz')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar baz')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this11.rerender();
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar baz')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar baz')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo')
        },
        content: 'hello'
      });
    };

    _proto2['@test it has an element'] = function testItHasAnElement() {
      var _this12 = this;

      var instance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          instance = this;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('<FooBar></FooBar>');
      var element1 = instance.element;
      this.assertComponentElement(element1, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.rerender();
      });
      var element2 = instance.element;
      this.assertComponentElement(element2, {
        content: 'hello'
      });
      this.assertSameNode(element2, element1);
    };

    _proto2['@test it has the right parentView and childViews'] = function testItHasTheRightParentViewAndChildViews(assert) {
      var _this13 = this;

      var fooBarInstance, fooBarBazInstance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          fooBarInstance = this;
        }
      });

      var FooBarBazComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          fooBarBazInstance = this;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'foo-bar {{foo-bar-baz}}'
      });
      this.registerComponent('foo-bar-baz', {
        ComponentClass: FooBarBazComponent,
        template: 'foo-bar-baz'
      });
      this.render('<FooBar />');
      this.assertText('foo-bar foo-bar-baz');
      assert.equal(fooBarInstance.parentView, this.component);
      assert.equal(fooBarBazInstance.parentView, fooBarInstance);
      assert.deepEqual(this.component.childViews, [fooBarInstance]);
      assert.deepEqual(fooBarInstance.childViews, [fooBarBazInstance]);
      (0, _internalTestHelpers.runTask)(function () {
        return _this13.rerender();
      });
      this.assertText('foo-bar foo-bar-baz');
      assert.equal(fooBarInstance.parentView, this.component);
      assert.equal(fooBarBazInstance.parentView, fooBarInstance);
      assert.deepEqual(this.component.childViews, [fooBarInstance]);
      assert.deepEqual(fooBarInstance.childViews, [fooBarBazInstance]);
    };

    _proto2['@test it renders passed named arguments'] = function testItRendersPassedNamedArguments() {
      var _this14 = this;

      this.registerComponent('foo-bar', {
        template: '{{@foo}}'
      });
      this.render('<FooBar @foo={{model.bar}} />', {
        model: {
          bar: 'Hola'
        }
      });
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(function () {
        return _this14.rerender();
      });
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(function () {
        return _this14.context.set('model.bar', 'Hello');
      });
      this.assertText('Hello');
      (0, _internalTestHelpers.runTask)(function () {
        return _this14.context.set('model', {
          bar: 'Hola'
        });
      });
      this.assertText('Hola');
    };

    _proto2['@test it reflects named arguments as properties'] = function testItReflectsNamedArgumentsAsProperties() {
      var _this15 = this;

      this.registerComponent('foo-bar', {
        template: '{{foo}}'
      });
      this.render('<FooBar @foo={{model.bar}} />', {
        model: {
          bar: 'Hola'
        }
      });
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(function () {
        return _this15.rerender();
      });
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(function () {
        return _this15.context.set('model.bar', 'Hello');
      });
      this.assertText('Hello');
      (0, _internalTestHelpers.runTask)(function () {
        return _this15.context.set('model', {
          bar: 'Hola'
        });
      });
      this.assertText('Hola');
    };

    _proto2['@test it can render a basic component with a block'] = function testItCanRenderABasicComponentWithABlock() {
      var _this16 = this;

      this.registerComponent('foo-bar', {
        template: '{{yield}} - In component'
      });
      this.render('<FooBar>hello</FooBar>');
      this.assertComponentElement(this.firstChild, {
        content: 'hello - In component'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this16.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello - In component'
      });
    };

    _proto2['@test it can yield internal and external properties positionally'] = function testItCanYieldInternalAndExternalPropertiesPositionally() {
      var _this17 = this;

      var instance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          instance = this;
        },
        greeting: 'hello'
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{yield greeting greetee.firstName}}'
      });
      this.render('<FooBar @greetee={{person}} as |greeting name|>{{name}} {{person.lastName}}, {{greeting}}</FooBar>', {
        person: {
          firstName: 'Joel',
          lastName: 'Kang'
        }
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Joel Kang, hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this17.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Joel Kang, hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this17.context, 'person', {
          firstName: 'Dora',
          lastName: 'the Explorer'
        });
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Dora the Explorer, hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(instance, 'greeting', 'hola');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Dora the Explorer, hola'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(instance, 'greeting', 'hello');
        (0, _metal.set)(_this17.context, 'person', {
          firstName: 'Joel',
          lastName: 'Kang'
        });
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Joel Kang, hello'
      });
    };

    _proto2['@test positional parameters are not allowed'] = function testPositionalParametersAreNotAllowed() {
      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['first', 'second']
        }),
        template: '{{first}}{{second}}'
      }); // this is somewhat silly as the browser "corrects" for these as
      // attribute names, but regardless the thing we care about here is that
      // they are **not** used as positional params

      this.render('<SampleComponent one two />');
      this.assertText('');
    };

    _proto2['@test can invoke curried components with capitalized block param names'] = function testCanInvokeCurriedComponentsWithCapitalizedBlockParamNames() {
      var _this18 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject2()));
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      this.assertStableRerender();
    };

    _proto2['@test can invoke curried components with named args'] = function testCanInvokeCurriedComponentsWithNamedArgs() {
      var _this19 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.registerComponent('test-harness', {
        template: '<@foo />'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject3()));
      this.assertComponentElement(this.firstChild.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this19.rerender();
      });
      this.assertComponentElement(this.firstChild.firstChild, {
        content: 'hello'
      });
      this.assertStableRerender();
    };

    _proto2['@test can invoke curried components with a path'] = function testCanInvokeCurriedComponentsWithAPath() {
      var _this20 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.registerComponent('test-harness', {
        template: '<this.foo />'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject4()));
      this.assertComponentElement(this.firstChild.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this20.rerender();
      });
      this.assertComponentElement(this.firstChild.firstChild, {
        content: 'hello'
      });
      this.assertStableRerender();
    };

    _proto2['@test can not invoke curried components with an implicit `this` path'] = function testCanNotInvokeCurriedComponentsWithAnImplicitThisPath(assert) {
      assert.expect(0);
      this.registerComponent('foo-bar', {
        template: 'hello',
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            assert.ok(false, 'should not have instantiated');
          }
        })
      });
      this.registerComponent('test-harness', {
        template: '<foo.bar />'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject5()));
    };

    _proto2['@test has-block'] = function testHasBlock() {
      this.registerComponent('check-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject6())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject7()));
      this.assertComponentElement(this.firstChild, {
        content: 'No'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'Yes'
      });
      this.assertStableRerender();
    };

    _proto2['@test includes invocation specified attributes in root element ("splattributes")'] = function testIncludesInvocationSpecifiedAttributesInRootElementSplattributes() {
      var _this21 = this;

      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend(),
        template: 'hello'
      });
      this.render('<FooBar data-foo={{foo}} data-bar={{bar}} />', {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this21.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this21.context, 'foo', 'FOO');
        (0, _metal.set)(_this21.context, 'bar', undefined);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'FOO'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this21.context, 'foo', 'foo');
        (0, _metal.set)(_this21.context, 'bar', 'bar');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
    };

    _proto2['@test attributes without values passed at invocation are included in `...attributes` ("splattributes")'] = function testAttributesWithoutValuesPassedAtInvocationAreIncludedInAttributesSplattributes() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div ...attributes>hello</div>'
      });
      this.render('<FooBar data-bar />');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-bar': ''
        },
        content: 'hello'
      });
      this.assertStableRerender();
    };

    _proto2['@test attributes without values at definition are included in `...attributes` ("splattributes")'] = function testAttributesWithoutValuesAtDefinitionAreIncludedInAttributesSplattributes() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div data-bar ...attributes>hello</div>'
      });
      this.render('<FooBar />');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-bar': ''
        },
        content: 'hello'
      });
      this.assertStableRerender();
    };

    _proto2['@test includes invocation specified attributes in `...attributes` slot in tagless component ("splattributes")'] = function testIncludesInvocationSpecifiedAttributesInAttributesSlotInTaglessComponentSplattributes() {
      var _this22 = this;

      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div ...attributes>hello</div>'
      });
      this.render('<FooBar data-foo={{foo}} data-bar={{bar}} />', {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this22.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this22.context, 'foo', 'FOO');
        (0, _metal.set)(_this22.context, 'bar', undefined);
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'FOO'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this22.context, 'foo', 'foo');
        (0, _metal.set)(_this22.context, 'bar', 'bar');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
    };

    _proto2['@test merges attributes with `...attributes` in tagless component ("splattributes")'] = function testMergesAttributesWithAttributesInTaglessComponentSplattributes() {
      var _this23 = this;

      var instance;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: '',
          init: function () {
            instance = this;

            this._super.apply(this, arguments);

            this.localProp = 'qux';
          }
        }),
        template: '<div data-derp={{localProp}} ...attributes>hello</div>'
      });
      this.render('<FooBar data-foo={{foo}} data-bar={{bar}} />', {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-derp': 'qux',
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this23.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-derp': 'qux',
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this23.context, 'foo', 'FOO');
        (0, _metal.set)(_this23.context, 'bar', undefined);
        (0, _metal.set)(instance, 'localProp', 'QUZ');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-derp': 'QUZ',
          'data-foo': 'FOO'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this23.context, 'foo', 'foo');
        (0, _metal.set)(_this23.context, 'bar', 'bar');
        (0, _metal.set)(instance, 'localProp', 'qux');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-derp': 'qux',
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
    };

    _proto2['@test merges class attribute with `...attributes` in tagless component ("splattributes")'] = function testMergesClassAttributeWithAttributesInTaglessComponentSplattributes() {
      var _this24 = this;

      var instance;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: '',
          init: function () {
            instance = this;

            this._super.apply(this, arguments);

            this.localProp = 'qux';
          }
        }),
        template: '<div class={{localProp}} ...attributes>hello</div>'
      });
      this.render('<FooBar class={{bar}} />', {
        bar: 'bar'
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('qux bar')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this24.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('qux bar')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this24.context, 'bar', undefined);
        (0, _metal.set)(instance, 'localProp', 'QUZ');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('QUZ')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this24.context, 'bar', 'bar');
        (0, _metal.set)(instance, 'localProp', 'qux');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('qux bar')
        },
        content: 'hello'
      });
    };

    _proto2['@test merges trailing class attribute with `...attributes` in tagless component ("splattributes")'] = function testMergesTrailingClassAttributeWithAttributesInTaglessComponentSplattributes() {
      var _this25 = this;

      var instance;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: '',
          init: function () {
            instance = this;

            this._super.apply(this, arguments);

            this.localProp = 'qux';
          }
        }),
        template: '<div ...attributes class={{localProp}}>hello</div>'
      });
      this.render('<FooBar class={{bar}} />', {
        bar: 'bar'
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('bar qux')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this25.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('bar qux')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this25.context, 'bar', undefined);
        (0, _metal.set)(instance, 'localProp', 'QUZ');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('QUZ')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this25.context, 'bar', 'bar');
        (0, _metal.set)(instance, 'localProp', 'qux');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('bar qux')
        },
        content: 'hello'
      });
    };

    _proto2['@test merges class attribute with `...attributes` in yielded contextual component ("splattributes")'] = function testMergesClassAttributeWithAttributesInYieldedContextualComponentSplattributes() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '{{yield (hash baz=(component "foo-bar/baz"))}}'
      });
      this.registerComponent('foo-bar/baz', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div class="default-class" ...attributes>hello</div>'
      });
      this.render('<FooBar as |fb|><fb.baz class="custom-class" title="foo"></fb.baz></FooBar>');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('default-class custom-class'),
          title: 'foo'
        },
        content: 'hello'
      });
    };

    _proto2['@test merges trailing class attribute with `...attributes` in yielded contextual component ("splattributes")'] = function testMergesTrailingClassAttributeWithAttributesInYieldedContextualComponentSplattributes() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '{{yield (hash baz=(component "foo-bar/baz"))}}'
      });
      this.registerComponent('foo-bar/baz', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div ...attributes class="default-class" >hello</div>'
      });
      this.render('<FooBar as |fb|><fb.baz class="custom-class" title="foo"></fb.baz></FooBar>');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('custom-class default-class'),
          title: 'foo'
        },
        content: 'hello'
      });
    };

    _proto2['@test the attributes passed on invocation trump over the default ones on elements with `...attributes` in yielded contextual component ("splattributes")'] = function testTheAttributesPassedOnInvocationTrumpOverTheDefaultOnesOnElementsWithAttributesInYieldedContextualComponentSplattributes() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '{{yield (hash baz=(component "foo-bar/baz"))}}'
      });
      this.registerComponent('foo-bar/baz', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div title="bar" ...attributes>hello</div>'
      });
      this.render('<FooBar as |fb|><fb.baz title="foo"></fb.baz></FooBar>');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          title: 'foo'
        },
        content: 'hello'
      });
    };

    _proto2['@test can forward ...attributes to dynamic component invocation ("splattributes")'] = function testCanForwardAttributesToDynamicComponentInvocationSplattributes() {
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<XInner ...attributes>{{yield}}</XInner>'
      });
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div ...attributes>{{yield}}</div>'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject8()));
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': ''
        },
        content: 'Hello!'
      });
    };

    _proto2['@test an inner angle invocation can forward ...attributes through dynamic component invocation ("splattributes")'] = function testAnInnerAngleInvocationCanForwardAttributesThroughDynamicComponentInvocationSplattributes() {
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: "{{#let (component 'x-inner') as |Thing|}}<Thing ...attributes>{{yield}}</Thing>{{/let}}"
      });
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div ...attributes>{{yield}}</div>'
      });
      this.render('<XOuter data-foo>Hello!</XOuter>');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': ''
        },
        content: 'Hello!'
      });
    };

    _proto2['@test an inner angle invocation can forward ...attributes through static component invocation ("splattributes")'] = function testAnInnerAngleInvocationCanForwardAttributesThroughStaticComponentInvocationSplattributes() {
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: "<XInner ...attributes>{{yield}}</XInner>"
      });
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div ...attributes>{{yield}}</div>'
      });
      this.render('<XOuter data-foo>Hello!</XOuter>');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': ''
        },
        content: 'Hello!'
      });
    };

    _proto2['@test can include `...attributes` in multiple elements in tagless component ("splattributes")'] = function testCanIncludeAttributesInMultipleElementsInTaglessComponentSplattributes() {
      var _this26 = this;

      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div ...attributes>hello</div><p ...attributes>world</p>'
      });
      this.render('<FooBar data-foo={{foo}} data-bar={{bar}} />', {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertElement(this.nthChild(1), {
        tagName: 'p',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'world'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this26.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertElement(this.nthChild(1), {
        tagName: 'p',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'world'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this26.context, 'foo', 'FOO');
        (0, _metal.set)(_this26.context, 'bar', undefined);
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'FOO'
        },
        content: 'hello'
      });
      this.assertElement(this.nthChild(1), {
        tagName: 'p',
        attrs: {
          'data-foo': 'FOO'
        },
        content: 'world'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this26.context, 'foo', 'foo');
        (0, _metal.set)(_this26.context, 'bar', 'bar');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertElement(this.nthChild(1), {
        tagName: 'p',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'world'
      });
    };

    _proto2['@test can yield content to contextual components invoked with angle-bracket components that receives splattributes'] = function testCanYieldContentToContextualComponentsInvokedWithAngleBracketComponentsThatReceivesSplattributes() {
      this.registerComponent('foo-bar/inner', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<h1 ...attributes>{{yield}}</h1>'
      });
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        // If <Inner> doesn't receive splattributes this test passes
        template: (0, _internalTestHelpers.strip)(_templateObject9())
      });
      this.render('<FooBar>Yielded content</FooBar>');
      this.assertElement(this.firstChild, {
        tagName: 'h1',
        attrs: {},
        content: 'Yielded content'
      });
      this.assertElement(this.nthChild(1), {
        tagName: 'h2',
        attrs: {},
        content: 'Inside the let'
      });
      this.assertElement(this.nthChild(2), {
        tagName: 'h3',
        attrs: {},
        content: 'Outside the let'
      });
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
  (0, _internalTestHelpers.moduleFor)('AngleBracket Invocation (splattributes)',
  /*#__PURE__*/
  function (_RenderingTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _RenderingTestCase2);

    function _class2() {
      var _this27;

      _this27 = _RenderingTestCase2.apply(this, arguments) || this;
      _this27._TEMPLATE_ONLY_GLIMMER_COMPONENTS = _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS;
      _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = true;
      return _this27;
    }

    var _proto3 = _class2.prototype;

    _proto3.teardown = function teardown() {
      _RenderingTestCase2.prototype.teardown.call(this);

      _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = this._TEMPLATE_ONLY_GLIMMER_COMPONENTS;
    };

    _proto3.registerComponent = function registerComponent(name, template) {
      _RenderingTestCase2.prototype.registerComponent.call(this, name, {
        template: template,
        ComponentClass: null
      });
    };

    _proto3['@test angle bracket invocation can pass merge ...attributes'] = function testAngleBracketInvocationCanPassMergeAttributes() {
      this.registerComponent('qux', '<div data-from-qux-before ...attributes data-from-qux-after></div>');
      this.registerComponent('bar', '<Qux data-from-bar-before ...attributes data-from-bar-after />');
      this.registerComponent('foo', '<Bar data-from-foo-before ...attributes data-from-foo-after />');
      this.render('<Foo data-from-top />');
      this.assertHTML("<div\n        data-from-qux-before=\"\"\n        data-from-bar-before=\"\"\n        data-from-foo-before=\"\"\n        data-from-top=\"\"\n        data-from-foo-after=\"\"\n        data-from-bar-after=\"\"\n        data-from-qux-after=\"\"\n      ></div>");
    };

    _proto3['@test angle bracket invocation can allow invocation side to override attributes with ...attributes'] = function testAngleBracketInvocationCanAllowInvocationSideToOverrideAttributesWithAttributes() {
      this.registerComponent('qux', '<div id="qux" ...attributes />');
      this.registerComponent('bar', '<Qux id="bar" ...attributes />');
      this.registerComponent('foo', '<Bar id="foo" ...attributes />');
      this.render('<Foo id="top" />');
      this.assertHTML('<div id="top"></div>');
    };

    _proto3['@test angle bracket invocation can override invocation side attributes with ...attributes'] = function testAngleBracketInvocationCanOverrideInvocationSideAttributesWithAttributes() {
      this.registerComponent('qux', '<div ...attributes id="qux" />');
      this.registerComponent('bar', '<Qux ...attributes id="bar" />');
      this.registerComponent('foo', '<Bar ...attributes id="foo" />');
      this.render('<Foo id="top" />');
      this.assertHTML('<div id="qux"></div>');
    };

    _proto3['@test angle bracket invocation can forward classes before ...attributes to a nested component'] = function testAngleBracketInvocationCanForwardClassesBeforeAttributesToANestedComponent() {
      this.registerComponent('qux', '<div class="qux" ...attributes />');
      this.registerComponent('bar', '<Qux class="bar" ...attributes />');
      this.registerComponent('foo', '<Bar class="foo" ...attributes />');
      this.render('<Foo class="top" />');
      this.assertHTML('<div class="qux bar foo top"></div>');
    };

    _proto3['@test angle bracket invocation can forward classes after ...attributes to a nested component'] = function testAngleBracketInvocationCanForwardClassesAfterAttributesToANestedComponent() {
      this.registerComponent('qux', '<div ...attributes class="qux" />');
      this.registerComponent('bar', '<Qux ...attributes class="bar" />');
      this.registerComponent('foo', '<Bar ...attributes class="foo" />');
      this.render('<Foo class="top" />');
      this.assertHTML('<div class="top foo bar qux"></div>');
    };

    return _class2;
  }(_internalTestHelpers.RenderingTestCase));

  if (true
  /* EMBER_GLIMMER_ANGLE_BRACKET_NESTED_LOOKUP */
  ) {
      (0, _internalTestHelpers.moduleFor)('AngleBracket Invocation Nested Lookup',
      /*#__PURE__*/
      function (_RenderingTestCase3) {
        (0, _emberBabel.inheritsLoose)(_class3, _RenderingTestCase3);

        function _class3() {
          return _RenderingTestCase3.apply(this, arguments) || this;
        }

        var _proto4 = _class3.prototype;

        _proto4['@test it can resolve <Foo::Bar::BazBing /> to foo/bar/baz-bing'] = function testItCanResolveFooBarBazBingToFooBarBazBing() {
          var _this28 = this;

          this.registerComponent('foo/bar/baz-bing', {
            template: 'hello'
          });
          this.render('<Foo::Bar::BazBing />');
          this.assertComponentElement(this.firstChild, {
            content: 'hello'
          });
          (0, _internalTestHelpers.runTask)(function () {
            return _this28.rerender();
          });
          this.assertComponentElement(this.firstChild, {
            content: 'hello'
          });
        };

        return _class3;
      }(_internalTestHelpers.RenderingTestCase));
    }

  if (true
  /* EMBER_GLIMMER_FORWARD_MODIFIERS_WITH_SPLATTRIBUTES */
  ) {
      (0, _internalTestHelpers.moduleFor)('Element modifiers on AngleBracket components',
      /*#__PURE__*/
      function (_RenderingTestCase4) {
        (0, _emberBabel.inheritsLoose)(_class4, _RenderingTestCase4);

        function _class4() {
          return _RenderingTestCase4.apply(this, arguments) || this;
        }

        var _proto5 = _class4.prototype;

        _proto5['@test modifiers are forwarded to a single element receiving the splattributes'] = function testModifiersAreForwardedToASingleElementReceivingTheSplattributes(assert) {
          var modifierParams = null;
          var modifierNamedArgs = null;
          var modifiedElement;
          this.registerComponent('the-foo', {
            ComponentClass: _helpers.Component.extend({
              tagName: ''
            }),
            template: '<div id="inner-div" ...attributes>Foo</div>'
          });
          this.registerModifier('bar', BaseModifier.extend({
            didInsertElement: function (params, namedArgs) {
              modifierParams = params;
              modifierNamedArgs = namedArgs;
              modifiedElement = this.element;
            }
          }));
          this.render('<TheFoo {{bar "something" foo="else"}}/>', {});
          assert.deepEqual(modifierParams, ['something']);
          assert.deepEqual(modifierNamedArgs, {
            foo: 'else'
          });
          assert.equal(modifiedElement && modifiedElement.getAttribute('id'), 'inner-div', 'Modifier is called on the element receiving the splattributes');
        };

        _proto5['@test modifiers are forwarded to all the elements receiving the splattributes'] = function testModifiersAreForwardedToAllTheElementsReceivingTheSplattributes(assert) {
          var elementIds = [];
          this.registerComponent('the-foo', {
            ComponentClass: _helpers.Component.extend({
              tagName: ''
            }),
            template: '<div id="inner-one" ...attributes>Foo</div><div id="inner-two" ...attributes>Bar</div>'
          });
          this.registerModifier('bar', BaseModifier.extend({
            didInsertElement: function (params, namedArgs) {
              assert.deepEqual(params, ['something']);
              assert.deepEqual(namedArgs, {
                foo: 'else'
              });

              if (this.element) {
                elementIds.push(this.element.getAttribute('id'));
              }
            }
          }));
          this.render('<TheFoo {{bar "something" foo="else"}}/>');
          assert.deepEqual(elementIds, ['inner-one', 'inner-two'], 'The modifier has been instantiated twice, once for each element with splattributes');
        };

        _proto5['@test modifiers on components accept bound arguments and track changes on the'] = function testModifiersOnComponentsAcceptBoundArgumentsAndTrackChangesOnThe(assert) {
          var _this29 = this;

          var modifierParams = null;
          var modifierNamedArgs = null;
          var modifiedElement;
          this.registerComponent('the-foo', {
            ComponentClass: _helpers.Component.extend({
              tagName: ''
            }),
            template: '<div id="inner-div" ...attributes>Foo</div>'
          });
          this.registerModifier('bar', BaseModifier.extend({
            didInsertElement: function (params, namedArgs) {
              modifierParams = params;
              modifierNamedArgs = namedArgs;
              modifiedElement = this.element;
            },
            didUpdate: function (params, namedArgs) {
              modifierParams = params;
              modifierNamedArgs = namedArgs;
              modifiedElement = this.element;
            }
          }));
          this.render('<TheFoo {{bar this.something foo=this.foo}}/>', {
            something: 'something',
            foo: 'else'
          });
          assert.deepEqual(modifierParams, ['something']);
          assert.deepEqual(modifierNamedArgs, {
            foo: 'else'
          });
          assert.equal(modifiedElement && modifiedElement.getAttribute('id'), 'inner-div', 'Modifier is called on the element receiving the splattributes');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.setProperties)(_this29.context, {
              something: 'another',
              foo: 'thingy'
            });
          });
          assert.deepEqual(modifierParams, ['another']);
          assert.deepEqual(modifierNamedArgs, {
            foo: 'thingy'
          });
          assert.equal(modifiedElement && modifiedElement.getAttribute('id'), 'inner-div', 'Modifier is called on the element receiving the splattributes');
        };

        _proto5['@test modifiers on components accept `this` in both positional params and named arguments, and updates when it changes'] = function testModifiersOnComponentsAcceptThisInBothPositionalParamsAndNamedArgumentsAndUpdatesWhenItChanges(assert) {
          var _this30 = this;

          var modifierParams = null;
          var modifierNamedArgs = null;
          var modifiedElement;
          var context = {
            id: 1
          };
          var context2 = {
            id: 2
          };
          this.registerComponent('the-foo', {
            ComponentClass: _helpers.Component.extend({
              tagName: ''
            }),
            template: '<div id="inner-div" ...attributes>Foo</div>'
          });
          this.registerModifier('bar', BaseModifier.extend({
            didInsertElement: function (params, namedArgs) {
              modifierParams = params;
              modifierNamedArgs = namedArgs;
              modifiedElement = this.element;
            },
            didUpdate: function (params, namedArgs) {
              modifierParams = params;
              modifierNamedArgs = namedArgs;
              modifiedElement = this.element;
            }
          }));
          this.render('<TheFoo {{bar "name" this foo=this}}/>', context);
          assert.equal(modifierParams[1].id, 1);
          assert.equal(modifierNamedArgs.foo.id, 1);
          assert.equal(modifiedElement && modifiedElement.getAttribute('id'), 'inner-div', 'Modifier is called on the element receiving the splattributes');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.setProperties)(_this30.context, context2);
          });
          assert.equal(modifierParams[1].id, 2);
          assert.equal(modifierNamedArgs.foo.id, 2);
          assert.equal(modifiedElement && modifiedElement.getAttribute('id'), 'inner-div', 'Modifier is called on the element receiving the splattributes');
        };

        _proto5['@test modifiers on components accept local variables in both positional params and named arguments, and updates when they change'] = function testModifiersOnComponentsAcceptLocalVariablesInBothPositionalParamsAndNamedArgumentsAndUpdatesWhenTheyChange(assert) {
          var _this31 = this;

          var modifierParams = null;
          var modifierNamedArgs = null;
          var modifiedElement;
          this.registerComponent('the-foo', {
            ComponentClass: _helpers.Component.extend({
              tagName: ''
            }),
            template: '<div id="inner-div" ...attributes>Foo</div>'
          });
          this.registerModifier('bar', BaseModifier.extend({
            didInsertElement: function (params, namedArgs) {
              modifierParams = params;
              modifierNamedArgs = namedArgs;
              modifiedElement = this.element;
            },
            didUpdate: function (params, namedArgs) {
              modifierParams = params;
              modifierNamedArgs = namedArgs;
              modifiedElement = this.element;
            }
          }));
          this.render("\n          {{#let this.foo as |v|}}\n            <TheFoo {{bar v foo=v}}/>\n          {{/let}}", {
            foo: 'bar'
          });
          assert.deepEqual(modifierParams, ['bar']);
          assert.deepEqual(modifierNamedArgs, {
            foo: 'bar'
          });
          assert.equal(modifiedElement && modifiedElement.getAttribute('id'), 'inner-div', 'Modifier is called on the element receiving the splattributes');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.setProperties)(_this31.context, {
              foo: 'qux'
            });
          });
          assert.deepEqual(modifierParams, ['qux']);
          assert.deepEqual(modifierNamedArgs, {
            foo: 'qux'
          });
          assert.equal(modifiedElement && modifiedElement.getAttribute('id'), 'inner-div', 'Modifier is called on the element receiving the splattributes');
        };

        _proto5['@test modifiers on components can be received and forwarded to inner component'] = function testModifiersOnComponentsCanBeReceivedAndForwardedToInnerComponent(assert) {
          var modifierParams = null;
          var modifierNamedArgs = null;
          var elementIds = [];
          this.registerComponent('the-inner', {
            ComponentClass: _helpers.Component.extend({
              tagName: ''
            }),
            template: '<div id="inner-div" ...attributes>{{yield}}</div>'
          });
          this.registerComponent('the-foo', {
            ComponentClass: _helpers.Component.extend({
              tagName: ''
            }),
            template: '<div id="outer-div" ...attributes>Outer</div><TheInner ...attributes>Hello</TheInner>'
          });
          this.registerModifier('bar', BaseModifier.extend({
            didInsertElement: function (params, namedArgs) {
              modifierParams = params;
              modifierNamedArgs = namedArgs;

              if (this.element) {
                elementIds.push(this.element.getAttribute('id'));
              }
            }
          }));
          this.render("\n          {{#let this.foo as |v|}}\n            <TheFoo {{bar v foo=v}}/>\n          {{/let}}\n        ", {
            foo: 'bar'
          });
          assert.deepEqual(modifierParams, ['bar']);
          assert.deepEqual(modifierNamedArgs, {
            foo: 'bar'
          });
          assert.deepEqual(elementIds, ['outer-div', 'inner-div'], 'Modifiers are called on all levels');
        };

        return _class4;
      }(_internalTestHelpers.RenderingTestCase));
    }
});
enifed("@ember/-internals/glimmer/tests/integration/components/append-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _helpers) {
  "use strict";

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#if showFooBar}}\n        {{foo-bar}}\n      {{else}}\n        {{baz-qux}}\n      {{/if}}\n    "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  var AbstractAppendTest =
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(AbstractAppendTest, _RenderingTestCase);

    function AbstractAppendTest() {
      var _this;

      _this = _RenderingTestCase.apply(this, arguments) || this;
      _this.components = [];
      _this.ids = [];
      return _this;
    }

    var _proto = AbstractAppendTest.prototype;

    _proto.teardown = function teardown() {
      this.component = null;
      this.components.forEach(function (component) {
        (0, _internalTestHelpers.runTask)(function () {
          return component.destroy();
        });
      });
      this.ids.forEach(function (id) {
        var $element = document.getElementById(id);

        if ($element) {
          $element.parentNode.removeChild($element);
        } // this.assert.strictEqual($element.length, 0, `Should not leak element: #${id}`);

      });

      _RenderingTestCase.prototype.teardown.call(this);
    }
    /* abstract append(component): Element; */
    ;

    _proto.didAppend = function didAppend(component) {
      this.components.push(component);
      this.ids.push(component.elementId);
    };

    _proto['@test lifecycle hooks during component append'] = function testLifecycleHooksDuringComponentAppend(assert) {
      var _this2 = this;

      var hooks = [];
      var oldRegisterComponent = this.registerComponent;
      var componentsByName = {}; // TODO: refactor/combine with other life-cycle tests

      this.registerComponent = function (name, _options) {
        function pushHook(hookName) {
          hooks.push([name, hookName]);
        }

        var options = {
          ComponentClass: _options.ComponentClass.extend({
            init: function () {
              this._super.apply(this, arguments);

              if (name in componentsByName) {
                throw new TypeError('Component named: ` ' + name + ' ` already registered');
              }

              componentsByName[name] = this;
              pushHook('init');
              this.on('init', function () {
                return pushHook('on(init)');
              });
            },
            didReceiveAttrs: function () {
              pushHook('didReceiveAttrs');
            },
            willInsertElement: function () {
              pushHook('willInsertElement');
            },
            willRender: function () {
              pushHook('willRender');
            },
            didInsertElement: function () {
              pushHook('didInsertElement');
            },
            didRender: function () {
              pushHook('didRender');
            },
            didUpdateAttrs: function () {
              pushHook('didUpdateAttrs');
            },
            willUpdate: function () {
              pushHook('willUpdate');
            },
            didUpdate: function () {
              pushHook('didUpdate');
            },
            willDestroyElement: function () {
              pushHook('willDestroyElement');
            },
            willClearRender: function () {
              pushHook('willClearRender');
            },
            didDestroyElement: function () {
              pushHook('didDestroyElement');
            },
            willDestroy: function () {
              pushHook('willDestroy');

              this._super.apply(this, arguments);
            }
          }),
          template: _options.template
        };
        oldRegisterComponent.call(this, name, options);
      };

      this.registerComponent('x-parent', {
        ComponentClass: _helpers.Component.extend({
          layoutName: 'components/x-parent'
        }),
        template: '[parent: {{foo}}]{{#x-child bar=foo}}[yielded: {{foo}}]{{/x-child}}'
      });
      this.registerComponent('x-child', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '[child: {{bar}}]{{yield}}'
      });
      var XParent;
      XParent = this.owner.factoryFor('component:x-parent');
      this.component = XParent.create({
        foo: 'zomg'
      });
      assert.deepEqual(hooks, [['x-parent', 'init'], ['x-parent', 'on(init)']], 'creation of x-parent');
      hooks.length = 0;
      this.element = this.append(this.component);
      assert.deepEqual(hooks, [['x-parent', 'willInsertElement'], ['x-child', 'init'], ['x-child', 'on(init)'], ['x-child', 'didReceiveAttrs'], ['x-child', 'willRender'], ['x-child', 'willInsertElement'], ['x-child', 'didInsertElement'], ['x-child', 'didRender'], ['x-parent', 'didInsertElement'], ['x-parent', 'didRender']], 'appending of x-parent');
      hooks.length = 0;
      (0, _internalTestHelpers.runTask)(function () {
        return componentsByName['x-parent'].rerender();
      });
      assert.deepEqual(hooks, [['x-parent', 'willUpdate'], ['x-parent', 'willRender'], ['x-parent', 'didUpdate'], ['x-parent', 'didRender']], 'rerender x-parent');
      hooks.length = 0;
      (0, _internalTestHelpers.runTask)(function () {
        return componentsByName['x-child'].rerender();
      });
      assert.deepEqual(hooks, [['x-parent', 'willUpdate'], ['x-parent', 'willRender'], ['x-child', 'willUpdate'], ['x-child', 'willRender'], ['x-child', 'didUpdate'], ['x-child', 'didRender'], ['x-parent', 'didUpdate'], ['x-parent', 'didRender']], 'rerender x-child');
      hooks.length = 0;
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.component, 'foo', 'wow');
      });
      assert.deepEqual(hooks, [['x-parent', 'willUpdate'], ['x-parent', 'willRender'], ['x-child', 'didUpdateAttrs'], ['x-child', 'didReceiveAttrs'], ['x-child', 'willUpdate'], ['x-child', 'willRender'], ['x-child', 'didUpdate'], ['x-child', 'didRender'], ['x-parent', 'didUpdate'], ['x-parent', 'didRender']], 'set foo = wow');
      hooks.length = 0;
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.component, 'foo', 'zomg');
      });
      assert.deepEqual(hooks, [['x-parent', 'willUpdate'], ['x-parent', 'willRender'], ['x-child', 'didUpdateAttrs'], ['x-child', 'didReceiveAttrs'], ['x-child', 'willUpdate'], ['x-child', 'willRender'], ['x-child', 'didUpdate'], ['x-child', 'didRender'], ['x-parent', 'didUpdate'], ['x-parent', 'didRender']], 'set foo = zomg');
      hooks.length = 0;
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.component.destroy();
      });
      assert.deepEqual(hooks, [['x-parent', 'willDestroyElement'], ['x-parent', 'willClearRender'], ['x-child', 'willDestroyElement'], ['x-child', 'willClearRender'], ['x-child', 'didDestroyElement'], ['x-parent', 'didDestroyElement'], ['x-parent', 'willDestroy'], ['x-child', 'willDestroy']], 'destroy');
    };

    _proto['@test appending, updating and destroying a single component'] = function testAppendingUpdatingAndDestroyingASingleComponent(assert) {
      var _this3 = this;

      var willDestroyCalled = 0;
      this.registerComponent('x-parent', {
        ComponentClass: _helpers.Component.extend({
          layoutName: 'components/x-parent',
          willDestroyElement: function () {
            willDestroyCalled++;
          }
        }),
        template: '[parent: {{foo}}]{{#x-child bar=foo}}[yielded: {{foo}}]{{/x-child}}'
      });
      this.registerComponent('x-child', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '[child: {{bar}}]{{yield}}'
      });
      var XParent;
      XParent = this.owner.factoryFor('component:x-parent');
      this.component = XParent.create({
        foo: 'zomg'
      });
      assert.ok(!this.component.element, 'precond - should not have an element');
      this.element = this.append(this.component);
      var componentElement = this.component.element;
      this.assertComponentElement(componentElement, {
        content: '[parent: zomg][child: zomg][yielded: zomg]'
      });
      assert.equal(componentElement.parentElement, this.element, 'It should be attached to the target');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assertComponentElement(componentElement, {
        content: '[parent: zomg][child: zomg][yielded: zomg]'
      });
      assert.equal(componentElement.parentElement, this.element, 'It should be attached to the target');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.component, 'foo', 'wow');
      });
      this.assertComponentElement(componentElement, {
        content: '[parent: wow][child: wow][yielded: wow]'
      });
      assert.equal(componentElement.parentElement, this.element, 'It should be attached to the target');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.component, 'foo', 'zomg');
      });
      this.assertComponentElement(componentElement, {
        content: '[parent: zomg][child: zomg][yielded: zomg]'
      });
      assert.equal(componentElement.parentElement, this.element, 'It should be attached to the target');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.component.destroy();
      });
      assert.ok(!this.component.element, 'It should not have an element');
      assert.ok(!componentElement.parentElement, 'The component element should be detached');
      this.assert.equal(willDestroyCalled, 1);
    };

    _proto['@test releasing a root component after it has been destroy'] = function testReleasingARootComponentAfterItHasBeenDestroy(assert) {
      var _this4 = this;

      var renderer = this.owner.lookup('renderer:-dom');
      this.registerComponent('x-component', {
        ComponentClass: _helpers.Component.extend()
      });
      this.component = this.owner.factoryFor('component:x-component').create();
      this.append(this.component);
      assert.equal(renderer._roots.length, 1, 'added a root component');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.component.destroy();
      });
      assert.equal(renderer._roots.length, 0, 'released the root component');
    };

    _proto['@test appending, updating and destroying multiple components'] = function testAppendingUpdatingAndDestroyingMultipleComponents(assert) {
      var _this5 = this;

      var willDestroyCalled = 0;
      this.registerComponent('x-first', {
        ComponentClass: _helpers.Component.extend({
          layoutName: 'components/x-first',
          willDestroyElement: function () {
            willDestroyCalled++;
          }
        }),
        template: 'x-first {{foo}}!'
      });
      this.registerComponent('x-second', {
        ComponentClass: _helpers.Component.extend({
          layoutName: 'components/x-second',
          willDestroyElement: function () {
            willDestroyCalled++;
          }
        }),
        template: 'x-second {{bar}}!'
      });
      var First, Second;
      First = this.owner.factoryFor('component:x-first');
      Second = this.owner.factoryFor('component:x-second');
      var first = First.create({
        foo: 'foo'
      });
      var second = Second.create({
        bar: 'bar'
      });
      this.assert.ok(!first.element, 'precond - should not have an element');
      this.assert.ok(!second.element, 'precond - should not have an element');
      var wrapper1, wrapper2;
      (0, _internalTestHelpers.runTask)(function () {
        return wrapper1 = _this5.append(first);
      });
      (0, _internalTestHelpers.runTask)(function () {
        return wrapper2 = _this5.append(second);
      });
      var componentElement1 = first.element;
      var componentElement2 = second.element;
      this.assertComponentElement(componentElement1, {
        content: 'x-first foo!'
      });
      this.assertComponentElement(componentElement2, {
        content: 'x-second bar!'
      });
      assert.equal(componentElement1.parentElement, wrapper1, 'The first component should be attached to the target');
      assert.equal(componentElement2.parentElement, wrapper2, 'The second component should be attached to the target');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(first, 'foo', 'FOO');
      });
      this.assertComponentElement(componentElement1, {
        content: 'x-first FOO!'
      });
      this.assertComponentElement(componentElement2, {
        content: 'x-second bar!'
      });
      assert.equal(componentElement1.parentElement, wrapper1, 'The first component should be attached to the target');
      assert.equal(componentElement2.parentElement, wrapper2, 'The second component should be attached to the target');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(second, 'bar', 'BAR');
      });
      this.assertComponentElement(componentElement1, {
        content: 'x-first FOO!'
      });
      this.assertComponentElement(componentElement2, {
        content: 'x-second BAR!'
      });
      assert.equal(componentElement1.parentElement, wrapper1, 'The first component should be attached to the target');
      assert.equal(componentElement2.parentElement, wrapper2, 'The second component should be attached to the target');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(first, 'foo', 'foo');
        (0, _metal.set)(second, 'bar', 'bar');
      });
      this.assertComponentElement(componentElement1, {
        content: 'x-first foo!'
      });
      this.assertComponentElement(componentElement2, {
        content: 'x-second bar!'
      });
      assert.equal(componentElement1.parentElement, wrapper1, 'The first component should be attached to the target');
      assert.equal(componentElement2.parentElement, wrapper2, 'The second component should be attached to the target');
      (0, _internalTestHelpers.runTask)(function () {
        first.destroy();
        second.destroy();
      });
      assert.ok(!first.element, 'The first component should not have an element');
      assert.ok(!second.element, 'The second component should not have an element');
      assert.ok(!componentElement1.parentElement, 'The first component element should be detached');
      assert.ok(!componentElement2.parentElement, 'The second component element should be detached');
      this.assert.equal(willDestroyCalled, 2);
    };

    _proto['@test can appendTo while rendering'] = function testCanAppendToWhileRendering() {
      var _this6 = this;

      var owner = this.owner;

      var append = function (component) {
        return _this6.append(component);
      };

      var element1, element2;
      this.registerComponent('first-component', {
        ComponentClass: _helpers.Component.extend({
          layout: (0, _helpers.compile)('component-one'),
          didInsertElement: function () {
            element1 = this.element;
            var SecondComponent = owner.factoryFor('component:second-component');
            append(SecondComponent.create());
          }
        })
      });
      this.registerComponent('second-component', {
        ComponentClass: _helpers.Component.extend({
          layout: (0, _helpers.compile)("component-two"),
          didInsertElement: function () {
            element2 = this.element;
          }
        })
      });
      var FirstComponent = this.owner.factoryFor('component:first-component');
      (0, _internalTestHelpers.runTask)(function () {
        return append(FirstComponent.create());
      });
      this.assertComponentElement(element1, {
        content: 'component-one'
      });
      this.assertComponentElement(element2, {
        content: 'component-two'
      });
    };

    _proto['@test can appendTo and remove while rendering'] = function testCanAppendToAndRemoveWhileRendering(assert) {
      var _this7 = this;

      var owner = this.owner;

      var append = function (component) {
        return _this7.append(component);
      };

      var element1, element2, element3, element4, component1, component2;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          layout: (0, _helpers.compile)('foo-bar'),
          init: function () {
            this._super.apply(this, arguments);

            component1 = this;
          },
          didInsertElement: function () {
            element1 = this.element;
            var OtherRoot = owner.factoryFor('component:other-root');
            this._instance = OtherRoot.create({
              didInsertElement: function () {
                element2 = this.element;
              }
            });
            append(this._instance);
          },
          willDestroy: function () {
            this._instance.destroy();
          }
        })
      });
      this.registerComponent('baz-qux', {
        ComponentClass: _helpers.Component.extend({
          layout: (0, _helpers.compile)('baz-qux'),
          init: function () {
            this._super.apply(this, arguments);

            component2 = this;
          },
          didInsertElement: function () {
            element3 = this.element;
            var OtherRoot = owner.factoryFor('component:other-root');
            this._instance = OtherRoot.create({
              didInsertElement: function () {
                element4 = this.element;
              }
            });
            append(this._instance);
          },
          willDestroy: function () {
            this._instance.destroy();
          }
        })
      });
      var instantiatedRoots = 0;
      var destroyedRoots = 0;
      this.registerComponent('other-root', {
        ComponentClass: _helpers.Component.extend({
          layout: (0, _helpers.compile)("fake-thing: {{counter}}"),
          init: function () {
            this._super.apply(this, arguments);

            this.counter = instantiatedRoots++;
          },
          willDestroy: function () {
            destroyedRoots++;

            this._super.apply(this, arguments);
          }
        })
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject()), {
        showFooBar: true
      });
      this.assertComponentElement(element1, {});
      this.assertComponentElement(element2, {
        content: 'fake-thing: 0'
      });
      assert.equal(instantiatedRoots, 1);
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'showFooBar', false);
      });
      assert.equal(instantiatedRoots, 2);
      assert.equal(destroyedRoots, 1);
      this.assertComponentElement(element3, {});
      this.assertComponentElement(element4, {
        content: 'fake-thing: 1'
      });
      (0, _internalTestHelpers.runTask)(function () {
        component1.destroy();
        component2.destroy();
      });
      assert.equal(instantiatedRoots, 2);
      assert.equal(destroyedRoots, 2);
    };

    return AbstractAppendTest;
  }(_internalTestHelpers.RenderingTestCase);

  (0, _internalTestHelpers.moduleFor)('append: no arguments (attaching to document.body)',
  /*#__PURE__*/
  function (_AbstractAppendTest) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractAppendTest);

    function _class() {
      return _AbstractAppendTest.apply(this, arguments) || this;
    }

    var _proto2 = _class.prototype;

    _proto2.append = function append(component) {
      (0, _internalTestHelpers.runTask)(function () {
        return component.append();
      });
      this.didAppend(component);
      return document.body;
    };

    return _class;
  }(AbstractAppendTest));
  (0, _internalTestHelpers.moduleFor)('appendTo: a selector',
  /*#__PURE__*/
  function (_AbstractAppendTest2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractAppendTest2);

    function _class2() {
      return _AbstractAppendTest2.apply(this, arguments) || this;
    }

    var _proto3 = _class2.prototype;

    _proto3.append = function append(component) {
      (0, _internalTestHelpers.runTask)(function () {
        return component.appendTo('#qunit-fixture');
      });
      this.didAppend(component);
      return document.getElementById('qunit-fixture');
    };

    _proto3['@test raises an assertion when the target does not exist in the DOM'] = function testRaisesAnAssertionWhenTheTargetDoesNotExistInTheDOM(assert) {
      var _this8 = this;

      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          layoutName: 'components/foo-bar'
        }),
        template: 'FOO BAR!'
      });
      var FooBar = this.owner.factoryFor('component:foo-bar');
      this.component = FooBar.create();
      assert.ok(!this.component.element, 'precond - should not have an element');
      (0, _internalTestHelpers.runTask)(function () {
        expectAssertion(function () {
          _this8.component.appendTo('#does-not-exist-in-dom');
        }, /You tried to append to \(#does-not-exist-in-dom\) but that isn't in the DOM/);
      });
      assert.ok(!this.component.element, 'component should not have an element');
    };

    return _class2;
  }(AbstractAppendTest));
  (0, _internalTestHelpers.moduleFor)('appendTo: an element',
  /*#__PURE__*/
  function (_AbstractAppendTest3) {
    (0, _emberBabel.inheritsLoose)(_class3, _AbstractAppendTest3);

    function _class3() {
      return _AbstractAppendTest3.apply(this, arguments) || this;
    }

    var _proto4 = _class3.prototype;

    _proto4.append = function append(component) {
      var element = document.getElementById('qunit-fixture');
      (0, _internalTestHelpers.runTask)(function () {
        return component.appendTo(element);
      });
      this.didAppend(component);
      return element;
    };

    return _class3;
  }(AbstractAppendTest));
  (0, _internalTestHelpers.moduleFor)('appendTo: with multiple components',
  /*#__PURE__*/
  function (_AbstractAppendTest4) {
    (0, _emberBabel.inheritsLoose)(_class4, _AbstractAppendTest4);

    function _class4() {
      return _AbstractAppendTest4.apply(this, arguments) || this;
    }

    var _proto5 = _class4.prototype;

    _proto5.append = function append(component) {
      (0, _internalTestHelpers.runTask)(function () {
        return component.appendTo('#qunit-fixture');
      });
      this.didAppend(component);
      return document.getElementById('qunit-fixture');
    };

    return _class4;
  }(AbstractAppendTest));
});
enifed("@ember/-internals/glimmer/tests/integration/components/attribute-bindings-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _helpers) {
  "use strict";

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      {{foo-bar hasFoo=true foo=foo hasBar=false bar=bar}}\n      {{foo-bar hasFoo=false foo=foo hasBar=true bar=bar}}\n      {{foo-bar hasFoo=true foo=foo hasBar=true bar=bar}}\n      {{foo-bar hasFoo=false foo=foo hasBar=false bar=bar}}\n    "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('Attribute bindings integration',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test it can have attribute bindings'] = function testItCanHaveAttributeBindings() {
      var _this = this;

      var FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['foo:data-foo', 'bar:data-bar']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar foo=foo bar=bar}}', {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this.context, 'foo', 'FOO');
        (0, _metal.set)(_this.context, 'bar', undefined);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'FOO'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this.context, 'foo', 'foo');
        (0, _metal.set)(_this.context, 'bar', 'bar');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
    };

    _proto['@test it can have attribute bindings with attrs'] = function testItCanHaveAttributeBindingsWithAttrs() {
      var _this2 = this;

      var FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['attrs.foo:data-foo', 'attrs.baz.bar:data-bar']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar foo=model.foo baz=model.baz}}', {
        model: {
          foo: undefined,
          baz: {
            bar: 'bar'
          }
        }
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          'data-bar': 'bar'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          'data-bar': 'bar'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this2.context, 'model.foo', 'foo');
        (0, _metal.set)(_this2.context, 'model.baz.bar', undefined);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'model', {
          foo: undefined,
          baz: {
            bar: 'bar'
          }
        });
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          'data-bar': 'bar'
        }
      });
    };

    _proto['@test it can have attribute bindings with a nested path'] = function testItCanHaveAttributeBindingsWithANestedPath() {
      var _this3 = this;

      var FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['foo.bar:data-foo-bar']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar foo=foo}}', {
        foo: {
          bar: 'foo-bar'
        }
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo-bar': 'foo-bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo-bar': 'foo-bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'foo.bar', 'FOO-BAR');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo-bar': 'FOO-BAR'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'foo.bar', undefined);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'foo', undefined);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'foo', {
          bar: 'foo-bar'
        });
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo-bar': 'foo-bar'
        },
        content: 'hello'
      });
    };

    _proto['@test handles non-microsyntax attributeBindings'] = function testHandlesNonMicrosyntaxAttributeBindings() {
      var _this4 = this;

      var FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['type']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar type=submit}}', {
        submit: 'submit'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          type: 'submit'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          type: 'submit'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'submit', 'password');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          type: 'password'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'submit', null);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'submit', 'submit');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          type: 'submit'
        },
        content: 'hello'
      });
    };

    _proto['@test non-microsyntax attributeBindings cannot contain nested paths'] = function testNonMicrosyntaxAttributeBindingsCannotContainNestedPaths() {
      var _this5 = this;

      var FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['foo.bar']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      expectAssertion(function () {
        _this5.render('{{foo-bar foo=foo}}', {
          foo: {
            bar: 'foo-bar'
          }
        });
      }, /Illegal attributeBinding: 'foo.bar' is not a valid attribute name./);
    };

    _proto['@test normalizes attributeBindings for property names'] = function testNormalizesAttributeBindingsForPropertyNames() {
      var _this6 = this;

      var FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['tiTLe']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar tiTLe=name}}', {
        name: 'qux'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          title: 'qux'
        },
        content: 'hello'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'name', null);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'name', 'qux');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          title: 'qux'
        },
        content: 'hello'
      });
    };

    _proto['@test normalizes attributeBindings for attribute names'] = function testNormalizesAttributeBindingsForAttributeNames() {
      var _this7 = this;

      var FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['foo:data-FOO']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar foo=foo}}', {
        foo: 'qux'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'qux'
        },
        content: 'hello'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'foo', null);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'foo', 'qux');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': 'qux'
        },
        content: 'hello'
      });
    };

    _proto['@test  attributeBindings preserves case for mixed-case attributes'] = function testAttributeBindingsPreservesCaseForMixedCaseAttributes() {
      var _this8 = this;

      var FooBarComponent = _helpers.Component.extend({
        tagName: 'svg',
        attributeBindings: ['viewBox']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: ''
      });
      this.render('{{foo-bar viewBox=foo}}', {
        foo: '0 0 100 100'
      });
      this.assert.equal(this.firstChild.getAttribute('viewBox'), '0 0 100 100', 'viewBox attribute');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this8.context, 'foo', null);
      });
      this.assert.ok(!this.firstChild.hasAttribute('viewBox'), 'viewBox attribute removed');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this8.context, 'foo', '0 0 100 200');
      });
      this.assert.equal(this.firstChild.getAttribute('viewBox'), '0 0 100 200', 'viewBox attribute');
    };

    _proto['@test attributeBindings handles null/undefined'] = function testAttributeBindingsHandlesNullUndefined() {
      var _this9 = this;

      var FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['fizz', 'bar']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar fizz=fizz bar=bar}}', {
        fizz: null,
        bar: undefined
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this9.context, 'fizz', 'fizz');
        (0, _metal.set)(_this9.context, 'bar', 'bar');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          fizz: 'fizz',
          bar: 'bar'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this9.context, 'fizz', null);
        (0, _metal.set)(_this9.context, 'bar', undefined);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
    };

    _proto['@test attributeBindings handles number value'] = function testAttributeBindingsHandlesNumberValue() {
      var _this10 = this;

      var FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['size']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar size=size}}', {
        size: 21
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          size: '21'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          size: '21'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'size', 0);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          size: '0'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'size', 21);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          size: '21'
        },
        content: 'hello'
      });
    };

    _proto['@test handles internal and external changes'] = function testHandlesInternalAndExternalChanges() {
      var _this11 = this;

      var component;

      var FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['type'],
        type: 'password',
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          type: 'password'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this11.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          type: 'password'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(component, 'type', 'checkbox');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          type: 'checkbox'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(component, 'type', 'password');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          type: 'password'
        },
        content: 'hello'
      });
    };

    _proto['@test can set attributeBindings on component with a different tagName'] = function testCanSetAttributeBindingsOnComponentWithADifferentTagName() {
      var _this12 = this;

      var FooBarComponent = _helpers.Component.extend({
        tagName: 'input',
        attributeBindings: ['type', 'isDisabled:disabled']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render('{{foo-bar type=type isDisabled=disabled}}', {
        type: 'password',
        disabled: false
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'input',
        attrs: {
          type: 'password'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'input',
        attrs: {
          type: 'password'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this12.context, 'type', 'checkbox');
        (0, _metal.set)(_this12.context, 'disabled', true);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'input',
        attrs: {
          type: 'checkbox',
          disabled: ''
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this12.context, 'type', 'password');
        (0, _metal.set)(_this12.context, 'disabled', false);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'input',
        attrs: {
          type: 'password'
        }
      });
    };

    _proto['@test should allow namespaced attributes in micro syntax'] = function testShouldAllowNamespacedAttributesInMicroSyntax() {
      var _this13 = this;

      var FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['xlinkHref:xlink:href']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render('{{foo-bar type=type xlinkHref=xlinkHref}}', {
        xlinkHref: '/foo.png'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'xlink:href': '/foo.png'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this13.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'xlink:href': '/foo.png'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'xlinkHref', '/lol.png');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'xlink:href': '/lol.png'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'xlinkHref', '/foo.png');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'xlink:href': '/foo.png'
        }
      });
    } // This comes into play when using the {{#each}} helper. If the
    // passed array item is a String, it will be converted into a
    // String object instead of a normal string.
    ;

    _proto['@test should allow for String objects'] = function testShouldAllowForStringObjects() {
      var _this14 = this;

      var FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['foo']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render('{{foo-bar foo=foo}}', {
        foo: function () {
          return this;
        }.call('bar')
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          foo: 'bar'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this14.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          foo: 'bar'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'foo', function () {
          return this;
        }.call('baz'));
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          foo: 'baz'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'foo', function () {
          return this;
        }.call('bar'));
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          foo: 'bar'
        }
      });
    };

    _proto['@test can set id initially via attributeBindings '] = function testCanSetIdInitiallyViaAttributeBindings() {
      var _this15 = this;

      var FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['specialSauce:id']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render('{{foo-bar specialSauce=sauce}}', {
        sauce: 'special-sauce'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'special-sauce'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this15.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'special-sauce'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'sauce', 'foo');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'special-sauce'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'sauce', 'special-sauce');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'special-sauce'
        }
      });
    };

    _proto['@test attributeBindings are overwritten'] = function testAttributeBindingsAreOverwritten() {
      var _this16 = this;

      var FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['href'],
        href: 'a href'
      });

      var FizzBarComponent = FooBarComponent.extend({
        attributeBindings: ['newHref:href']
      });
      this.registerComponent('fizz-bar', {
        ComponentClass: FizzBarComponent
      });
      this.render('{{fizz-bar newHref=href}}', {
        href: 'dog.html'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          href: 'dog.html'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this16.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          href: 'dog.html'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this16.context, 'href', 'cat.html');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          href: 'cat.html'
        }
      });
    };

    _proto['@test it can set attribute bindings in the constructor'] = function testItCanSetAttributeBindingsInTheConstructor() {
      var _this17 = this;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          var bindings = [];

          if (this.get('hasFoo')) {
            bindings.push('foo:data-foo');
          }

          if (this.get('hasBar')) {
            bindings.push('bar:data-bar');
          }

          this.attributeBindings = bindings;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject()), {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this17.rerender();
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this17.context, 'foo', 'FOO');
        (0, _metal.set)(_this17.context, 'bar', undefined);
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          'data-foo': 'FOO'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          'data-foo': 'FOO'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this17.context, 'bar', 'BAR');
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          'data-foo': 'FOO'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          'data-bar': 'BAR'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          'data-foo': 'FOO',
          'data-bar': 'BAR'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this17.context, 'foo', 'foo');
        (0, _metal.set)(_this17.context, 'bar', 'bar');
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          'data-foo': 'foo',
          'data-bar': 'bar'
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {},
        content: 'hello'
      });
    };

    _proto['@test asserts if an attributeBinding is setup on class'] = function testAssertsIfAnAttributeBindingIsSetupOnClass() {
      var _this18 = this;

      var FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['class']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      expectAssertion(function () {
        _this18.render('{{foo-bar}}');
      }, /You cannot use class as an attributeBinding, use classNameBindings instead./i);
    };

    _proto['@test blacklists href bindings based on protocol'] = function testBlacklistsHrefBindingsBasedOnProtocol() {
      var FooBarComponent = _helpers.Component.extend({
        tagName: 'a',
        attributeBindings: ['href']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar href=xss}}', {
        xss: "javascript:alert('foo')"
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'a',
        attrs: {
          href: "unsafe:javascript:alert('foo')"
        }
      });
    };

    _proto['@test it can bind the role attribute (issue #14007)'] = function testItCanBindTheRoleAttributeIssue14007() {
      var _this19 = this;

      var FooBarComponent = _helpers.Component.extend({
        attributeBindings: ['role']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar role=role}}', {
        role: 'button'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          role: 'button'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this19.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          role: 'button'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this19.context, 'role', 'combobox');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          role: 'combobox'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this19.context, 'role', null);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div'
      });
    };

    _proto['@test component with an `id` attribute binding of undefined'] = function testComponentWithAnIdAttributeBindingOfUndefined() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          attributeBindings: ['id'],
          id: undefined
        })
      });
      this.registerComponent('baz-qux', {
        ComponentClass: _helpers.Component.extend({
          attributeBindings: ['somethingUndefined:id'],
          somethingUndefined: undefined
        })
      });
      this.render("{{foo-bar}}{{baz-qux}}");
      this.assertComponentElement(this.nthChild(0), {
        content: ''
      });
      this.assertComponentElement(this.nthChild(1), {
        content: ''
      });
      this.assert.ok(this.nthChild(0).id.match(/ember\d+/), 'a valid `id` was used');
      this.assert.ok(this.nthChild(1).id.match(/ember\d+/), 'a valid `id` was used');
    };

    _proto['@test component with an `id` attribute binding of null'] = function testComponentWithAnIdAttributeBindingOfNull() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          attributeBindings: ['id'],
          id: null
        })
      });
      this.registerComponent('baz-qux', {
        ComponentClass: _helpers.Component.extend({
          attributeBindings: ['somethingNull:id'],
          somethingNull: null
        })
      });
      this.render("{{foo-bar}}{{baz-qux}}");
      this.assertComponentElement(this.nthChild(0), {
        content: ''
      });
      this.assertComponentElement(this.nthChild(1), {
        content: ''
      });
      this.assert.ok(this.nthChild(0).id.match(/ember\d+/), 'a valid `id` was used');
      this.assert.ok(this.nthChild(1).id.match(/ember\d+/), 'a valid `id` was used');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/components/attrs-lookup-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Components test: attrs lookup',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test it should be able to lookup attrs without `attrs.` - template access'] = function testItShouldBeAbleToLookupAttrsWithoutAttrsTemplateAccess() {
      var _this = this;

      this.registerComponent('foo-bar', {
        template: '{{first}}'
      });
      this.render("{{foo-bar first=firstAttr}}", {
        firstAttr: 'first attr'
      });
      this.assertText('first attr');
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertText('first attr');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'firstAttr', 'second attr');
      });
      this.assertText('second attr');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'firstAttr', 'first attr');
      });
      this.assertText('first attr');
    };

    _proto['@test it should be able to lookup attrs without `attrs.` - component access'] = function testItShouldBeAbleToLookupAttrsWithoutAttrsComponentAccess(assert) {
      var _this2 = this;

      var instance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          instance = this;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{first}}'
      });
      this.render("{{foo-bar first=firstAttr}}", {
        firstAttr: 'first attr'
      });
      assert.equal(instance.get('first'), 'first attr');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      assert.equal(instance.get('first'), 'first attr');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'firstAttr', 'second attr');
      });
      assert.equal(instance.get('first'), 'second attr');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'firstAttr', 'first attr');
      });
      this.assertText('first attr');
    };

    _proto['@test should be able to modify a provided attr into local state #11571 / #11559'] = function testShouldBeAbleToModifyAProvidedAttrIntoLocalState1157111559(assert) {
      var _this3 = this;

      var instance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          instance = this;
        },
        didReceiveAttrs: function () {
          this.set('first', this.get('first').toUpperCase());
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{first}}'
      });
      this.render("{{foo-bar first=\"first attr\"}}");
      assert.equal(instance.get('first'), 'FIRST ATTR', 'component lookup uses local state');
      this.assertText('FIRST ATTR');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      assert.equal(instance.get('first'), 'FIRST ATTR', 'component lookup uses local state during rerender');
      this.assertText('FIRST ATTR'); // This is testing that passing string literals for use as initial values,
      // so there is no update step
    };

    _proto['@test should be able to access unspecified attr #12035'] = function testShouldBeAbleToAccessUnspecifiedAttr12035(assert) {
      var _this4 = this;

      var instance;
      var wootVal = 'yes';

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          instance = this;
        },
        didReceiveAttrs: function () {
          assert.equal(this.get('woot'), wootVal, 'found attr in didReceiveAttrs');
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render("{{foo-bar woot=woot}}", {
        woot: wootVal
      });
      assert.equal(instance.get('woot'), 'yes', 'component found attr');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      assert.equal(instance.get('woot'), 'yes', 'component found attr after rerender');
      (0, _internalTestHelpers.runTask)(function () {
        wootVal = 'nope';
        (0, _metal.set)(_this4.context, 'woot', wootVal);
      });
      assert.equal(instance.get('woot'), 'nope', 'component found attr after attr change');
      (0, _internalTestHelpers.runTask)(function () {
        wootVal = 'yes';
        (0, _metal.set)(_this4.context, 'woot', wootVal);
      });
      assert.equal(instance.get('woot'), 'yes', 'component found attr after reset');
    };

    _proto['@test getAttr() should return the same value as get()'] = function testGetAttrShouldReturnTheSameValueAsGet(assert) {
      var _this5 = this;

      assert.expect(33);
      var instance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          instance = this;
        },
        didReceiveAttrs: function () {
          var rootFirstPositional = this.get('firstPositional');
          var rootFirst = this.get('first');
          var rootSecond = this.get('second');
          var attrFirstPositional = this.getAttr('firstPositional');
          var attrFirst = this.getAttr('first');
          var attrSecond = this.getAttr('second');
          assert.equal(rootFirstPositional, attrFirstPositional, 'root property matches attrs value');
          assert.equal(rootFirst, attrFirst, 'root property matches attrs value');
          assert.equal(rootSecond, attrSecond, 'root property matches attrs value');
        }
      });

      FooBarComponent.reopenClass({
        positionalParams: ['firstPositional']
      });
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render("{{foo-bar firstPositional first=first second=second}}", {
        firstPositional: 'firstPositional',
        first: 'first',
        second: 'second'
      });
      assert.equal(instance.get('firstPositional'), 'firstPositional', 'matches known value');
      assert.equal(instance.get('first'), 'first', 'matches known value');
      assert.equal(instance.get('second'), 'second', 'matches known value');
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.rerender();
      });
      assert.equal(instance.get('firstPositional'), 'firstPositional', 'matches known value');
      assert.equal(instance.get('first'), 'first', 'matches known value');
      assert.equal(instance.get('second'), 'second', 'matches known value');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this5.context, 'first', 'third');
      });
      assert.equal(instance.get('firstPositional'), 'firstPositional', 'matches known value');
      assert.equal(instance.get('first'), 'third', 'matches known value');
      assert.equal(instance.get('second'), 'second', 'matches known value');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this5.context, 'second', 'fourth');
      });
      assert.equal(instance.get('firstPositional'), 'firstPositional', 'matches known value');
      assert.equal(instance.get('first'), 'third', 'matches known value');
      assert.equal(instance.get('second'), 'fourth', 'matches known value');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this5.context, 'firstPositional', 'fifth');
      });
      assert.equal(instance.get('firstPositional'), 'fifth', 'matches known value');
      assert.equal(instance.get('first'), 'third', 'matches known value');
      assert.equal(instance.get('second'), 'fourth', 'matches known value');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this5.context, 'firstPositional', 'firstPositional');
        (0, _metal.set)(_this5.context, 'first', 'first');
        (0, _metal.set)(_this5.context, 'second', 'second');
      });
      assert.equal(instance.get('firstPositional'), 'firstPositional', 'matches known value');
      assert.equal(instance.get('first'), 'first', 'matches known value');
      assert.equal(instance.get('second'), 'second', 'matches known value');
    };

    _proto['@test bound computed properties can be overridden in extensions, set during init, and passed in as attrs'] = function testBoundComputedPropertiesCanBeOverriddenInExtensionsSetDuringInitAndPassedInAsAttrs() {
      var FooClass = _helpers.Component.extend({
        attributeBindings: ['style'],
        style: (0, _metal.computed)('height', 'color', function () {
          var height = this.get('height');
          var color = this.get('color');
          return (0, _helpers.htmlSafe)("height: " + height + "px; background-color: " + color + ";");
        }),
        color: 'red',
        height: 20
      });

      var BarClass = FooClass.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.height = 150;
        },
        color: 'yellow'
      });
      this.registerComponent('x-foo', {
        ComponentClass: FooClass
      });
      this.registerComponent('x-bar', {
        ComponentClass: BarClass
      });
      this.render('{{x-foo}}{{x-bar}}{{x-bar color="green"}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 20px; background-color: red;')
        }
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 150px; background-color: yellow;')
        }
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 150px; background-color: green;')
        }
      });
      this.assertStableRerender(); // No U-R
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/components/class-bindings-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _helpers) {
  "use strict";

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      {{foo-bar foo=foo bindIsEnabled=true isEnabled=isEnabled bindIsHappy=false isHappy=isHappy}}\n      {{foo-bar foo=foo bindIsEnabled=false isEnabled=isEnabled bindIsHappy=true isHappy=isHappy}}\n      {{foo-bar foo=foo bindIsEnabled=true isEnabled=isEnabled bindIsHappy=true isHappy=isHappy}}\n      {{foo-bar foo=foo bindIsEnabled=false isEnabled=isEnabled bindIsHappy=false isHappy=isHappy}}\n    "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('ClassNameBindings integration',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test it can have class name bindings on the class definition'] = function testItCanHaveClassNameBindingsOnTheClassDefinition() {
      var _this = this;

      var FooBarComponent = _helpers.Component.extend({
        classNameBindings: ['foo', 'isEnabled:enabled', 'isHappy:happy:sad']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar foo=foo isEnabled=isEnabled isHappy=isHappy}}', {
        foo: 'foo',
        isEnabled: true,
        isHappy: false
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled sad')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled sad')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this.context, 'foo', 'FOO');
        (0, _metal.set)(_this.context, 'isEnabled', false);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view FOO sad')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this.context, 'foo', undefined);
        (0, _metal.set)(_this.context, 'isHappy', true);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view happy')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this.context, 'foo', 'foo');
        (0, _metal.set)(_this.context, 'isEnabled', true);
        (0, _metal.set)(_this.context, 'isHappy', false);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled sad')
        },
        content: 'hello'
      });
    };

    _proto['@test attrs in classNameBindings'] = function testAttrsInClassNameBindings() {
      var _this2 = this;

      var FooBarComponent = _helpers.Component.extend({
        classNameBindings: ['attrs.joker:purple:green', 'attrs.batman.robin:black:red']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar joker=model.wat batman=model.super}}', {
        model: {
          wat: false,
          super: {
            robin: true
          }
        }
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view green black')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view green black')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this2.context, 'model.wat', true);
        (0, _metal.set)(_this2.context, 'model.super.robin', false);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view purple red')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'model', {
          wat: false,
          super: {
            robin: true
          }
        });
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view green black')
        },
        content: 'hello'
      });
    };

    _proto['@test it can have class name bindings in the template'] = function testItCanHaveClassNameBindingsInTheTemplate() {
      var _this3 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar classNameBindings="model.someInitiallyTrueProperty model.someInitiallyFalseProperty model.someInitiallyUndefinedProperty :static model.isBig:big model.isOpen:open:closed model.isUp::down model.bar:isTruthy:isFalsy"}}', {
        model: {
          someInitiallyTrueProperty: true,
          someInitiallyFalseProperty: false,
          isBig: true,
          isOpen: false,
          isUp: true,
          bar: true
        }
      });
      this.assertComponentElement(this.firstChild, {
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view some-initially-true-property static big closed isTruthy')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view some-initially-true-property static big closed isTruthy')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this3.context, 'model.someInitiallyTrueProperty', false);
        (0, _metal.set)(_this3.context, 'model.someInitiallyFalseProperty', true);
        (0, _metal.set)(_this3.context, 'model.someInitiallyUndefinedProperty', true);
        (0, _metal.set)(_this3.context, 'model.isBig', false);
        (0, _metal.set)(_this3.context, 'model.isOpen', true);
        (0, _metal.set)(_this3.context, 'model.isUp', false);
        (0, _metal.set)(_this3.context, 'model.bar', false);
      });
      this.assertComponentElement(this.firstChild, {
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view some-initially-false-property some-initially-undefined-property static open down isFalsy')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this3.context, 'model', {
          someInitiallyTrueProperty: true,
          someInitiallyFalseProperty: false,
          someInitiallyUndefinedProperty: undefined,
          isBig: true,
          isOpen: false,
          isUp: true,
          bar: true
        });
      });
      this.assertComponentElement(this.firstChild, {
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view some-initially-true-property static big closed isTruthy')
        },
        content: 'hello'
      });
    };

    _proto['@test it can have class name bindings with nested paths'] = function testItCanHaveClassNameBindingsWithNestedPaths() {
      var _this4 = this;

      var FooBarComponent = _helpers.Component.extend({
        classNameBindings: ['foo.bar', 'is.enabled:enabled', 'is.happy:happy:sad']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar foo=foo is=is}}', {
        foo: {
          bar: 'foo-bar'
        },
        is: {
          enabled: true,
          happy: false
        }
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar enabled sad')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar enabled sad')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this4.context, 'foo.bar', 'FOO-BAR');
        (0, _metal.set)(_this4.context, 'is.enabled', false);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view FOO-BAR sad')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this4.context, 'foo.bar', null);
        (0, _metal.set)(_this4.context, 'is.happy', true);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view happy')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this4.context, 'foo', null);
        (0, _metal.set)(_this4.context, 'is', null);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view sad')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this4.context, 'foo', {
          bar: 'foo-bar'
        });
        (0, _metal.set)(_this4.context, 'is', {
          enabled: true,
          happy: false
        });
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar enabled sad')
        },
        content: 'hello'
      });
    };

    _proto['@test it should dasherize the path when the it resolves to true'] = function testItShouldDasherizeThePathWhenTheItResolvesToTrue() {
      var _this5 = this;

      var FooBarComponent = _helpers.Component.extend({
        classNameBindings: ['fooBar', 'nested.fooBarBaz']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar fooBar=fooBar nested=nested}}', {
        fooBar: true,
        nested: {
          fooBarBaz: false
        }
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this5.context, 'fooBar', false);
        (0, _metal.set)(_this5.context, 'nested.fooBarBaz', true);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar-baz')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this5.context, 'fooBar', 'FOO-BAR');
        (0, _metal.set)(_this5.context, 'nested.fooBarBaz', null);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view FOO-BAR')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'nested', null);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view FOO-BAR')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this5.context, 'fooBar', true);
        (0, _metal.set)(_this5.context, 'nested', {
          fooBarBaz: false
        });
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        },
        content: 'hello'
      });
    };

    _proto['@test const bindings can be set as attrs'] = function testConstBindingsCanBeSetAsAttrs() {
      var _this6 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar classNameBindings="foo:enabled:disabled"}}', {
        foo: true
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view enabled')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view enabled')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'foo', false);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view disabled')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'foo', true);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view enabled')
        },
        content: 'hello'
      });
    };

    _proto['@test :: class name syntax works with an empty true class'] = function testClassNameSyntaxWorksWithAnEmptyTrueClass() {
      var _this7 = this;

      var FooBarComponent = _helpers.Component.extend({
        classNameBindings: ['isEnabled::not-enabled']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar isEnabled=enabled}}', {
        enabled: false
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view not-enabled')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'enabled', true);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'enabled', false);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view not-enabled')
        },
        content: 'hello'
      });
    };

    _proto['@test uses all provided static class names (issue #11193)'] = function testUsesAllProvidedStaticClassNamesIssue11193() {
      var _this8 = this;

      var FooBarComponent = _helpers.Component.extend({
        classNameBindings: [':class-one', ':class-two']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar}}', {
        enabled: false
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view class-one class-two')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this8.context, 'enabled', true);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view class-one class-two')
        },
        content: 'hello'
      });
    };

    _proto['@test Providing a binding with a space in it asserts'] = function testProvidingABindingWithASpaceInItAsserts() {
      var _this9 = this;

      var FooBarComponent = _helpers.Component.extend({
        classNameBindings: 'i:think:i am:so:clever'
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      expectAssertion(function () {
        _this9.render('{{foo-bar}}');
      }, /classNameBindings must not have spaces in them/i);
    };

    _proto['@test it asserts that items must be strings'] = function testItAssertsThatItemsMustBeStrings() {
      var _this10 = this;

      var FooBarComponent = _helpers.Component.extend({
        foo: 'foo',
        bar: 'bar',
        classNameBindings: ['foo',, 'bar'] // eslint-disable-line no-sparse-arrays

      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      expectAssertion(function () {
        _this10.render('{{foo-bar}}');
      }, /classNameBindings must be non-empty strings/);
    };

    _proto['@test it asserts that items must be non-empty strings'] = function testItAssertsThatItemsMustBeNonEmptyStrings() {
      var _this11 = this;

      var FooBarComponent = _helpers.Component.extend({
        foo: 'foo',
        bar: 'bar',
        classNameBindings: ['foo', '', 'bar']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      expectAssertion(function () {
        _this11.render('{{foo-bar}}');
      }, /classNameBindings must be non-empty strings/);
    };

    _proto['@test it can set class name bindings in the constructor'] = function testItCanSetClassNameBindingsInTheConstructor() {
      var _this12 = this;

      var FooBarComponent = _helpers.Component.extend({
        classNameBindings: ['foo'],
        init: function () {
          this._super();

          var bindings = this.classNameBindings = this.classNameBindings.slice();

          if (this.get('bindIsEnabled')) {
            bindings.push('isEnabled:enabled');
          }

          if (this.get('bindIsHappy')) {
            bindings.push('isHappy:happy:sad');
          }
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject()), {
        foo: 'foo',
        isEnabled: true,
        isHappy: false
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo sad')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled sad')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.rerender();
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo sad')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled sad')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this12.context, 'foo', 'FOO');
        (0, _metal.set)(_this12.context, 'isEnabled', false);
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view FOO')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view FOO sad')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view FOO sad')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view FOO')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this12.context, 'foo', undefined);
        (0, _metal.set)(_this12.context, 'isHappy', true);
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view happy')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view happy')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this12.context, 'foo', 'foo');
        (0, _metal.set)(_this12.context, 'isEnabled', true);
        (0, _metal.set)(_this12.context, 'isHappy', false);
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo sad')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo enabled sad')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(3), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo')
        },
        content: 'hello'
      });
    };

    _proto['@test using a computed property for classNameBindings triggers an assertion'] = function testUsingAComputedPropertyForClassNameBindingsTriggersAnAssertion() {
      var _this13 = this;

      var FooBarComponent = _helpers.Component.extend({
        classNameBindings: (0, _metal.computed)(function () {
          return ['isHappy:happy:sad'];
        })
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      expectAssertion(function () {
        _this13.render('{{foo-bar}}');
      }, /Only arrays are allowed/);
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
  (0, _internalTestHelpers.moduleFor)('ClassBinding integration',
  /*#__PURE__*/
  function (_RenderingTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _RenderingTestCase2);

    function _class2() {
      return _RenderingTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test it should apply classBinding without condition always'] = function testItShouldApplyClassBindingWithoutConditionAlways() {
      var _this14 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar classBinding=":foo"}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo  ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this14.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo  ember-view')
        }
      });
    };

    _proto2['@test it should merge classBinding with class'] = function testItShouldMergeClassBindingWithClass() {
      var _this15 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar classBinding="birdman:respeck" class="myName"}}', {
        birdman: true
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('respeck myName ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this15.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('respeck myName ember-view')
        }
      });
    };

    _proto2['@test it should apply classBinding with only truthy condition'] = function testItShouldApplyClassBindingWithOnlyTruthyCondition() {
      var _this16 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar classBinding="myName:respeck"}}', {
        myName: true
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('respeck  ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this16.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('respeck  ember-view')
        }
      });
    };

    _proto2['@test it should apply classBinding with only falsy condition'] = function testItShouldApplyClassBindingWithOnlyFalsyCondition() {
      var _this17 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar classBinding="myName::shade"}}', {
        myName: false
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('shade  ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this17.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('shade  ember-view')
        }
      });
    };

    _proto2['@test it should apply nothing when classBinding is falsy but only supplies truthy class'] = function testItShouldApplyNothingWhenClassBindingIsFalsyButOnlySuppliesTruthyClass() {
      var _this18 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar classBinding="myName:respeck"}}', {
        myName: false
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        }
      });
    };

    _proto2['@test it should apply nothing when classBinding is truthy but only supplies falsy class'] = function testItShouldApplyNothingWhenClassBindingIsTruthyButOnlySuppliesFalsyClass() {
      var _this19 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar classBinding="myName::shade"}}', {
        myName: true
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this19.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        }
      });
    };

    _proto2['@test it should apply classBinding with falsy condition'] = function testItShouldApplyClassBindingWithFalsyCondition() {
      var _this20 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar classBinding="swag:fresh:scrub"}}', {
        swag: false
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('scrub  ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this20.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('scrub  ember-view')
        }
      });
    };

    _proto2['@test it should apply classBinding with truthy condition'] = function testItShouldApplyClassBindingWithTruthyCondition() {
      var _this21 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar classBinding="swag:fresh:scrub"}}', {
        swag: true
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('fresh  ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this21.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('fresh  ember-view')
        }
      });
    };

    return _class2;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/components/contextual-components-test", ["ember-babel", "internal-test-helpers", "@ember/polyfills", "@ember/-internals/metal", "@ember/-internals/runtime", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _polyfills, _metal, _runtime, _helpers) {
  "use strict";

  function _templateObject21() {
    const data = _taggedTemplateLiteralLoose(["\n          <button {{action (action (mut val) 10)}} class=\"my-button\">\n            Change to 10\n          </button>"]);

    _templateObject21 = function () {
      return data;
    };

    return data;
  }

  function _templateObject20() {
    const data = _taggedTemplateLiteralLoose(["\n          {{#let 'foo-bar' as |foo|}}\n            {{foo 1 2 3}}\n          {{/let}}\n        "]);

    _templateObject20 = function () {
      return data;
    };

    return data;
  }

  function _templateObject19() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#let (component 'foo-bar') as |foo|}}\n          {{foo 1 2 3}}\n        {{/let}}\n      "]);

    _templateObject19 = function () {
      return data;
    };

    return data;
  }

  function _templateObject18() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#let (component 'foo-bar') as |foo|}}\n          {{foo}}\n        {{/let}}\n      "]);

    _templateObject18 = function () {
      return data;
    };

    return data;
  }

  function _templateObject17() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with (hash ctxCmp=(component compName isOpen=isOpen)) as |thing|}}\n        {{#thing.ctxCmp}}This is a contextual component{{/thing.ctxCmp}}\n      {{/with}}\n    "]);

    _templateObject17 = function () {
      return data;
    };

    return data;
  }

  function _templateObject16() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with (hash ctxCmp=(component compName isOpen=isOpen)) as |thing|}}\n        {{#thing.ctxCmp}}This is a contextual component{{/thing.ctxCmp}}\n      {{/with}}\n    "]);

    _templateObject16 = function () {
      return data;
    };

    return data;
  }

  function _templateObject15() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with (hash ctxCmp=(component \"my-comp\" isOpen=isOpen)) as |thing|}}\n        {{#thing.ctxCmp}}This is a contextual component{{/thing.ctxCmp}}\n      {{/with}}\n    "]);

    _templateObject15 = function () {
      return data;
    };

    return data;
  }

  function _templateObject14() {
    const data = _taggedTemplateLiteralLoose(["\n        message: {{message}}{{inner-component message=message}}\n        <button onclick={{action \"change\"}} />"]);

    _templateObject14 = function () {
      return data;
    };

    return data;
  }

  function _templateObject13() {
    const data = _taggedTemplateLiteralLoose(["\n      {{component (component \"change-button\" model.val2)}}\n      <span class=\"value\">{{model.val2}}</span>"]);

    _templateObject13 = function () {
      return data;
    };

    return data;
  }

  function _templateObject12() {
    const data = _taggedTemplateLiteralLoose(["\n        <button {{action (action (mut val) 10)}} class=\"my-button\">\n          Change to 10\n        </button>"]);

    _templateObject12 = function () {
      return data;
    };

    return data;
  }

  function _templateObject11() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#select-box as |sb|}}\n        {{sb.option label=\"Foo\"}}\n        {{sb.option}}\n      {{/select-box}}"]);

    _templateObject11 = function () {
      return data;
    };

    return data;
  }

  function _templateObject10() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#my-component my-attr=myProp as |api|}}\n          {{api.my-nested-component}}\n        {{/my-component}}\n        <br>\n        <button onclick={{action 'changeValue'}}>Change value</button>"]);

    _templateObject10 = function () {
      return data;
    };

    return data;
  }

  function _templateObject9() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with (hash my-component=(component 'my-component' first)) as |c|}}\n        {{c.my-component}}\n      {{/with}}"]);

    _templateObject9 = function () {
      return data;
    };

    return data;
  }

  function _templateObject8() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with (hash lookedup=(component \"-looked-up\")) as |object|}}\n        {{object.lookedup model.expectedText \"Hola\"}}\n      {{/with}}"]);

    _templateObject8 = function () {
      return data;
    };

    return data;
  }

  function _templateObject7() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with (hash lookedup=(component \"-looked-up\" expectedText=model.expectedText)) as |object|}}\n        {{object.lookedup}}\n      {{/with}}"]);

    _templateObject7 = function () {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with (hash lookedup=(component \"-looked-up\")) as |object|}}\n        {{object.lookedup expectedText=model.expectedText}}\n      {{/with}}"]);

    _templateObject6 = function () {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with (hash lookedup=(component \"-looked-up\")) as |object|}}\n        {{object.lookedup}}\n      {{/with}}"]);

    _templateObject5 = function () {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with (component \"-looked-up\" greeting=\"Hola\" name=\"Dolores\" age=33) as |first|}}\n        {{#with (component first greeting=\"Hej\" name=\"Sigmundur\") as |second|}}\n          {{component second greeting=model.greeting}}\n        {{/with}}\n      {{/with}}"]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with (hash comp=(component \"-looked-up\" greeting=model.greeting)) as |my|}}\n        {{#my.comp}}{{/my.comp}}\n      {{/with}}"]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n      {{component (component \"-looked-up\" \"Hodari\" greeting=\"Hodi\")\n                  greeting=\"Hola\"}}"]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      {{component (component \"-looked-up\") \"Hodari\" greeting=\"Hodi\"}}"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('Components test: contextual components',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test renders with component helper'] = function testRendersWithComponentHelper() {
      var _this = this;

      var expectedText = 'Hodi';
      this.registerComponent('-looked-up', {
        template: expectedText
      });
      this.render('{{component (component "-looked-up")}}');
      this.assertText(expectedText);
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertText(expectedText);
    };

    _proto['@test renders with component helper with invocation params, hash'] = function testRendersWithComponentHelperWithInvocationParamsHash() {
      var _this2 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name']
        }),
        template: '{{greeting}} {{name}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject()));
      this.assertText('Hodi Hodari');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertText('Hodi Hodari');
    };

    _proto['@test GH#13742 keeps nested rest positional parameters if rendered with no positional parameters'] = function testGH13742KeepsNestedRestPositionalParametersIfRenderedWithNoPositionalParameters() {
      var _this3 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each params as |p|}}{{p}}{{/each}}'
      });
      this.render('{{component (component "-looked-up" model.greeting model.name)}}', {
        model: {
          greeting: 'Gabon ',
          name: 'Zack'
        }
      });
      this.assertText('Gabon Zack');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assertText('Gabon Zack');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.context.set('model.greeting', 'Good morning ');
      });
      this.assertText('Good morning Zack');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.context.set('model.name', 'Matthew');
      });
      this.assertText('Good morning Matthew');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.context.set('model', {
          greeting: 'Gabon ',
          name: 'Zack'
        });
      });
      this.assertText('Gabon Zack');
    } // Take a look at this one. Seems to pass even when currying isn't implemented.
    ;

    _proto['@test overwrites nested rest positional parameters if rendered with positional parameters'] = function testOverwritesNestedRestPositionalParametersIfRenderedWithPositionalParameters() {
      var _this4 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each params as |p|}}{{p}}{{/each}}'
      });
      this.render('{{component (component "-looked-up" model.greeting model.name) model.name model.greeting}}', {
        model: {
          greeting: 'Gabon ',
          name: 'Zack '
        }
      });
      this.assertText('Gabon Zack Zack Gabon ');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      this.assertText('Gabon Zack Zack Gabon ');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.context.set('model.greeting', 'Good morning ');
      });
      this.assertText('Good morning Zack Zack Good morning ');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.context.set('model.name', 'Matthew ');
      });
      this.assertText('Good morning Matthew Matthew Good morning ');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.context.set('model', {
          greeting: 'Gabon ',
          name: 'Zack '
        });
      });
      this.assertText('Gabon Zack Zack Gabon ');
    };

    _proto['@test GH#13742  keeps nested rest positional parameters if nested and rendered with no positional parameters'] = function testGH13742KeepsNestedRestPositionalParametersIfNestedAndRenderedWithNoPositionalParameters() {
      var _this5 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each params as |p|}}{{p}}{{/each}}'
      });
      this.render('{{component (component (component "-looked-up" model.greeting model.name))}}', {
        model: {
          greeting: 'Gabon ',
          name: 'Zack'
        }
      });
      this.assertText('Gabon Zack');
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.rerender();
      });
      this.assertText('Gabon Zack');
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.context.set('model.greeting', 'Good morning ');
      });
      this.assertText('Good morning Zack');
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.context.set('model.name', 'Matthew');
      });
      this.assertText('Good morning Matthew');
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.context.set('model', {
          greeting: 'Gabon ',
          name: 'Zack'
        });
      });
      this.assertText('Gabon Zack');
    };

    _proto['@test overwrites nested rest positional parameters if nested with new pos params and rendered with no positional parameters'] = function testOverwritesNestedRestPositionalParametersIfNestedWithNewPosParamsAndRenderedWithNoPositionalParameters() {
      var _this6 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each params as |p|}}{{p}}{{/each}}'
      });
      this.render('{{component (component (component "-looked-up" model.greeting model.name) model.name model.greeting)}}', {
        model: {
          greeting: 'Gabon ',
          name: 'Zack '
        }
      });
      this.assertText('Gabon Zack Zack Gabon ');
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.rerender();
      });
      this.assertText('Gabon Zack Zack Gabon ');
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.context.set('model.greeting', 'Good morning ');
      });
      this.assertText('Good morning Zack Zack Good morning ');
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.context.set('model.name', 'Matthew ');
      });
      this.assertText('Good morning Matthew Matthew Good morning ');
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.context.set('model', {
          greeting: 'Gabon ',
          name: 'Zack '
        });
      });
      this.assertText('Gabon Zack Zack Gabon ');
    };

    _proto['@test renders with component helper with curried params, hash'] = function testRendersWithComponentHelperWithCurriedParamsHash() {
      var _this7 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name']
        }),
        template: '{{greeting}} {{name}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject2()));
      this.assertText('Hola Hodari');
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.rerender();
      });
      this.assertText('Hola Hodari');
    };

    _proto['@test updates when component path is bound'] = function testUpdatesWhenComponentPathIsBound() {
      var _this8 = this;

      this.registerComponent('-mandarin', {
        template: 'ni hao'
      });
      this.registerComponent('-hindi', {
        template: 'Namaste'
      });
      this.render('{{component (component model.lookupComponent)}}', {
        model: {
          lookupComponent: '-mandarin'
        }
      });
      this.assertText('ni hao');
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.rerender();
      });
      this.assertText('ni hao');
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.context.set('model.lookupComponent', '-hindi');
      });
      this.assertText('Namaste');
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.context.set('model', {
          lookupComponent: '-mandarin'
        });
      });
      this.assertText('ni hao');
    };

    _proto['@test updates when curried hash argument is bound'] = function testUpdatesWhenCurriedHashArgumentIsBound() {
      var _this9 = this;

      this.registerComponent('-looked-up', {
        template: '{{greeting}}'
      });
      this.render("{{component (component \"-looked-up\" greeting=model.greeting)}}", {
        model: {
          greeting: 'Hodi'
        }
      });
      this.assertText('Hodi');
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.rerender();
      });
      this.assertText('Hodi');
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.context.set('model.greeting', 'Hola');
      });
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.context.set('model', {
          greeting: 'Hodi'
        });
      });
      this.assertText('Hodi');
    };

    _proto['@test updates when curried hash arguments is bound in block form'] = function testUpdatesWhenCurriedHashArgumentsIsBoundInBlockForm() {
      var _this10 = this;

      this.registerComponent('-looked-up', {
        template: '{{greeting}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject3()), {
        model: {
          greeting: 'Hodi'
        }
      });
      this.assertText('Hodi');
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.rerender();
      });
      this.assertText('Hodi');
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.context.set('model.greeting', 'Hola');
      });
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.context.set('model', {
          greeting: 'Hodi'
        });
      });
      this.assertText('Hodi');
    };

    _proto['@test nested components do not overwrite positional parameters'] = function testNestedComponentsDoNotOverwritePositionalParameters() {
      var _this11 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        }),
        template: '{{name}} {{age}}'
      });
      this.render('{{component (component (component "-looked-up" "Sergio" 29) "Marvin" 21) "Hodari"}}');
      this.assertText('Sergio 29');
      (0, _internalTestHelpers.runTask)(function () {
        return _this11.rerender();
      });
      this.assertText('Sergio 29');
    };

    _proto['@test positional parameters are combined not clobbered'] = function testPositionalParametersAreCombinedNotClobbered() {
      var _this12 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['greeting', 'name', 'age']
        }),
        template: '{{greeting}} {{name}} {{age}}'
      });
      this.render('{{component (component (component "-looked-up" "Hi") "Max") 9}}');
      this.assertText('Hi Max 9');
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.rerender();
      });
      this.assertText('Hi Max 9');
    };

    _proto['@test nested components overwrite hash parameters'] = function testNestedComponentsOverwriteHashParameters() {
      var _this13 = this;

      this.registerComponent('-looked-up', {
        template: '{{greeting}} {{name}} {{age}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject4()), {
        model: {
          greeting: 'Hodi'
        }
      });
      this.assertText('Hodi Sigmundur 33');
      (0, _internalTestHelpers.runTask)(function () {
        return _this13.rerender();
      });
      this.assertText('Hodi Sigmundur 33');
      (0, _internalTestHelpers.runTask)(function () {
        return _this13.context.set('model.greeting', 'Kaixo');
      });
      this.assertText('Kaixo Sigmundur 33');
      (0, _internalTestHelpers.runTask)(function () {
        return _this13.context.set('model', {
          greeting: 'Hodi'
        });
      });
      this.assertText('Hodi Sigmundur 33');
    };

    _proto['@test bound outer named parameters get updated in the right scope'] = function testBoundOuterNamedParametersGetUpdatedInTheRightScope() {
      var _this14 = this;

      this.registerComponent('-inner-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['comp']
        }),
        template: '{{component comp "Inner"}}'
      });
      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        }),
        template: '{{name}} {{age}}'
      });
      this.render('{{component "-inner-component" (component "-looked-up" model.outerName model.outerAge)}}', {
        model: {
          outerName: 'Outer',
          outerAge: 28
        }
      });
      this.assertText('Outer 28');
      (0, _internalTestHelpers.runTask)(function () {
        return _this14.rerender();
      });
      this.assertText('Outer 28');
      (0, _internalTestHelpers.runTask)(function () {
        return _this14.context.set('model.outerAge', 29);
      });
      this.assertText('Outer 29');
      (0, _internalTestHelpers.runTask)(function () {
        return _this14.context.set('model.outerName', 'Not outer');
      });
      this.assertText('Not outer 29');
      (0, _internalTestHelpers.runTask)(function () {
        _this14.context.set('model', {
          outerName: 'Outer',
          outerAge: 28
        });
      });
      this.assertText('Outer 28');
    };

    _proto['@test bound outer hash parameters get updated in the right scope'] = function testBoundOuterHashParametersGetUpdatedInTheRightScope() {
      var _this15 = this;

      this.registerComponent('-inner-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['comp']
        }),
        template: '{{component comp name="Inner"}}'
      });
      this.registerComponent('-looked-up', {
        template: '{{name}} {{age}}'
      });
      this.render('{{component "-inner-component" (component "-looked-up" name=model.outerName age=model.outerAge)}}', {
        model: {
          outerName: 'Outer',
          outerAge: 28
        }
      });
      this.assertText('Inner 28');
      (0, _internalTestHelpers.runTask)(function () {
        return _this15.rerender();
      });
      this.assertText('Inner 28');
      (0, _internalTestHelpers.runTask)(function () {
        return _this15.context.set('model.outerAge', 29);
      });
      this.assertText('Inner 29');
      (0, _internalTestHelpers.runTask)(function () {
        return _this15.context.set('model.outerName', 'Not outer');
      });
      this.assertText('Inner 29');
      (0, _internalTestHelpers.runTask)(function () {
        _this15.context.set('model', {
          outerName: 'Outer',
          outerAge: 28
        });
      });
      this.assertText('Inner 28');
    };

    _proto['@test conflicting positional and hash parameters does not raise an assertion if rerendered'] = function testConflictingPositionalAndHashParametersDoesNotRaiseAnAssertionIfRerendered() {
      var _this16 = this; // In some cases, rerendering with a positional param used to cause an
      // assertion. This test checks it does not.


      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name']
        }),
        template: '{{greeting}} {{name}}'
      });
      this.render('{{component (component "-looked-up" model.name greeting="Hodi")}}', {
        model: {
          name: 'Hodari'
        }
      });
      this.assertText('Hodi Hodari');
      (0, _internalTestHelpers.runTask)(function () {
        return _this16.rerender();
      });
      this.assertText('Hodi Hodari');
      (0, _internalTestHelpers.runTask)(function () {
        return _this16.context.set('model.name', 'Sergio');
      });
      this.assertText('Hodi Sergio');
      (0, _internalTestHelpers.runTask)(function () {
        return _this16.context.set('model', {
          name: 'Hodari'
        });
      });
      this.assertText('Hodi Hodari');
    };

    _proto['@test component with dynamic component name resolving to undefined, then an existing component'] = function testComponentWithDynamicComponentNameResolvingToUndefinedThenAnExistingComponent() {
      var _this17 = this;

      this.registerComponent('foo-bar', {
        template: 'hello {{name}}'
      });
      this.render('{{component (component componentName name=name)}}', {
        componentName: undefined,
        name: 'Alex'
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return _this17.rerender();
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return _this17.context.set('componentName', 'foo-bar');
      });
      this.assertText('hello Alex');
      (0, _internalTestHelpers.runTask)(function () {
        return _this17.context.set('componentName', undefined);
      });
      this.assertText('');
    };

    _proto['@test component with dynamic component name resolving to a component, then undefined'] = function testComponentWithDynamicComponentNameResolvingToAComponentThenUndefined() {
      var _this18 = this;

      this.registerComponent('foo-bar', {
        template: 'hello {{name}}'
      });
      this.render('{{component (component componentName name=name)}}', {
        componentName: 'foo-bar',
        name: 'Alex'
      });
      this.assertText('hello Alex');
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.rerender();
      });
      this.assertText('hello Alex');
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.context.set('componentName', undefined);
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.context.set('componentName', 'foo-bar');
      });
      this.assertText('hello Alex');
    };

    _proto['@test component with dynamic component name resolving to null, then an existing component'] = function testComponentWithDynamicComponentNameResolvingToNullThenAnExistingComponent() {
      var _this19 = this;

      this.registerComponent('foo-bar', {
        template: 'hello {{name}}'
      });
      this.render('{{component (component componentName name=name)}}', {
        componentName: null,
        name: 'Alex'
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return _this19.rerender();
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return _this19.context.set('componentName', 'foo-bar');
      });
      this.assertText('hello Alex');
      (0, _internalTestHelpers.runTask)(function () {
        return _this19.context.set('componentName', null);
      });
      this.assertText('');
    };

    _proto['@test component with dynamic component name resolving to a component, then null'] = function testComponentWithDynamicComponentNameResolvingToAComponentThenNull() {
      var _this20 = this;

      this.registerComponent('foo-bar', {
        template: 'hello {{name}}'
      });
      this.render('{{component (component componentName name=name)}}', {
        componentName: 'foo-bar',
        name: 'Alex'
      });
      this.assertText('hello Alex');
      (0, _internalTestHelpers.runTask)(function () {
        return _this20.rerender();
      });
      this.assertText('hello Alex');
      (0, _internalTestHelpers.runTask)(function () {
        return _this20.context.set('componentName', null);
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return _this20.context.set('componentName', 'foo-bar');
      });
      this.assertText('hello Alex');
    };

    _proto['@test raises an assertion when component path is not a component name (static)'] = function testRaisesAnAssertionWhenComponentPathIsNotAComponentNameStatic() {
      var _this21 = this;

      expectAssertion(function () {
        _this21.render('{{component (component "not-a-component")}}');
      }, 'Could not find component named "not-a-component" (no component or template with that name was found)');
    };

    _proto['@test raises an assertion when component path is not a component name (dynamic)'] = function testRaisesAnAssertionWhenComponentPathIsNotAComponentNameDynamic() {
      var _this22 = this;

      expectAssertion(function () {
        _this22.render('{{component (component compName)}}', {
          compName: 'not-a-component'
        });
      }, 'Could not find component named "not-a-component" (no component or template with that name was found)');
    };

    _proto['@test renders with dot path'] = function testRendersWithDotPath() {
      var _this23 = this;

      var expectedText = 'Hodi';
      this.registerComponent('-looked-up', {
        template: expectedText
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject5()));
      this.assertText(expectedText);
      (0, _internalTestHelpers.runTask)(function () {
        return _this23.rerender();
      });
      this.assertText(expectedText);
    };

    _proto['@test renders with dot path and attr'] = function testRendersWithDotPathAndAttr() {
      var _this24 = this;

      var expectedText = 'Hodi';
      this.registerComponent('-looked-up', {
        template: '{{expectedText}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject6()), {
        model: {
          expectedText: expectedText
        }
      });
      this.assertText(expectedText);
      (0, _internalTestHelpers.runTask)(function () {
        return _this24.rerender();
      });
      this.assertText(expectedText);
      (0, _internalTestHelpers.runTask)(function () {
        return _this24.context.set('model.expectedText', 'Hola');
      });
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(function () {
        return _this24.context.set('model', {
          expectedText: expectedText
        });
      });
      this.assertText(expectedText);
    };

    _proto['@test renders with dot path and curried over attr'] = function testRendersWithDotPathAndCurriedOverAttr() {
      var _this25 = this;

      var expectedText = 'Hodi';
      this.registerComponent('-looked-up', {
        template: '{{expectedText}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject7()), {
        model: {
          expectedText: expectedText
        }
      });
      this.assertText(expectedText);
      (0, _internalTestHelpers.runTask)(function () {
        return _this25.rerender();
      });
      this.assertText(expectedText);
      (0, _internalTestHelpers.runTask)(function () {
        return _this25.context.set('model.expectedText', 'Hola');
      });
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(function () {
        return _this25.context.set('model', {
          expectedText: expectedText
        });
      });
      this.assertText(expectedText);
    };

    _proto['@test renders with dot path and with rest positional parameters'] = function testRendersWithDotPathAndWithRestPositionalParameters() {
      var _this26 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{params}}'
      });
      var expectedText = 'Hodi';
      this.render((0, _internalTestHelpers.strip)(_templateObject8()), {
        model: {
          expectedText: expectedText
        }
      });
      this.assertText(expectedText + ",Hola");
      (0, _internalTestHelpers.runTask)(function () {
        return _this26.rerender();
      });
      this.assertText(expectedText + ",Hola");
      (0, _internalTestHelpers.runTask)(function () {
        return _this26.context.set('model.expectedText', 'Kaixo');
      });
      this.assertText('Kaixo,Hola');
      (0, _internalTestHelpers.runTask)(function () {
        return _this26.context.set('model', {
          expectedText: expectedText
        });
      });
      this.assertText(expectedText + ",Hola");
    };

    _proto['@test renders with dot path and rest parameter does not leak'] = function testRendersWithDotPathAndRestParameterDoesNotLeak(assert) {
      // In the original implementation, positional parameters were not handled
      // correctly causing the first positional parameter to be the contextual
      // component itself.
      var value = false;
      this.registerComponent('my-component', {
        ComponentClass: _helpers.Component.extend({
          didReceiveAttrs: function () {
            value = this.getAttr('value');
          }
        }).reopenClass({
          positionalParams: ['value']
        })
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject9()), {
        first: 'first'
      });
      assert.equal(value, 'first', 'value is the expected parameter');
    };

    _proto['@test renders with dot path and updates attributes'] = function testRendersWithDotPathAndUpdatesAttributes(assert) {
      var _this27 = this;

      this.registerComponent('my-nested-component', {
        ComponentClass: _helpers.Component.extend({
          didReceiveAttrs: function () {
            this.set('myProp', this.getAttr('my-parent-attr'));
          }
        }),
        template: '<span id="nested-prop">{{myProp}}</span>'
      });
      this.registerComponent('my-component', {
        template: '{{yield (hash my-nested-component=(component "my-nested-component" my-parent-attr=my-attr))}}'
      });
      this.registerComponent('my-action-component', {
        ComponentClass: _helpers.Component.extend({
          actions: {
            changeValue: function () {
              this.incrementProperty('myProp');
            }
          }
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject10())
      });
      this.render('{{my-action-component myProp=model.myProp}}', {
        model: {
          myProp: 1
        }
      });
      assert.equal(this.$('#nested-prop').text(), '1');
      (0, _internalTestHelpers.runTask)(function () {
        return _this27.rerender();
      });
      assert.equal(this.$('#nested-prop').text(), '1');
      (0, _internalTestHelpers.runTask)(function () {
        return _this27.$('button').click();
      });
      assert.equal(this.$('#nested-prop').text(), '2');
      (0, _internalTestHelpers.runTask)(function () {
        return _this27.$('button').click();
      });
      assert.equal(this.$('#nested-prop').text(), '3');
      (0, _internalTestHelpers.runTask)(function () {
        return _this27.context.set('model', {
          myProp: 1
        });
      });
      assert.equal(this.$('#nested-prop').text(), '1');
    };

    _proto["@test adding parameters to a contextual component's instance does not add it to other instances"] = function testAddingParametersToAContextualComponentSInstanceDoesNotAddItToOtherInstances() {
      var _this28 = this; // If parameters and attributes are not handled correctly, setting a value
      // in an invokation can leak to others invocation.


      this.registerComponent('select-box', {
        template: '{{yield (hash option=(component "select-box-option"))}}'
      });
      this.registerComponent('select-box-option', {
        template: '{{label}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject11()));
      this.assertText('Foo');
      (0, _internalTestHelpers.runTask)(function () {
        return _this28.rerender();
      });
      this.assertText('Foo');
    };

    _proto['@test parameters in a contextual component are mutable when value is a param'] = function testParametersInAContextualComponentAreMutableWhenValueIsAParam(assert) {
      var _this29 = this; // This checks that a `(mut)` is added to parameters and attributes to
      // contextual components when it is a param.


      this.registerComponent('change-button', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['val']
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject12())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject13()), {
        model: {
          val2: 8
        }
      });
      assert.equal(this.$('.value').text(), '8');
      (0, _internalTestHelpers.runTask)(function () {
        return _this29.rerender();
      });
      assert.equal(this.$('.value').text(), '8');
      (0, _internalTestHelpers.runTask)(function () {
        return _this29.$('.my-button').click();
      });
      assert.equal(this.$('.value').text(), '10');
      (0, _internalTestHelpers.runTask)(function () {
        return _this29.context.set('model', {
          val2: 8
        });
      });
      assert.equal(this.$('.value').text(), '8');
    };

    _proto['@test tagless blockless components render'] = function testTaglessBlocklessComponentsRender(assert) {
      var _this30 = this;

      this.registerComponent('my-comp', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        })
      });
      this.render("{{my-comp}}");
      (0, _internalTestHelpers.runTask)(function () {
        return _this30.rerender();
      });
      assert.equal(this.$().text(), '');
    };

    _proto['@test GH#13494 tagless blockless component with property binding'] = function testGH13494TaglessBlocklessComponentWithPropertyBinding(assert) {
      var _this31 = this;

      this.registerComponent('outer-component', {
        ComponentClass: _helpers.Component.extend({
          message: 'hello',
          actions: {
            change: function () {
              this.set('message', 'goodbye');
            }
          }
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject14())
      });
      this.registerComponent('inner-component', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        })
      });
      this.render("{{outer-component}}");
      assert.equal(this.$().text(), 'message: hello');
      (0, _internalTestHelpers.runTask)(function () {
        return _this31.rerender();
      });
      assert.equal(this.$().text(), 'message: hello');
      (0, _internalTestHelpers.runTask)(function () {
        return _this31.$('button').click();
      });
      assert.equal(this.$().text(), 'message: goodbye');
      (0, _internalTestHelpers.runTask)(function () {
        return _this31.rerender();
      });
      assert.equal(this.$().text(), 'message: goodbye');
    };

    _proto['@test GH#13982 contextual component ref is stable even when bound params change'] = function testGH13982ContextualComponentRefIsStableEvenWhenBoundParamsChange(assert) {
      var _this32 = this;

      var instance, previousInstance;
      var initCount = 0;
      this.registerComponent('my-comp', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super();

            previousInstance = instance;
            instance = this;
            initCount++;
          },
          isOpen: undefined
        }),
        template: '{{if isOpen "open" "closed"}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject15()), {
        isOpen: true
      });
      assert.ok(!(0, _metal.isEmpty)(instance), 'a instance was created');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the components text is "open"');
      (0, _internalTestHelpers.runTask)(function () {
        return _this32.rerender();
      });
      assert.ok(!(0, _metal.isEmpty)(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the components text is "open"');
      (0, _internalTestHelpers.runTask)(function () {
        return _this32.context.set('isOpen', false);
      });
      assert.ok(!(0, _metal.isEmpty)(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'closed', 'the component text is "closed"');
      (0, _internalTestHelpers.runTask)(function () {
        return _this32.rerender();
      });
      assert.ok(!(0, _metal.isEmpty)(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'closed', 'the component text is "closed"');
      (0, _internalTestHelpers.runTask)(function () {
        return _this32.context.set('isOpen', true);
      });
      assert.ok(!(0, _metal.isEmpty)(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the components text is "open"');
    };

    _proto['@test GH#13982 contextual component ref is stable even when bound params change (bound name param)'] = function testGH13982ContextualComponentRefIsStableEvenWhenBoundParamsChangeBoundNameParam(assert) {
      var _this33 = this;

      var instance, previousInstance;
      var initCount = 0;
      this.registerComponent('my-comp', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super();

            previousInstance = instance;
            instance = this;
            initCount++;
          },
          isOpen: undefined
        }),
        template: '{{if isOpen "open" "closed"}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject16()), {
        compName: 'my-comp',
        isOpen: true
      });
      assert.ok(!(0, _metal.isEmpty)(instance), 'a instance was created');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the components text is "open"');
      (0, _internalTestHelpers.runTask)(function () {
        return _this33.rerender();
      });
      assert.ok(!(0, _metal.isEmpty)(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the components text is "open"');
      (0, _internalTestHelpers.runTask)(function () {
        return _this33.context.set('isOpen', false);
      });
      assert.ok(!(0, _metal.isEmpty)(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'closed', 'the component text is "closed"');
      (0, _internalTestHelpers.runTask)(function () {
        return _this33.rerender();
      });
      assert.ok(!(0, _metal.isEmpty)(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'closed', 'the component text is "closed"');
      (0, _internalTestHelpers.runTask)(function () {
        return _this33.context.set('isOpen', true);
      });
      assert.ok(!(0, _metal.isEmpty)(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the components text is "open"');
    };

    _proto['@test GH#13982 contextual component ref is recomputed when component name param changes'] = function testGH13982ContextualComponentRefIsRecomputedWhenComponentNameParamChanges(assert) {
      var _this34 = this;

      var instance, previousInstance;
      var initCount = 0;
      this.registerComponent('my-comp', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super();

            previousInstance = instance;
            instance = this;
            initCount++;
          },
          isOpen: undefined
        }),
        template: 'my-comp: {{if isOpen "open" "closed"}}'
      });
      this.registerComponent('your-comp', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super();

            previousInstance = instance;
            instance = this;
            initCount++;
          },
          isOpen: undefined
        }),
        template: 'your-comp: {{if isOpen "open" "closed"}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject17()), {
        compName: 'my-comp',
        isOpen: true
      });
      assert.ok(!(0, _metal.isEmpty)(instance), 'a instance was created');
      assert.equal(previousInstance, undefined, 'there is no previous instance');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'my-comp: open');
      (0, _internalTestHelpers.runTask)(function () {
        return _this34.rerender();
      });
      assert.ok(!(0, _metal.isEmpty)(instance), 'a instance exists after rerender');
      assert.equal(previousInstance, undefined, 'there is no previous instance after rerender');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'my-comp: open');
      (0, _internalTestHelpers.runTask)(function () {
        return _this34.context.set('compName', 'your-comp');
      });
      assert.ok(!(0, _metal.isEmpty)(instance), 'an instance was created after component name changed');
      assert.ok(!(0, _metal.isEmpty)(previousInstance), 'a previous instance now exists');
      assert.notEqual(instance, previousInstance, 'the instance and previous instance are not the same object');
      assert.equal(initCount, 2, 'the component was constructed exactly 2 times');
      assert.equal(this.$().text(), 'your-comp: open');
      (0, _internalTestHelpers.runTask)(function () {
        return _this34.rerender();
      });
      assert.ok(!(0, _metal.isEmpty)(instance), 'an instance was created after component name changed (rerender)');
      assert.ok(!(0, _metal.isEmpty)(previousInstance), 'a previous instance now exists (rerender)');
      assert.notEqual(instance, previousInstance, 'the instance and previous instance are not the same object (rerender)');
      assert.equal(initCount, 2, 'the component was constructed exactly 2 times (rerender)');
      assert.equal(this.$().text(), 'your-comp: open');
      (0, _internalTestHelpers.runTask)(function () {
        return _this34.context.set('compName', 'my-comp');
      });
      assert.ok(!(0, _metal.isEmpty)(instance), 'an instance was created after component name changed');
      assert.ok(!(0, _metal.isEmpty)(previousInstance), 'a previous instance still exists');
      assert.notEqual(instance, previousInstance, 'the instance and previous instance are not the same object');
      assert.equal(initCount, 3, 'the component was constructed exactly 3 times (rerender)');
      assert.equal(this.$().text(), 'my-comp: open');
    };

    _proto['@test GH#14508 rest positional params are received when passed as named parameter'] = function testGH14508RestPositionalParamsAreReceivedWhenPassedAsNamedParameter() {
      var _this35 = this;

      this.registerComponent('my-link', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each params as |p|}}{{p}}{{/each}}'
      });
      this.render('{{component (component "my-link") params=allParams}}', {
        allParams: (0, _runtime.A)(['a', 'b'])
      });
      this.assertText('ab');
      (0, _internalTestHelpers.runTask)(function () {
        return _this35.rerender();
      });
      this.assertText('ab');
      (0, _internalTestHelpers.runTask)(function () {
        return _this35.context.get('allParams').pushObject('c');
      });
      this.assertText('abc');
      (0, _internalTestHelpers.runTask)(function () {
        return _this35.context.get('allParams').popObject();
      });
      this.assertText('ab');
      (0, _internalTestHelpers.runTask)(function () {
        return _this35.context.get('allParams').clear();
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return _this35.context.set('allParams', (0, _runtime.A)(['1', '2']));
      });
      this.assertText('12');
      (0, _internalTestHelpers.runTask)(function () {
        return _this35.context.set('allParams', (0, _runtime.A)(['a', 'b']));
      });
      this.assertText('ab');
    };

    _proto['@test GH#14508 rest positional params are received when passed as named parameter with dot notation'] = function testGH14508RestPositionalParamsAreReceivedWhenPassedAsNamedParameterWithDotNotation() {
      var _this36 = this;

      this.registerComponent('my-link', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each params as |p|}}{{p}}{{/each}}'
      });
      this.render('{{#with (hash link=(component "my-link")) as |c|}}{{c.link params=allParams}}{{/with}}', {
        allParams: (0, _runtime.A)(['a', 'b'])
      });
      this.assertText('ab');
      (0, _internalTestHelpers.runTask)(function () {
        return _this36.rerender();
      });
      this.assertText('ab');
      (0, _internalTestHelpers.runTask)(function () {
        return _this36.context.get('allParams').pushObject('c');
      });
      this.assertText('abc');
      (0, _internalTestHelpers.runTask)(function () {
        return _this36.context.get('allParams').popObject();
      });
      this.assertText('ab');
      (0, _internalTestHelpers.runTask)(function () {
        return _this36.context.get('allParams').clear();
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return _this36.context.set('allParams', (0, _runtime.A)(['1', '2']));
      });
      this.assertText('12');
      (0, _internalTestHelpers.runTask)(function () {
        return _this36.context.set('allParams', (0, _runtime.A)(['a', 'b']));
      });
      this.assertText('ab');
    };

    _proto['@feature(!ember-glimmer-angle-bracket-built-ins) GH#14632 give useful warning when calling contextual components with input as a name'] = function featureEmberGlimmerAngleBracketBuiltInsGH14632GiveUsefulWarningWhenCallingContextualComponentsWithInputAsAName() {
      var _this37 = this;

      expectAssertion(function () {
        _this37.render('{{component (component "input" type="text")}}');
      }, 'Invoking `{{input}}` using angle bracket syntax or `component` helper is not yet supported.');
    };

    _proto['@feature(ember-glimmer-angle-bracket-built-ins) it can invoke input component'] = function featureEmberGlimmerAngleBracketBuiltInsItCanInvokeInputComponent() {
      var _this38 = this;

      this.render('{{component (component "input" type="text" value=value)}}', {
        value: 'foo'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'input',
        attrs: {
          class: 'ember-text-field ember-view',
          type: 'text'
        }
      });
      this.assert.strictEqual('foo', this.firstChild.value);
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this38.context.set('value', 'bar');
      });
      this.assert.strictEqual('bar', this.firstChild.value);
      (0, _internalTestHelpers.runTask)(function () {
        return _this38.context.set('value', 'foo');
      });
      this.assert.strictEqual('foo', this.firstChild.value);
    };

    _proto['@feature(!ember-glimmer-angle-bracket-built-ins) GH#14632 give useful warning when calling contextual components with textarea as a name'] = function featureEmberGlimmerAngleBracketBuiltInsGH14632GiveUsefulWarningWhenCallingContextualComponentsWithTextareaAsAName() {
      var _this39 = this;

      expectAssertion(function () {
        _this39.render('{{component (component "textarea")}}');
      }, 'Invoking `{{textarea}}` using angle bracket syntax or `component` helper is not yet supported.');
    };

    _proto['@feature(ember-glimmer-angle-bracket-built-ins) it can invoke textarea component'] = function featureEmberGlimmerAngleBracketBuiltInsItCanInvokeTextareaComponent() {
      var _this40 = this;

      this.render('{{component (component "textarea" value=value)}}', {
        value: 'foo'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'textarea',
        attrs: {
          class: 'ember-text-area ember-view'
        }
      });
      this.assert.strictEqual('foo', this.firstChild.value);
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this40.context.set('value', 'bar');
      });
      this.assert.strictEqual('bar', this.firstChild.value);
      (0, _internalTestHelpers.runTask)(function () {
        return _this40.context.set('value', 'foo');
      });
      this.assert.strictEqual('foo', this.firstChild.value);
    };

    _proto['@test GH#17121 local variable should win over helper (without arguments)'] = function testGH17121LocalVariableShouldWinOverHelperWithoutArguments() {
      this.registerHelper('foo', function () {
        return 'foo helper';
      });
      this.registerComponent('foo-bar', {
        template: 'foo-bar component'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject18()));
      this.assertText('foo-bar component');
      this.assertStableRerender();
    };

    _proto['@test GH#17121 local variable should win over helper (with arguments)'] = function testGH17121LocalVariableShouldWinOverHelperWithArguments() {
      this.registerHelper('foo', function (params) {
        return "foo helper: " + params.join(' ');
      });
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: 'foo-bar component:{{#each params as |param|}} {{param}}{{/each}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject19()));
      this.assertText('foo-bar component: 1 2 3');
      this.assertStableRerender();
    };

    _proto['@test GH#17121 implicit component invocations should not perform string lookup'] = function testGH17121ImplicitComponentInvocationsShouldNotPerformStringLookup() {
      var _this41 = this;

      this.registerComponent('foo-bar', {
        template: 'foo-bar component'
      });
      expectAssertion(function () {
        return _this41.render((0, _internalTestHelpers.strip)(_templateObject20()));
      }, "expected `foo` to be a contextual component but found a string. Did you mean `(component foo)`? ('-top-level' @ L1:C29) ");
    };

    _proto['@test RFC#311 invoking named args (without arguments)'] = function testRFC311InvokingNamedArgsWithoutArguments() {
      this.registerComponent('x-outer', {
        template: '{{@inner}}'
      });
      this.registerComponent('x-inner', {
        template: 'inner'
      });
      this.render('{{x-outer inner=(component "x-inner")}}');
      this.assertText('inner');
      this.assertStableRerender();
    };

    _proto['@test RFC#311 invoking named args (with arguments)'] = function testRFC311InvokingNamedArgsWithArguments() {
      this.registerComponent('x-outer', {
        template: '{{@inner 1 2 3}}'
      });
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: 'inner:{{#each params as |param|}} {{param}}{{/each}}'
      });
      this.render('{{x-outer inner=(component "x-inner")}}');
      this.assertText('inner: 1 2 3');
      this.assertStableRerender();
    };

    _proto['@test RFC#311 invoking named args (with a block)'] = function testRFC311InvokingNamedArgsWithABlock() {
      this.registerComponent('x-outer', {
        template: '{{#@inner}}outer{{/@inner}}'
      });
      this.registerComponent('x-inner', {
        template: 'inner {{yield}}'
      });
      this.render('{{x-outer inner=(component "x-inner")}}');
      this.assertText('inner outer');
      this.assertStableRerender();
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));

  var ContextualComponentMutableParamsTest =
  /*#__PURE__*/
  function (_RenderingTestCase2) {
    (0, _emberBabel.inheritsLoose)(ContextualComponentMutableParamsTest, _RenderingTestCase2);

    function ContextualComponentMutableParamsTest() {
      return _RenderingTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = ContextualComponentMutableParamsTest.prototype;

    _proto2.render = function render(templateStr) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _RenderingTestCase2.prototype.render.call(this, templateStr + "<span class=\"value\">{{model.val2}}</span>", (0, _polyfills.assign)(context, {
        model: {
          val2: 8
        }
      }));
    };

    return ContextualComponentMutableParamsTest;
  }(_internalTestHelpers.RenderingTestCase);

  var MutableParamTestGenerator =
  /*#__PURE__*/
  function () {
    function MutableParamTestGenerator(cases) {
      this.cases = cases;
    }

    var _proto3 = MutableParamTestGenerator.prototype;

    _proto3.generate = function generate(_ref) {
      var _ref2;

      var title = _ref.title,
          setup = _ref.setup;
      return _ref2 = {}, _ref2["@test parameters in a contextual component are mutable when value is a " + title] = function (assert) {
        var _this42 = this;

        this.registerComponent('change-button', {
          ComponentClass: _helpers.Component.extend().reopenClass({
            positionalParams: ['val']
          }),
          template: (0, _internalTestHelpers.strip)(_templateObject21())
        });
        setup.call(this, assert);
        assert.equal(this.$('.value').text(), '8');
        (0, _internalTestHelpers.runTask)(function () {
          return _this42.rerender();
        });
        assert.equal(this.$('.value').text(), '8');
        (0, _internalTestHelpers.runTask)(function () {
          return _this42.$('.my-button').click();
        });
        assert.equal(this.$('.value').text(), '10');
        (0, _internalTestHelpers.runTask)(function () {
          return _this42.context.set('model', {
            val2: 8
          });
        });
        assert.equal(this.$('.value').text(), '8');
      }, _ref2;
    };

    return MutableParamTestGenerator;
  }();

  (0, _internalTestHelpers.applyMixins)(ContextualComponentMutableParamsTest, new MutableParamTestGenerator([{
    title: 'param',
    setup: function () {
      this.render('{{component (component "change-button" model.val2)}}');
    }
  }, {
    title: 'nested param',
    setup: function () {
      this.registerComponent('my-comp', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['components']
        }),
        template: '{{component components.comp}}'
      });
      this.render('{{my-comp (hash comp=(component "change-button" model.val2))}}');
    }
  }, {
    title: 'hash value',
    setup: function () {
      this.registerComponent('my-comp', {
        template: '{{component component}}'
      });
      this.render('{{my-comp component=(component "change-button" val=model.val2)}}');
    }
  }, {
    title: 'nested hash value',
    setup: function () {
      this.registerComponent('my-comp', {
        template: '{{component components.button}}'
      });
      this.render('{{my-comp components=(hash button=(component "change-button" val=model.val2))}}');
    }
  }]));
  (0, _internalTestHelpers.moduleFor)('Components test: contextual components -- mutable params', ContextualComponentMutableParamsTest);
});
enifed("@ember/-internals/glimmer/tests/integration/components/curly-components-test", ["ember-babel", "internal-test-helpers", "@ember/runloop", "@ember/-internals/metal", "@ember/service", "@ember/-internals/runtime", "@ember/-internals/views", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _runloop, _metal, _service, _runtime, _views, _helpers) {
  "use strict";

  function _templateObject55() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#list-items items=items as |thing|}}\n        |{{thing}}|\n\n        {{#if editMode}}\n          Remove {{thing}}\n        {{/if}}\n      {{/list-items}}\n    "]);

    _templateObject55 = function () {
      return data;
    };

    return data;
  }

  function _templateObject54() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#x-select value=value as |select|}}\n        {{#x-option value=\"1\" select=select}}1{{/x-option}}\n        {{#x-option value=\"2\" select=select}}2{{/x-option}}\n      {{/x-select}}\n    "]);

    _templateObject54 = function () {
      return data;
    };

    return data;
  }

  function _templateObject53() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#some-clicky-thing blahzz=\"baz\"}}\n        Click Me\n      {{/some-clicky-thing}}"]);

    _templateObject53 = function () {
      return data;
    };

    return data;
  }

  function _templateObject52() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#each blahzz as |p|}}\n          {{p}}\n        {{/each}}\n        - {{yield}}"]);

    _templateObject52 = function () {
      return data;
    };

    return data;
  }

  function _templateObject51() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#some-clicky-thing classNames=\"baz\"}}\n        Click Me\n      {{/some-clicky-thing}}"]);

    _templateObject51 = function () {
      return data;
    };

    return data;
  }

  function _templateObject50() {
    const data = _taggedTemplateLiteralLoose(["\n        In layout. {{#each items as |item|}}\n          [{{child-non-block item=item}}]\n        {{/each}}"]);

    _templateObject50 = function () {
      return data;
    };

    return data;
  }

  function _templateObject49() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#x-outer}}\n        {{#if showInner}}\n          {{x-inner}}\n        {{/if}}\n      {{/x-outer}}"]);

    _templateObject49 = function () {
      return data;
    };

    return data;
  }

  function _templateObject48() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#check-helper}}{{/check-helper}}\n      {{#check-helper as |something|}}{{/check-helper}}"]);

    _templateObject48 = function () {
      return data;
    };

    return data;
  }

  function _templateObject47() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#check-helper}}{{/check-helper}}\n      {{#check-helper as |something|}}{{/check-helper}}"]);

    _templateObject47 = function () {
      return data;
    };

    return data;
  }

  function _templateObject46() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#check-helper}}{{/check-helper}}\n      {{#check-helper as |something|}}{{/check-helper}}"]);

    _templateObject46 = function () {
      return data;
    };

    return data;
  }

  function _templateObject45() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#check-helper}}{{/check-helper}}\n      {{#check-helper}}{{else}}{{/check-helper}}"]);

    _templateObject45 = function () {
      return data;
    };

    return data;
  }

  function _templateObject44() {
    const data = _taggedTemplateLiteralLoose(["\n      {{check-helper}}\n      {{#check-helper}}{{/check-helper}}"]);

    _templateObject44 = function () {
      return data;
    };

    return data;
  }

  function _templateObject43() {
    const data = _taggedTemplateLiteralLoose(["\n      {{check-helper}}\n      {{#check-helper}}{{/check-helper}}"]);

    _templateObject43 = function () {
      return data;
    };

    return data;
  }

  function _templateObject42() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#check-attr}}{{/check-attr}}\n      {{#check-attr as |something|}}{{/check-attr}}"]);

    _templateObject42 = function () {
      return data;
    };

    return data;
  }

  function _templateObject41() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#check-attr}}{{/check-attr}}\n      {{#check-attr as |something|}}{{/check-attr}}"]);

    _templateObject41 = function () {
      return data;
    };

    return data;
  }

  function _templateObject40() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#check-attr}}{{/check-attr}}\n      {{#check-attr}}{{else}}{{/check-attr}}"]);

    _templateObject40 = function () {
      return data;
    };

    return data;
  }

  function _templateObject39() {
    const data = _taggedTemplateLiteralLoose(["\n      {{check-attr}}\n      {{#check-attr}}{{/check-attr}}"]);

    _templateObject39 = function () {
      return data;
    };

    return data;
  }

  function _templateObject38() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#check-params}}{{/check-params}}\n      {{#check-params as |foo|}}{{/check-params}}"]);

    _templateObject38 = function () {
      return data;
    };

    return data;
  }

  function _templateObject37() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#if hasBlockParams}}\n          Yes\n        {{else}}\n          No\n        {{/if}}"]);

    _templateObject37 = function () {
      return data;
    };

    return data;
  }

  function _templateObject36() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#check-params}}{{/check-params}}\n      {{#check-params as |foo|}}{{/check-params}}"]);

    _templateObject36 = function () {
      return data;
    };

    return data;
  }

  function _templateObject35() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#if (hasBlockParams)}}\n          Yes\n        {{else}}\n          No\n        {{/if}}"]);

    _templateObject35 = function () {
      return data;
    };

    return data;
  }

  function _templateObject34() {
    const data = _taggedTemplateLiteralLoose(["\n      {{check-block}}\n      {{#check-block}}{{/check-block}}"]);

    _templateObject34 = function () {
      return data;
    };

    return data;
  }

  function _templateObject33() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#if hasBlock}}\n          Yes\n        {{else}}\n          No\n        {{/if}}"]);

    _templateObject33 = function () {
      return data;
    };

    return data;
  }

  function _templateObject32() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#check-block}}{{/check-block}}\n      {{#check-block as |something|}}{{/check-block}}"]);

    _templateObject32 = function () {
      return data;
    };

    return data;
  }

  function _templateObject31() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#if (hasBlockParams)}}\n          Yes\n        {{else}}\n          No\n        {{/if}}"]);

    _templateObject31 = function () {
      return data;
    };

    return data;
  }

  function _templateObject30() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#check-inverse}}{{/check-inverse}}\n      {{#check-inverse as |something|}}{{/check-inverse}}"]);

    _templateObject30 = function () {
      return data;
    };

    return data;
  }

  function _templateObject29() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#if (hasBlockParams \"inverse\")}}\n          Yes\n        {{else}}\n          No\n        {{/if}}"]);

    _templateObject29 = function () {
      return data;
    };

    return data;
  }

  function _templateObject28() {
    const data = _taggedTemplateLiteralLoose(["\n      {{check-block}}\n      {{#check-block}}{{/check-block}}"]);

    _templateObject28 = function () {
      return data;
    };

    return data;
  }

  function _templateObject27() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#if (hasBlock)}}\n          Yes\n        {{else}}\n          No\n        {{/if}}"]);

    _templateObject27 = function () {
      return data;
    };

    return data;
  }

  function _templateObject26() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#check-inverse}}{{/check-inverse}}\n      {{#check-inverse}}{{else}}{{/check-inverse}}"]);

    _templateObject26 = function () {
      return data;
    };

    return data;
  }

  function _templateObject25() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#if (hasBlock \"inverse\")}}\n          Yes\n        {{else}}\n          No\n        {{/if}}"]);

    _templateObject25 = function () {
      return data;
    };

    return data;
  }

  function _templateObject24() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#my-if predicate=activated someValue=42 as |result|}}\n        Hello{{result}}\n      {{else}}\n        Goodbye\n      {{/my-if}}"]);

    _templateObject24 = function () {
      return data;
    };

    return data;
  }

  function _templateObject23() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#if predicate}}\n          Yes:{{yield someValue}}\n        {{else}}\n          No:{{yield to=\"inverse\"}}\n        {{/if}}"]);

    _templateObject23 = function () {
      return data;
    };

    return data;
  }

  function _templateObject22() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with-block}}\n        In block\n      {{/with-block}}"]);

    _templateObject22 = function () {
      return data;
    };

    return data;
  }

  function _templateObject21() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#if hasBlockParams}}\n          {{yield this}}\n        {{else}}\n          {{yield}} No Block Param!\n        {{/if}}"]);

    _templateObject21 = function () {
      return data;
    };

    return data;
  }

  function _templateObject20() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with-block as |something|}}\n        In template\n      {{/with-block}}"]);

    _templateObject20 = function () {
      return data;
    };

    return data;
  }

  function _templateObject19() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#if hasBlockParams}}\n          {{yield this}} - In Component\n        {{else}}\n          {{yield}} No Block!\n        {{/if}}"]);

    _templateObject19 = function () {
      return data;
    };

    return data;
  }

  function _templateObject18() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#if hasBlock}}\n          {{yield}}\n        {{else}}\n          No Block!\n        {{/if}}"]);

    _templateObject18 = function () {
      return data;
    };

    return data;
  }

  function _templateObject17() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with-block}}\n        In template\n      {{/with-block}}"]);

    _templateObject17 = function () {
      return data;
    };

    return data;
  }

  function _templateObject16() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#if hasBlock}}\n          {{yield}}\n        {{else}}\n          No Block!\n        {{/if}}"]);

    _templateObject16 = function () {
      return data;
    };

    return data;
  }

  function _templateObject15() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with-template name=\"with-block\"}}\n        [In block - {{name}}]\n      {{/with-template}}\n      {{with-template name=\"without-block\"}}"]);

    _templateObject15 = function () {
      return data;
    };

    return data;
  }

  function _templateObject14() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#each n as |name|}}\n          {{name}}\n        {{/each}}"]);

    _templateObject14 = function () {
      return data;
    };

    return data;
  }

  function _templateObject13() {
    const data = _taggedTemplateLiteralLoose(["\n      {{sample-component \"one\" \"two\" elementId=\"two-positional\"}}\n      {{sample-component \"one\" second=\"two\" elementId=\"one-positional\"}}\n      {{sample-component first=\"one\" second=\"two\" elementId=\"no-positional\"}}"]);

    _templateObject13 = function () {
      return data;
    };

    return data;
  }

  function _templateObject12() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#each names as |name|}}\n          {{name}}\n        {{/each}}"]);

    _templateObject12 = function () {
      return data;
    };

    return data;
  }

  function _templateObject11() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#each names as |name|}}\n          {{name}}\n        {{/each}}"]);

    _templateObject11 = function () {
      return data;
    };

    return data;
  }

  function _templateObject10() {
    const data = _taggedTemplateLiteralLoose(["\n      {{sample-component \"Foo\" 4 \"Bar\" elementId=\"args-3\"}}\n      {{sample-component \"Foo\" 4 \"Bar\" 5 \"Baz\" elementId=\"args-5\"}}"]);

    _templateObject10 = function () {
      return data;
    };

    return data;
  }

  function _templateObject9() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#each names as |name|}}\n          {{name}}\n        {{/each}}"]);

    _templateObject9 = function () {
      return data;
    };

    return data;
  }

  function _templateObject8() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with-block someProp=prop}}\n        In template\n      {{/with-block}}"]);

    _templateObject8 = function () {
      return data;
    };

    return data;
  }

  function _templateObject7() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with-block someProp=prop}}\n        In template\n      {{/with-block}}"]);

    _templateObject7 = function () {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with-block someProp=prop}}\n        In template\n      {{/with-block}}"]);

    _templateObject6 = function () {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    const data = _taggedTemplateLiteralLoose(["Args: lul | lul | lul | lul1111"]);

    _templateObject5 = function () {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    const data = _taggedTemplateLiteralLoose(["\n        Args: {{this.attrs.value}} | {{attrs.value}} | {{@value}} | {{value}}\n        {{#each this.attrs.items as |item|}}\n          {{item}}\n        {{/each}}\n        {{#each attrs.items as |item|}}\n          {{item}}\n        {{/each}}\n        {{#each @items as |item|}}\n          {{item}}\n        {{/each}}\n        {{#each items as |item|}}\n          {{item}}\n        {{/each}}\n      "]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#if isStream}}\n          true\n        {{else}}\n          false\n        {{/if}}\n      "]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#if cond1}}\n        {{#foo-bar id=1}}\n          {{#if cond2}}\n            {{#foo-bar id=2}}{{/foo-bar}}\n            {{#if cond3}}\n              {{#foo-bar id=3}}\n                {{#if cond4}}\n                  {{#foo-bar id=4}}\n                    {{#if cond5}}\n                      {{#foo-bar id=5}}{{/foo-bar}}\n                      {{#foo-bar id=6}}{{/foo-bar}}\n                      {{#foo-bar id=7}}{{/foo-bar}}\n                    {{/if}}\n                    {{#foo-bar id=8}}{{/foo-bar}}\n                  {{/foo-bar}}\n                {{/if}}\n              {{/foo-bar}}\n            {{/if}}\n          {{/if}}\n        {{/foo-bar}}\n      {{/if}}"]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      {{foo-bar class=\"bar baz\"}}\n      {{foo-bar classNames=\"bar baz\"}}\n      {{foo-bar}}\n    "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('Components test: curly components',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test it can render a basic component'] = function testItCanRenderABasicComponent() {
      var _this = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    };

    _proto['@test it can have a custom id and it is not bound'] = function testItCanHaveACustomIdAndItIsNotBound() {
      var _this2 = this;

      this.registerComponent('foo-bar', {
        template: '{{id}} {{elementId}}'
      });
      this.render('{{foo-bar id=customId}}', {
        customId: 'bizz'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'bizz bizz'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'bizz bizz'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'customId', 'bar');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'bar bizz'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'customId', 'bizz');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'bizz'
        },
        content: 'bizz bizz'
      });
    };

    _proto['@test elementId cannot change'] = function testElementIdCannotChange(assert) {
      var component;

      var FooBarComponent = _helpers.Component.extend({
        elementId: 'blahzorz',
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{elementId}}'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'blahzorz'
        },
        content: 'blahzorz'
      });

      if (EmberDev && !EmberDev.runningProdBuild) {
        var willThrow = function () {
          return (0, _runloop.run)(null, _metal.set, component, 'elementId', 'herpyderpy');
        };

        assert.throws(willThrow, /Changing a view's elementId after creation is not allowed/);
        this.assertComponentElement(this.firstChild, {
          tagName: 'div',
          attrs: {
            id: 'blahzorz'
          },
          content: 'blahzorz'
        });
      }
    };

    _proto['@test can specify template with `layoutName` property'] = function testCanSpecifyTemplateWithLayoutNameProperty() {
      var FooBarComponent = _helpers.Component.extend({
        elementId: 'blahzorz',
        layoutName: 'fizz-bar',
        init: function () {
          this._super.apply(this, arguments);

          this.local = 'hey';
        }
      });

      this.registerTemplate('fizz-bar', "FIZZ BAR {{local}}");
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render('{{foo-bar}}');
      this.assertText('FIZZ BAR hey');
    };

    _proto['@test layout supports computed property'] = function testLayoutSupportsComputedProperty() {
      var FooBarComponent = _helpers.Component.extend({
        elementId: 'blahzorz',
        layout: (0, _metal.computed)(function () {
          return (0, _helpers.compile)('so much layout wat {{lulz}}');
        }),
        init: function () {
          this._super.apply(this, arguments);

          this.lulz = 'heyo';
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render('{{foo-bar}}');
      this.assertText('so much layout wat heyo');
    };

    _proto['@test passing undefined elementId results in a default elementId'] = function testPassingUndefinedElementIdResultsInADefaultElementId(assert) {
      var _this3 = this;

      var FooBarComponent = _helpers.Component.extend({
        tagName: 'h1'
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'something'
      });
      this.render('{{foo-bar id=somethingUndefined}}');
      var foundId = this.$('h1').attr('id');
      assert.ok(/^ember/.test(foundId), 'Has a reasonable id attribute (found id=' + foundId + ').');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      var newFoundId = this.$('h1').attr('id');
      assert.ok(/^ember/.test(newFoundId), 'Has a reasonable id attribute (found id=' + newFoundId + ').');
      assert.equal(foundId, newFoundId);
    };

    _proto['@test id is an alias for elementId'] = function testIdIsAnAliasForElementId(assert) {
      var _this4 = this;

      var FooBarComponent = _helpers.Component.extend({
        tagName: 'h1'
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'something'
      });
      this.render('{{foo-bar id="custom-id"}}');
      var foundId = this.$('h1').attr('id');
      assert.equal(foundId, 'custom-id');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      var newFoundId = this.$('h1').attr('id');
      assert.equal(newFoundId, 'custom-id');
      assert.equal(foundId, newFoundId);
    };

    _proto['@test cannot pass both id and elementId at the same time'] = function testCannotPassBothIdAndElementIdAtTheSameTime() {
      var _this5 = this;

      this.registerComponent('foo-bar', {
        template: ''
      });
      expectAssertion(function () {
        _this5.render('{{foo-bar id="zomg" elementId="lol"}}');
      }, /You cannot invoke a component with both 'id' and 'elementId' at the same time./);
    };

    _proto['@test it can have a custom tagName'] = function testItCanHaveACustomTagName() {
      var _this6 = this;

      var FooBarComponent = _helpers.Component.extend({
        tagName: 'foo-bar'
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
    };

    _proto['@test it can have a custom tagName set in the constructor'] = function testItCanHaveACustomTagNameSetInTheConstructor() {
      var _this7 = this;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          this.tagName = 'foo-bar';
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
    };

    _proto['@test it can have a custom tagName from the invocation'] = function testItCanHaveACustomTagNameFromTheInvocation() {
      var _this8 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar tagName="foo-bar"}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'foo-bar',
        content: 'hello'
      });
    };

    _proto['@test tagName can not be a computed property'] = function testTagNameCanNotBeAComputedProperty() {
      var _this9 = this;

      var FooBarComponent = _helpers.Component.extend({
        tagName: (0, _metal.computed)(function () {
          return 'foo-bar';
        })
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      expectAssertion(function () {
        _this9.render('{{foo-bar}}');
      }, /You cannot use a computed property for the component's `tagName` \(<.+?>\)\./);
    };

    _proto['@test class is applied before didInsertElement'] = function testClassIsAppliedBeforeDidInsertElement(assert) {
      var componentClass;

      var FooBarComponent = _helpers.Component.extend({
        didInsertElement: function () {
          componentClass = this.element.className;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar class="foo-bar"}}');
      assert.equal(componentClass, 'foo-bar ember-view');
    };

    _proto['@test it can have custom classNames'] = function testItCanHaveCustomClassNames() {
      var _this10 = this;

      var FooBarComponent = _helpers.Component.extend({
        classNames: ['foo', 'bar']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar')
        },
        content: 'hello'
      });
    };

    _proto['@test should not apply falsy class name'] = function testShouldNotApplyFalsyClassName() {
      var _this11 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar class=somethingFalsy}}', {
        somethingFalsy: false
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: 'ember-view'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this11.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: 'ember-view'
        },
        content: 'hello'
      });
    };

    _proto['@test should update class using inline if, initially false, no alternate'] = function testShouldUpdateClassUsingInlineIfInitiallyFalseNoAlternate() {
      var _this12 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar class=(if predicate "thing") }}', {
        predicate: false
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: 'ember-view'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'predicate', true);
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view thing')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'predicate', false);
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: 'ember-view'
        },
        content: 'hello'
      });
    };

    _proto['@test should update class using inline if, initially true, no alternate'] = function testShouldUpdateClassUsingInlineIfInitiallyTrueNoAlternate() {
      var _this13 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar class=(if predicate "thing") }}', {
        predicate: true
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view thing')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'predicate', false);
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this13.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: 'ember-view'
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'predicate', true);
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this13.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view thing')
        },
        content: 'hello'
      });
    };

    _proto['@test should apply classes of the dasherized property name when bound property specified is true'] = function testShouldApplyClassesOfTheDasherizedPropertyNameWhenBoundPropertySpecifiedIsTrue() {
      var _this14 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar class=model.someTruth}}', {
        model: {
          someTruth: true
        }
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view some-truth')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this14.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view some-truth')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'model.someTruth', false);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'model', {
          someTruth: true
        });
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view some-truth')
        },
        content: 'hello'
      });
    };

    _proto['@test class property on components can be dynamic'] = function testClassPropertyOnComponentsCanBeDynamic() {
      var _this15 = this;

      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar class=(if fooBar "foo-bar")}}', {
        fooBar: true
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this15.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'fooBar', false);
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'fooBar', true);
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo-bar')
        }
      });
    };

    _proto['@test it can have custom classNames from constructor'] = function testItCanHaveCustomClassNamesFromConstructor() {
      var _this16 = this;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          this.classNames = this.classNames.slice();
          this.classNames.push('foo', 'bar', "outside-" + this.get('extraClass'));
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar extraClass="baz"}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar outside-baz')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this16.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar outside-baz')
        },
        content: 'hello'
      });
    };

    _proto['@test it can set custom classNames from the invocation'] = function testItCanSetCustomClassNamesFromTheInvocation() {
      var _this17 = this;

      var FooBarComponent = _helpers.Component.extend({
        classNames: ['foo']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject()));
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar baz')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar baz')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this17.rerender();
      });
      this.assertComponentElement(this.nthChild(0), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar baz')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(1), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo bar baz')
        },
        content: 'hello'
      });
      this.assertComponentElement(this.nthChild(2), {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view foo')
        },
        content: 'hello'
      });
    };

    _proto['@test it has an element'] = function testItHasAnElement() {
      var _this18 = this;

      var instance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          instance = this;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{foo-bar}}');
      var element1 = instance.element;
      this.assertComponentElement(element1, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.rerender();
      });
      var element2 = instance.element;
      this.assertComponentElement(element2, {
        content: 'hello'
      });
      this.assertSameNode(element2, element1);
    };

    _proto['@test an empty component does not have childNodes'] = function testAnEmptyComponentDoesNotHaveChildNodes(assert) {
      var _this19 = this;

      var fooBarInstance;

      var FooBarComponent = _helpers.Component.extend({
        tagName: 'input',
        init: function () {
          this._super();

          fooBarInstance = this;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: ''
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        tagName: 'input'
      });
      assert.strictEqual(fooBarInstance.element.childNodes.length, 0);
      (0, _internalTestHelpers.runTask)(function () {
        return _this19.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'input'
      });
      assert.strictEqual(fooBarInstance.element.childNodes.length, 0);
    };

    _proto['@test it has the right parentView and childViews'] = function testItHasTheRightParentViewAndChildViews(assert) {
      var _this20 = this;

      var fooBarInstance, fooBarBazInstance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          fooBarInstance = this;
        }
      });

      var FooBarBazComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          fooBarBazInstance = this;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'foo-bar {{foo-bar-baz}}'
      });
      this.registerComponent('foo-bar-baz', {
        ComponentClass: FooBarBazComponent,
        template: 'foo-bar-baz'
      });
      this.render('{{foo-bar}}');
      this.assertText('foo-bar foo-bar-baz');
      assert.equal(fooBarInstance.parentView, this.component);
      assert.equal(fooBarBazInstance.parentView, fooBarInstance);
      assert.deepEqual(this.component.childViews, [fooBarInstance]);
      assert.deepEqual(fooBarInstance.childViews, [fooBarBazInstance]);
      (0, _internalTestHelpers.runTask)(function () {
        return _this20.rerender();
      });
      this.assertText('foo-bar foo-bar-baz');
      assert.equal(fooBarInstance.parentView, this.component);
      assert.equal(fooBarBazInstance.parentView, fooBarInstance);
      assert.deepEqual(this.component.childViews, [fooBarInstance]);
      assert.deepEqual(fooBarInstance.childViews, [fooBarBazInstance]);
    };

    _proto['@test it renders passed named arguments'] = function testItRendersPassedNamedArguments() {
      var _this21 = this;

      this.registerComponent('foo-bar', {
        template: '{{@foo}}'
      });
      this.render('{{foo-bar foo=model.bar}}', {
        model: {
          bar: 'Hola'
        }
      });
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(function () {
        return _this21.rerender();
      });
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(function () {
        return _this21.context.set('model.bar', 'Hello');
      });
      this.assertText('Hello');
      (0, _internalTestHelpers.runTask)(function () {
        return _this21.context.set('model', {
          bar: 'Hola'
        });
      });
      this.assertText('Hola');
    };

    _proto['@test it reflects named arguments as properties'] = function testItReflectsNamedArgumentsAsProperties() {
      var _this22 = this;

      this.registerComponent('foo-bar', {
        template: '{{foo}}'
      });
      this.render('{{foo-bar foo=model.bar}}', {
        model: {
          bar: 'Hola'
        }
      });
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(function () {
        return _this22.rerender();
      });
      this.assertText('Hola');
      (0, _internalTestHelpers.runTask)(function () {
        return _this22.context.set('model.bar', 'Hello');
      });
      this.assertText('Hello');
      (0, _internalTestHelpers.runTask)(function () {
        return _this22.context.set('model', {
          bar: 'Hola'
        });
      });
      this.assertText('Hola');
    };

    _proto['@test it can render a basic component with a block'] = function testItCanRenderABasicComponentWithABlock() {
      var _this23 = this;

      this.registerComponent('foo-bar', {
        template: '{{yield}} - In component'
      });
      this.render('{{#foo-bar}}hello{{/foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        content: 'hello - In component'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this23.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello - In component'
      });
    };

    _proto['@test it can render a basic component with a block when the yield is in a partial'] = function testItCanRenderABasicComponentWithABlockWhenTheYieldIsInAPartial() {
      var _this24 = this;

      this.registerPartial('_partialWithYield', 'yielded: [{{yield}}]');
      this.registerComponent('foo-bar', {
        template: '{{partial "partialWithYield"}} - In component'
      });
      this.render('{{#foo-bar}}hello{{/foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        content: 'yielded: [hello] - In component'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this24.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'yielded: [hello] - In component'
      });
    };

    _proto['@test it can render a basic component with a block param when the yield is in a partial'] = function testItCanRenderABasicComponentWithABlockParamWhenTheYieldIsInAPartial() {
      var _this25 = this;

      this.registerPartial('_partialWithYield', 'yielded: [{{yield "hello"}}]');
      this.registerComponent('foo-bar', {
        template: '{{partial "partialWithYield"}} - In component'
      });
      this.render('{{#foo-bar as |value|}}{{value}}{{/foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        content: 'yielded: [hello] - In component'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this25.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'yielded: [hello] - In component'
      });
    };

    _proto['@test it renders the layout with the component instance as the context'] = function testItRendersTheLayoutWithTheComponentInstanceAsTheContext() {
      var _this26 = this;

      var instance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          instance = this;
          this.set('message', 'hello');
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{message}}'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this26.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(instance, 'message', 'goodbye');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'goodbye'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(instance, 'message', 'hello');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    };

    _proto['@test it preserves the outer context when yielding'] = function testItPreservesTheOuterContextWhenYielding() {
      var _this27 = this;

      this.registerComponent('foo-bar', {
        template: '{{yield}}'
      });
      this.render('{{#foo-bar}}{{message}}{{/foo-bar}}', {
        message: 'hello'
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this27.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this27.context, 'message', 'goodbye');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'goodbye'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this27.context, 'message', 'hello');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    };

    _proto['@test it can yield a block param named for reserved words [GH#14096]'] = function testItCanYieldABlockParamNamedForReservedWordsGH14096() {
      var instance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          instance = this;
        },
        name: 'foo-bar'
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{yield this}}'
      });
      this.render('{{#foo-bar as |component|}}{{component.name}}{{/foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        content: 'foo-bar'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(instance, 'name', 'derp-qux');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'derp-qux'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(instance, 'name', 'foo-bar');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'foo-bar'
      });
    };

    _proto['@test it can yield internal and external properties positionally'] = function testItCanYieldInternalAndExternalPropertiesPositionally() {
      var _this28 = this;

      var instance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          instance = this;
        },
        greeting: 'hello'
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{yield greeting greetee.firstName}}'
      });
      this.render('{{#foo-bar greetee=person as |greeting name|}}{{name}} {{person.lastName}}, {{greeting}}{{/foo-bar}}', {
        person: {
          firstName: 'Joel',
          lastName: 'Kang'
        }
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Joel Kang, hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this28.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Joel Kang, hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this28.context, 'person', {
          firstName: 'Dora',
          lastName: 'the Explorer'
        });
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Dora the Explorer, hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(instance, 'greeting', 'hola');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Dora the Explorer, hola'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(instance, 'greeting', 'hello');
        (0, _metal.set)(_this28.context, 'person', {
          firstName: 'Joel',
          lastName: 'Kang'
        });
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Joel Kang, hello'
      });
    };

    _proto['@test #11519 - block param infinite loop'] = function test11519BlockParamInfiniteLoop() {
      var _this29 = this;

      var instance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          instance = this;
        },
        danger: 0
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{danger}}{{yield danger}}'
      }); // On initial render, create streams. The bug will not have manifested yet, but at this point
      // we have created streams that create a circular invalidation.

      this.render("{{#foo-bar as |dangerBlockParam|}}{{/foo-bar}}");
      this.assertText('0'); // Trigger a non-revalidating re-render. The yielded block will not be dirtied
      // nor will block param streams, and thus no infinite loop will occur.

      (0, _internalTestHelpers.runTask)(function () {
        return _this29.rerender();
      });
      this.assertText('0'); // Trigger a revalidation, which will cause an infinite loop without the fix
      // in place.  Note that we do not see the infinite loop is in testing mode,
      // because a deprecation warning about re-renders is issued, which Ember
      // treats as an exception.

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(instance, 'danger', 1);
      });
      this.assertText('1');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(instance, 'danger', 0);
      });
      this.assertText('0');
    };

    _proto['@test the component and its child components are destroyed'] = function testTheComponentAndItsChildComponentsAreDestroyed(assert) {
      var _this30 = this;

      var destroyed = {
        1: 0,
        2: 0,
        3: 0,
        4: 0,
        5: 0,
        6: 0,
        7: 0,
        8: 0
      };
      this.registerComponent('foo-bar', {
        template: '{{id}} {{yield}}',
        ComponentClass: _helpers.Component.extend({
          willDestroy: function () {
            this._super();

            destroyed[this.get('id')]++;
          }
        })
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject2()), {
        cond1: true,
        cond2: true,
        cond3: true,
        cond4: true,
        cond5: true
      });
      this.assertText('1 2 3 4 5 6 7 8 ');
      (0, _internalTestHelpers.runTask)(function () {
        return _this30.rerender();
      });
      assert.deepEqual(destroyed, {
        1: 0,
        2: 0,
        3: 0,
        4: 0,
        5: 0,
        6: 0,
        7: 0,
        8: 0
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this30.context, 'cond5', false);
      });
      this.assertText('1 2 3 4 8 ');
      assert.deepEqual(destroyed, {
        1: 0,
        2: 0,
        3: 0,
        4: 0,
        5: 1,
        6: 1,
        7: 1,
        8: 0
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this30.context, 'cond3', false);
        (0, _metal.set)(_this30.context, 'cond5', true);
        (0, _metal.set)(_this30.context, 'cond4', false);
      });
      assert.deepEqual(destroyed, {
        1: 0,
        2: 0,
        3: 1,
        4: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this30.context, 'cond2', false);
        (0, _metal.set)(_this30.context, 'cond1', false);
      });
      assert.deepEqual(destroyed, {
        1: 1,
        2: 1,
        3: 1,
        4: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1
      });
    };

    _proto['@test should escape HTML in normal mustaches'] = function testShouldEscapeHTMLInNormalMustaches() {
      var _this31 = this;

      var component;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        output: 'you need to be more <b>bold</b>'
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{output}}'
      });
      this.render('{{foo-bar}}');
      this.assertText('you need to be more <b>bold</b>');
      (0, _internalTestHelpers.runTask)(function () {
        return _this31.rerender();
      });
      this.assertText('you need to be more <b>bold</b>');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(component, 'output', 'you are so <i>super</i>');
      });
      this.assertText('you are so <i>super</i>');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(component, 'output', 'you need to be more <b>bold</b>');
      });
    };

    _proto['@test should not escape HTML in triple mustaches'] = function testShouldNotEscapeHTMLInTripleMustaches() {
      var _this32 = this;

      var expectedHtmlBold = 'you need to be more <b>bold</b>';
      var expectedHtmlItalic = 'you are so <i>super</i>';
      var component;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        output: expectedHtmlBold
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{{output}}}'
      });
      this.render('{{foo-bar}}');
      (0, _internalTestHelpers.equalTokens)(this.firstChild, expectedHtmlBold);
      (0, _internalTestHelpers.runTask)(function () {
        return _this32.rerender();
      });
      (0, _internalTestHelpers.equalTokens)(this.firstChild, expectedHtmlBold);
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(component, 'output', expectedHtmlItalic);
      });
      (0, _internalTestHelpers.equalTokens)(this.firstChild, expectedHtmlItalic);
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(component, 'output', expectedHtmlBold);
      });
      (0, _internalTestHelpers.equalTokens)(this.firstChild, expectedHtmlBold);
    };

    _proto['@test should not escape HTML if string is a htmlSafe'] = function testShouldNotEscapeHTMLIfStringIsAHtmlSafe() {
      var _this33 = this;

      var expectedHtmlBold = 'you need to be more <b>bold</b>';
      var expectedHtmlItalic = 'you are so <i>super</i>';
      var component;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        output: (0, _helpers.htmlSafe)(expectedHtmlBold)
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{output}}'
      });
      this.render('{{foo-bar}}');
      (0, _internalTestHelpers.equalTokens)(this.firstChild, expectedHtmlBold);
      (0, _internalTestHelpers.runTask)(function () {
        return _this33.rerender();
      });
      (0, _internalTestHelpers.equalTokens)(this.firstChild, expectedHtmlBold);
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(component, 'output', (0, _helpers.htmlSafe)(expectedHtmlItalic));
      });
      (0, _internalTestHelpers.equalTokens)(this.firstChild, expectedHtmlItalic);
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(component, 'output', (0, _helpers.htmlSafe)(expectedHtmlBold));
      });
      (0, _internalTestHelpers.equalTokens)(this.firstChild, expectedHtmlBold);
    };

    _proto['@test late bound layouts return the same definition'] = function testLateBoundLayoutsReturnTheSameDefinition(assert) {
      var templateIds = []; // This is testing the scenario where you import a template and
      // set it to the layout property:
      //
      // import Component from '@ember/component';
      // import layout from './template';
      //
      // export default Component.extend({
      //   layout
      // });

      var hello = (0, _helpers.compile)('Hello');
      var bye = (0, _helpers.compile)('Bye');

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.layout = this.cond ? hello : bye;
          templateIds.push(this.layout.id);
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render('{{foo-bar cond=true}}{{foo-bar cond=false}}{{foo-bar cond=true}}{{foo-bar cond=false}}');
      var t1 = templateIds[0],
          t2 = templateIds[1],
          t3 = templateIds[2],
          t4 = templateIds[3];
      assert.equal(t1, t3);
      assert.equal(t2, t4);
    };

    _proto['@test can use isStream property without conflict (#13271)'] = function testCanUseIsStreamPropertyWithoutConflict13271() {
      var _this34 = this;

      var component;

      var FooBarComponent = _helpers.Component.extend({
        isStream: true,
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject3())
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        content: 'true'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this34.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'true'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(component, 'isStream', false);
      });
      this.assertComponentElement(this.firstChild, {
        content: 'false'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(component, 'isStream', true);
      });
      this.assertComponentElement(this.firstChild, {
        content: 'true'
      });
    };

    _proto['@test lookup of component takes priority over property'] = function testLookupOfComponentTakesPriorityOverProperty() {
      var _this35 = this;

      this.registerComponent('some-component', {
        template: 'some-component'
      });
      this.render('{{some-prop}} {{some-component}}', {
        'some-component': 'not-some-component',
        'some-prop': 'some-prop'
      });
      this.assertText('some-prop some-component');
      (0, _internalTestHelpers.runTask)(function () {
        return _this35.rerender();
      });
      this.assertText('some-prop some-component');
    };

    _proto['@feature(ember-glimmer-angle-bracket-built-ins) component without dash is looked up'] = function featureEmberGlimmerAngleBracketBuiltInsComponentWithoutDashIsLookedUp() {
      var _this36 = this;

      this.registerComponent('somecomponent', {
        template: 'somecomponent'
      });
      this.render('{{somecomponent}}', {
        somecomponent: 'notsomecomponent'
      });
      this.assertText('somecomponent');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this36.context.set('somecomponent', 'not not notsomecomponent');
      });
      this.assertText('somecomponent');
      (0, _internalTestHelpers.runTask)(function () {
        return _this36.context.set('somecomponent', 'notsomecomponent');
      });
      this.assertText('somecomponent');
    };

    _proto['@feature(!ember-glimmer-angle-bracket-built-ins) component without dash is not looked up'] = function featureEmberGlimmerAngleBracketBuiltInsComponentWithoutDashIsNotLookedUp() {
      var _this37 = this;

      this.registerComponent('somecomponent', {
        template: 'somecomponent'
      });
      this.render('{{somecomponent}}', {
        somecomponent: 'notsomecomponent'
      });
      this.assertText('notsomecomponent');
      (0, _internalTestHelpers.runTask)(function () {
        return _this37.rerender();
      });
      this.assertText('notsomecomponent');
      (0, _internalTestHelpers.runTask)(function () {
        return _this37.context.set('somecomponent', 'not not notsomecomponent');
      });
      this.assertText('not not notsomecomponent');
      (0, _internalTestHelpers.runTask)(function () {
        return _this37.context.set('somecomponent', 'notsomecomponent');
      });
      this.assertText('notsomecomponent');
    };

    _proto['@test non-block with properties on attrs'] = function testNonBlockWithPropertiesOnAttrs() {
      var _this38 = this;

      this.registerComponent('non-block', {
        template: 'In layout - someProp: {{attrs.someProp}}'
      });
      this.render('{{non-block someProp=prop}}', {
        prop: 'something here'
      });
      this.assertText('In layout - someProp: something here');
      (0, _internalTestHelpers.runTask)(function () {
        return _this38.rerender();
      });
      this.assertText('In layout - someProp: something here');
      (0, _internalTestHelpers.runTask)(function () {
        return _this38.context.set('prop', 'other thing there');
      });
      this.assertText('In layout - someProp: other thing there');
      (0, _internalTestHelpers.runTask)(function () {
        return _this38.context.set('prop', 'something here');
      });
      this.assertText('In layout - someProp: something here');
    };

    _proto['@test non-block with named argument'] = function testNonBlockWithNamedArgument() {
      var _this39 = this;

      this.registerComponent('non-block', {
        template: 'In layout - someProp: {{@someProp}}'
      });
      this.render('{{non-block someProp=prop}}', {
        prop: 'something here'
      });
      this.assertText('In layout - someProp: something here');
      (0, _internalTestHelpers.runTask)(function () {
        return _this39.rerender();
      });
      this.assertText('In layout - someProp: something here');
      (0, _internalTestHelpers.runTask)(function () {
        return _this39.context.set('prop', 'other thing there');
      });
      this.assertText('In layout - someProp: other thing there');
      (0, _internalTestHelpers.runTask)(function () {
        return _this39.context.set('prop', 'something here');
      });
      this.assertText('In layout - someProp: something here');
    };

    _proto['@test non-block with properties overridden in init'] = function testNonBlockWithPropertiesOverriddenInInit() {
      var _this40 = this;

      var instance;
      this.registerComponent('non-block', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            instance = this;
            this.someProp = 'value set in instance';
          }
        }),
        template: 'In layout - someProp: {{someProp}}'
      });
      this.render('{{non-block someProp=prop}}', {
        prop: 'something passed when invoked'
      });
      this.assertText('In layout - someProp: value set in instance');
      (0, _internalTestHelpers.runTask)(function () {
        return _this40.rerender();
      });
      this.assertText('In layout - someProp: value set in instance');
      (0, _internalTestHelpers.runTask)(function () {
        return _this40.context.set('prop', 'updated something passed when invoked');
      });
      this.assertText('In layout - someProp: updated something passed when invoked');
      (0, _internalTestHelpers.runTask)(function () {
        return instance.set('someProp', 'update value set in instance');
      });
      this.assertText('In layout - someProp: update value set in instance');
      (0, _internalTestHelpers.runTask)(function () {
        return _this40.context.set('prop', 'something passed when invoked');
      });
      (0, _internalTestHelpers.runTask)(function () {
        return instance.set('someProp', 'value set in instance');
      });
      this.assertText('In layout - someProp: value set in instance');
    };

    _proto['@test rerendering component with attrs from parent'] = function testRerenderingComponentWithAttrsFromParent(assert) {
      var _this41 = this;

      var willUpdateCount = 0;
      var didReceiveAttrsCount = 0;

      function expectHooks(_ref, callback) {
        var willUpdate = _ref.willUpdate,
            didReceiveAttrs = _ref.didReceiveAttrs;
        willUpdateCount = 0;
        didReceiveAttrsCount = 0;
        callback();

        if (willUpdate) {
          assert.strictEqual(willUpdateCount, 1, 'The willUpdate hook was fired');
        } else {
          assert.strictEqual(willUpdateCount, 0, 'The willUpdate hook was not fired');
        }

        if (didReceiveAttrs) {
          assert.strictEqual(didReceiveAttrsCount, 1, 'The didReceiveAttrs hook was fired');
        } else {
          assert.strictEqual(didReceiveAttrsCount, 0, 'The didReceiveAttrs hook was not fired');
        }
      }

      this.registerComponent('non-block', {
        ComponentClass: _helpers.Component.extend({
          didReceiveAttrs: function () {
            didReceiveAttrsCount++;
          },
          willUpdate: function () {
            willUpdateCount++;
          }
        }),
        template: 'In layout - someProp: {{someProp}}'
      });
      expectHooks({
        willUpdate: false,
        didReceiveAttrs: true
      }, function () {
        _this41.render('{{non-block someProp=someProp}}', {
          someProp: 'wycats'
        });
      });
      this.assertText('In layout - someProp: wycats'); // Note: Hooks are not fired in Glimmer for idempotent re-renders

      expectHooks({
        willUpdate: false,
        didReceiveAttrs: false
      }, function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this41.rerender();
        });
      });
      this.assertText('In layout - someProp: wycats');
      expectHooks({
        willUpdate: true,
        didReceiveAttrs: true
      }, function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this41.context.set('someProp', 'tomdale');
        });
      });
      this.assertText('In layout - someProp: tomdale'); // Note: Hooks are not fired in Glimmer for idempotent re-renders

      expectHooks({
        willUpdate: false,
        didReceiveAttrs: false
      }, function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this41.rerender();
        });
      });
      this.assertText('In layout - someProp: tomdale');
      expectHooks({
        willUpdate: true,
        didReceiveAttrs: true
      }, function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this41.context.set('someProp', 'wycats');
        });
      });
      this.assertText('In layout - someProp: wycats');
    };

    _proto['@test this.attrs.foo === attrs.foo === @foo === foo'] = function testThisAttrsFooAttrsFooFooFoo() {
      var _this42 = this;

      this.registerComponent('foo-bar', {
        template: (0, _internalTestHelpers.strip)(_templateObject4())
      });
      this.render('{{foo-bar value=model.value items=model.items}}', {
        model: {
          value: 'wat',
          items: [1, 2, 3]
        }
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        _this42.context.set('model.value', 'lul');

        _this42.context.set('model.items', [1]);
      });
      this.assertText((0, _internalTestHelpers.strip)(_templateObject5()));
      (0, _internalTestHelpers.runTask)(function () {
        return _this42.context.set('model', {
          value: 'wat',
          items: [1, 2, 3]
        });
      });
      this.assertText('Args: wat | wat | wat | wat123123123123');
    };

    _proto['@test non-block with properties on self'] = function testNonBlockWithPropertiesOnSelf() {
      var _this43 = this;

      this.registerComponent('non-block', {
        template: 'In layout - someProp: {{someProp}}'
      });
      this.render('{{non-block someProp=prop}}', {
        prop: 'something here'
      });
      this.assertText('In layout - someProp: something here');
      (0, _internalTestHelpers.runTask)(function () {
        return _this43.rerender();
      });
      this.assertText('In layout - someProp: something here');
      (0, _internalTestHelpers.runTask)(function () {
        return _this43.context.set('prop', 'something else');
      });
      this.assertText('In layout - someProp: something else');
      (0, _internalTestHelpers.runTask)(function () {
        return _this43.context.set('prop', 'something here');
      });
      this.assertText('In layout - someProp: something here');
    };

    _proto['@test block with properties on self'] = function testBlockWithPropertiesOnSelf() {
      var _this44 = this;

      this.registerComponent('with-block', {
        template: 'In layout - someProp: {{someProp}} - {{yield}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject6()), {
        prop: 'something here'
      });
      this.assertText('In layout - someProp: something here - In template');
      (0, _internalTestHelpers.runTask)(function () {
        return _this44.rerender();
      });
      this.assertText('In layout - someProp: something here - In template');
      (0, _internalTestHelpers.runTask)(function () {
        return _this44.context.set('prop', 'something else');
      });
      this.assertText('In layout - someProp: something else - In template');
      (0, _internalTestHelpers.runTask)(function () {
        return _this44.context.set('prop', 'something here');
      });
      this.assertText('In layout - someProp: something here - In template');
    };

    _proto['@test block with properties on attrs'] = function testBlockWithPropertiesOnAttrs() {
      var _this45 = this;

      this.registerComponent('with-block', {
        template: 'In layout - someProp: {{attrs.someProp}} - {{yield}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject7()), {
        prop: 'something here'
      });
      this.assertText('In layout - someProp: something here - In template');
      (0, _internalTestHelpers.runTask)(function () {
        return _this45.rerender();
      });
      this.assertText('In layout - someProp: something here - In template');
      (0, _internalTestHelpers.runTask)(function () {
        return _this45.context.set('prop', 'something else');
      });
      this.assertText('In layout - someProp: something else - In template');
      (0, _internalTestHelpers.runTask)(function () {
        return _this45.context.set('prop', 'something here');
      });
      this.assertText('In layout - someProp: something here - In template');
    };

    _proto['@test block with named argument'] = function testBlockWithNamedArgument() {
      var _this46 = this;

      this.registerComponent('with-block', {
        template: 'In layout - someProp: {{@someProp}} - {{yield}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject8()), {
        prop: 'something here'
      });
      this.assertText('In layout - someProp: something here - In template');
      (0, _internalTestHelpers.runTask)(function () {
        return _this46.rerender();
      });
      this.assertText('In layout - someProp: something here - In template');
      (0, _internalTestHelpers.runTask)(function () {
        return _this46.context.set('prop', 'something else');
      });
      this.assertText('In layout - someProp: something else - In template');
      (0, _internalTestHelpers.runTask)(function () {
        return _this46.context.set('prop', 'something here');
      });
      this.assertText('In layout - someProp: something here - In template');
    };

    _proto['@test static arbitrary number of positional parameters'] = function testStaticArbitraryNumberOfPositionalParameters(assert) {
      var _this47 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'names'
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject9())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject10()));
      assert.equal(this.$('#args-3').text(), 'Foo4Bar');
      assert.equal(this.$('#args-5').text(), 'Foo4Bar5Baz');
      (0, _internalTestHelpers.runTask)(function () {
        return _this47.rerender();
      });
      assert.equal(this.$('#args-3').text(), 'Foo4Bar');
      assert.equal(this.$('#args-5').text(), 'Foo4Bar5Baz');
    };

    _proto['@test arbitrary positional parameter conflict with hash parameter is reported'] = function testArbitraryPositionalParameterConflictWithHashParameterIsReported() {
      var _this48 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'names'
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject11())
      });
      expectAssertion(function () {
        _this48.render("{{sample-component \"Foo\" 4 \"Bar\" names=numbers id=\"args-3\"}}", {
          numbers: [1, 2, 3]
        });
      }, 'You cannot specify positional parameters and the hash argument `names`.');
    };

    _proto['@test can use hash parameter instead of arbitrary positional param [GH #12444]'] = function testCanUseHashParameterInsteadOfArbitraryPositionalParamGH12444() {
      var _this49 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'names'
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject12())
      });
      this.render('{{sample-component names=things}}', {
        things: (0, _runtime.A)(['Foo', 4, 'Bar'])
      });
      this.assertText('Foo4Bar');
      (0, _internalTestHelpers.runTask)(function () {
        return _this49.rerender();
      });
      this.assertText('Foo4Bar');
      (0, _internalTestHelpers.runTask)(function () {
        return _this49.context.get('things').pushObject(5);
      });
      this.assertText('Foo4Bar5');
      (0, _internalTestHelpers.runTask)(function () {
        return _this49.context.get('things').shiftObject();
      });
      this.assertText('4Bar5');
      (0, _internalTestHelpers.runTask)(function () {
        return _this49.context.get('things').clear();
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return _this49.context.set('things', (0, _runtime.A)(['Foo', 4, 'Bar']));
      });
      this.assertText('Foo4Bar');
    };

    _proto['@test can use hash parameter instead of positional param'] = function testCanUseHashParameterInsteadOfPositionalParam(assert) {
      var _this50 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['first', 'second']
        }),
        template: '{{first}} - {{second}}'
      }); // TODO: Fix when id is implemented

      this.render((0, _internalTestHelpers.strip)(_templateObject13()));
      assert.equal(this.$('#two-positional').text(), 'one - two');
      assert.equal(this.$('#one-positional').text(), 'one - two');
      assert.equal(this.$('#no-positional').text(), 'one - two');
      (0, _internalTestHelpers.runTask)(function () {
        return _this50.rerender();
      });
      assert.equal(this.$('#two-positional').text(), 'one - two');
      assert.equal(this.$('#one-positional').text(), 'one - two');
      assert.equal(this.$('#no-positional').text(), 'one - two');
    };

    _proto['@test dynamic arbitrary number of positional parameters'] = function testDynamicArbitraryNumberOfPositionalParameters() {
      var _this51 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'n'
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject14())
      });
      this.render("{{sample-component user1 user2}}", {
        user1: 'Foo',
        user2: 4
      });
      this.assertText('Foo4');
      (0, _internalTestHelpers.runTask)(function () {
        return _this51.rerender();
      });
      this.assertText('Foo4');
      (0, _internalTestHelpers.runTask)(function () {
        return _this51.context.set('user1', 'Bar');
      });
      this.assertText('Bar4');
      (0, _internalTestHelpers.runTask)(function () {
        return _this51.context.set('user2', '5');
      });
      this.assertText('Bar5');
      (0, _internalTestHelpers.runTask)(function () {
        _this51.context.set('user1', 'Foo');

        _this51.context.set('user2', 4);
      });
      this.assertText('Foo4');
    };

    _proto['@test with ariaRole specified'] = function testWithAriaRoleSpecified() {
      var _this52 = this;

      this.registerComponent('aria-test', {
        template: 'Here!'
      });
      this.render('{{aria-test ariaRole=role}}', {
        role: 'main'
      });
      this.assertComponentElement(this.firstChild, {
        attrs: {
          role: 'main'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this52.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        attrs: {
          role: 'main'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this52.context.set('role', 'input');
      });
      this.assertComponentElement(this.firstChild, {
        attrs: {
          role: 'input'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this52.context.set('role', 'main');
      });
      this.assertComponentElement(this.firstChild, {
        attrs: {
          role: 'main'
        }
      });
    };

    _proto['@test with ariaRole defined but initially falsey GH#16379'] = function testWithAriaRoleDefinedButInitiallyFalseyGH16379() {
      var _this53 = this;

      this.registerComponent('aria-test', {
        template: 'Here!'
      });
      this.render('{{aria-test ariaRole=role}}', {
        role: undefined
      });
      this.assertComponentElement(this.firstChild, {
        attrs: {}
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this53.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        attrs: {}
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this53.context.set('role', 'input');
      });
      this.assertComponentElement(this.firstChild, {
        attrs: {
          role: 'input'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this53.context.set('role', undefined);
      });
      this.assertComponentElement(this.firstChild, {
        attrs: {}
      });
    };

    _proto['@test without ariaRole defined initially'] = function testWithoutAriaRoleDefinedInitially() {
      var _this54 = this; // we are using the ability to lazily add a role as a sign that we are
      // doing extra work


      var instance;
      this.registerComponent('aria-test', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            instance = this;
          }
        }),
        template: 'Here!'
      });
      this.render('{{aria-test}}');
      this.assertComponentElement(this.firstChild, {
        attrs: {}
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this54.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        attrs: {}
      });
      (0, _internalTestHelpers.runTask)(function () {
        return instance.set('ariaRole', 'input');
      });
      this.assertComponentElement(this.firstChild, {
        attrs: {}
      });
    };

    _proto['@test `template` specified in component is overridden by block'] = function testTemplateSpecifiedInComponentIsOverriddenByBlock() {
      var _this55 = this;

      this.registerComponent('with-template', {
        ComponentClass: _helpers.Component.extend({
          template: (0, _helpers.compile)('Should not be used')
        }),
        template: '[In layout - {{name}}] {{yield}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject15()), {
        name: 'Whoop, whoop!'
      });
      this.assertText('[In layout - with-block] [In block - Whoop, whoop!][In layout - without-block] ');
      (0, _internalTestHelpers.runTask)(function () {
        return _this55.rerender();
      });
      this.assertText('[In layout - with-block] [In block - Whoop, whoop!][In layout - without-block] ');
      (0, _internalTestHelpers.runTask)(function () {
        return _this55.context.set('name', 'Ole, ole');
      });
      this.assertText('[In layout - with-block] [In block - Ole, ole][In layout - without-block] ');
      (0, _internalTestHelpers.runTask)(function () {
        return _this55.context.set('name', 'Whoop, whoop!');
      });
      this.assertText('[In layout - with-block] [In block - Whoop, whoop!][In layout - without-block] ');
    };

    _proto['@test hasBlock is true when block supplied'] = function testHasBlockIsTrueWhenBlockSupplied() {
      var _this56 = this;

      this.registerComponent('with-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject16())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject17()));
      this.assertText('In template');
      (0, _internalTestHelpers.runTask)(function () {
        return _this56.rerender();
      });
      this.assertText('In template');
    };

    _proto['@test hasBlock is false when no block supplied'] = function testHasBlockIsFalseWhenNoBlockSupplied() {
      var _this57 = this;

      this.registerComponent('with-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject18())
      });
      this.render('{{with-block}}');
      this.assertText('No Block!');
      (0, _internalTestHelpers.runTask)(function () {
        return _this57.rerender();
      });
      this.assertText('No Block!');
    };

    _proto['@test hasBlockParams is true when block param supplied'] = function testHasBlockParamsIsTrueWhenBlockParamSupplied() {
      var _this58 = this;

      this.registerComponent('with-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject19())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject20()));
      this.assertText('In template - In Component');
      (0, _internalTestHelpers.runTask)(function () {
        return _this58.rerender();
      });
      this.assertText('In template - In Component');
    };

    _proto['@test hasBlockParams is false when no block param supplied'] = function testHasBlockParamsIsFalseWhenNoBlockParamSupplied() {
      var _this59 = this;

      this.registerComponent('with-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject21())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject22()));
      this.assertText('In block No Block Param!');
      (0, _internalTestHelpers.runTask)(function () {
        return _this59.rerender();
      });
      this.assertText('In block No Block Param!');
    };

    _proto['@test static named positional parameters'] = function testStaticNamedPositionalParameters() {
      var _this60 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        }),
        template: '{{name}}{{age}}'
      });
      this.render('{{sample-component "Quint" 4}}');
      this.assertText('Quint4');
      (0, _internalTestHelpers.runTask)(function () {
        return _this60.rerender();
      });
      this.assertText('Quint4');
    };

    _proto['@test dynamic named positional parameters'] = function testDynamicNamedPositionalParameters() {
      var _this61 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        }),
        template: '{{name}}{{age}}'
      });
      this.render('{{sample-component myName myAge}}', {
        myName: 'Quint',
        myAge: 4
      });
      this.assertText('Quint4');
      (0, _internalTestHelpers.runTask)(function () {
        return _this61.rerender();
      });
      this.assertText('Quint4');
      (0, _internalTestHelpers.runTask)(function () {
        return _this61.context.set('myName', 'Sergio');
      });
      this.assertText('Sergio4');
      (0, _internalTestHelpers.runTask)(function () {
        return _this61.context.set('myAge', 2);
      });
      this.assertText('Sergio2');
      (0, _internalTestHelpers.runTask)(function () {
        _this61.context.set('myName', 'Quint');

        _this61.context.set('myAge', 4);
      });
      this.assertText('Quint4');
    };

    _proto['@test if a value is passed as a non-positional parameter, it raises an assertion'] = function testIfAValueIsPassedAsANonPositionalParameterItRaisesAnAssertion() {
      var _this62 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name']
        }),
        template: '{{name}}'
      });
      expectAssertion(function () {
        _this62.render('{{sample-component notMyName name=myName}}', {
          myName: 'Quint',
          notMyName: 'Sergio'
        });
      }, 'You cannot specify both a positional param (at position 0) and the hash argument `name`.');
    };

    _proto['@test yield to inverse'] = function testYieldToInverse() {
      var _this63 = this;

      this.registerComponent('my-if', {
        template: (0, _internalTestHelpers.strip)(_templateObject23())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject24()), {
        activated: true
      });
      this.assertText('Yes:Hello42');
      (0, _internalTestHelpers.runTask)(function () {
        return _this63.rerender();
      });
      this.assertText('Yes:Hello42');
      (0, _internalTestHelpers.runTask)(function () {
        return _this63.context.set('activated', false);
      });
      this.assertText('No:Goodbye');
      (0, _internalTestHelpers.runTask)(function () {
        return _this63.context.set('activated', true);
      });
      this.assertText('Yes:Hello42');
    };

    _proto['@test expression hasBlock inverse'] = function testExpressionHasBlockInverse() {
      this.registerComponent('check-inverse', {
        template: (0, _internalTestHelpers.strip)(_templateObject25())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject26()));
      this.assertComponentElement(this.firstChild, {
        content: 'No'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'Yes'
      });
      this.assertStableRerender();
    };

    _proto['@test expression hasBlock default'] = function testExpressionHasBlockDefault() {
      this.registerComponent('check-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject27())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject28()));
      this.assertComponentElement(this.firstChild, {
        content: 'No'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'Yes'
      });
      this.assertStableRerender();
    };

    _proto['@test expression hasBlockParams inverse'] = function testExpressionHasBlockParamsInverse() {
      this.registerComponent('check-inverse', {
        template: (0, _internalTestHelpers.strip)(_templateObject29())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject30()));
      this.assertComponentElement(this.firstChild, {
        content: 'No'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'No'
      });
      this.assertStableRerender();
    };

    _proto['@test expression hasBlockParams default'] = function testExpressionHasBlockParamsDefault() {
      this.registerComponent('check-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject31())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject32()));
      this.assertComponentElement(this.firstChild, {
        content: 'No'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'Yes'
      });
      this.assertStableRerender();
    };

    _proto['@test non-expression hasBlock'] = function testNonExpressionHasBlock() {
      this.registerComponent('check-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject33())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject34()));
      this.assertComponentElement(this.firstChild, {
        content: 'No'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'Yes'
      });
      this.assertStableRerender();
    };

    _proto['@test expression hasBlockParams'] = function testExpressionHasBlockParams() {
      this.registerComponent('check-params', {
        template: (0, _internalTestHelpers.strip)(_templateObject35())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject36()));
      this.assertComponentElement(this.firstChild, {
        content: 'No'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'Yes'
      });
      this.assertStableRerender();
    };

    _proto['@test non-expression hasBlockParams'] = function testNonExpressionHasBlockParams() {
      this.registerComponent('check-params', {
        template: (0, _internalTestHelpers.strip)(_templateObject37())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject38()));
      this.assertComponentElement(this.firstChild, {
        content: 'No'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'Yes'
      });
      this.assertStableRerender();
    };

    _proto['@test hasBlock expression in an attribute'] = function testHasBlockExpressionInAnAttribute(assert) {
      this.registerComponent('check-attr', {
        template: '<button name={{hasBlock}}></button>'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject39()));
      (0, _internalTestHelpers.equalsElement)(assert, this.$('button')[0], 'button', {
        name: 'false'
      }, '');
      (0, _internalTestHelpers.equalsElement)(assert, this.$('button')[1], 'button', {
        name: 'true'
      }, '');
      this.assertStableRerender();
    };

    _proto['@test hasBlock inverse expression in an attribute'] = function testHasBlockInverseExpressionInAnAttribute(assert) {
      this.registerComponent('check-attr', {
        template: '<button name={{hasBlock "inverse"}}></button>'
      }, '');
      this.render((0, _internalTestHelpers.strip)(_templateObject40()));
      (0, _internalTestHelpers.equalsElement)(assert, this.$('button')[0], 'button', {
        name: 'false'
      }, '');
      (0, _internalTestHelpers.equalsElement)(assert, this.$('button')[1], 'button', {
        name: 'true'
      }, '');
      this.assertStableRerender();
    };

    _proto['@test hasBlockParams expression in an attribute'] = function testHasBlockParamsExpressionInAnAttribute(assert) {
      this.registerComponent('check-attr', {
        template: '<button name={{hasBlockParams}}></button>'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject41()));
      (0, _internalTestHelpers.equalsElement)(assert, this.$('button')[0], 'button', {
        name: 'false'
      }, '');
      (0, _internalTestHelpers.equalsElement)(assert, this.$('button')[1], 'button', {
        name: 'true'
      }, '');
      this.assertStableRerender();
    };

    _proto['@test hasBlockParams inverse expression in an attribute'] = function testHasBlockParamsInverseExpressionInAnAttribute(assert) {
      this.registerComponent('check-attr', {
        template: '<button name={{hasBlockParams "inverse"}}></button>'
      }, '');
      this.render((0, _internalTestHelpers.strip)(_templateObject42()));
      (0, _internalTestHelpers.equalsElement)(assert, this.$('button')[0], 'button', {
        name: 'false'
      }, '');
      (0, _internalTestHelpers.equalsElement)(assert, this.$('button')[1], 'button', {
        name: 'false'
      }, '');
      this.assertStableRerender();
    };

    _proto['@test hasBlock as a param to a helper'] = function testHasBlockAsAParamToAHelper() {
      this.registerComponent('check-helper', {
        template: '{{if hasBlock "true" "false"}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject43()));
      this.assertComponentElement(this.firstChild, {
        content: 'false'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'true'
      });
      this.assertStableRerender();
    };

    _proto['@test hasBlock as an expression param to a helper'] = function testHasBlockAsAnExpressionParamToAHelper() {
      this.registerComponent('check-helper', {
        template: '{{if (hasBlock) "true" "false"}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject44()));
      this.assertComponentElement(this.firstChild, {
        content: 'false'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'true'
      });
      this.assertStableRerender();
    };

    _proto['@test hasBlock inverse as a param to a helper'] = function testHasBlockInverseAsAParamToAHelper() {
      this.registerComponent('check-helper', {
        template: '{{if (hasBlock "inverse") "true" "false"}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject45()));
      this.assertComponentElement(this.firstChild, {
        content: 'false'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'true'
      });
      this.assertStableRerender();
    };

    _proto['@test hasBlockParams as a param to a helper'] = function testHasBlockParamsAsAParamToAHelper() {
      this.registerComponent('check-helper', {
        template: '{{if hasBlockParams "true" "false"}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject46()));
      this.assertComponentElement(this.firstChild, {
        content: 'false'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'true'
      });
      this.assertStableRerender();
    };

    _proto['@test hasBlockParams as an expression param to a helper'] = function testHasBlockParamsAsAnExpressionParamToAHelper() {
      this.registerComponent('check-helper', {
        template: '{{if (hasBlockParams) "true" "false"}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject47()));
      this.assertComponentElement(this.firstChild, {
        content: 'false'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'true'
      });
      this.assertStableRerender();
    };

    _proto['@test hasBlockParams inverse as a param to a helper'] = function testHasBlockParamsInverseAsAParamToAHelper() {
      this.registerComponent('check-helper', {
        template: '{{if (hasBlockParams "inverse") "true" "false"}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject48()));
      this.assertComponentElement(this.firstChild, {
        content: 'false'
      });
      this.assertComponentElement(this.nthChild(1), {
        content: 'false'
      });
      this.assertStableRerender();
    };

    _proto['@test component in template of a yielding component should have the proper parentView'] = function testComponentInTemplateOfAYieldingComponentShouldHaveTheProperParentView(assert) {
      var _this64 = this;

      var outer, innerTemplate, innerLayout;
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            outer = this;
          }
        }),
        template: '{{x-inner-in-layout}}{{yield}}'
      });
      this.registerComponent('x-inner-in-template', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            innerTemplate = this;
          }
        })
      });
      this.registerComponent('x-inner-in-layout', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            innerLayout = this;
          }
        })
      });
      this.render('{{#x-outer}}{{x-inner-in-template}}{{/x-outer}}');
      assert.equal(innerTemplate.parentView, outer, 'receives the wrapping component as its parentView in template blocks');
      assert.equal(innerLayout.parentView, outer, 'receives the wrapping component as its parentView in layout');
      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView');
      (0, _internalTestHelpers.runTask)(function () {
        return _this64.rerender();
      });
      assert.equal(innerTemplate.parentView, outer, 'receives the wrapping component as its parentView in template blocks');
      assert.equal(innerLayout.parentView, outer, 'receives the wrapping component as its parentView in layout');
      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView');
    };

    _proto['@test newly-added sub-components get correct parentView'] = function testNewlyAddedSubComponentsGetCorrectParentView(assert) {
      var _this65 = this;

      var outer, inner;
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            outer = this;
          }
        })
      });
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            inner = this;
          }
        })
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject49()), {
        showInner: false
      });
      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView');
      (0, _internalTestHelpers.runTask)(function () {
        return _this65.rerender();
      });
      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView (after rerender)');
      (0, _internalTestHelpers.runTask)(function () {
        return _this65.context.set('showInner', true);
      });
      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView');
      assert.equal(inner.parentView, outer, 'receives the wrapping component as its parentView in template blocks');
      (0, _internalTestHelpers.runTask)(function () {
        return _this65.context.set('showInner', false);
      });
      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView');
    };

    _proto["@test when a property is changed during children's rendering"] = function testWhenAPropertyIsChangedDuringChildrenSRendering() {
      var _this66 = this;

      var middle;
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          value: 1
        }),
        template: '{{#x-middle}}{{x-inner value=value}}{{/x-middle}}'
      });
      this.registerComponent('x-middle', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            middle = this;
          },
          value: null
        }),
        template: '<div id="middle-value">{{value}}</div>{{yield}}'
      });
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          value: null,
          didReceiveAttrs: function () {
            middle.set('value', this.get('value'));
          }
        }),
        template: '<div id="inner-value">{{value}}</div>'
      });
      var expectedBacktrackingMessage = /modified "value" twice on <.+?> in a single render\. It was rendered in "component:x-middle" and modified in "component:x-inner"/;
      expectAssertion(function () {
        _this66.render('{{x-outer}}');
      }, expectedBacktrackingMessage);
    };

    _proto["@test when a shared dependency is changed during children's rendering"] = function testWhenASharedDependencyIsChangedDuringChildrenSRendering() {
      var _this67 = this;

      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          value: 1,
          wrapper: _runtime.Object.create({
            content: null
          })
        }),
        template: '<div id="outer-value">{{wrapper.content}}</div> {{x-inner value=value wrapper=wrapper}}'
      });
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          didReceiveAttrs: function () {
            this.get('wrapper').set('content', this.get('value'));
          },
          value: null
        }),
        template: '<div id="inner-value">{{wrapper.content}}</div>'
      });
      var expectedBacktrackingMessage = /modified "wrapper\.content" twice on <.+?> in a single render\. It was rendered in "component:x-outer" and modified in "component:x-inner"/;
      expectAssertion(function () {
        _this67.render('{{x-outer}}');
      }, expectedBacktrackingMessage);
    };

    _proto['@test non-block with each rendering child components'] = function testNonBlockWithEachRenderingChildComponents() {
      var _this68 = this;

      this.registerComponent('non-block', {
        template: (0, _internalTestHelpers.strip)(_templateObject50())
      });
      this.registerComponent('child-non-block', {
        template: 'Child: {{item}}.'
      });
      var items = (0, _runtime.A)(['Tom', 'Dick', 'Harry']);
      this.render('{{non-block items=items}}', {
        items: items
      });
      this.assertText('In layout. [Child: Tom.][Child: Dick.][Child: Harry.]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this68.rerender();
      });
      this.assertText('In layout. [Child: Tom.][Child: Dick.][Child: Harry.]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this68.context.get('items').pushObject('Sergio');
      });
      this.assertText('In layout. [Child: Tom.][Child: Dick.][Child: Harry.][Child: Sergio.]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this68.context.get('items').shiftObject();
      });
      this.assertText('In layout. [Child: Dick.][Child: Harry.][Child: Sergio.]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this68.context.set('items', (0, _runtime.A)(['Tom', 'Dick', 'Harry']));
      });
      this.assertText('In layout. [Child: Tom.][Child: Dick.][Child: Harry.]');
    };

    _proto['@test specifying classNames results in correct class'] = function testSpecifyingClassNamesResultsInCorrectClass(assert) {
      var _this69 = this;

      this.registerComponent('some-clicky-thing', {
        ComponentClass: _helpers.Component.extend({
          tagName: 'button',
          classNames: ['foo', 'bar']
        })
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject51())); // TODO: ember-view is no longer viewable in the classNames array. Bug or
      // feature?

      var expectedClassNames = ['ember-view', 'foo', 'bar', 'baz'];
      assert.ok(this.$('button').is('.foo.bar.baz.ember-view'), "the element has the correct classes: " + this.$('button').attr('class')); // `ember-view` is no longer in classNames.
      // assert.deepEqual(clickyThing.get('classNames'), expectedClassNames, 'classNames are properly combined');

      this.assertComponentElement(this.firstChild, {
        tagName: 'button',
        attrs: {
          class: (0, _internalTestHelpers.classes)(expectedClassNames.join(' '))
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this69.rerender();
      });
      assert.ok(this.$('button').is('.foo.bar.baz.ember-view'), "the element has the correct classes: " + this.$('button').attr('class') + " (rerender)"); // `ember-view` is no longer in classNames.
      // assert.deepEqual(clickyThing.get('classNames'), expectedClassNames, 'classNames are properly combined (rerender)');

      this.assertComponentElement(this.firstChild, {
        tagName: 'button',
        attrs: {
          class: (0, _internalTestHelpers.classes)(expectedClassNames.join(' '))
        }
      });
    };

    _proto['@test specifying custom concatenatedProperties avoids clobbering'] = function testSpecifyingCustomConcatenatedPropertiesAvoidsClobbering() {
      var _this70 = this;

      this.registerComponent('some-clicky-thing', {
        ComponentClass: _helpers.Component.extend({
          concatenatedProperties: ['blahzz'],
          blahzz: ['blark', 'pory']
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject52())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject53()));
      this.assertText('blarkporybaz- Click Me');
      (0, _internalTestHelpers.runTask)(function () {
        return _this70.rerender();
      });
      this.assertText('blarkporybaz- Click Me');
    };

    _proto['@test a two way binding flows upstream when consumed in the template'] = function testATwoWayBindingFlowsUpstreamWhenConsumedInTheTemplate() {
      var _this71 = this;

      var component;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{bar}}'
      });
      this.render('{{localBar}} - {{foo-bar bar=localBar}}', {
        localBar: 'initial value'
      });
      this.assertText('initial value - initial value');
      (0, _internalTestHelpers.runTask)(function () {
        return _this71.rerender();
      });
      this.assertText('initial value - initial value');

      if (true
      /* DEBUG */
      ) {
          var message = false
          /* EMBER_METAL_TRACKED_PROPERTIES */
          ? /You attempted to update .*, but it is being tracked by a tracking context/ : /You must use set\(\) to set the `bar` property \(of .+\) to `foo-bar`\./;
          expectAssertion(function () {
            component.bar = 'foo-bar';
          }, message);
          this.assertText('initial value - initial value');
        }

      (0, _internalTestHelpers.runTask)(function () {
        component.set('bar', 'updated value');
      });
      this.assertText('updated value - updated value');
      (0, _internalTestHelpers.runTask)(function () {
        component.set('bar', undefined);
      });
      this.assertText(' - ');
      (0, _internalTestHelpers.runTask)(function () {
        _this71.component.set('localBar', 'initial value');
      });
      this.assertText('initial value - initial value');
    };

    _proto['@test a two way binding flows upstream through a CP when consumed in the template'] = function testATwoWayBindingFlowsUpstreamThroughACPWhenConsumedInTheTemplate() {
      var _this72 = this;

      var component;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        bar: (0, _metal.computed)({
          get: function () {
            return this._bar;
          },
          set: function (key, value) {
            this._bar = value;
            return this._bar;
          }
        })
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{bar}}'
      });
      this.render('{{localBar}} - {{foo-bar bar=localBar}}', {
        localBar: 'initial value'
      });
      this.assertText('initial value - initial value');
      (0, _internalTestHelpers.runTask)(function () {
        return _this72.rerender();
      });
      this.assertText('initial value - initial value');
      (0, _internalTestHelpers.runTask)(function () {
        component.set('bar', 'updated value');
      });
      this.assertText('updated value - updated value');
      (0, _internalTestHelpers.runTask)(function () {
        _this72.component.set('localBar', 'initial value');
      });
      this.assertText('initial value - initial value');
    };

    _proto['@test a two way binding flows upstream through a CP without template consumption'] = function testATwoWayBindingFlowsUpstreamThroughACPWithoutTemplateConsumption() {
      var _this73 = this;

      var component;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        bar: (0, _metal.computed)({
          get: function () {
            return this._bar;
          },
          set: function (key, value) {
            this._bar = value;
            return this._bar;
          }
        })
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: ''
      });
      this.render('{{localBar}}{{foo-bar bar=localBar}}', {
        localBar: 'initial value'
      });
      this.assertText('initial value');
      (0, _internalTestHelpers.runTask)(function () {
        return _this73.rerender();
      });
      this.assertText('initial value');
      (0, _internalTestHelpers.runTask)(function () {
        component.set('bar', 'updated value');
      });
      this.assertText('updated value');
      (0, _internalTestHelpers.runTask)(function () {
        _this73.component.set('localBar', 'initial value');
      });
      this.assertText('initial value');
    };

    _proto['@test services can be injected into components'] = function testServicesCanBeInjectedIntoComponents() {
      var _this74 = this;

      var service;
      this.registerService('name', _service.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          service = this;
        },
        last: 'Jackson'
      }));
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          name: (0, _service.inject)()
        }),
        template: '{{name.last}}'
      });
      this.render('{{foo-bar}}');
      this.assertText('Jackson');
      (0, _internalTestHelpers.runTask)(function () {
        return _this74.rerender();
      });
      this.assertText('Jackson');
      (0, _internalTestHelpers.runTask)(function () {
        service.set('last', 'McGuffey');
      });
      this.assertText('McGuffey');
      (0, _internalTestHelpers.runTask)(function () {
        service.set('last', 'Jackson');
      });
      this.assertText('Jackson');
    };

    _proto['@test injecting an unknown service raises an exception'] = function testInjectingAnUnknownServiceRaisesAnException() {
      var _this75 = this;

      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          missingService: (0, _service.inject)()
        })
      });
      expectAssertion(function () {
        _this75.render('{{foo-bar}}');
      }, "Attempting to inject an unknown injection: 'service:missingService'");
    };

    _proto['@test throws if `this._super` is not called from `init`'] = function testThrowsIfThis_superIsNotCalledFromInit() {
      var _this76 = this;

      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init: function () {}
        })
      });
      expectAssertion(function () {
        _this76.render('{{foo-bar}}');
      }, /You must call `this._super\(...arguments\);` when overriding `init` on a framework object. Please update .* to call `this._super\(...arguments\);` from `init`./);
    };

    _proto['@test should toggle visibility with isVisible'] = function testShouldToggleVisibilityWithIsVisible(assert) {
      var _this77 = this;

      var assertStyle = function (expected) {
        var matcher = (0, _internalTestHelpers.styles)(expected);

        var actual = _this77.firstChild.getAttribute('style');

        assert.pushResult({
          result: matcher.match(actual),
          message: matcher.message(),
          actual: actual,
          expected: expected
        });
      };

      this.registerComponent('foo-bar', {
        template: "<p>foo</p>"
      });
      this.render("{{foo-bar id=\"foo-bar\" isVisible=visible}}", {
        visible: false
      });
      assertStyle('display: none;');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this77.context, 'visible', true);
      });
      assertStyle('');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this77.context, 'visible', false);
      });
      assertStyle('display: none;');
    };

    _proto['@test isVisible does not overwrite component style'] = function testIsVisibleDoesNotOverwriteComponentStyle() {
      var _this78 = this;

      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          attributeBindings: ['style'],
          style: (0, _helpers.htmlSafe)('color: blue;')
        }),
        template: "<p>foo</p>"
      });
      this.render("{{foo-bar id=\"foo-bar\" isVisible=visible}}", {
        visible: false
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'foo-bar',
          style: (0, _internalTestHelpers.styles)('color: blue; display: none;')
        }
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this78.context, 'visible', true);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'foo-bar',
          style: (0, _internalTestHelpers.styles)('color: blue;')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this78.context, 'visible', false);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          id: 'foo-bar',
          style: (0, _internalTestHelpers.styles)('color: blue; display: none;')
        }
      });
    };

    _proto['@test adds isVisible binding when style binding is missing and other bindings exist'] = function testAddsIsVisibleBindingWhenStyleBindingIsMissingAndOtherBindingsExist(assert) {
      var _this79 = this;

      var assertStyle = function (expected) {
        var matcher = (0, _internalTestHelpers.styles)(expected);

        var actual = _this79.firstChild.getAttribute('style');

        assert.pushResult({
          result: matcher.match(actual),
          message: matcher.message(),
          actual: actual,
          expected: expected
        });
      };

      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          attributeBindings: ['foo'],
          foo: 'bar'
        }),
        template: "<p>foo</p>"
      });
      this.render("{{foo-bar id=\"foo-bar\" foo=foo isVisible=visible}}", {
        visible: false,
        foo: 'baz'
      });
      assertStyle('display: none;');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this79.context, 'visible', true);
      });
      assertStyle('');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this79.context, 'visible', false);
        (0, _metal.set)(_this79.context, 'foo', 'woo');
      });
      assertStyle('display: none;');
      assert.equal(this.firstChild.getAttribute('foo'), 'woo');
    };

    _proto['@test it can use readDOMAttr to read input value'] = function testItCanUseReadDOMAttrToReadInputValue() {
      var _this80 = this;

      var component;

      var assertElement = function (expectedValue) {
        // value is a property, not an attribute
        _this80.assertHTML("<input class=\"ember-view\" id=\"" + component.elementId + "\">");

        _this80.assert.equal(_this80.firstChild.value, expectedValue, 'value property is correct');

        _this80.assert.equal((0, _metal.get)(component, 'value'), expectedValue, 'component.get("value") is correct');
      };

      this.registerComponent('one-way-input', {
        ComponentClass: _helpers.Component.extend({
          tagName: 'input',
          attributeBindings: ['value'],
          init: function () {
            this._super.apply(this, arguments);

            component = this;
          },
          change: function () {
            var value = this.readDOMAttr('value');
            this.set('value', value);
          }
        })
      });
      this.render('{{one-way-input value=value}}', {
        value: 'foo'
      });
      assertElement('foo');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        _this80.firstChild.value = 'bar';

        _this80.$('input').trigger('change');
      });
      assertElement('bar');
      (0, _internalTestHelpers.runTask)(function () {
        _this80.firstChild.value = 'foo';

        _this80.$('input').trigger('change');
      });
      assertElement('foo');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(component, 'value', 'bar');
      });
      assertElement('bar');
      (0, _internalTestHelpers.runTask)(function () {
        _this80.firstChild.value = 'foo';

        _this80.$('input').trigger('change');
      });
      assertElement('foo');
    };

    _proto['@test child triggers revalidate during parent destruction (GH#13846)'] = function testChildTriggersRevalidateDuringParentDestructionGH13846() {
      this.registerComponent('x-select', {
        ComponentClass: _helpers.Component.extend({
          tagName: 'select',
          init: function () {
            this._super();

            this.options = (0, _runtime.A)([]);
            this.value = null;
          },
          updateValue: function () {
            var newValue = this.get('options.lastObject.value');
            this.set('value', newValue);
          },
          registerOption: function (option) {
            this.get('options').addObject(option);
          },
          unregisterOption: function (option) {
            this.get('options').removeObject(option);
            this.updateValue();
          }
        }),
        template: '{{yield this}}'
      });
      this.registerComponent('x-option', {
        ComponentClass: _helpers.Component.extend({
          tagName: 'option',
          attributeBindings: ['selected'],
          didInsertElement: function () {
            this._super.apply(this, arguments);

            this.get('select').registerOption(this);
          },
          selected: (0, _metal.computed)('select.value', function () {
            return this.get('value') === this.get('select.value');
          }),
          willDestroyElement: function () {
            this._super.apply(this, arguments);

            this.get('select').unregisterOption(this);
          }
        })
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject54()));
      this.teardown();
      this.assert.ok(true, 'no errors during teardown');
    };

    _proto['@test setting a property in willDestroyElement does not assert (GH#14273)'] = function testSettingAPropertyInWillDestroyElementDoesNotAssertGH14273(assert) {
      assert.expect(2);
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            this.showFoo = true;
          },
          willDestroyElement: function () {
            this.set('showFoo', false);
            assert.ok(true, 'willDestroyElement was fired');

            this._super.apply(this, arguments);
          }
        }),
        template: "{{#if showFoo}}things{{/if}}"
      });
      this.render("{{foo-bar}}");
      this.assertText('things');
    };

    _proto['@test didReceiveAttrs fires after .init() but before observers become active'] =
    /*#__PURE__*/
    function () {
      var _testDidReceiveAttrsFiresAfterInitButBeforeObserversBecomeActive = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var barCopyDidChangeCount;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              barCopyDidChangeCount = 0;
              this.registerComponent('foo-bar', {
                ComponentClass: _helpers.Component.extend({
                  init: function () {
                    this._super.apply(this, arguments);

                    this.didInit = true;
                  },
                  didReceiveAttrs: function () {
                    assert.ok(this.didInit, 'expected init to have run before didReceiveAttrs');
                    this.set('barCopy', this.attrs.bar.value + 1);
                  },
                  barCopyDidChange: (0, _metal.observer)('barCopy', function () {
                    barCopyDidChangeCount++;
                  })
                }),
                template: '{{bar}}-{{barCopy}}'
              });
              _context.next = 4;
              return this.render("{{foo-bar bar=bar}}", {
                bar: 3
              });

            case 4:
              this.assertText('3-4');
              assert.strictEqual(barCopyDidChangeCount, 1, 'expected observer firing for: barCopy');
              (0, _metal.set)(this.context, 'bar', 7);
              _context.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assertText('7-8');
              assert.strictEqual(barCopyDidChangeCount, 2, 'expected observer firing for: barCopy');

            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testDidReceiveAttrsFiresAfterInitButBeforeObserversBecomeActive(_x) {
        return _testDidReceiveAttrsFiresAfterInitButBeforeObserversBecomeActive.apply(this, arguments);
      }

      return testDidReceiveAttrsFiresAfterInitButBeforeObserversBecomeActive;
    }();

    _proto['@test overriding didReceiveAttrs does not trigger deprecation'] = function testOverridingDidReceiveAttrsDoesNotTriggerDeprecation(assert) {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          didReceiveAttrs: function () {
            assert.equal(1, this.get('foo'), 'expected attrs to have correct value');
          }
        }),
        template: '{{foo}}-{{fooCopy}}-{{bar}}-{{barCopy}}'
      });
      this.render("{{foo-bar foo=foo bar=bar}}", {
        foo: 1,
        bar: 3
      });
    };

    _proto['@test overriding didUpdateAttrs does not trigger deprecation'] = function testOverridingDidUpdateAttrsDoesNotTriggerDeprecation(assert) {
      var _this81 = this;

      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          didUpdateAttrs: function () {
            assert.equal(5, this.get('foo'), 'expected newAttrs to have new value');
          }
        }),
        template: '{{foo}}-{{fooCopy}}-{{bar}}-{{barCopy}}'
      });
      this.render("{{foo-bar foo=foo bar=bar}}", {
        foo: 1,
        bar: 3
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this81.context, 'foo', 5);
      });
    };

    _proto['@test returning `true` from an action does not bubble if `target` is not specified (GH#14275)'] = function testReturningTrueFromAnActionDoesNotBubbleIfTargetIsNotSpecifiedGH14275(assert) {
      var _this82 = this;

      this.registerComponent('display-toggle', {
        ComponentClass: _helpers.Component.extend({
          actions: {
            show: function () {
              assert.ok(true, 'display-toggle show action was called');
              return true;
            }
          }
        }),
        template: "<button {{action 'show'}}>Show</button>"
      });
      this.render("{{display-toggle}}", {
        send: function () {
          assert.notOk(true, 'send should not be called when action is not "subscribed" to');
        }
      });
      this.assertText('Show');
      (0, _internalTestHelpers.runTask)(function () {
        return _this82.$('button').click();
      });
    };

    _proto['@test returning `true` from an action bubbles to the `target` if specified'] = function testReturningTrueFromAnActionBubblesToTheTargetIfSpecified(assert) {
      var _this83 = this;

      assert.expect(4);
      this.registerComponent('display-toggle', {
        ComponentClass: _helpers.Component.extend({
          actions: {
            show: function () {
              assert.ok(true, 'display-toggle show action was called');
              return true;
            }
          }
        }),
        template: "<button {{action 'show'}}>Show</button>"
      });
      this.render("{{display-toggle target=this}}", {
        send: function (actionName) {
          assert.ok(true, 'send should be called when action is "subscribed" to');
          assert.equal(actionName, 'show');
        }
      });
      this.assertText('Show');
      (0, _internalTestHelpers.runTask)(function () {
        return _this83.$('button').click();
      });
    };

    _proto['@test triggering an event only attempts to invoke an identically named method, if it actually is a function (GH#15228)'] = function testTriggeringAnEventOnlyAttemptsToInvokeAnIdenticallyNamedMethodIfItActuallyIsAFunctionGH15228(assert) {
      assert.expect(3);
      var payload = ['arbitrary', 'event', 'data'];
      this.registerComponent('evented-component', {
        ComponentClass: _helpers.Component.extend({
          someTruthyProperty: true,
          init: function () {
            this._super.apply(this, arguments);

            this.trigger.apply(this, ['someMethod'].concat(payload));
            this.trigger.apply(this, ['someTruthyProperty'].concat(payload));
          },
          someMethod: function () {
            for (var _len = arguments.length, data = new Array(_len), _key = 0; _key < _len; _key++) {
              data[_key] = arguments[_key];
            }

            assert.deepEqual(data, payload, 'the method `someMethod` should be called, when `someMethod` is triggered');
          },
          listenerForSomeMethod: (0, _metal.on)('someMethod', function () {
            for (var _len2 = arguments.length, data = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              data[_key2] = arguments[_key2];
            }

            assert.deepEqual(data, payload, 'the listener `listenerForSomeMethod` should be called, when `someMethod` is triggered');
          }),
          listenerForSomeTruthyProperty: (0, _metal.on)('someTruthyProperty', function () {
            for (var _len3 = arguments.length, data = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              data[_key3] = arguments[_key3];
            }

            assert.deepEqual(data, payload, 'the listener `listenerForSomeTruthyProperty` should be called, when `someTruthyProperty` is triggered');
          })
        })
      });
      this.render("{{evented-component}}");
    };

    _proto['@test component yielding in an {{#each}} has correct block values after rerendering (GH#14284)'] = function testComponentYieldingInAnEachHasCorrectBlockValuesAfterRerenderingGH14284() {
      var _this84 = this;

      this.registerComponent('list-items', {
        template: "{{#each items as |item|}}{{yield item}}{{/each}}"
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject55()), {
        editMode: false,
        items: ['foo', 'bar', 'qux', 'baz']
      });
      this.assertText('|foo||bar||qux||baz|');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this84.context, 'editMode', true);
      });
      this.assertText('|foo|Remove foo|bar|Remove bar|qux|Remove qux|baz|Remove baz');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this84.context, 'editMode', false);
      });
      this.assertText('|foo||bar||qux||baz|');
    };

    _proto['@test unimplimented positionalParams do not cause an error GH#14416'] = function testUnimplimentedPositionalParamsDoNotCauseAnErrorGH14416() {
      this.registerComponent('foo-bar', {
        template: 'hello'
      });
      this.render('{{foo-bar wat}}');
      this.assertText('hello');
    };

    _proto['@test using attrs for positional params'] = function testUsingAttrsForPositionalParams() {
      var MyComponent = _helpers.Component.extend();

      this.registerComponent('foo-bar', {
        ComponentClass: MyComponent.reopenClass({
          positionalParams: ['myVar']
        }),
        template: 'MyVar1: {{attrs.myVar}} {{myVar}} MyVar2: {{myVar2}} {{attrs.myVar2}}'
      });
      this.render('{{foo-bar 1 myVar2=2}}');
      this.assertText('MyVar1: 1 1 MyVar2: 2 2');
    };

    _proto['@test using named arguments for positional params'] = function testUsingNamedArgumentsForPositionalParams() {
      var MyComponent = _helpers.Component.extend();

      this.registerComponent('foo-bar', {
        ComponentClass: MyComponent.reopenClass({
          positionalParams: ['myVar']
        }),
        template: 'MyVar1: {{@myVar}} {{myVar}} MyVar2: {{myVar2}} {{@myVar2}}'
      });
      this.render('{{foo-bar 1 myVar2=2}}');
      this.assertText('MyVar1: 1 1 MyVar2: 2 2');
    };

    _proto["@test can use `{{this}}` to emit the component's toString value [GH#14581]"] = function testCanUseThisToEmitTheComponentSToStringValueGH14581() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          toString: function () {
            return 'special sauce goes here!';
          }
        }),
        template: '{{this}}'
      });
      this.render('{{foo-bar}}');
      this.assertText('special sauce goes here!');
    };

    _proto['@test can use `{{this` to access paths on current context [GH#14581]'] = function testCanUseThisToAccessPathsOnCurrentContextGH14581() {
      var instance;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            instance = this;
          },
          foo: {
            bar: {
              baz: 'huzzah!'
            }
          }
        }),
        template: '{{this.foo.bar.baz}}'
      });
      this.render('{{foo-bar}}');
      this.assertText('huzzah!');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(instance, 'foo.bar.baz', 'yippie!');
      });
      this.assertText('yippie!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(instance, 'foo.bar.baz', 'huzzah!');
      });
      this.assertText('huzzah!');
    };

    _proto['@test can use custom element in component layout'] = function testCanUseCustomElementInComponentLayout() {
      this.registerComponent('foo-bar', {
        template: '<blah-zorz>Hi!</blah-zorz>'
      });
      this.render('{{foo-bar}}');
      this.assertText('Hi!');
    };

    _proto['@test can use nested custom element in component layout'] = function testCanUseNestedCustomElementInComponentLayout() {
      this.registerComponent('foo-bar', {
        template: '<blah-zorz><hows-it-going>Hi!</hows-it-going></blah-zorz>'
      });
      this.render('{{foo-bar}}');
      this.assertText('Hi!');
    };

    _proto['@test can access properties off of rest style positionalParams array'] = function testCanAccessPropertiesOffOfRestStylePositionalParamsArray() {
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'things'
        }),
        template: "{{@things.length}}"
      });
      this.render('{{foo-bar "foo" "bar" "baz"}}');
      this.assertText('3');
    };

    _proto['@test has attrs by didReceiveAttrs with native classes'] = function testHasAttrsByDidReceiveAttrsWithNativeClasses(assert) {
      var FooBarComponent =
      /*#__PURE__*/
      function (_Component) {
        (0, _emberBabel.inheritsLoose)(FooBarComponent, _Component);

        function FooBarComponent(injections) {
          var _this85;

          _this85 = _Component.call(this, injections) || this; // analagous to class field defaults

          _this85.foo = 'bar';
          return _this85;
        }

        var _proto2 = FooBarComponent.prototype;

        _proto2.didReceiveAttrs = function didReceiveAttrs() {
          assert.equal(this.foo, 'bar', 'received default attrs correctly');
        };

        return FooBarComponent;
      }(_helpers.Component);

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent
      });
      this.render('{{foo-bar}}');
    };

    _proto['@test ensure aliases are watched properly [GH#17243]'] = function testEnsureAliasesAreWatchedProperlyGH17243() {
      var fooInstance, barInstance;

      var FooComponent = _helpers.Component.extend({
        source: 'first',
        foo: (0, _metal.alias)('source'),
        init: function () {
          this._super.apply(this, arguments);

          fooInstance = this;
        }
      });

      this.registerComponent('foo', {
        ComponentClass: FooComponent,
        template: '{{this.foo}}'
      });

      var BarComponent = _helpers.Component.extend({
        target: null,
        init: function () {
          this._super.apply(this, arguments);

          barInstance = this;
        },
        bar: (0, _metal.computed)('target.foo', function () {
          if (this.target) {
            return this.target.foo.toUpperCase();
          }
        })
      });

      this.registerComponent('bar', {
        ComponentClass: BarComponent,
        template: '{{this.bar}}'
      });
      this.render('[<Foo />][<Bar />]');
      this.assertText('[first][]'); // addObserver

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(barInstance, 'target', fooInstance);
      });
      this.assertText('[first][FIRST]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(fooInstance, 'source', 'second');
      });
      this.assertText('[second][SECOND]'); // removeObserver

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(barInstance, 'target', null);
      });
      this.assertText('[second][]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(fooInstance, 'source', 'third');
      });
      this.assertText('[third][]');
    };

    _proto['@feature(EMBER_FRAMEWORK_OBJECT_OWNER_ARGUMENT) it can render a basic component in native ES class syntax'] = function featureEMBER_FRAMEWORK_OBJECT_OWNER_ARGUMENTItCanRenderABasicComponentInNativeESClassSyntax(assert) {
      var _this87 = this;

      var testContext = this;
      this.registerComponent('foo-bar', {
        ComponentClass:
        /*#__PURE__*/
        function (_Component2) {
          (0, _emberBabel.inheritsLoose)(ComponentClass, _Component2);

          function ComponentClass(owner) {
            var _this86;

            _this86 = _Component2.call(this, owner) || this;
            assert.equal(owner, testContext.owner, 'owner was passed as a constructor argument');
            return _this86;
          }

          return ComponentClass;
        }(_helpers.Component),
        template: 'hello'
      });
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this87.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));

  if (_views.jQueryDisabled) {
    (0, _internalTestHelpers.moduleFor)('Components test: curly components: jQuery disabled',
    /*#__PURE__*/
    function (_RenderingTestCase2) {
      (0, _emberBabel.inheritsLoose)(_class2, _RenderingTestCase2);

      function _class2() {
        return _RenderingTestCase2.apply(this, arguments) || this;
      }

      var _proto3 = _class2.prototype;

      _proto3['@test jQuery proxy is not available without jQuery'] = function testJQueryProxyIsNotAvailableWithoutJQuery() {
        var instance;

        var FooBarComponent = _helpers.Component.extend({
          init: function () {
            this._super();

            instance = this;
          }
        });

        this.registerComponent('foo-bar', {
          ComponentClass: FooBarComponent,
          template: 'hello'
        });
        this.render('{{foo-bar}}');
        expectAssertion(function () {
          instance.$()[0];
        }, 'You cannot access this.$() with `jQuery` disabled.');
      };

      return _class2;
    }(_internalTestHelpers.RenderingTestCase));
  } else {
    (0, _internalTestHelpers.moduleFor)('Components test: curly components: jQuery enabled',
    /*#__PURE__*/
    function (_RenderingTestCase3) {
      (0, _emberBabel.inheritsLoose)(_class3, _RenderingTestCase3);

      function _class3() {
        return _RenderingTestCase3.apply(this, arguments) || this;
      }

      var _proto4 = _class3.prototype;

      _proto4['@test it has a jQuery proxy to the element'] = function testItHasAJQueryProxyToTheElement() {
        var _this88 = this;

        var instance;
        var element1;
        var element2;

        var FooBarComponent = _helpers.Component.extend({
          init: function () {
            this._super();

            instance = this;
          }
        });

        this.registerComponent('foo-bar', {
          ComponentClass: FooBarComponent,
          template: 'hello'
        });
        this.render('{{foo-bar}}');
        expectDeprecation(function () {
          element1 = instance.$()[0];
        }, 'Using this.$() in a component has been deprecated, consider using this.element');
        this.assertComponentElement(element1, {
          content: 'hello'
        });
        (0, _internalTestHelpers.runTask)(function () {
          return _this88.rerender();
        });
        expectDeprecation(function () {
          element2 = instance.$()[0];
        }, 'Using this.$() in a component has been deprecated, consider using this.element');
        this.assertComponentElement(element2, {
          content: 'hello'
        });
        this.assertSameNode(element2, element1);
      };

      _proto4['@test it scopes the jQuery proxy to the component element'] = function testItScopesTheJQueryProxyToTheComponentElement(assert) {
        var _this89 = this;

        var instance;
        var $span;

        var FooBarComponent = _helpers.Component.extend({
          init: function () {
            this._super();

            instance = this;
          }
        });

        this.registerComponent('foo-bar', {
          ComponentClass: FooBarComponent,
          template: '<span class="inner">inner</span>'
        });
        this.render('<span class="outer">outer</span>{{foo-bar}}');
        expectDeprecation(function () {
          $span = instance.$('span');
        }, 'Using this.$() in a component has been deprecated, consider using this.element');
        assert.equal($span.length, 1);
        assert.equal($span.attr('class'), 'inner');
        (0, _internalTestHelpers.runTask)(function () {
          return _this89.rerender();
        });
        expectDeprecation(function () {
          $span = instance.$('span');
        }, 'Using this.$() in a component has been deprecated, consider using this.element');
        assert.equal($span.length, 1);
        assert.equal($span.attr('class'), 'inner');
      };

      return _class3;
    }(_internalTestHelpers.RenderingTestCase));
  }
});
enifed("@ember/-internals/glimmer/tests/integration/components/destroy-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Component destroy',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test it correctly releases the destroyed components'] = function testItCorrectlyReleasesTheDestroyedComponents(assert) {
      var _this = this;

      var FooBarComponent = _helpers.Component.extend({});

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{#if switch}}{{#foo-bar}}{{foo-bar}}{{/foo-bar}}{{/if}}', {
        switch: true
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'switch', false);
      });
      this.assertText('');
      assert.equal(this.env.destroyedComponents.length, 0, 'environment.destroyedComponents should be empty');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/components/dynamic-components-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/views", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _views, _helpers) {
  "use strict";

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#each n as |name|}}\n          {{name}}\n        {{/each}}"]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#each names as |name|}}\n          {{name}}\n        {{/each}}"]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#if cond1}}\n        {{#component \"foo-bar\" id=1}}\n          {{#if cond2}}\n            {{#component \"foo-bar\" id=2}}{{/component}}\n            {{#if cond3}}\n              {{#component \"foo-bar\" id=3}}\n                {{#if cond4}}\n                  {{#component \"foo-bar\" id=4}}\n                    {{#if cond5}}\n                      {{#component \"foo-bar\" id=5}}{{/component}}\n                      {{#component \"foo-bar\" id=6}}{{/component}}\n                      {{#component \"foo-bar\" id=7}}{{/component}}\n                    {{/if}}\n                    {{#component \"foo-bar\" id=8}}{{/component}}\n                  {{/component}}\n                {{/if}}\n              {{/component}}\n            {{/if}}\n          {{/if}}\n        {{/component}}\n      {{/if}}"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('Components test: dynamic components',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test it can render a basic component with a static component name argument'] = function testItCanRenderABasicComponentWithAStaticComponentNameArgument() {
      var _this = this;

      this.registerComponent('foo-bar', {
        template: 'hello {{name}}'
      });
      this.render('{{component "foo-bar" name=name}}', {
        name: 'Sarah'
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Sarah'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Sarah'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'name', 'Gavin');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Gavin'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'name', 'Sarah');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Sarah'
      });
    };

    _proto['@test it can render a basic component with a dynamic component name argument'] = function testItCanRenderABasicComponentWithADynamicComponentNameArgument() {
      var _this2 = this;

      this.registerComponent('foo-bar', {
        template: 'hello {{name}} from foo-bar'
      });
      this.registerComponent('foo-bar-baz', {
        template: 'hello {{name}} from foo-bar-baz'
      });
      this.render('{{component componentName name=name}}', {
        componentName: 'foo-bar',
        name: 'Alex'
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Alex from foo-bar'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Alex from foo-bar'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'name', 'Ben');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Ben from foo-bar'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'componentName', 'foo-bar-baz');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Ben from foo-bar-baz'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this2.context, 'componentName', 'foo-bar');
        (0, _metal.set)(_this2.context, 'name', 'Alex');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Alex from foo-bar'
      });
    };

    _proto['@test it has an element'] = function testItHasAnElement() {
      var _this3 = this;

      var instance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          instance = this;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{component "foo-bar"}}');
      var element1 = instance.element;
      this.assertComponentElement(element1, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      var element2 = instance.element;
      this.assertComponentElement(element2, {
        content: 'hello'
      });
      this.assertSameNode(element2, element1);
    };

    _proto['@test it has the right parentView and childViews'] = function testItHasTheRightParentViewAndChildViews(assert) {
      var _this4 = this;

      var fooBarInstance, fooBarBazInstance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          fooBarInstance = this;
        }
      });

      var FooBarBazComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          fooBarBazInstance = this;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'foo-bar {{foo-bar-baz}}'
      });
      this.registerComponent('foo-bar-baz', {
        ComponentClass: FooBarBazComponent,
        template: 'foo-bar-baz'
      });
      this.render('{{component "foo-bar"}}');
      this.assertText('foo-bar foo-bar-baz');
      assert.equal(fooBarInstance.parentView, this.component);
      assert.equal(fooBarBazInstance.parentView, fooBarInstance);
      assert.deepEqual(this.component.childViews, [fooBarInstance]);
      assert.deepEqual(fooBarInstance.childViews, [fooBarBazInstance]);
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      this.assertText('foo-bar foo-bar-baz');
      assert.equal(fooBarInstance.parentView, this.component);
      assert.equal(fooBarBazInstance.parentView, fooBarInstance);
      assert.deepEqual(this.component.childViews, [fooBarInstance]);
      assert.deepEqual(fooBarInstance.childViews, [fooBarBazInstance]);
    };

    _proto['@test it can render a basic component with a block'] = function testItCanRenderABasicComponentWithABlock() {
      var _this5 = this;

      this.registerComponent('foo-bar', {
        template: '{{yield}}'
      });
      this.render('{{#component "foo-bar"}}hello{{/component}}');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    };

    _proto['@test it renders the layout with the component instance as the context'] = function testItRendersTheLayoutWithTheComponentInstanceAsTheContext() {
      var _this6 = this;

      var instance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          instance = this;
          this.set('message', 'hello');
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{message}}'
      });
      this.render('{{component "foo-bar"}}');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(instance, 'message', 'goodbye');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'goodbye'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(instance, 'message', 'hello');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    };

    _proto['@test it preserves the outer context when yielding'] = function testItPreservesTheOuterContextWhenYielding() {
      var _this7 = this;

      this.registerComponent('foo-bar', {
        template: '{{yield}}'
      });
      this.render('{{#component "foo-bar"}}{{message}}{{/component}}', {
        message: 'hello'
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'message', 'goodbye');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'goodbye'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'message', 'hello');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
    };

    _proto['@test the component and its child components are destroyed'] = function testTheComponentAndItsChildComponentsAreDestroyed(assert) {
      var _this8 = this;

      var destroyed = {
        1: 0,
        2: 0,
        3: 0,
        4: 0,
        5: 0,
        6: 0,
        7: 0,
        8: 0
      };
      this.registerComponent('foo-bar', {
        template: '{{id}} {{yield}}',
        ComponentClass: _helpers.Component.extend({
          willDestroy: function () {
            this._super();

            destroyed[this.get('id')]++;
          }
        })
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject()), {
        cond1: true,
        cond2: true,
        cond3: true,
        cond4: true,
        cond5: true
      });
      this.assertText('1 2 3 4 5 6 7 8 ');
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.rerender();
      });
      assert.deepEqual(destroyed, {
        1: 0,
        2: 0,
        3: 0,
        4: 0,
        5: 0,
        6: 0,
        7: 0,
        8: 0
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this8.context, 'cond5', false);
      });
      this.assertText('1 2 3 4 8 ');
      assert.deepEqual(destroyed, {
        1: 0,
        2: 0,
        3: 0,
        4: 0,
        5: 1,
        6: 1,
        7: 1,
        8: 0
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this8.context, 'cond3', false);
        (0, _metal.set)(_this8.context, 'cond5', true);
        (0, _metal.set)(_this8.context, 'cond4', false);
      });
      assert.deepEqual(destroyed, {
        1: 0,
        2: 0,
        3: 1,
        4: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this8.context, 'cond2', false);
        (0, _metal.set)(_this8.context, 'cond1', false);
      });
      assert.deepEqual(destroyed, {
        1: 1,
        2: 1,
        3: 1,
        4: 1,
        5: 1,
        6: 1,
        7: 1,
        8: 1
      });
    };

    _proto['@test component helper destroys underlying component when it is swapped out'] = function testComponentHelperDestroysUnderlyingComponentWhenItIsSwappedOut(assert) {
      var _this9 = this;

      var destroyed = {
        'foo-bar': 0,
        'foo-bar-baz': 0
      };
      var testContext = this;
      this.registerComponent('foo-bar', {
        template: 'hello from foo-bar',
        ComponentClass: _helpers.Component.extend({
          willDestroyElement: function () {
            assert.equal(testContext.$("#" + this.elementId).length, 1, 'element is still attached to the document');
          },
          willDestroy: function () {
            this._super();

            destroyed['foo-bar']++;
          }
        })
      });
      this.registerComponent('foo-bar-baz', {
        template: 'hello from foo-bar-baz',
        ComponentClass: _helpers.Component.extend({
          willDestroy: function () {
            this._super();

            destroyed['foo-bar-baz']++;
          }
        })
      });
      this.render('{{component componentName name=name}}', {
        componentName: 'foo-bar'
      });
      assert.deepEqual(destroyed, {
        'foo-bar': 0,
        'foo-bar-baz': 0
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.rerender();
      });
      assert.deepEqual(destroyed, {
        'foo-bar': 0,
        'foo-bar-baz': 0
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this9.context, 'componentName', 'foo-bar-baz');
      });
      assert.deepEqual(destroyed, {
        'foo-bar': 1,
        'foo-bar-baz': 0
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this9.context, 'componentName', 'foo-bar');
      });
      assert.deepEqual(destroyed, {
        'foo-bar': 1,
        'foo-bar-baz': 1
      });
    };

    _proto['@test component helper with bound properties are updating correctly in init of component'] = function testComponentHelperWithBoundPropertiesAreUpdatingCorrectlyInInitOfComponent() {
      var _this10 = this;

      this.registerComponent('foo-bar', {
        template: 'foo-bar {{location}} {{locationCopy}} {{yield}}',
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            this.set('locationCopy', this.get('location'));
          }
        })
      });
      this.registerComponent('foo-bar-baz', {
        template: 'foo-bar-baz {{location}} {{locationCopy}} {{yield}}',
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            this.set('locationCopy', this.get('location'));
          }
        })
      });
      this.registerComponent('outer-component', {
        template: '{{#component componentName location=location}}arepas!{{/component}}',
        ComponentClass: _helpers.Component.extend({
          componentName: (0, _metal.computed)('location', function () {
            if (this.get('location') === 'Caracas') {
              return 'foo-bar';
            } else {
              return 'foo-bar-baz';
            }
          })
        })
      });
      this.render('{{outer-component location=location}}', {
        location: 'Caracas'
      });
      this.assertText('foo-bar Caracas Caracas arepas!');
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.rerender();
      });
      this.assertText('foo-bar Caracas Caracas arepas!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'location', 'Loisaida');
      });
      this.assertText('foo-bar-baz Loisaida Loisaida arepas!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'location', 'Caracas');
      });
      this.assertText('foo-bar Caracas Caracas arepas!');
    };

    _proto['@test component helper with actions'] = function testComponentHelperWithActions(assert) {
      var _this12 = this;

      this.registerComponent('inner-component', {
        template: 'inner-component {{yield}}',
        ComponentClass: _helpers.Component.extend({
          classNames: 'inner-component',
          didInsertElement: function () {
            var _this11 = this; // trigger action on click in absence of app's EventDispatcher


            var sendAction = this.eventHandler = function () {
              if (_this11.somethingClicked) {
                _this11.somethingClicked();
              }
            };

            this.element.addEventListener('click', sendAction);
          },
          willDestroyElement: function () {
            this.element.removeEventListener('click', this.eventHandler);
          }
        })
      });
      var actionTriggered = 0;
      this.registerComponent('outer-component', {
        template: '{{#component componentName somethingClicked=(action "mappedAction")}}arepas!{{/component}}',
        ComponentClass: _helpers.Component.extend({
          classNames: 'outer-component',
          componentName: 'inner-component',
          actions: {
            mappedAction: function () {
              actionTriggered++;
            }
          }
        })
      });
      this.render('{{outer-component}}');
      assert.equal(actionTriggered, 0, 'action was not triggered');
      (0, _internalTestHelpers.runTask)(function () {
        _this12.$('.inner-component').click();
      });
      assert.equal(actionTriggered, 1, 'action was triggered');
    };

    _proto['@test nested component helpers'] = function testNestedComponentHelpers() {
      var _this13 = this;

      this.registerComponent('foo-bar', {
        template: 'yippie! {{attrs.location}} {{yield}}'
      });
      this.registerComponent('baz-qux', {
        template: 'yummy {{attrs.location}} {{yield}}'
      });
      this.registerComponent('corge-grault', {
        template: 'delicious {{attrs.location}} {{yield}}'
      });
      this.render('{{#component componentName1 location=location}}{{#component componentName2 location=location}}arepas!{{/component}}{{/component}}', {
        componentName1: 'foo-bar',
        componentName2: 'baz-qux',
        location: 'Caracas'
      });
      this.assertText('yippie! Caracas yummy Caracas arepas!');
      (0, _internalTestHelpers.runTask)(function () {
        return _this13.rerender();
      });
      this.assertText('yippie! Caracas yummy Caracas arepas!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'location', 'Loisaida');
      });
      this.assertText('yippie! Loisaida yummy Loisaida arepas!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'componentName1', 'corge-grault');
      });
      this.assertText('delicious Loisaida yummy Loisaida arepas!');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this13.context, 'componentName1', 'foo-bar');
        (0, _metal.set)(_this13.context, 'location', 'Caracas');
      });
      this.assertText('yippie! Caracas yummy Caracas arepas!');
    };

    _proto['@test component with dynamic name argument resolving to non-existent component'] = function testComponentWithDynamicNameArgumentResolvingToNonExistentComponent() {
      var _this14 = this;

      expectAssertion(function () {
        _this14.render('{{component componentName}}', {
          componentName: 'does-not-exist'
        });
      }, /Could not find component named "does-not-exist"/);
    };

    _proto['@test component with static name argument for non-existent component'] = function testComponentWithStaticNameArgumentForNonExistentComponent() {
      var _this15 = this;

      expectAssertion(function () {
        _this15.render('{{component "does-not-exist"}}');
      }, /Could not find component named "does-not-exist"/);
    };

    _proto['@test component with dynamic component name resolving to a component, then non-existent component'] = function testComponentWithDynamicComponentNameResolvingToAComponentThenNonExistentComponent() {
      var _this16 = this;

      this.registerComponent('foo-bar', {
        template: 'hello {{name}}'
      });
      this.render('{{component componentName name=name}}', {
        componentName: 'foo-bar',
        name: 'Alex'
      });
      this.assertText('hello Alex');
      (0, _internalTestHelpers.runTask)(function () {
        return _this16.rerender();
      });
      this.assertText('hello Alex');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this16.context, 'componentName', undefined);
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this16.context, 'componentName', 'foo-bar');
      });
      this.assertText('hello Alex');
    };

    _proto['@test component helper properly invalidates hash params inside an {{each}} invocation #11044'] = function testComponentHelperProperlyInvalidatesHashParamsInsideAnEachInvocation11044() {
      var _this17 = this;

      this.registerComponent('foo-bar', {
        template: '[{{internalName}} - {{name}}]',
        ComponentClass: _helpers.Component.extend({
          willRender: function () {
            // store internally available name to ensure that the name available in `this.attrs.name`
            // matches the template lookup name
            (0, _metal.set)(this, 'internalName', this.get('name'));
          }
        })
      });
      this.render('{{#each items as |item|}}{{component "foo-bar" name=item.name}}{{/each}}', {
        items: [{
          name: 'Robert'
        }, {
          name: 'Jacquie'
        }]
      });
      this.assertText('[Robert - Robert][Jacquie - Jacquie]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this17.rerender();
      });
      this.assertText('[Robert - Robert][Jacquie - Jacquie]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this17.context, 'items', [{
          name: 'Max'
        }, {
          name: 'James'
        }]);
      });
      this.assertText('[Max - Max][James - James]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this17.context, 'items', [{
          name: 'Robert'
        }, {
          name: 'Jacquie'
        }]);
      });
      this.assertText('[Robert - Robert][Jacquie - Jacquie]');
    };

    _proto['@test positional parameters does not clash when rendering different components'] = function testPositionalParametersDoesNotClashWhenRenderingDifferentComponents() {
      var _this18 = this;

      this.registerComponent('foo-bar', {
        template: 'hello {{name}} ({{age}}) from foo-bar',
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        })
      });
      this.registerComponent('foo-bar-baz', {
        template: 'hello {{name}} ({{age}}) from foo-bar-baz',
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        })
      });
      this.render('{{component componentName name age}}', {
        componentName: 'foo-bar',
        name: 'Alex',
        age: 29
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Alex (29) from foo-bar'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Alex (29) from foo-bar'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this18.context, 'name', 'Ben');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Ben (29) from foo-bar'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this18.context, 'age', 22);
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Ben (22) from foo-bar'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this18.context, 'componentName', 'foo-bar-baz');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Ben (22) from foo-bar-baz'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this18.context, 'componentName', 'foo-bar');
        (0, _metal.set)(_this18.context, 'name', 'Alex');
        (0, _metal.set)(_this18.context, 'age', 29);
      });
      this.assertComponentElement(this.firstChild, {
        content: 'hello Alex (29) from foo-bar'
      });
    };

    _proto['@test positional parameters does not pollute the attributes when changing components'] = function testPositionalParametersDoesNotPolluteTheAttributesWhenChangingComponents() {
      var _this19 = this;

      this.registerComponent('normal-message', {
        template: 'Normal: {{something}}!',
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: ['something']
        })
      });
      this.registerComponent('alternative-message', {
        template: 'Alternative: {{something}} {{somethingElse}}!',
        ComponentClass: _helpers.Component.extend({
          something: 'Another'
        }).reopenClass({
          positionalParams: ['somethingElse']
        })
      });
      this.render('{{component componentName message}}', {
        componentName: 'normal-message',
        message: 'Hello'
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Normal: Hello!'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this19.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Normal: Hello!'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this19.context, 'componentName', 'alternative-message');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Alternative: Another Hello!'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this19.context, 'message', 'Hi');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Alternative: Another Hi!'
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this19.context, 'componentName', 'normal-message');
        (0, _metal.set)(_this19.context, 'message', 'Hello');
      });
      this.assertComponentElement(this.firstChild, {
        content: 'Normal: Hello!'
      });
    };

    _proto['@test static arbitrary number of positional parameters'] = function testStaticArbitraryNumberOfPositionalParameters() {
      var _this20 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'names'
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject2())
      });
      this.render("{{component \"sample-component\" \"Foo\" 4 \"Bar\" 5 \"Baz\" elementId=\"helper\"}}");
      this.assertText('Foo4Bar5Baz');
      (0, _internalTestHelpers.runTask)(function () {
        return _this20.rerender();
      });
      this.assertText('Foo4Bar5Baz');
    };

    _proto['@test dynamic arbitrary number of positional parameters'] = function testDynamicArbitraryNumberOfPositionalParameters() {
      var _this21 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _helpers.Component.extend().reopenClass({
          positionalParams: 'n'
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject3())
      });
      this.render("{{component \"sample-component\" user1 user2}}", {
        user1: 'Foo',
        user2: 4
      });
      this.assertText('Foo4');
      (0, _internalTestHelpers.runTask)(function () {
        return _this21.rerender();
      });
      this.assertText('Foo4');
      (0, _internalTestHelpers.runTask)(function () {
        return _this21.context.set('user1', 'Bar');
      });
      this.assertText('Bar4');
      (0, _internalTestHelpers.runTask)(function () {
        return _this21.context.set('user2', '5');
      });
      this.assertText('Bar5');
      (0, _internalTestHelpers.runTask)(function () {
        _this21.context.set('user1', 'Foo');

        _this21.context.set('user2', 4);
      });
      this.assertText('Foo4');
    };

    _proto['@test component helper emits useful backtracking re-render assertion message'] = function testComponentHelperEmitsUsefulBacktrackingReRenderAssertionMessage() {
      var _this22 = this;

      this.registerComponent('outer-component', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            this.set('person', {
              name: 'Alex'
            });
          }
        }),
        template: "Hi {{person.name}}! {{component \"error-component\" person=person}}"
      });
      this.registerComponent('error-component', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            this.set('person.name', {
              name: 'Ben'
            });
          }
        }),
        template: '{{person.name}}'
      });
      var expectedBacktrackingMessage = /modified "person\.name" twice on \[object Object\] in a single render\. It was rendered in "component:outer-component" and modified in "component:error-component"/;
      expectAssertion(function () {
        _this22.render('{{component componentName}}', {
          componentName: 'outer-component'
        });
      }, expectedBacktrackingMessage);
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));

  if (_views.jQueryDisabled) {
    (0, _internalTestHelpers.moduleFor)('Components test: dynamic components: jQuery disabled',
    /*#__PURE__*/
    function (_RenderingTestCase2) {
      (0, _emberBabel.inheritsLoose)(_class2, _RenderingTestCase2);

      function _class2() {
        return _RenderingTestCase2.apply(this, arguments) || this;
      }

      var _proto2 = _class2.prototype;

      _proto2['@test jQuery proxy is not available without jQuery'] = function testJQueryProxyIsNotAvailableWithoutJQuery() {
        var instance;

        var FooBarComponent = _helpers.Component.extend({
          init: function () {
            this._super();

            instance = this;
          }
        });

        this.registerComponent('foo-bar', {
          ComponentClass: FooBarComponent,
          template: 'hello'
        });
        this.render('{{component "foo-bar"}}');
        expectAssertion(function () {
          instance.$()[0];
        }, 'You cannot access this.$() with `jQuery` disabled.');
      };

      return _class2;
    }(_internalTestHelpers.RenderingTestCase));
  } else {
    (0, _internalTestHelpers.moduleFor)('Components test: dynamic components : jQuery enabled',
    /*#__PURE__*/
    function (_RenderingTestCase3) {
      (0, _emberBabel.inheritsLoose)(_class3, _RenderingTestCase3);

      function _class3() {
        return _RenderingTestCase3.apply(this, arguments) || this;
      }

      var _proto3 = _class3.prototype;

      _proto3['@test it has a jQuery proxy to the element'] = function testItHasAJQueryProxyToTheElement() {
        var _this23 = this;

        var instance;
        var element1;
        var element2;

        var FooBarComponent = _helpers.Component.extend({
          init: function () {
            this._super();

            instance = this;
          }
        });

        this.registerComponent('foo-bar', {
          ComponentClass: FooBarComponent,
          template: 'hello'
        });
        this.render('{{component "foo-bar"}}');
        expectDeprecation(function () {
          element1 = instance.$()[0];
        }, 'Using this.$() in a component has been deprecated, consider using this.element');
        this.assertComponentElement(element1, {
          content: 'hello'
        });
        (0, _internalTestHelpers.runTask)(function () {
          return _this23.rerender();
        });
        expectDeprecation(function () {
          element2 = instance.$()[0];
        }, 'Using this.$() in a component has been deprecated, consider using this.element');
        this.assertComponentElement(element2, {
          content: 'hello'
        });
        this.assertSameNode(element2, element1);
      };

      _proto3['@test it scopes the jQuery proxy to the component element'] = function testItScopesTheJQueryProxyToTheComponentElement(assert) {
        var _this24 = this;

        var instance;
        var $span;

        var FooBarComponent = _helpers.Component.extend({
          init: function () {
            this._super();

            instance = this;
          }
        });

        this.registerComponent('foo-bar', {
          ComponentClass: FooBarComponent,
          template: '<span class="inner">inner</span>'
        });
        this.render('<span class="outer">outer</span>{{component "foo-bar"}}');
        expectDeprecation(function () {
          $span = instance.$('span');
        }, 'Using this.$() in a component has been deprecated, consider using this.element');
        assert.equal($span.length, 1);
        assert.equal($span.attr('class'), 'inner');
        (0, _internalTestHelpers.runTask)(function () {
          return _this24.rerender();
        });
        expectDeprecation(function () {
          $span = instance.$('span');
        }, 'Using this.$() in a component has been deprecated, consider using this.element');
        assert.equal($span.length, 1);
        assert.equal($span.attr('class'), 'inner');
      };

      return _class3;
    }(_internalTestHelpers.RenderingTestCase));
  }
});
enifed("@ember/-internals/glimmer/tests/integration/components/error-handling-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Errors thrown during render',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test it can recover resets the transaction when an error is thrown during initial render'] = function testItCanRecoverResetsTheTransactionWhenAnErrorIsThrownDuringInitialRender(assert) {
      var _this = this;

      var shouldThrow = true;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          if (shouldThrow) {
            throw new Error('silly mistake in init!');
          }
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      assert.throws(function () {
        _this.render('{{#if switch}}{{#foo-bar}}{{foo-bar}}{{/foo-bar}}{{/if}}', {
          switch: true
        });
      }, /silly mistake in init/);
      assert.equal(this.env.inTransaction, false, 'should not be in a transaction even though an error was thrown');
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'switch', false);
      });
      shouldThrow = false;
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'switch', true);
      });
      this.assertText('hello');
    };

    _proto['@skip it can recover resets the transaction when an error is thrown during rerender'] = function skipItCanRecoverResetsTheTransactionWhenAnErrorIsThrownDuringRerender(assert) {
      var _this2 = this;

      var shouldThrow = false;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          if (shouldThrow) {
            throw new Error('silly mistake in init!');
          }
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{#if switch}}{{#foo-bar}}{{foo-bar}}{{/foo-bar}}{{/if}}', {
        switch: true
      });
      this.assertText('hello');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'switch', false);
      });
      shouldThrow = true;
      assert.throws(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(_this2.context, 'switch', true);
        });
      }, /silly mistake in init/);
      assert.equal(this.env.inTransaction, false, 'should not be in a transaction even though an error was thrown');
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'switch', false);
      });
      shouldThrow = false;
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'switch', true);
      });
      this.assertText('hello');
    };

    _proto['@test it can recover resets the transaction when an error is thrown during didInsertElement'] = function testItCanRecoverResetsTheTransactionWhenAnErrorIsThrownDuringDidInsertElement(assert) {
      var _this3 = this;

      var shouldThrow = true;

      var FooBarComponent = _helpers.Component.extend({
        didInsertElement: function () {
          this._super.apply(this, arguments);

          if (shouldThrow) {
            throw new Error('silly mistake!');
          }
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      assert.throws(function () {
        _this3.render('{{#if switch}}{{#foo-bar}}{{foo-bar}}{{/foo-bar}}{{/if}}', {
          switch: true
        });
      }, /silly mistake/);
      assert.equal(this.env.inTransaction, false, 'should not be in a transaction even though an error was thrown');
      this.assertText('hello');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'switch', false);
      });
      this.assertText('');
    };

    _proto['@test it can recover resets the transaction when an error is thrown during destroy'] = function testItCanRecoverResetsTheTransactionWhenAnErrorIsThrownDuringDestroy(assert) {
      var _this4 = this;

      var shouldThrow = true;

      var FooBarComponent = _helpers.Component.extend({
        destroy: function () {
          this._super.apply(this, arguments);

          if (shouldThrow) {
            throw new Error('silly mistake!');
          }
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{#if switch}}{{#foo-bar}}{{foo-bar}}{{/foo-bar}}{{/if}}', {
        switch: true
      });
      this.assertText('hello');
      assert.throws(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(_this4.context, 'switch', false);
        });
      }, /silly mistake/);
      this.assertText('');
      shouldThrow = false;
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'switch', true);
      });
      this.assertText('hello');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/components/fragment-components-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _helpers) {
  "use strict";

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["<!---->bizz"]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["<!---->bar"]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["<div>Hey</div>bar"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('Components test: fragment components',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.getCustomDispatcherEvents = function getCustomDispatcherEvents() {
      return {
        hitDem: 'folks'
      };
    };

    _proto['@test fragments do not render an outer tag'] = function testFragmentsDoNotRenderAnOuterTag() {
      var instance;

      var FooBarComponent = _helpers.Component.extend({
        tagName: '',
        init: function () {
          this._super();

          instance = this;
          this.foo = true;
          this.bar = 'bar';
        }
      });

      var template = "{{#if foo}}<div>Hey</div>{{/if}}{{yield bar}}";
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: template
      });
      this.render("{{#foo-bar as |bar|}}{{bar}}{{/foo-bar}}");
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject()));
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(instance, 'foo', false);
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject2()));
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(instance, 'bar', 'bizz');
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject3()));
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(instance, 'bar', 'bar');
        (0, _metal.set)(instance, 'foo', true);
      });
    };

    _proto['@test throws an error if an event function is defined in a tagless component'] = function testThrowsAnErrorIfAnEventFunctionIsDefinedInATaglessComponent() {
      var _this = this;

      var template = "hit dem folks";

      var FooBarComponent = _helpers.Component.extend({
        tagName: '',
        click: function () {},
        mouseEnter: function () {}
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: template
      });
      expectAssertion(function () {
        _this.render("{{#foo-bar}}{{/foo-bar}}");
      }, /You can not define `click,mouseEnter` function\(s\) to handle DOM event in the .* tagless component since it doesn't have any DOM element./);
    };

    _proto['@test throws an error if a custom defined event function is defined in a tagless component'] = function testThrowsAnErrorIfACustomDefinedEventFunctionIsDefinedInATaglessComponent() {
      var _this2 = this;

      var template = "hit dem folks";

      var FooBarComponent = _helpers.Component.extend({
        tagName: '',
        folks: function () {}
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: template
      });
      expectAssertion(function () {
        _this2.render("{{#foo-bar}}{{/foo-bar}}");
      }, /You can not define `folks` function\(s\) to handle DOM event in the .* tagless component since it doesn't have any DOM element./);
    };

    _proto['@test throws an error if `tagName` is an empty string and `classNameBindings` are specified'] = function testThrowsAnErrorIfTagNameIsAnEmptyStringAndClassNameBindingsAreSpecified() {
      var _this3 = this;

      var template = "hit dem folks";

      var FooBarComponent = _helpers.Component.extend({
        tagName: '',
        foo: true,
        classNameBindings: ['foo:is-foo:is-bar']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: template
      });
      expectAssertion(function () {
        _this3.render("{{#foo-bar}}{{/foo-bar}}");
      }, /You cannot use `classNameBindings` on a tag-less component/);
    };

    _proto['@test throws an error if `tagName` is an empty string and `attributeBindings` are specified'] = function testThrowsAnErrorIfTagNameIsAnEmptyStringAndAttributeBindingsAreSpecified() {
      var _this4 = this;

      var template = "hit dem folks";

      var FooBarComponent = _helpers.Component.extend({
        tagName: '',
        attributeBindings: ['href']
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: template
      });
      expectAssertion(function () {
        _this4.render("{{#foo-bar}}{{/foo-bar}}");
      }, /You cannot use `attributeBindings` on a tag-less component/);
    };

    _proto['@test throws an error if `tagName` is an empty string and `elementId` is specified via JS'] = function testThrowsAnErrorIfTagNameIsAnEmptyStringAndElementIdIsSpecifiedViaJS() {
      var _this5 = this;

      var template = "hit dem folks";

      var FooBarComponent = _helpers.Component.extend({
        tagName: '',
        elementId: 'turntUp'
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: template
      });
      expectAssertion(function () {
        _this5.render("{{#foo-bar}}{{/foo-bar}}");
      }, /You cannot use `elementId` on a tag-less component/);
    };

    _proto['@test throws an error if `tagName` is an empty string and `elementId` is specified via template'] = function testThrowsAnErrorIfTagNameIsAnEmptyStringAndElementIdIsSpecifiedViaTemplate() {
      var _this6 = this;

      var template = "hit dem folks";

      var FooBarComponent = _helpers.Component.extend({
        tagName: ''
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: template
      });
      expectAssertion(function () {
        _this6.render("{{#foo-bar elementId='turntUp'}}{{/foo-bar}}");
      }, /You cannot use `elementId` on a tag-less component/);
    };

    _proto['@test does not throw an error if `tagName` is an empty string and `id` is specified via JS'] = function testDoesNotThrowAnErrorIfTagNameIsAnEmptyStringAndIdIsSpecifiedViaJS() {
      var template = "{{id}}";

      var FooBarComponent = _helpers.Component.extend({
        tagName: '',
        id: 'baz'
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: template
      });
      this.render("{{#foo-bar}}{{/foo-bar}}");
      this.assertText('baz');
    };

    _proto['@test does not throw an error if `tagName` is an empty string and `id` is specified via template'] = function testDoesNotThrowAnErrorIfTagNameIsAnEmptyStringAndIdIsSpecifiedViaTemplate() {
      var template = "{{id}}";

      var FooBarComponent = _helpers.Component.extend({
        tagName: ''
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: template
      });
      this.render("{{#foo-bar id='baz'}}{{/foo-bar}}");
      this.assertText('baz');
    };

    _proto['@test does not throw an error if `tagName` is an empty string and `id` is bound property specified via template'] = function testDoesNotThrowAnErrorIfTagNameIsAnEmptyStringAndIdIsBoundPropertySpecifiedViaTemplate() {
      var _this7 = this;

      var template = "{{id}}";

      var FooBarComponent = _helpers.Component.extend({
        tagName: ''
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: template
      });
      this.render("{{#foo-bar id=fooBarId}}{{/foo-bar}}", {
        fooBarId: 'baz'
      });
      this.assertText('baz');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'fooBarId', 'qux');
      });
      this.assertText('qux');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'fooBarId', 'baz');
      });
      this.assertText('baz');
    };

    _proto['@test does not throw an error if `tagName` is an empty string and `id` is specified via template and passed to child component'] = function testDoesNotThrowAnErrorIfTagNameIsAnEmptyStringAndIdIsSpecifiedViaTemplateAndPassedToChildComponent() {
      var fooBarTemplate = "{{#baz-child id=id}}{{/baz-child}}";

      var FooBarComponent = _helpers.Component.extend({
        tagName: ''
      });

      var BazChildComponent = _helpers.Component.extend();

      var bazChildTemplate = "{{id}}";
      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: fooBarTemplate
      });
      this.registerComponent('baz-child', {
        ComponentClass: BazChildComponent,
        template: bazChildTemplate
      });
      this.render("{{#foo-bar id='baz'}}{{/foo-bar}}");
      this.assertText('baz');
    };

    _proto['@test throws an error if when $() is accessed on component where `tagName` is an empty string'] = function testThrowsAnErrorIfWhen$IsAccessedOnComponentWhereTagNameIsAnEmptyString() {
      var _this8 = this;

      var template = "hit dem folks";

      var FooBarComponent = _helpers.Component.extend({
        tagName: '',
        init: function () {
          this._super();

          this.$();
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: template
      });
      expectAssertion(function () {
        _this8.render("{{#foo-bar}}{{/foo-bar}}");
      }, /You cannot access this.\$\(\) on a component with `tagName: \'\'` specified/);
    };

    _proto['@test renders a contained view with omitted start tag and tagless parent view context'] = function testRendersAContainedViewWithOmittedStartTagAndTaglessParentViewContext() {
      var _this9 = this;

      this.registerComponent('root-component', {
        ComponentClass: _helpers.Component.extend({
          tagName: 'section'
        }),
        template: '{{frag-ment}}'
      });
      this.registerComponent('frag-ment', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '{{my-span}}'
      });
      this.registerComponent('my-span', {
        ComponentClass: _helpers.Component.extend({
          tagName: 'span'
        }),
        template: 'dab'
      });
      this.render("{{root-component}}");
      this.assertElement(this.firstChild, {
        tagName: 'section'
      });
      this.assertElement(this.firstChild.firstElementChild, {
        tagName: 'span'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'section'
      });
      this.assertElement(this.firstChild.firstElementChild, {
        tagName: 'span'
      });
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/components/input-angle-test", ["ember-babel", "internal-test-helpers", "@ember/polyfills", "@ember/-internals/metal", "@ember/-internals/views", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _polyfills, _metal, _views, _helpers) {
  "use strict";

  if (true
  /* EMBER_GLIMMER_ANGLE_BRACKET_BUILT_INS */
  ) {
      var InputRenderingTest =
      /*#__PURE__*/
      function (_RenderingTestCase) {
        (0, _emberBabel.inheritsLoose)(InputRenderingTest, _RenderingTestCase);

        function InputRenderingTest() {
          return _RenderingTestCase.apply(this, arguments) || this;
        }

        var _proto = InputRenderingTest.prototype;

        _proto.$input = function $input() {
          return this.$('input');
        };

        _proto.inputID = function inputID() {
          return this.$input().prop('id');
        };

        _proto.assertDisabled = function assertDisabled() {
          this.assert.ok(this.$('input').prop('disabled'), 'The input is disabled');
        };

        _proto.assertNotDisabled = function assertNotDisabled() {
          this.assert.ok(this.$('input').is(':not(:disabled)'), 'The input is not disabled');
        };

        _proto.assertInputId = function assertInputId(expectedId) {
          this.assert.equal(this.inputID(), expectedId, 'the input id should be `expectedId`');
        };

        _proto.assertSingleInput = function assertSingleInput() {
          this.assert.equal(this.$('input').length, 1, 'A single text field was inserted');
        };

        _proto.assertSingleCheckbox = function assertSingleCheckbox() {
          this.assert.equal(this.$('input[type=checkbox]').length, 1, 'A single checkbox is added');
        };

        _proto.assertCheckboxIsChecked = function assertCheckboxIsChecked() {
          this.assert.equal(this.$input().prop('checked'), true, 'the checkbox is checked');
        };

        _proto.assertCheckboxIsNotChecked = function assertCheckboxIsNotChecked() {
          this.assert.equal(this.$input().prop('checked'), false, 'the checkbox is not checked');
        };

        _proto.assertValue = function assertValue(expected) {
          this.assert.equal(this.$input().val(), expected, "the input value should be " + expected);
        };

        _proto.assertAttr = function assertAttr(name, expected) {
          this.assert.equal(this.$input().attr(name), expected, "the input " + name + " attribute has the value '" + expected + "'");
        };

        _proto.assertAllAttrs = function assertAllAttrs(names, expected) {
          var _this = this;

          names.forEach(function (name) {
            return _this.assertAttr(name, expected);
          });
        };

        _proto.assertSelectionRange = function assertSelectionRange(start, end) {
          var input = this.$input()[0];
          this.assert.equal(input.selectionStart, start, "the cursor start position should be " + start);
          this.assert.equal(input.selectionEnd, end, "the cursor end position should be " + end);
        };

        _proto.triggerEvent = function triggerEvent(type, options, selector) {
          var event = document.createEvent('Events');
          event.initEvent(type, true, true);
          (0, _polyfills.assign)(event, options);
          var element = this.$(selector || 'input')[0];
          (0, _internalTestHelpers.runTask)(function () {
            element.dispatchEvent(event);
          });
        };

        _proto.assertTriggersNativeDOMEvents = function assertTriggersNativeDOMEvents(type) {
          var _this2 = this; // Defaults from EventDispatcher


          var events = {
            touchstart: 'touchStart',
            touchmove: 'touchMove',
            touchend: 'touchEnd',
            touchcancel: 'touchCancel',
            keydown: 'keyDown',
            keyup: 'keyUp',
            keypress: 'keyPress',
            mousedown: 'mouseDown',
            mouseup: 'mouseUp',
            contextmenu: 'contextMenu',
            click: 'click',
            dblclick: 'doubleClick',
            mousemove: 'mouseMove',
            focusin: 'focusIn',
            focusout: 'focusOut',
            mouseenter: 'mouseEnter',
            mouseleave: 'mouseLeave',
            submit: 'submit',
            input: 'input',
            change: 'change',
            dragstart: 'dragStart',
            drag: 'drag',
            dragenter: 'dragEnter',
            dragleave: 'dragLeave',
            dragover: 'dragOver',
            drop: 'drop',
            dragend: 'dragEnd'
          };
          this.registerComponent('test-component', {
            ComponentClass: _helpers.Component.extend({
              tagName: 'input',
              attributeBindings: ['type']
            })
          });
          var triggered = {
            standard: [],
            custom: []
          };
          var actions = {
            didTrigger: function (id, event) {
              triggered[id].push(event);
            }
          };

          function argsFor(id) {
            var args = ["id=\"" + id + "\""];

            if (type) {
              args.push("@type=\"" + type + "\"");
            }

            Object.keys(events).forEach(function (event) {
              args.push("@" + events[event] + "={{action \"didTrigger\" \"" + id + "\" \"" + event + "\"}}");
            });
            return args.join(' ');
          }

          var template = "\n        <Input " + argsFor('standard') + " />\n        <TestComponent " + argsFor('custom') + " />\n      ";
          this.render(template, {
            actions: actions
          });
          this.assert.ok(this.$('input').length === 2);
          var $standard = this.$('#standard');
          var $custom = this.$('#custom');
          this.assert.equal($standard.type, $custom.type);
          Object.keys(events).forEach(function (event) {
            _this2.triggerEvent(event, null, '#standard');

            _this2.triggerEvent(event, null, '#custom');
          });
          this.assert.ok(triggered.standard.length > 10, 'sanity check that most events are triggered (standard)');
          this.assert.ok(triggered.custom.length > 10, 'sanity check that most events are triggered (custom)');
          this.assert.deepEqual(triggered.standard, triggered.custom, 'called for all events');
        };

        return InputRenderingTest;
      }(_internalTestHelpers.RenderingTestCase);

      (0, _internalTestHelpers.moduleFor)('Components test: <Input />',
      /*#__PURE__*/
      function (_InputRenderingTest) {
        (0, _emberBabel.inheritsLoose)(_class, _InputRenderingTest);

        function _class() {
          return _InputRenderingTest.apply(this, arguments) || this;
        }

        var _proto2 = _class.prototype;

        _proto2['@test a single text field is inserted into the DOM'] = function testASingleTextFieldIsInsertedIntoTheDOM() {
          var _this3 = this;

          this.render("<Input @type=\"text\" @value={{value}} />", {
            value: 'hello'
          });
          var id = this.inputID();
          this.assertValue('hello');
          this.assertSingleInput();
          (0, _internalTestHelpers.runTask)(function () {
            return _this3.rerender();
          });
          this.assertValue('hello');
          this.assertSingleInput();
          this.assertInputId(id);
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this3.context, 'value', 'goodbye');
          });
          this.assertValue('goodbye');
          this.assertSingleInput();
          this.assertInputId(id);
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this3.context, 'value', 'hello');
          });
          this.assertValue('hello');
          this.assertSingleInput();
          this.assertInputId(id);
        };

        _proto2['@test default type'] = function testDefaultType() {
          var _this4 = this;

          this.render("<Input />");
          this.assertAttr('type', 'text');
          (0, _internalTestHelpers.runTask)(function () {
            return _this4.rerender();
          });
          this.assertAttr('type', 'text');
        };

        _proto2['@test dynamic attributes (HTML attribute)'] = function testDynamicAttributesHTMLAttribute() {
          var _this5 = this;

          this.render("\n        <Input @type=\"text\" @value={{value}}\n          disabled={{disabled}}\n          placeholder={{placeholder}}\n          name={{name}}\n          maxlength={{maxlength}}\n          minlength={{minlength}}\n          size={{size}}\n          tabindex={{tabindex}}\n        />", {
            value: 'Original value',
            disabled: false,
            placeholder: 'Original placeholder',
            name: 'original-name',
            maxlength: 10,
            minlength: 5,
            size: 20,
            tabindex: 30
          });
          this.assertNotDisabled();
          this.assertValue('Original value');
          this.assertAttr('placeholder', 'Original placeholder');
          this.assertAttr('name', 'original-name');
          this.assertAttr('maxlength', '10');
          this.assertAttr('minlength', '5'); // this.assertAttr('size', '20'); //NOTE: failing in IE  (TEST_SUITE=sauce)
          // this.assertAttr('tabindex', '30'); //NOTE: failing in IE (TEST_SUITE=sauce)

          (0, _internalTestHelpers.runTask)(function () {
            return _this5.rerender();
          });
          this.assertNotDisabled();
          this.assertValue('Original value');
          this.assertAttr('placeholder', 'Original placeholder');
          this.assertAttr('name', 'original-name');
          this.assertAttr('maxlength', '10');
          this.assertAttr('minlength', '5'); // this.assertAttr('size', '20'); //NOTE: failing in IE (TEST_SUITE=sauce)
          // this.assertAttr('tabindex', '30'); //NOTE: failing in IE (TEST_SUITE=sauce)

          (0, _internalTestHelpers.runTask)(function () {
            (0, _metal.set)(_this5.context, 'value', 'Updated value');
            (0, _metal.set)(_this5.context, 'disabled', true);
            (0, _metal.set)(_this5.context, 'placeholder', 'Updated placeholder');
            (0, _metal.set)(_this5.context, 'name', 'updated-name');
            (0, _metal.set)(_this5.context, 'maxlength', 11);
            (0, _metal.set)(_this5.context, 'minlength', 6); // set(this.context, 'size', 21); //NOTE: failing in IE (TEST_SUITE=sauce)
            // set(this.context, 'tabindex', 31); //NOTE: failing in IE (TEST_SUITE=sauce)
          });
          this.assertDisabled();
          this.assertValue('Updated value');
          this.assertAttr('placeholder', 'Updated placeholder');
          this.assertAttr('name', 'updated-name');
          this.assertAttr('maxlength', '11');
          this.assertAttr('minlength', '6'); // this.assertAttr('size', '21'); //NOTE: failing in IE (TEST_SUITE=sauce)
          // this.assertAttr('tabindex', '31'); //NOTE: failing in IE (TEST_SUITE=sauce)

          (0, _internalTestHelpers.runTask)(function () {
            (0, _metal.set)(_this5.context, 'value', 'Original value');
            (0, _metal.set)(_this5.context, 'disabled', false);
            (0, _metal.set)(_this5.context, 'placeholder', 'Original placeholder');
            (0, _metal.set)(_this5.context, 'name', 'original-name');
            (0, _metal.set)(_this5.context, 'maxlength', 10);
            (0, _metal.set)(_this5.context, 'minlength', 5); // set(this.context, 'size', 20); //NOTE: failing in IE (TEST_SUITE=sauce)
            // set(this.context, 'tabindex', 30); //NOTE: failing in IE (TEST_SUITE=sauce)
          });
          this.assertNotDisabled();
          this.assertValue('Original value');
          this.assertAttr('placeholder', 'Original placeholder');
          this.assertAttr('name', 'original-name');
          this.assertAttr('maxlength', '10');
          this.assertAttr('minlength', '5'); // this.assertAttr('size', '20'); //NOTE: failing in IE (TEST_SUITE=sauce)
          // this.assertAttr('tabindex', '30'); //NOTE: failing in IE (TEST_SUITE=sauce)
        };

        _proto2['@test dynamic attributes (named argument)'] = function testDynamicAttributesNamedArgument() {
          var _this6 = this;

          this.render("\n        <Input @type=\"text\" @value={{value}}\n          @disabled={{disabled}}\n          @placeholder={{placeholder}}\n          @name={{name}}\n          @maxlength={{maxlength}}\n          @minlength={{minlength}}\n          @size={{size}}\n          @tabindex={{tabindex}}\n        />", {
            value: 'Original value',
            disabled: false,
            placeholder: 'Original placeholder',
            name: 'original-name',
            maxlength: 10,
            minlength: 5,
            size: 20,
            tabindex: 30
          });
          this.assertNotDisabled();
          this.assertValue('Original value');
          this.assertAttr('placeholder', 'Original placeholder');
          this.assertAttr('name', 'original-name');
          this.assertAttr('maxlength', '10');
          this.assertAttr('minlength', '5'); // this.assertAttr('size', '20'); //NOTE: failing in IE  (TEST_SUITE=sauce)
          // this.assertAttr('tabindex', '30'); //NOTE: failing in IE (TEST_SUITE=sauce)

          (0, _internalTestHelpers.runTask)(function () {
            return _this6.rerender();
          });
          this.assertNotDisabled();
          this.assertValue('Original value');
          this.assertAttr('placeholder', 'Original placeholder');
          this.assertAttr('name', 'original-name');
          this.assertAttr('maxlength', '10');
          this.assertAttr('minlength', '5'); // this.assertAttr('size', '20'); //NOTE: failing in IE (TEST_SUITE=sauce)
          // this.assertAttr('tabindex', '30'); //NOTE: failing in IE (TEST_SUITE=sauce)

          (0, _internalTestHelpers.runTask)(function () {
            (0, _metal.set)(_this6.context, 'value', 'Updated value');
            (0, _metal.set)(_this6.context, 'disabled', true);
            (0, _metal.set)(_this6.context, 'placeholder', 'Updated placeholder');
            (0, _metal.set)(_this6.context, 'name', 'updated-name');
            (0, _metal.set)(_this6.context, 'maxlength', 11);
            (0, _metal.set)(_this6.context, 'minlength', 6); // set(this.context, 'size', 21); //NOTE: failing in IE (TEST_SUITE=sauce)
            // set(this.context, 'tabindex', 31); //NOTE: failing in IE (TEST_SUITE=sauce)
          });
          this.assertDisabled();
          this.assertValue('Updated value');
          this.assertAttr('placeholder', 'Updated placeholder');
          this.assertAttr('name', 'updated-name');
          this.assertAttr('maxlength', '11');
          this.assertAttr('minlength', '6'); // this.assertAttr('size', '21'); //NOTE: failing in IE (TEST_SUITE=sauce)
          // this.assertAttr('tabindex', '31'); //NOTE: failing in IE (TEST_SUITE=sauce)

          (0, _internalTestHelpers.runTask)(function () {
            (0, _metal.set)(_this6.context, 'value', 'Original value');
            (0, _metal.set)(_this6.context, 'disabled', false);
            (0, _metal.set)(_this6.context, 'placeholder', 'Original placeholder');
            (0, _metal.set)(_this6.context, 'name', 'original-name');
            (0, _metal.set)(_this6.context, 'maxlength', 10);
            (0, _metal.set)(_this6.context, 'minlength', 5); // set(this.context, 'size', 20); //NOTE: failing in IE (TEST_SUITE=sauce)
            // set(this.context, 'tabindex', 30); //NOTE: failing in IE (TEST_SUITE=sauce)
          });
          this.assertNotDisabled();
          this.assertValue('Original value');
          this.assertAttr('placeholder', 'Original placeholder');
          this.assertAttr('name', 'original-name');
          this.assertAttr('maxlength', '10');
          this.assertAttr('minlength', '5'); // this.assertAttr('size', '20'); //NOTE: failing in IE (TEST_SUITE=sauce)
          // this.assertAttr('tabindex', '30'); //NOTE: failing in IE (TEST_SUITE=sauce)
        };

        _proto2['@test static attributes (HTML attribute)'] = function testStaticAttributesHTMLAttribute() {
          var _this7 = this;

          this.render("\n        <Input @type=\"text\" @value=\"Original value\"\n          disabled=\"disabled\"\n          placeholder=\"Original placeholder\"\n          name=\"original-name\"\n          maxlength=\"10\"\n          minlength=\"5\"\n          size=\"20\"\n          tabindex=\"30\"\n        />");
          this.assertDisabled();
          this.assertValue('Original value');
          this.assertAttr('placeholder', 'Original placeholder');
          this.assertAttr('name', 'original-name');
          this.assertAttr('maxlength', '10');
          this.assertAttr('minlength', '5'); // this.assertAttr('size', '20');  //NOTE: failing in IE (TEST_SUITE=sauce)
          // this.assertAttr('tabindex', '30');  //NOTE: failing in IE (TEST_SUITE=sauce)

          (0, _internalTestHelpers.runTask)(function () {
            return _this7.rerender();
          });
          this.assertDisabled();
          this.assertValue('Original value');
          this.assertAttr('placeholder', 'Original placeholder');
          this.assertAttr('name', 'original-name');
          this.assertAttr('maxlength', '10');
          this.assertAttr('minlength', '5'); // this.assertAttr('size', '20');  //NOTE: failing in IE (TEST_SUITE=sauce)
          // this.assertAttr('tabindex', '30');  //NOTE: failing in IE (TEST_SUITE=sauce)
        };

        _proto2['@test static attributes (named argument)'] = function testStaticAttributesNamedArgument() {
          var _this8 = this;

          this.render("\n        <Input @type=\"text\" @value=\"Original value\"\n          @disabled={{true}}\n          @placeholder=\"Original placeholder\"\n          @name=\"original-name\"\n          @maxlength={{10}}\n          @minlength={{5}}\n          @size={{20}}\n          @tabindex={{30}}\n        />");
          this.assertDisabled();
          this.assertValue('Original value');
          this.assertAttr('placeholder', 'Original placeholder');
          this.assertAttr('name', 'original-name');
          this.assertAttr('maxlength', '10');
          this.assertAttr('minlength', '5'); // this.assertAttr('size', '20');  //NOTE: failing in IE (TEST_SUITE=sauce)
          // this.assertAttr('tabindex', '30');  //NOTE: failing in IE (TEST_SUITE=sauce)

          (0, _internalTestHelpers.runTask)(function () {
            return _this8.rerender();
          });
          this.assertDisabled();
          this.assertValue('Original value');
          this.assertAttr('placeholder', 'Original placeholder');
          this.assertAttr('name', 'original-name');
          this.assertAttr('maxlength', '10');
          this.assertAttr('minlength', '5'); // this.assertAttr('size', '20');  //NOTE: failing in IE (TEST_SUITE=sauce)
          // this.assertAttr('tabindex', '30');  //NOTE: failing in IE (TEST_SUITE=sauce)
        };

        _proto2['@test cursor selection range'] = function testCursorSelectionRange() {
          var _this9 = this; // Modifying input.selectionStart, which is utilized in the cursor tests,
          // causes an event in Safari.


          (0, _internalTestHelpers.runDestroy)(this.owner.lookup('event_dispatcher:main'));
          this.render("<Input @type=\"text\" @value={{value}} />", {
            value: 'original'
          });
          var input = this.$input()[0]; // See https://ember-twiddle.com/33e506329f8176ae874422644d4cc08c?openFiles=components.input-component.js%2Ctemplates.components.input-component.hbs
          // this.assertSelectionRange(8, 8); //NOTE: this is (0, 0) on Firefox (TEST_SUITE=sauce)

          (0, _internalTestHelpers.runTask)(function () {
            return _this9.rerender();
          }); // this.assertSelectionRange(8, 8); //NOTE: this is (0, 0) on Firefox (TEST_SUITE=sauce)

          (0, _internalTestHelpers.runTask)(function () {
            input.selectionStart = 2;
            input.selectionEnd = 4;
          });
          this.assertSelectionRange(2, 4);
          (0, _internalTestHelpers.runTask)(function () {
            return _this9.rerender();
          });
          this.assertSelectionRange(2, 4); // runTask(() => set(this.context, 'value', 'updated'));
          //
          // this.assertSelectionRange(7, 7); //NOTE: this fails in IE, the range is 0 -> 0 (TEST_SUITE=sauce)
          //
          // runTask(() => set(this.context, 'value', 'original'));
          //
          // this.assertSelectionRange(8, 8); //NOTE: this fails in IE, the range is 0 -> 0 (TEST_SUITE=sauce)
        };

        _proto2['@test [DEPRECATED] sends an action with `<Input @enter="foo" />` when <enter> is pressed'] = function testDEPRECATEDSendsAnActionWithInputEnterFooWhenEnterIsPressed(assert) {
          var _this10 = this;

          assert.expect(4);
          expectDeprecation(function () {
            _this10.render("<Input @enter=\"foo\" />", {
              actions: {
                foo: function (value, event) {
                  assert.ok(true, 'action was triggered');

                  if (_views.jQueryDisabled) {
                    assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
                  } else {
                    assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
                  }
                }
              }
            });
          }, 'Passing actions to components as strings (like `<Input @enter="foo" />`) is deprecated. Please use closure actions instead (`<Input @enter={{action "foo"}} />`). (\'-top-level\' @ L1:C0) ');
          expectDeprecation(function () {
            _this10.triggerEvent('keyup', {
              keyCode: 13
            });
          }, 'Passing actions to components as strings (like `<Input @enter="foo" />`) is deprecated. Please use closure actions instead (`<Input @enter={{action "foo"}} />`).');
        };

        _proto2['@test sends an action with `<Input @enter={{action "foo"}} />` when <enter> is pressed'] = function testSendsAnActionWithInputEnterActionFooWhenEnterIsPressed(assert) {
          assert.expect(2);
          this.render("<Input @enter={{action 'foo'}} />", {
            actions: {
              foo: function (value, event) {
                assert.ok(true, 'action was triggered');

                if (_views.jQueryDisabled) {
                  assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
                } else {
                  assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
                }
              }
            }
          });
          this.triggerEvent('keyup', {
            keyCode: 13
          });
        };

        _proto2['@test [DEPRECATED] sends an action with `<Input @key-press="foo" />` is pressed'] = function testDEPRECATEDSendsAnActionWithInputKeyPressFooIsPressed(assert) {
          var _this11 = this;

          assert.expect(4);
          expectDeprecation(function () {
            _this11.render("<Input @value={{value}} @key-press='foo' />", {
              value: 'initial',
              actions: {
                foo: function (value, event) {
                  assert.ok(true, 'action was triggered');

                  if (_views.jQueryDisabled) {
                    assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
                  } else {
                    assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
                  }
                }
              }
            });
          }, 'Passing actions to components as strings (like `<Input @key-press="foo" />`) is deprecated. Please use closure actions instead (`<Input @key-press={{action "foo"}} />`). (\'-top-level\' @ L1:C0) ');
          expectDeprecation(function () {
            _this11.triggerEvent('keypress', {
              keyCode: 65
            });
          }, 'Passing actions to components as strings (like `<Input @key-press="foo" />`) is deprecated. Please use closure actions instead (`<Input @key-press={{action "foo"}} />`).');
        };

        _proto2['@test sends an action with `<Input @key-press={{action "foo"}} />` is pressed'] = function testSendsAnActionWithInputKeyPressActionFooIsPressed(assert) {
          assert.expect(2);
          this.render("<Input @value={{value}} @key-press={{action 'foo'}} />", {
            value: 'initial',
            actions: {
              foo: function (value, event) {
                assert.ok(true, 'action was triggered');

                if (_views.jQueryDisabled) {
                  assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
                } else {
                  assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
                }
              }
            }
          });
          this.triggerEvent('keypress', {
            keyCode: 65
          });
        };

        _proto2['@test sends an action to the parent level when `bubbles=true` is provided'] = function testSendsAnActionToTheParentLevelWhenBubblesTrueIsProvided(assert) {
          assert.expect(1);

          var ParentComponent = _helpers.Component.extend({
            change: function () {
              assert.ok(true, 'bubbled upwards');
            }
          });

          this.registerComponent('parent', {
            ComponentClass: ParentComponent,
            template: "<Input @bubbles={{true}} />"
          });
          this.render("<Parent />");
          this.triggerEvent('change');
        };

        _proto2['@test triggers `focus-in` when focused'] = function testTriggersFocusInWhenFocused(assert) {
          var _this12 = this;

          var wasFocused = false;
          this.render("<Input @focus-in={{action 'foo'}} />", {
            actions: {
              foo: function () {
                wasFocused = true;
              }
            }
          });
          (0, _internalTestHelpers.runTask)(function () {
            _this12.$input().focus();
          });
          assert.ok(wasFocused, 'action was triggered');
        };

        _proto2['@test sends `insert-newline` when <enter> is pressed'] = function testSendsInsertNewlineWhenEnterIsPressed(assert) {
          assert.expect(2);
          this.render("<Input @insert-newline={{action 'foo'}} />", {
            actions: {
              foo: function (value, event) {
                assert.ok(true, 'action was triggered');

                if (_views.jQueryDisabled) {
                  assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
                } else {
                  assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
                }
              }
            }
          });
          this.triggerEvent('keyup', {
            keyCode: 13
          });
        };

        _proto2['@test [DEPRECATED] sends an action with `<Input @escape-press="foo" />` when <escape> is pressed'] = function testDEPRECATEDSendsAnActionWithInputEscapePressFooWhenEscapeIsPressed(assert) {
          var _this13 = this;

          assert.expect(4);
          expectDeprecation(function () {
            _this13.render("<Input @escape-press='foo' />", {
              actions: {
                foo: function (value, event) {
                  assert.ok(true, 'action was triggered');

                  if (_views.jQueryDisabled) {
                    assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
                  } else {
                    assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
                  }
                }
              }
            });
          }, 'Passing actions to components as strings (like `<Input @escape-press="foo" />`) is deprecated. Please use closure actions instead (`<Input @escape-press={{action "foo"}} />`). (\'-top-level\' @ L1:C0) ');
          expectDeprecation(function () {
            _this13.triggerEvent('keyup', {
              keyCode: 27
            });
          }, 'Passing actions to components as strings (like `<Input @escape-press="foo" />`) is deprecated. Please use closure actions instead (`<Input @escape-press={{action "foo"}} />`).');
        };

        _proto2['@test sends an action with `<Input @escape-press={{action "foo"}} />` when <escape> is pressed'] = function testSendsAnActionWithInputEscapePressActionFooWhenEscapeIsPressed(assert) {
          assert.expect(2);
          this.render("<Input @escape-press={{action 'foo'}} />", {
            actions: {
              foo: function (value, event) {
                assert.ok(true, 'action was triggered');

                if (_views.jQueryDisabled) {
                  assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
                } else {
                  assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
                }
              }
            }
          });
          this.triggerEvent('keyup', {
            keyCode: 27
          });
        };

        _proto2['@test [DEPRECATED] sends an action with `<Input @key-down="foo" />` when a key is pressed'] = function testDEPRECATEDSendsAnActionWithInputKeyDownFooWhenAKeyIsPressed(assert) {
          var _this14 = this;

          assert.expect(4);
          expectDeprecation(function () {
            _this14.render("<Input @key-down='foo' />", {
              actions: {
                foo: function (value, event) {
                  assert.ok(true, 'action was triggered');

                  if (_views.jQueryDisabled) {
                    assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
                  } else {
                    assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
                  }
                }
              }
            });
          }, 'Passing actions to components as strings (like `<Input @key-down="foo" />`) is deprecated. Please use closure actions instead (`<Input @key-down={{action "foo"}} />`). (\'-top-level\' @ L1:C0) ');
          expectDeprecation(function () {
            _this14.triggerEvent('keydown', {
              keyCode: 65
            });
          }, 'Passing actions to components as strings (like `<Input @key-down="foo" />`) is deprecated. Please use closure actions instead (`<Input @key-down={{action "foo"}} />`).');
        };

        _proto2['@test sends an action with `<Input @key-down={{action "foo"}} />` when a key is pressed'] = function testSendsAnActionWithInputKeyDownActionFooWhenAKeyIsPressed(assert) {
          assert.expect(2);
          this.render("<Input @key-down={{action 'foo'}} />", {
            actions: {
              foo: function (value, event) {
                assert.ok(true, 'action was triggered');

                if (_views.jQueryDisabled) {
                  assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
                } else {
                  assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
                }
              }
            }
          });
          this.triggerEvent('keydown', {
            keyCode: 65
          });
        };

        _proto2['@test [DEPRECATED] sends an action with `<Input @key-up="foo" />` when a key is pressed'] = function testDEPRECATEDSendsAnActionWithInputKeyUpFooWhenAKeyIsPressed(assert) {
          var _this15 = this;

          assert.expect(4);
          expectDeprecation(function () {
            _this15.render("<Input @key-up='foo' />", {
              actions: {
                foo: function (value, event) {
                  assert.ok(true, 'action was triggered');

                  if (_views.jQueryDisabled) {
                    assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
                  } else {
                    assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
                  }
                }
              }
            });
          }, 'Passing actions to components as strings (like `<Input @key-up="foo" />`) is deprecated. Please use closure actions instead (`<Input @key-up={{action "foo"}} />`). (\'-top-level\' @ L1:C0) ');
          expectDeprecation(function () {
            _this15.triggerEvent('keyup', {
              keyCode: 65
            });
          }, 'Passing actions to components as strings (like `<Input @key-up="foo" />`) is deprecated. Please use closure actions instead (`<Input @key-up={{action "foo"}} />`).');
        };

        _proto2['@test sends an action with `<Input @key-up={{action "foo"}} />` when a key is pressed'] = function testSendsAnActionWithInputKeyUpActionFooWhenAKeyIsPressed(assert) {
          assert.expect(2);
          this.render("<Input @key-up={{action 'foo'}} />", {
            actions: {
              foo: function (value, event) {
                assert.ok(true, 'action was triggered');

                if (_views.jQueryDisabled) {
                  assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
                } else {
                  assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
                }
              }
            }
          });
          this.triggerEvent('keyup', {
            keyCode: 65
          });
        };

        _proto2['@test GH#14727 can render a file input after having had render an input of other type'] = function testGH14727CanRenderAFileInputAfterHavingHadRenderAnInputOfOtherType() {
          this.render("<Input @type=\"text\" /><Input @type=\"file\" />");
          this.assert.equal(this.$input()[0].type, 'text');
          this.assert.equal(this.$input()[1].type, 'file');
        };

        _proto2['@test sends an action with `<Input EVENT={{action "foo"}} />` for native DOM events'] = function testSendsAnActionWithInputEVENTActionFooForNativeDOMEvents() {
          this.assertTriggersNativeDOMEvents();
        };

        return _class;
      }(InputRenderingTest));
      (0, _internalTestHelpers.moduleFor)('Components test: <Input /> with dynamic type',
      /*#__PURE__*/
      function (_InputRenderingTest2) {
        (0, _emberBabel.inheritsLoose)(_class2, _InputRenderingTest2);

        function _class2() {
          return _InputRenderingTest2.apply(this, arguments) || this;
        }

        var _proto3 = _class2.prototype;

        _proto3['@test a bound property can be used to determine type'] = function testABoundPropertyCanBeUsedToDetermineType() {
          var _this16 = this;

          this.render("<Input @type={{type}} />", {
            type: 'password'
          });
          this.assertAttr('type', 'password');
          (0, _internalTestHelpers.runTask)(function () {
            return _this16.rerender();
          });
          this.assertAttr('type', 'password');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this16.context, 'type', 'text');
          });
          this.assertAttr('type', 'text');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this16.context, 'type', 'password');
          });
          this.assertAttr('type', 'password');
        };

        _proto3['@test a subexpression can be used to determine type'] = function testASubexpressionCanBeUsedToDetermineType() {
          var _this17 = this;

          this.render("<Input @type={{if isTruthy trueType falseType}} />", {
            isTruthy: true,
            trueType: 'text',
            falseType: 'password'
          });
          this.assertAttr('type', 'text');
          (0, _internalTestHelpers.runTask)(function () {
            return _this17.rerender();
          });
          this.assertAttr('type', 'text');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this17.context, 'isTruthy', false);
          });
          this.assertAttr('type', 'password');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this17.context, 'isTruthy', true);
          });
          this.assertAttr('type', 'text');
        };

        _proto3['@test GH16256 input macro does not modify params in place'] = function testGH16256InputMacroDoesNotModifyParamsInPlace() {
          this.registerComponent('my-input', {
            template: "<Input @type={{inputType}} />"
          });
          this.render("<MyInput @inputType={{firstType}} /><MyInput @inputType={{secondType}} />", {
            firstType: 'password',
            secondType: 'email'
          });
          var inputs = this.element.querySelectorAll('input');
          this.assert.equal(inputs.length, 2, 'there are two inputs');
          this.assert.equal(inputs[0].getAttribute('type'), 'password');
          this.assert.equal(inputs[1].getAttribute('type'), 'email');
        };

        return _class2;
      }(InputRenderingTest));
      (0, _internalTestHelpers.moduleFor)("Components test: <Input @type='checkbox' />",
      /*#__PURE__*/
      function (_InputRenderingTest3) {
        (0, _emberBabel.inheritsLoose)(_class3, _InputRenderingTest3);

        function _class3() {
          return _InputRenderingTest3.apply(this, arguments) || this;
        }

        var _proto4 = _class3.prototype;

        _proto4['@test dynamic attributes (HTML attribute)'] = function testDynamicAttributesHTMLAttribute() {
          var _this18 = this;

          this.render("<Input @type='checkbox' @checked={{checked}}\n            disabled={{disabled}}\n            name={{name}}\n            tabindex={{tabindex}}\n          />", {
            disabled: false,
            name: 'original-name',
            checked: false,
            tabindex: 10
          });
          this.assertSingleCheckbox();
          this.assertNotDisabled();
          this.assertAttr('name', 'original-name');
          this.assertAttr('tabindex', '10');
          (0, _internalTestHelpers.runTask)(function () {
            return _this18.rerender();
          });
          this.assertSingleCheckbox();
          this.assertNotDisabled();
          this.assertAttr('name', 'original-name');
          this.assertAttr('tabindex', '10');
          (0, _internalTestHelpers.runTask)(function () {
            (0, _metal.set)(_this18.context, 'disabled', true);
            (0, _metal.set)(_this18.context, 'name', 'updated-name');
            (0, _metal.set)(_this18.context, 'tabindex', 11);
          });
          this.assertSingleCheckbox();
          this.assertDisabled();
          this.assertAttr('name', 'updated-name');
          this.assertAttr('tabindex', '11');
          (0, _internalTestHelpers.runTask)(function () {
            (0, _metal.set)(_this18.context, 'disabled', false);
            (0, _metal.set)(_this18.context, 'name', 'original-name');
            (0, _metal.set)(_this18.context, 'tabindex', 10);
          });
          this.assertSingleCheckbox();
          this.assertNotDisabled();
          this.assertAttr('name', 'original-name');
          this.assertAttr('tabindex', '10');
        };

        _proto4['@test dynamic attributes (named argument)'] = function testDynamicAttributesNamedArgument() {
          var _this19 = this;

          this.render("<Input @type='checkbox' @checked={{checked}}\n            @disabled={{disabled}}\n            @name={{name}}\n            @tabindex={{tabindex}}\n          />", {
            disabled: false,
            name: 'original-name',
            checked: false,
            tabindex: 10
          });
          this.assertSingleCheckbox();
          this.assertNotDisabled();
          this.assertAttr('name', 'original-name');
          this.assertAttr('tabindex', '10');
          (0, _internalTestHelpers.runTask)(function () {
            return _this19.rerender();
          });
          this.assertSingleCheckbox();
          this.assertNotDisabled();
          this.assertAttr('name', 'original-name');
          this.assertAttr('tabindex', '10');
          (0, _internalTestHelpers.runTask)(function () {
            (0, _metal.set)(_this19.context, 'disabled', true);
            (0, _metal.set)(_this19.context, 'name', 'updated-name');
            (0, _metal.set)(_this19.context, 'tabindex', 11);
          });
          this.assertSingleCheckbox();
          this.assertDisabled();
          this.assertAttr('name', 'updated-name');
          this.assertAttr('tabindex', '11');
          (0, _internalTestHelpers.runTask)(function () {
            (0, _metal.set)(_this19.context, 'disabled', false);
            (0, _metal.set)(_this19.context, 'name', 'original-name');
            (0, _metal.set)(_this19.context, 'tabindex', 10);
          });
          this.assertSingleCheckbox();
          this.assertNotDisabled();
          this.assertAttr('name', 'original-name');
          this.assertAttr('tabindex', '10');
        };

        _proto4['@test `value` property assertion'] = function testValuePropertyAssertion() {
          var _this20 = this;

          expectAssertion(function () {
            _this20.render("<Input @type=\"checkbox\" @value={{value}} />", {
              value: 'value'
            });
          }, /checkbox.+@value.+not supported.+use.+@checked.+instead/);
        };

        _proto4['@test with a bound type'] = function testWithABoundType() {
          var _this21 = this;

          this.render("<Input @type={{inputType}} @checked={{isChecked}} />", {
            inputType: 'checkbox',
            isChecked: true
          });
          this.assertSingleCheckbox();
          this.assertCheckboxIsChecked();
          (0, _internalTestHelpers.runTask)(function () {
            return _this21.rerender();
          });
          this.assertCheckboxIsChecked();
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this21.context, 'isChecked', false);
          });
          this.assertCheckboxIsNotChecked();
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this21.context, 'isChecked', true);
          });
          this.assertCheckboxIsChecked();
        };

        _proto4['@test native click changes check property'] = function testNativeClickChangesCheckProperty() {
          this.render("<Input @type=\"checkbox\" />");
          this.assertSingleCheckbox();
          this.assertCheckboxIsNotChecked();
          this.$input()[0].click();
          this.assertCheckboxIsChecked();
          this.$input()[0].click();
          this.assertCheckboxIsNotChecked();
        };

        _proto4['@test with static values (HTML attribute)'] = function testWithStaticValuesHTMLAttribute() {
          var _this22 = this;

          this.render("<Input @type=\"checkbox\" @checked={{false}} disabled={{false}} tabindex=\"10\" name=\"original-name\" />");
          this.assertSingleCheckbox();
          this.assertCheckboxIsNotChecked();
          this.assertNotDisabled();
          this.assertAttr('tabindex', '10');
          this.assertAttr('name', 'original-name');
          (0, _internalTestHelpers.runTask)(function () {
            return _this22.rerender();
          });
          this.assertSingleCheckbox();
          this.assertCheckboxIsNotChecked();
          this.assertNotDisabled();
          this.assertAttr('tabindex', '10');
          this.assertAttr('name', 'original-name');
        };

        _proto4['@test with static values (named argument)'] = function testWithStaticValuesNamedArgument() {
          var _this23 = this;

          this.render("<Input @type=\"checkbox\" @checked={{false}} @disabled={{false}} @tabindex={{10}} @name=\"original-name\" />");
          this.assertSingleCheckbox();
          this.assertCheckboxIsNotChecked();
          this.assertNotDisabled();
          this.assertAttr('tabindex', '10');
          this.assertAttr('name', 'original-name');
          (0, _internalTestHelpers.runTask)(function () {
            return _this23.rerender();
          });
          this.assertSingleCheckbox();
          this.assertCheckboxIsNotChecked();
          this.assertNotDisabled();
          this.assertAttr('tabindex', '10');
          this.assertAttr('name', 'original-name');
        };

        _proto4['@test sends an action with `<Input EVENT={{action "foo"}} />` for native DOM events'] = function testSendsAnActionWithInputEVENTActionFooForNativeDOMEvents() {
          this.assertTriggersNativeDOMEvents('checkbox');
        };

        return _class3;
      }(InputRenderingTest));
      (0, _internalTestHelpers.moduleFor)("Components test: <Input @type='text' />",
      /*#__PURE__*/
      function (_InputRenderingTest4) {
        (0, _emberBabel.inheritsLoose)(_class4, _InputRenderingTest4);

        function _class4() {
          return _InputRenderingTest4.apply(this, arguments) || this;
        }

        var _proto5 = _class4.prototype;

        _proto5['@test null values (HTML attribute)'] = function testNullValuesHTMLAttribute() {
          var _this24 = this;

          var attributes = ['disabled', 'placeholder', 'name', 'maxlength', 'size', 'tabindex'];
          this.render("\n        <Input @type=\"text\" @value={{value}}\n          disabled={{disabled}}\n          placeholder={{placeholder}}\n          name={{name}}\n          maxlength={{maxlength}}\n          size={{size}}\n          tabindex={{tabindex}}\n        />", {
            value: null,
            disabled: null,
            placeholder: null,
            name: null,
            maxlength: null,
            size: null,
            tabindex: null
          });
          this.assertValue('');
          this.assertAllAttrs(attributes, undefined);
          (0, _internalTestHelpers.runTask)(function () {
            return _this24.rerender();
          });
          this.assertValue('');
          this.assertAllAttrs(attributes, undefined);
          (0, _internalTestHelpers.runTask)(function () {
            (0, _metal.set)(_this24.context, 'disabled', true);
            (0, _metal.set)(_this24.context, 'value', 'Updated value');
            (0, _metal.set)(_this24.context, 'placeholder', 'Updated placeholder');
            (0, _metal.set)(_this24.context, 'name', 'updated-name');
            (0, _metal.set)(_this24.context, 'maxlength', 11);
            (0, _metal.set)(_this24.context, 'size', 21);
            (0, _metal.set)(_this24.context, 'tabindex', 31);
          });
          this.assertDisabled();
          this.assertValue('Updated value');
          this.assertAttr('placeholder', 'Updated placeholder');
          this.assertAttr('name', 'updated-name');
          this.assertAttr('maxlength', '11');
          this.assertAttr('size', '21');
          this.assertAttr('tabindex', '31');
          (0, _internalTestHelpers.runTask)(function () {
            (0, _metal.set)(_this24.context, 'disabled', null);
            (0, _metal.set)(_this24.context, 'value', null);
            (0, _metal.set)(_this24.context, 'placeholder', null);
            (0, _metal.set)(_this24.context, 'name', null);
            (0, _metal.set)(_this24.context, 'maxlength', null); // set(this.context, 'size', null); //NOTE: this fails with `Error: Failed to set the 'size' property on 'HTMLInputElement': The value provided is 0, which is an invalid size.` (TEST_SUITE=sauce)

            (0, _metal.set)(_this24.context, 'tabindex', null);
          });
          this.assertAttr('disabled', undefined);
          this.assertValue(''); // this.assertAttr('placeholder', undefined); //NOTE: this fails with a value of "null" (TEST_SUITE=sauce)
          // this.assertAttr('name', undefined); //NOTE: this fails with a value of "null" (TEST_SUITE=sauce)

          this.assertAttr('maxlength', undefined); // this.assertAttr('size', undefined); //NOTE: re-enable once `size` bug above has been addressed

          this.assertAttr('tabindex', undefined);
        };

        _proto5['@test null values (named argument)'] = function testNullValuesNamedArgument() {
          var _this25 = this;

          var attributes = ['disabled', 'placeholder', 'name', 'maxlength', 'size', 'tabindex'];
          this.render("\n        <Input @type=\"text\" @value={{value}}\n          @disabled={{disabled}}\n          @placeholder={{placeholder}}\n          @name={{name}}\n          @maxlength={{maxlength}}\n          @size={{size}}\n          @tabindex={{tabindex}}\n        />", {
            value: null,
            disabled: null,
            placeholder: null,
            name: null,
            maxlength: null,
            size: null,
            tabindex: null
          });
          this.assertValue('');
          this.assertAllAttrs(attributes, undefined);
          (0, _internalTestHelpers.runTask)(function () {
            return _this25.rerender();
          });
          this.assertValue('');
          this.assertAllAttrs(attributes, undefined);
          (0, _internalTestHelpers.runTask)(function () {
            (0, _metal.set)(_this25.context, 'disabled', true);
            (0, _metal.set)(_this25.context, 'value', 'Updated value');
            (0, _metal.set)(_this25.context, 'placeholder', 'Updated placeholder');
            (0, _metal.set)(_this25.context, 'name', 'updated-name');
            (0, _metal.set)(_this25.context, 'maxlength', 11);
            (0, _metal.set)(_this25.context, 'size', 21);
            (0, _metal.set)(_this25.context, 'tabindex', 31);
          });
          this.assertDisabled();
          this.assertValue('Updated value');
          this.assertAttr('placeholder', 'Updated placeholder');
          this.assertAttr('name', 'updated-name');
          this.assertAttr('maxlength', '11');
          this.assertAttr('size', '21');
          this.assertAttr('tabindex', '31');
          (0, _internalTestHelpers.runTask)(function () {
            (0, _metal.set)(_this25.context, 'disabled', null);
            (0, _metal.set)(_this25.context, 'value', null);
            (0, _metal.set)(_this25.context, 'placeholder', null);
            (0, _metal.set)(_this25.context, 'name', null);
            (0, _metal.set)(_this25.context, 'maxlength', null); // set(this.context, 'size', null); //NOTE: this fails with `Error: Failed to set the 'size' property on 'HTMLInputElement': The value provided is 0, which is an invalid size.` (TEST_SUITE=sauce)

            (0, _metal.set)(_this25.context, 'tabindex', null);
          });
          this.assertAttr('disabled', undefined);
          this.assertValue(''); // this.assertAttr('placeholder', undefined); //NOTE: this fails with a value of "null" (TEST_SUITE=sauce)
          // this.assertAttr('name', undefined); //NOTE: this fails with a value of "null" (TEST_SUITE=sauce)

          this.assertAttr('maxlength', undefined); // this.assertAttr('size', undefined); //NOTE: re-enable once `size` bug above has been addressed

          this.assertAttr('tabindex', undefined);
        };

        return _class4;
      }(InputRenderingTest)); // These are the permutations of the set:
      // ['type="range"', 'min="-5" max="50"', value="%x"']

      [// HTML attribute
      '@type="range" min="-5" max="50" @value="%x"', '@type="range" @value="%x" min="-5" max="50"', 'min="-5" max="50" @type="range" @value="%x"', 'min="-5" max="50" @value="%x" @type="range"', '@value="%x" min="-5" max="50" @type="range"', '@value="%x" @type="range" min="-5" max="50"', // Named argument
      '@type="range" @min="-5" @max="50" @value="%x"', '@type="range" @value="%x" @min="-5" @max="50"', '@min="-5" @max="50" @type="range" @value="%x"', '@min="-5" @max="50" @value="%x" @type="range"', '@value="%x" @min="-5" @max="50" @type="range"', '@value="%x" @type="range" @min="-5" @max="50"'].forEach(function (attrs) {
        (0, _internalTestHelpers.moduleFor)("[GH#15675] Components test: <Input " + attrs + " />",
        /*#__PURE__*/
        function (_InputRenderingTest5) {
          (0, _emberBabel.inheritsLoose)(_class5, _InputRenderingTest5);

          function _class5() {
            return _InputRenderingTest5.apply(this, arguments) || this;
          }

          var _proto6 = _class5.prototype;

          _proto6.renderInput = function renderInput() {
            var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 25;
            this.render("<Input " + attrs.replace('%x', value) + " />");
          };

          _proto6['@test value over default max but below set max is kept'] = function testValueOverDefaultMaxButBelowSetMaxIsKept() {
            this.renderInput('25');
            this.assertValue('25');
          };

          _proto6['@test value below default min but above set min is kept'] = function testValueBelowDefaultMinButAboveSetMinIsKept() {
            this.renderInput('-2');
            this.assertValue('-2');
          };

          _proto6['@test in the valid default range is kept'] = function testInTheValidDefaultRangeIsKept() {
            this.renderInput('5');
            this.assertValue('5');
          };

          _proto6['@test value above max is reset to max'] = function testValueAboveMaxIsResetToMax() {
            this.renderInput('55');
            this.assertValue('50');
          };

          _proto6['@test value below min is reset to min'] = function testValueBelowMinIsResetToMin() {
            this.renderInput('-10');
            this.assertValue('-5');
          };

          return _class5;
        }(InputRenderingTest));
      });
    } else {
    (0, _internalTestHelpers.moduleFor)('Components test: <Input>',
    /*#__PURE__*/
    function (_RenderingTestCase2) {
      (0, _emberBabel.inheritsLoose)(_class6, _RenderingTestCase2);

      function _class6() {
        return _RenderingTestCase2.apply(this, arguments) || this;
      }

      var _proto7 = _class6.prototype;

      _proto7['@test it is not allowed'] = function testItIsNotAllowed() {
        var _this26 = this;

        expectAssertion(function () {
          _this26.render("<Input />");
        }, 'Invoking `{{input}}` using angle bracket syntax or `component` helper is not yet supported.');
      };

      return _class6;
    }(_internalTestHelpers.RenderingTestCase));
  }
});
enifed("@ember/-internals/glimmer/tests/integration/components/input-curly-test", ["ember-babel", "internal-test-helpers", "@ember/polyfills", "@ember/-internals/metal", "@ember/-internals/views", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _polyfills, _metal, _views, _helpers) {
  "use strict";

  var InputRenderingTest =
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(InputRenderingTest, _RenderingTestCase);

    function InputRenderingTest() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = InputRenderingTest.prototype;

    _proto.$input = function $input() {
      return this.$('input');
    };

    _proto.inputID = function inputID() {
      return this.$input().prop('id');
    };

    _proto.assertDisabled = function assertDisabled() {
      this.assert.ok(this.$('input').prop('disabled'), 'The input is disabled');
    };

    _proto.assertNotDisabled = function assertNotDisabled() {
      this.assert.ok(this.$('input').is(':not(:disabled)'), 'The input is not disabled');
    };

    _proto.assertInputId = function assertInputId(expectedId) {
      this.assert.equal(this.inputID(), expectedId, 'the input id should be `expectedId`');
    };

    _proto.assertSingleInput = function assertSingleInput() {
      this.assert.equal(this.$('input').length, 1, 'A single text field was inserted');
    };

    _proto.assertSingleCheckbox = function assertSingleCheckbox() {
      this.assert.equal(this.$('input[type=checkbox]').length, 1, 'A single checkbox is added');
    };

    _proto.assertCheckboxIsChecked = function assertCheckboxIsChecked() {
      this.assert.equal(this.$input().prop('checked'), true, 'the checkbox is checked');
    };

    _proto.assertCheckboxIsNotChecked = function assertCheckboxIsNotChecked() {
      this.assert.equal(this.$input().prop('checked'), false, 'the checkbox is not checked');
    };

    _proto.assertValue = function assertValue(expected) {
      this.assert.equal(this.$input().val(), expected, "the input value should be " + expected);
    };

    _proto.assertAttr = function assertAttr(name, expected) {
      this.assert.equal(this.$input().attr(name), expected, "the input " + name + " attribute has the value '" + expected + "'");
    };

    _proto.assertAllAttrs = function assertAllAttrs(names, expected) {
      var _this = this;

      names.forEach(function (name) {
        return _this.assertAttr(name, expected);
      });
    };

    _proto.assertSelectionRange = function assertSelectionRange(start, end) {
      var input = this.$input()[0];
      this.assert.equal(input.selectionStart, start, "the cursor start position should be " + start);
      this.assert.equal(input.selectionEnd, end, "the cursor end position should be " + end);
    };

    _proto.triggerEvent = function triggerEvent(type, options) {
      var event = document.createEvent('Events');
      event.initEvent(type, true, true);
      (0, _polyfills.assign)(event, options);
      var element = this.$input()[0];
      (0, _internalTestHelpers.runTask)(function () {
        element.dispatchEvent(event);
      });
    };

    _proto.assertTriggersNativeDOMEvents = function assertTriggersNativeDOMEvents(type) {
      var _this2 = this; // Defaults from EventDispatcher


      var events = {
        touchstart: 'touchStart',
        touchmove: 'touchMove',
        touchend: 'touchEnd',
        touchcancel: 'touchCancel',
        keydown: 'keyDown',
        keyup: 'keyUp',
        keypress: 'keyPress',
        mousedown: 'mouseDown',
        mouseup: 'mouseUp',
        contextmenu: 'contextMenu',
        click: 'click',
        dblclick: 'doubleClick',
        mousemove: 'mouseMove',
        focusin: 'focusIn',
        focusout: 'focusOut',
        mouseenter: 'mouseEnter',
        mouseleave: 'mouseLeave',
        submit: 'submit',
        input: 'input',
        change: 'change',
        dragstart: 'dragStart',
        drag: 'drag',
        dragenter: 'dragEnter',
        dragleave: 'dragLeave',
        dragover: 'dragOver',
        drop: 'drop',
        dragend: 'dragEnd'
      };

      var TestComponent = _helpers.Component.extend({
        tagName: 'input'
      });

      this.registerComponent('test-component', {
        ComponentClass: TestComponent
      });
      var triggeredEvents = [];
      var actions = {};
      Object.keys(events).forEach(function (evt) {
        actions["run_" + evt] = function () {
          triggeredEvents.push(evt);
        };
      });
      var typeAttr = type ? "type=\"" + type + "\" " : '';
      var actionAttrs = Object.keys(events).map(function (evt) {
        return events[evt] + "=(action 'run_" + evt + "')";
      }).join(' ');
      var template = "{{test-component " + typeAttr + actionAttrs + "}}{{input " + typeAttr + actionAttrs + "}}";
      this.render(template, {
        actions: actions
      });
      Object.keys(events).forEach(function (evt) {
        return _this2.triggerEvent(evt, null, 'input:first-of-type');
      });
      var normallyTriggeredEvents = [].concat(triggeredEvents);
      triggeredEvents.length = 0;
      this.assert.ok(normallyTriggeredEvents.length > 10, 'sanity check that most events are triggered');
      normallyTriggeredEvents.forEach(function (evt) {
        return _this2.triggerEvent(evt, null, 'input:last-of-type');
      });
      this.assert.deepEqual(triggeredEvents, normallyTriggeredEvents, 'called for all events');
    };

    return InputRenderingTest;
  }(_internalTestHelpers.RenderingTestCase);

  (0, _internalTestHelpers.moduleFor)('Components test: {{input}}',
  /*#__PURE__*/
  function (_InputRenderingTest) {
    (0, _emberBabel.inheritsLoose)(_class, _InputRenderingTest);

    function _class() {
      return _InputRenderingTest.apply(this, arguments) || this;
    }

    var _proto2 = _class.prototype;

    _proto2['@test a single text field is inserted into the DOM'] = function testASingleTextFieldIsInsertedIntoTheDOM() {
      var _this3 = this;

      this.render("{{input type=\"text\" value=value}}", {
        value: 'hello'
      });
      var id = this.inputID();
      this.assertValue('hello');
      this.assertSingleInput();
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assertValue('hello');
      this.assertSingleInput();
      this.assertInputId(id);
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'value', 'goodbye');
      });
      this.assertValue('goodbye');
      this.assertSingleInput();
      this.assertInputId(id);
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'value', 'hello');
      });
      this.assertValue('hello');
      this.assertSingleInput();
      this.assertInputId(id);
    };

    _proto2['@test default type'] = function testDefaultType() {
      var _this4 = this;

      this.render("{{input}}");
      this.assertAttr('type', 'text');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      this.assertAttr('type', 'text');
    };

    _proto2['@test dynamic attributes'] = function testDynamicAttributes() {
      var _this5 = this;

      this.render("\n      {{input type=\"text\"\n        disabled=disabled\n        value=value\n        placeholder=placeholder\n        name=name\n        maxlength=maxlength\n        minlength=minlength\n        size=size\n        tabindex=tabindex\n      }}", {
        disabled: false,
        value: 'Original value',
        placeholder: 'Original placeholder',
        name: 'original-name',
        maxlength: 10,
        minlength: 5,
        size: 20,
        tabindex: 30
      });
      this.assertNotDisabled();
      this.assertValue('Original value');
      this.assertAttr('placeholder', 'Original placeholder');
      this.assertAttr('name', 'original-name');
      this.assertAttr('maxlength', '10');
      this.assertAttr('minlength', '5'); // this.assertAttr('size', '20'); //NOTE: failing in IE  (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '30'); //NOTE: failing in IE (TEST_SUITE=sauce)

      (0, _internalTestHelpers.runTask)(function () {
        return _this5.rerender();
      });
      this.assertNotDisabled();
      this.assertValue('Original value');
      this.assertAttr('placeholder', 'Original placeholder');
      this.assertAttr('name', 'original-name');
      this.assertAttr('maxlength', '10');
      this.assertAttr('minlength', '5'); // this.assertAttr('size', '20'); //NOTE: failing in IE (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '30'); //NOTE: failing in IE (TEST_SUITE=sauce)

      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this5.context, 'value', 'Updated value');
        (0, _metal.set)(_this5.context, 'disabled', true);
        (0, _metal.set)(_this5.context, 'placeholder', 'Updated placeholder');
        (0, _metal.set)(_this5.context, 'name', 'updated-name');
        (0, _metal.set)(_this5.context, 'maxlength', 11);
        (0, _metal.set)(_this5.context, 'minlength', 6); // set(this.context, 'size', 21); //NOTE: failing in IE (TEST_SUITE=sauce)
        // set(this.context, 'tabindex', 31); //NOTE: failing in IE (TEST_SUITE=sauce)
      });
      this.assertDisabled();
      this.assertValue('Updated value');
      this.assertAttr('placeholder', 'Updated placeholder');
      this.assertAttr('name', 'updated-name');
      this.assertAttr('maxlength', '11');
      this.assertAttr('minlength', '6'); // this.assertAttr('size', '21'); //NOTE: failing in IE (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '31'); //NOTE: failing in IE (TEST_SUITE=sauce)

      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this5.context, 'value', 'Original value');
        (0, _metal.set)(_this5.context, 'disabled', false);
        (0, _metal.set)(_this5.context, 'placeholder', 'Original placeholder');
        (0, _metal.set)(_this5.context, 'name', 'original-name');
        (0, _metal.set)(_this5.context, 'maxlength', 10);
        (0, _metal.set)(_this5.context, 'minlength', 5); // set(this.context, 'size', 20); //NOTE: failing in IE (TEST_SUITE=sauce)
        // set(this.context, 'tabindex', 30); //NOTE: failing in IE (TEST_SUITE=sauce)
      });
      this.assertNotDisabled();
      this.assertValue('Original value');
      this.assertAttr('placeholder', 'Original placeholder');
      this.assertAttr('name', 'original-name');
      this.assertAttr('maxlength', '10');
      this.assertAttr('minlength', '5'); // this.assertAttr('size', '20'); //NOTE: failing in IE (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '30'); //NOTE: failing in IE (TEST_SUITE=sauce)
    };

    _proto2['@test static attributes'] = function testStaticAttributes() {
      var _this6 = this;

      this.render("\n      {{input type=\"text\"\n        disabled=true\n        value=\"Original value\"\n        placeholder=\"Original placeholder\"\n        name=\"original-name\"\n        maxlength=10\n        minlength=5\n        size=20\n        tabindex=30\n      }}");
      this.assertDisabled();
      this.assertValue('Original value');
      this.assertAttr('placeholder', 'Original placeholder');
      this.assertAttr('name', 'original-name');
      this.assertAttr('maxlength', '10');
      this.assertAttr('minlength', '5'); // this.assertAttr('size', '20');  //NOTE: failing in IE (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '30');  //NOTE: failing in IE (TEST_SUITE=sauce)

      (0, _internalTestHelpers.runTask)(function () {
        return _this6.rerender();
      });
      this.assertDisabled();
      this.assertValue('Original value');
      this.assertAttr('placeholder', 'Original placeholder');
      this.assertAttr('name', 'original-name');
      this.assertAttr('maxlength', '10');
      this.assertAttr('minlength', '5'); // this.assertAttr('size', '20');  //NOTE: failing in IE (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '30');  //NOTE: failing in IE (TEST_SUITE=sauce)
    };

    _proto2['@test cursor selection range'] = function testCursorSelectionRange() {
      var _this7 = this; // Modifying input.selectionStart, which is utilized in the cursor tests,
      // causes an event in Safari.


      (0, _internalTestHelpers.runDestroy)(this.owner.lookup('event_dispatcher:main'));
      this.render("{{input type=\"text\" value=value}}", {
        value: 'original'
      });
      var input = this.$input()[0]; // See https://ember-twiddle.com/33e506329f8176ae874422644d4cc08c?openFiles=components.input-component.js%2Ctemplates.components.input-component.hbs
      // this.assertSelectionRange(8, 8); //NOTE: this is (0, 0) on Firefox (TEST_SUITE=sauce)

      (0, _internalTestHelpers.runTask)(function () {
        return _this7.rerender();
      }); // this.assertSelectionRange(8, 8); //NOTE: this is (0, 0) on Firefox (TEST_SUITE=sauce)

      (0, _internalTestHelpers.runTask)(function () {
        input.selectionStart = 2;
        input.selectionEnd = 4;
      });
      this.assertSelectionRange(2, 4);
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.rerender();
      });
      this.assertSelectionRange(2, 4); // runTask(() => set(this.context, 'value', 'updated'));
      //
      // this.assertSelectionRange(7, 7); //NOTE: this fails in IE, the range is 0 -> 0 (TEST_SUITE=sauce)
      //
      // runTask(() => set(this.context, 'value', 'original'));
      //
      // this.assertSelectionRange(8, 8); //NOTE: this fails in IE, the range is 0 -> 0 (TEST_SUITE=sauce)
    };

    _proto2['@test [DEPRECATED] sends an action with `{{input enter="foo"}}` when <enter> is pressed'] = function testDEPRECATEDSendsAnActionWithInputEnterFooWhenEnterIsPressed(assert) {
      var _this8 = this;

      assert.expect(4);
      expectDeprecation(function () {
        _this8.render("{{input enter='foo'}}", {
          actions: {
            foo: function (value, event) {
              assert.ok(true, 'action was triggered');

              if (_views.jQueryDisabled) {
                assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
              } else {
                assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
              }
            }
          }
        });
      }, 'Passing actions to components as strings (like `{{input enter="foo"}}`) is deprecated. Please use closure actions instead (`{{input enter=(action "foo")}}`). (\'-top-level\' @ L1:C0) ');

      if (true
      /* EMBER_GLIMMER_ANGLE_BRACKET_BUILT_INS */
      ) {
          expectDeprecation(function () {
            _this8.triggerEvent('keyup', {
              keyCode: 13
            });
          }, 'Passing actions to components as strings (like `<Input @enter="foo" />`) is deprecated. Please use closure actions instead (`<Input @enter={{action "foo"}} />`).');
        } else {
        expectDeprecation(function () {
          _this8.triggerEvent('keyup', {
            keyCode: 13
          });
        }, 'Passing actions to components as strings (like `{{input enter="foo"}}`) is deprecated. Please use closure actions instead (`{{input enter=(action "foo")}}`).');
      }
    };

    _proto2['@test sends an action with `{{input enter=(action "foo")}}` when <enter> is pressed'] = function testSendsAnActionWithInputEnterActionFooWhenEnterIsPressed(assert) {
      assert.expect(2);
      this.render("{{input enter=(action 'foo')}}", {
        actions: {
          foo: function (value, event) {
            assert.ok(true, 'action was triggered');

            if (_views.jQueryDisabled) {
              assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
            } else {
              assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
            }
          }
        }
      });
      this.triggerEvent('keyup', {
        keyCode: 13
      });
    };

    _proto2['@test [DEPRECATED] sends an action with `{{input key-press="foo"}}` is pressed'] = function testDEPRECATEDSendsAnActionWithInputKeyPressFooIsPressed(assert) {
      var _this9 = this;

      assert.expect(4);
      expectDeprecation(function () {
        _this9.render("{{input value=value key-press='foo'}}", {
          value: 'initial',
          actions: {
            foo: function (value, event) {
              assert.ok(true, 'action was triggered');

              if (_views.jQueryDisabled) {
                assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
              } else {
                assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
              }
            }
          }
        });
      }, 'Passing actions to components as strings (like `{{input key-press="foo"}}`) is deprecated. Please use closure actions instead (`{{input key-press=(action "foo")}}`). (\'-top-level\' @ L1:C0) ');

      if (true
      /* EMBER_GLIMMER_ANGLE_BRACKET_BUILT_INS */
      ) {
          expectDeprecation(function () {
            _this9.triggerEvent('keypress', {
              keyCode: 65
            });
          }, 'Passing actions to components as strings (like `<Input @key-press="foo" />`) is deprecated. Please use closure actions instead (`<Input @key-press={{action "foo"}} />`).');
        } else {
        expectDeprecation(function () {
          _this9.triggerEvent('keypress', {
            keyCode: 65
          });
        }, 'Passing actions to components as strings (like `{{input key-press="foo"}}`) is deprecated. Please use closure actions instead (`{{input key-press=(action "foo")}}`).');
      }
    };

    _proto2['@test sends an action with `{{input key-press=(action "foo")}}` is pressed'] = function testSendsAnActionWithInputKeyPressActionFooIsPressed(assert) {
      assert.expect(2);
      this.render("{{input value=value key-press=(action 'foo')}}", {
        value: 'initial',
        actions: {
          foo: function (value, event) {
            assert.ok(true, 'action was triggered');

            if (_views.jQueryDisabled) {
              assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
            } else {
              assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
            }
          }
        }
      });
      this.triggerEvent('keypress', {
        keyCode: 65
      });
    };

    _proto2['@test sends an action to the parent level when `bubbles=true` is provided'] = function testSendsAnActionToTheParentLevelWhenBubblesTrueIsProvided(assert) {
      assert.expect(1);

      var ParentComponent = _helpers.Component.extend({
        change: function () {
          assert.ok(true, 'bubbled upwards');
        }
      });

      this.registerComponent('x-parent', {
        ComponentClass: ParentComponent,
        template: "{{input bubbles=true}}"
      });
      this.render("{{x-parent}}");
      this.triggerEvent('change');
    };

    _proto2['@test triggers `focus-in` when focused'] = function testTriggersFocusInWhenFocused(assert) {
      var _this10 = this;

      var wasFocused = false;
      this.render("{{input focus-in=(action 'foo')}}", {
        actions: {
          foo: function () {
            wasFocused = true;
          }
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        _this10.$input().focus();
      });
      assert.ok(wasFocused, 'action was triggered');
    };

    _proto2['@test sends `insert-newline` when <enter> is pressed'] = function testSendsInsertNewlineWhenEnterIsPressed(assert) {
      assert.expect(2);
      this.render("{{input insert-newline=(action 'foo')}}", {
        actions: {
          foo: function (value, event) {
            assert.ok(true, 'action was triggered');

            if (_views.jQueryDisabled) {
              assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
            } else {
              assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
            }
          }
        }
      });
      this.triggerEvent('keyup', {
        keyCode: 13
      });
    };

    _proto2['@test [DEPRECATED] sends an action with `{{input escape-press="foo"}}` when <escape> is pressed'] = function testDEPRECATEDSendsAnActionWithInputEscapePressFooWhenEscapeIsPressed(assert) {
      var _this11 = this;

      assert.expect(4);
      expectDeprecation(function () {
        _this11.render("{{input escape-press='foo'}}", {
          actions: {
            foo: function (value, event) {
              assert.ok(true, 'action was triggered');

              if (_views.jQueryDisabled) {
                assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
              } else {
                assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
              }
            }
          }
        });
      }, 'Passing actions to components as strings (like `{{input escape-press="foo"}}`) is deprecated. Please use closure actions instead (`{{input escape-press=(action "foo")}}`). (\'-top-level\' @ L1:C0) ');

      if (true
      /* EMBER_GLIMMER_ANGLE_BRACKET_BUILT_INS */
      ) {
          expectDeprecation(function () {
            _this11.triggerEvent('keyup', {
              keyCode: 27
            });
          }, 'Passing actions to components as strings (like `<Input @escape-press="foo" />`) is deprecated. Please use closure actions instead (`<Input @escape-press={{action "foo"}} />`).');
        } else {
        expectDeprecation(function () {
          _this11.triggerEvent('keyup', {
            keyCode: 27
          });
        }, 'Passing actions to components as strings (like `{{input escape-press="foo"}}`) is deprecated. Please use closure actions instead (`{{input escape-press=(action "foo")}}`).');
      }
    };

    _proto2['@test sends an action with `{{input escape-press=(action "foo")}}` when <escape> is pressed'] = function testSendsAnActionWithInputEscapePressActionFooWhenEscapeIsPressed(assert) {
      assert.expect(2);
      this.render("{{input escape-press=(action 'foo')}}", {
        actions: {
          foo: function (value, event) {
            assert.ok(true, 'action was triggered');

            if (_views.jQueryDisabled) {
              assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
            } else {
              assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
            }
          }
        }
      });
      this.triggerEvent('keyup', {
        keyCode: 27
      });
    };

    _proto2['@test [DEPRECATED] sends an action with `{{input key-down="foo"}}` when a key is pressed'] = function testDEPRECATEDSendsAnActionWithInputKeyDownFooWhenAKeyIsPressed(assert) {
      var _this12 = this;

      assert.expect(4);
      expectDeprecation(function () {
        _this12.render("{{input key-down='foo'}}", {
          actions: {
            foo: function (value, event) {
              assert.ok(true, 'action was triggered');

              if (_views.jQueryDisabled) {
                assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
              } else {
                assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
              }
            }
          }
        });
      }, 'Passing actions to components as strings (like `{{input key-down="foo"}}`) is deprecated. Please use closure actions instead (`{{input key-down=(action "foo")}}`). (\'-top-level\' @ L1:C0) ');

      if (true
      /* EMBER_GLIMMER_ANGLE_BRACKET_BUILT_INS */
      ) {
          expectDeprecation(function () {
            _this12.triggerEvent('keydown', {
              keyCode: 65
            });
          }, 'Passing actions to components as strings (like `<Input @key-down="foo" />`) is deprecated. Please use closure actions instead (`<Input @key-down={{action "foo"}} />`).');
        } else {
        expectDeprecation(function () {
          _this12.triggerEvent('keydown', {
            keyCode: 65
          });
        }, 'Passing actions to components as strings (like `{{input key-down="foo"}}`) is deprecated. Please use closure actions instead (`{{input key-down=(action "foo")}}`).');
      }
    };

    _proto2['@test sends an action with `{{input key-down=(action "foo")}}` when a key is pressed'] = function testSendsAnActionWithInputKeyDownActionFooWhenAKeyIsPressed(assert) {
      assert.expect(2);
      this.render("{{input key-down=(action 'foo')}}", {
        actions: {
          foo: function (value, event) {
            assert.ok(true, 'action was triggered');

            if (_views.jQueryDisabled) {
              assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
            } else {
              assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
            }
          }
        }
      });
      this.triggerEvent('keydown', {
        keyCode: 65
      });
    };

    _proto2['@test [DEPRECATED] sends an action with `{{input key-up="foo"}}` when a key is pressed'] = function testDEPRECATEDSendsAnActionWithInputKeyUpFooWhenAKeyIsPressed(assert) {
      var _this13 = this;

      assert.expect(4);
      expectDeprecation(function () {
        _this13.render("{{input key-up='foo'}}", {
          actions: {
            foo: function (value, event) {
              assert.ok(true, 'action was triggered');

              if (_views.jQueryDisabled) {
                assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
              } else {
                assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
              }
            }
          }
        });
      }, 'Passing actions to components as strings (like `{{input key-up="foo"}}`) is deprecated. Please use closure actions instead (`{{input key-up=(action "foo")}}`). (\'-top-level\' @ L1:C0) ');

      if (true
      /* EMBER_GLIMMER_ANGLE_BRACKET_BUILT_INS */
      ) {
          expectDeprecation(function () {
            _this13.triggerEvent('keyup', {
              keyCode: 65
            });
          }, 'Passing actions to components as strings (like `<Input @key-up="foo" />`) is deprecated. Please use closure actions instead (`<Input @key-up={{action "foo"}} />`).');
        } else {
        expectDeprecation(function () {
          _this13.triggerEvent('keyup', {
            keyCode: 65
          });
        }, 'Passing actions to components as strings (like `{{input key-up="foo"}}`) is deprecated. Please use closure actions instead (`{{input key-up=(action "foo")}}`).');
      }
    };

    _proto2['@test sends an action with `{{input key-up=(action "foo")}}` when a key is pressed'] = function testSendsAnActionWithInputKeyUpActionFooWhenAKeyIsPressed(assert) {
      assert.expect(2);
      this.render("{{input key-up=(action 'foo')}}", {
        actions: {
          foo: function (value, event) {
            assert.ok(true, 'action was triggered');

            if (_views.jQueryDisabled) {
              assert.notOk(event.originalEvent, 'event is not a jQuery.Event');
            } else {
              assert.ok(event instanceof _views.jQuery.Event, 'jQuery event was passed');
            }
          }
        }
      });
      this.triggerEvent('keyup', {
        keyCode: 65
      });
    };

    _proto2['@test GH#14727 can render a file input after having had render an input of other type'] = function testGH14727CanRenderAFileInputAfterHavingHadRenderAnInputOfOtherType() {
      this.render("{{input type=\"text\"}}{{input type=\"file\"}}");
      this.assert.equal(this.$input()[0].type, 'text');
      this.assert.equal(this.$input()[1].type, 'file');
    };

    _proto2['@test sends an action with `{{input EVENT=(action "foo")}}` for native DOM events'] = function testSendsAnActionWithInputEVENTActionFooForNativeDOMEvents() {
      this.assertTriggersNativeDOMEvents();
    };

    return _class;
  }(InputRenderingTest));
  (0, _internalTestHelpers.moduleFor)('Components test: {{input}} with dynamic type',
  /*#__PURE__*/
  function (_InputRenderingTest2) {
    (0, _emberBabel.inheritsLoose)(_class2, _InputRenderingTest2);

    function _class2() {
      return _InputRenderingTest2.apply(this, arguments) || this;
    }

    var _proto3 = _class2.prototype;

    _proto3['@test a bound property can be used to determine type'] = function testABoundPropertyCanBeUsedToDetermineType() {
      var _this14 = this;

      this.render("{{input type=type}}", {
        type: 'password'
      });
      this.assertAttr('type', 'password');
      (0, _internalTestHelpers.runTask)(function () {
        return _this14.rerender();
      });
      this.assertAttr('type', 'password');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'type', 'text');
      });
      this.assertAttr('type', 'text');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'type', 'password');
      });
      this.assertAttr('type', 'password');
    };

    _proto3['@test a subexpression can be used to determine type'] = function testASubexpressionCanBeUsedToDetermineType() {
      var _this15 = this;

      this.render("{{input type=(if isTruthy trueType falseType)}}", {
        isTruthy: true,
        trueType: 'text',
        falseType: 'password'
      });
      this.assertAttr('type', 'text');
      (0, _internalTestHelpers.runTask)(function () {
        return _this15.rerender();
      });
      this.assertAttr('type', 'text');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'isTruthy', false);
      });
      this.assertAttr('type', 'password');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'isTruthy', true);
      });
      this.assertAttr('type', 'text');
    };

    _proto3['@test GH16256 input macro does not modify params in place'] = function testGH16256InputMacroDoesNotModifyParamsInPlace() {
      this.registerComponent('my-input', {
        template: "{{input type=inputType}}"
      });
      this.render("{{my-input inputType=firstType}}{{my-input inputType=secondType}}", {
        firstType: 'password',
        secondType: 'email'
      });
      var inputs = this.element.querySelectorAll('input');
      this.assert.equal(inputs.length, 2, 'there are two inputs');
      this.assert.equal(inputs[0].getAttribute('type'), 'password');
      this.assert.equal(inputs[1].getAttribute('type'), 'email');
    };

    return _class2;
  }(InputRenderingTest));
  (0, _internalTestHelpers.moduleFor)("Components test: {{input type='checkbox'}}",
  /*#__PURE__*/
  function (_InputRenderingTest3) {
    (0, _emberBabel.inheritsLoose)(_class3, _InputRenderingTest3);

    function _class3() {
      return _InputRenderingTest3.apply(this, arguments) || this;
    }

    var _proto4 = _class3.prototype;

    _proto4['@test dynamic attributes'] = function testDynamicAttributes() {
      var _this16 = this;

      this.render("{{input\n      type='checkbox'\n      disabled=disabled\n      name=name\n      checked=checked\n      tabindex=tabindex\n    }}", {
        disabled: false,
        name: 'original-name',
        checked: false,
        tabindex: 10
      });
      this.assertSingleCheckbox();
      this.assertNotDisabled();
      this.assertAttr('name', 'original-name');
      this.assertAttr('tabindex', '10');
      (0, _internalTestHelpers.runTask)(function () {
        return _this16.rerender();
      });
      this.assertSingleCheckbox();
      this.assertNotDisabled();
      this.assertAttr('name', 'original-name');
      this.assertAttr('tabindex', '10');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this16.context, 'disabled', true);
        (0, _metal.set)(_this16.context, 'name', 'updated-name');
        (0, _metal.set)(_this16.context, 'tabindex', 11);
      });
      this.assertSingleCheckbox();
      this.assertDisabled();
      this.assertAttr('name', 'updated-name');
      this.assertAttr('tabindex', '11');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this16.context, 'disabled', false);
        (0, _metal.set)(_this16.context, 'name', 'original-name');
        (0, _metal.set)(_this16.context, 'tabindex', 10);
      });
      this.assertSingleCheckbox();
      this.assertNotDisabled();
      this.assertAttr('name', 'original-name');
      this.assertAttr('tabindex', '10');
    };

    _proto4['@test `value` property assertion'] = function testValuePropertyAssertion() {
      var _this17 = this;

      expectAssertion(function () {
        _this17.render("{{input type=\"checkbox\" value=value}}", {
          value: 'value'
        });
      }, /checkbox.+value.+not supported.+use.+checked.+instead/);
    };

    _proto4['@test with a bound type'] = function testWithABoundType() {
      var _this18 = this;

      this.render("{{input type=inputType checked=isChecked}}", {
        inputType: 'checkbox',
        isChecked: true
      });
      this.assertSingleCheckbox();
      this.assertCheckboxIsChecked();
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.rerender();
      });
      this.assertCheckboxIsChecked();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this18.context, 'isChecked', false);
      });
      this.assertCheckboxIsNotChecked();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this18.context, 'isChecked', true);
      });
      this.assertCheckboxIsChecked();
    };

    _proto4['@test native click changes check property'] = function testNativeClickChangesCheckProperty() {
      this.render("{{input type=\"checkbox\"}}");
      this.assertSingleCheckbox();
      this.assertCheckboxIsNotChecked();
      this.$input()[0].click();
      this.assertCheckboxIsChecked();
      this.$input()[0].click();
      this.assertCheckboxIsNotChecked();
    };

    _proto4['@test with static values'] = function testWithStaticValues() {
      var _this19 = this;

      this.render("{{input type=\"checkbox\" disabled=false tabindex=10 name=\"original-name\" checked=false}}");
      this.assertSingleCheckbox();
      this.assertCheckboxIsNotChecked();
      this.assertNotDisabled();
      this.assertAttr('tabindex', '10');
      this.assertAttr('name', 'original-name');
      (0, _internalTestHelpers.runTask)(function () {
        return _this19.rerender();
      });
      this.assertSingleCheckbox();
      this.assertCheckboxIsNotChecked();
      this.assertNotDisabled();
      this.assertAttr('tabindex', '10');
      this.assertAttr('name', 'original-name');
    };

    _proto4['@test sends an action with `{{input EVENT=(action "foo")}}` for native DOM events'] = function testSendsAnActionWithInputEVENTActionFooForNativeDOMEvents() {
      this.assertTriggersNativeDOMEvents('checkbox');
    };

    return _class3;
  }(InputRenderingTest));
  (0, _internalTestHelpers.moduleFor)("Components test: {{input type='text'}}",
  /*#__PURE__*/
  function (_InputRenderingTest4) {
    (0, _emberBabel.inheritsLoose)(_class4, _InputRenderingTest4);

    function _class4() {
      return _InputRenderingTest4.apply(this, arguments) || this;
    }

    var _proto5 = _class4.prototype;

    _proto5['@test null values'] = function testNullValues() {
      var _this20 = this;

      var attributes = ['disabled', 'placeholder', 'name', 'maxlength', 'size', 'tabindex'];
      this.render("\n      {{input type=\"text\"\n        disabled=disabled\n        value=value\n        placeholder=placeholder\n        name=name\n        maxlength=maxlength\n        size=size\n        tabindex=tabindex\n      }}", {
        disabled: null,
        value: null,
        placeholder: null,
        name: null,
        maxlength: null,
        size: null,
        tabindex: null
      });
      this.assertValue('');
      this.assertAllAttrs(attributes, undefined);
      (0, _internalTestHelpers.runTask)(function () {
        return _this20.rerender();
      });
      this.assertValue('');
      this.assertAllAttrs(attributes, undefined);
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this20.context, 'disabled', true);
        (0, _metal.set)(_this20.context, 'value', 'Updated value');
        (0, _metal.set)(_this20.context, 'placeholder', 'Updated placeholder');
        (0, _metal.set)(_this20.context, 'name', 'updated-name');
        (0, _metal.set)(_this20.context, 'maxlength', 11);
        (0, _metal.set)(_this20.context, 'size', 21);
        (0, _metal.set)(_this20.context, 'tabindex', 31);
      });
      this.assertDisabled();
      this.assertValue('Updated value');
      this.assertAttr('placeholder', 'Updated placeholder');
      this.assertAttr('name', 'updated-name');
      this.assertAttr('maxlength', '11');
      this.assertAttr('size', '21');
      this.assertAttr('tabindex', '31');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this20.context, 'disabled', null);
        (0, _metal.set)(_this20.context, 'value', null);
        (0, _metal.set)(_this20.context, 'placeholder', null);
        (0, _metal.set)(_this20.context, 'name', null);
        (0, _metal.set)(_this20.context, 'maxlength', null); // set(this.context, 'size', null); //NOTE: this fails with `Error: Failed to set the 'size' property on 'HTMLInputElement': The value provided is 0, which is an invalid size.` (TEST_SUITE=sauce)

        (0, _metal.set)(_this20.context, 'tabindex', null);
      });
      this.assertAttr('disabled', undefined);
      this.assertValue(''); // this.assertAttr('placeholder', undefined); //NOTE: this fails with a value of "null" (TEST_SUITE=sauce)
      // this.assertAttr('name', undefined); //NOTE: this fails with a value of "null" (TEST_SUITE=sauce)

      this.assertAttr('maxlength', undefined); // this.assertAttr('size', undefined); //NOTE: re-enable once `size` bug above has been addressed

      this.assertAttr('tabindex', undefined);
    };

    return _class4;
  }(InputRenderingTest)); // These are the permutations of the set:
  // ['type="range"', 'min="-5" max="50"', 'value="%x"']

  ['type="range" min="-5" max="50" value="%x"', 'type="range" value="%x" min="-5" max="50"', 'min="-5" max="50" type="range" value="%x"', 'min="-5" max="50" value="%x" type="range"', 'value="%x" min="-5" max="50" type="range"', 'value="%x" type="range" min="-5" max="50"'].forEach(function (attrs) {
    (0, _internalTestHelpers.moduleFor)("[GH#15675] Components test: {{input " + attrs + "}}",
    /*#__PURE__*/
    function (_InputRenderingTest5) {
      (0, _emberBabel.inheritsLoose)(_class5, _InputRenderingTest5);

      function _class5() {
        return _InputRenderingTest5.apply(this, arguments) || this;
      }

      var _proto6 = _class5.prototype;

      _proto6.renderInput = function renderInput() {
        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 25;
        this.render("{{input " + attrs.replace('%x', value) + "}}");
      };

      _proto6['@test value over default max but below set max is kept'] = function testValueOverDefaultMaxButBelowSetMaxIsKept() {
        this.renderInput('25');
        this.assertValue('25');
      };

      _proto6['@test value below default min but above set min is kept'] = function testValueBelowDefaultMinButAboveSetMinIsKept() {
        this.renderInput('-2');
        this.assertValue('-2');
      };

      _proto6['@test in the valid default range is kept'] = function testInTheValidDefaultRangeIsKept() {
        this.renderInput('5');
        this.assertValue('5');
      };

      _proto6['@test value above max is reset to max'] = function testValueAboveMaxIsResetToMax() {
        this.renderInput('55');
        this.assertValue('50');
      };

      _proto6['@test value below min is reset to min'] = function testValueBelowMinIsResetToMin() {
        this.renderInput('-10');
        this.assertValue('-5');
      };

      return _class5;
    }(InputRenderingTest));
  });
});
enifed("@ember/-internals/glimmer/tests/integration/components/instrumentation-compile-test", ["ember-babel", "internal-test-helpers", "@ember/instrumentation", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _instrumentation, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Components compile instrumentation',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      var _this;

      _this = _RenderingTestCase.apply(this, arguments) || this;

      _this.resetEvents();

      (0, _instrumentation.subscribe)('render.getComponentDefinition', {
        before: function (name, timestamp, payload) {
          if (payload.view !== _this.component) {
            _this.actual.before.push(payload);
          }
        },
        after: function (name, timestamp, payload) {
          if (payload.view !== _this.component) {
            _this.actual.after.push(payload);
          }
        }
      });
      return _this;
    }

    var _proto = _class.prototype;

    _proto.resetEvents = function resetEvents() {
      this.expected = {
        before: [],
        after: []
      };
      this.actual = {
        before: [],
        after: []
      };
    };

    _proto.teardown = function teardown() {
      this.assert.deepEqual(this.actual.before, [], 'No unexpected events (before)');
      this.assert.deepEqual(this.actual.after, [], 'No unexpected events (after)');

      _RenderingTestCase.prototype.teardown.call(this);

      (0, _instrumentation.reset)();
    };

    _proto['@test it should only receive an instrumentation event for initial render'] = function testItShouldOnlyReceiveAnInstrumentationEventForInitialRender() {
      var _this2 = this;

      var testCase = this;

      var BaseClass = _helpers.Component.extend({
        tagName: '',
        willRender: function () {
          testCase.expected.before.push(this);
          testCase.expected.after.unshift(this);
        }
      });

      this.registerComponent('x-bar', {
        template: '[x-bar: {{bar}}]',
        ComponentClass: BaseClass.extend()
      });
      this.render("[-top-level: {{foo}}] {{x-bar bar=bar}}", {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertText('[-top-level: foo] [x-bar: bar]');
      this.assertEvents('after initial render');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertEvents('after no-op rerender');
    };

    _proto.assertEvents = function assertEvents(label) {
      var actual = this.actual,
          expected = this.expected;
      this.assert.strictEqual(actual.before.length, actual.after.length, label + ": before and after callbacks should be balanced");

      this._assertEvents(label + " (before):", actual.before, expected.before);

      this._assertEvents(label + " (after):", actual.before, expected.before);

      this.resetEvents();
    };

    _proto._assertEvents = function _assertEvents(label, actual, expected) {
      var _this3 = this;

      this.assert.equal(actual.length, expected.length, label + ": expected " + expected.length + " and got " + actual.length);
      actual.forEach(function (payload, i) {
        return _this3.assertPayload(payload, expected[i]);
      });
    };

    _proto.assertPayload = function assertPayload(payload, component) {
      this.assert.equal(payload.object, component._debugContainerKey, 'payload.object');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/components/instrumentation-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/instrumentation", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _instrumentation, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Components instrumentation',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      var _this;

      _this = _RenderingTestCase.apply(this, arguments) || this;

      _this.resetEvents();

      (0, _instrumentation.subscribe)('render.component', {
        before: function (name, timestamp, payload) {
          if (payload.view !== _this.component) {
            _this.actual.before.push(payload);
          }
        },
        after: function (name, timestamp, payload) {
          if (payload.view !== _this.component) {
            _this.actual.after.push(payload);
          }
        }
      });
      return _this;
    }

    var _proto = _class.prototype;

    _proto.resetEvents = function resetEvents() {
      this.expected = {
        before: [],
        after: []
      };
      this.actual = {
        before: [],
        after: []
      };
    };

    _proto.teardown = function teardown() {
      this.assert.deepEqual(this.actual.before, [], 'No unexpected events (before)');
      this.assert.deepEqual(this.actual.after, [], 'No unexpected events (after)');

      _RenderingTestCase.prototype.teardown.call(this);

      (0, _instrumentation.reset)();
    };

    _proto['@test zomg'] = function testZomg(assert) {
      assert.ok(true);
    };

    _proto['@test it should receive an instrumentation event for both initial render and updates'] = function testItShouldReceiveAnInstrumentationEventForBothInitialRenderAndUpdates() {
      var _this2 = this;

      var testCase = this;

      var BaseClass = _helpers.Component.extend({
        tagName: '',
        willRender: function () {
          testCase.expected.before.push(this);
          testCase.expected.after.unshift(this);
        }
      });

      this.registerComponent('x-bar', {
        template: '[x-bar: {{bar}}] {{yield}}',
        ComponentClass: BaseClass.extend()
      });
      this.registerComponent('x-baz', {
        template: '[x-baz: {{baz}}]',
        ComponentClass: BaseClass.extend()
      });
      this.registerComponent('x-bat', {
        template: '[x-bat: {{bat}}]',
        ComponentClass: BaseClass.extend()
      });
      this.render("[-top-level: {{foo}}] {{#x-bar bar=bar}}{{x-baz baz=baz}}{{/x-bar}} {{x-bat bat=bat}}", {
        foo: 'foo',
        bar: 'bar',
        baz: 'baz',
        bat: 'bat'
      });
      this.assertText('[-top-level: foo] [x-bar: bar] [x-baz: baz] [x-bat: bat]');
      this.assertEvents('after initial render', true);
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertEvents('after no-op rerender');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'foo', 'FOO');
      });
      this.assertEvents('after updating top-level');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'baz', 'BAZ');
      });
      this.assertEvents('after updating inner-most');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this2.context, 'bar', 'BAR');
        (0, _metal.set)(_this2.context, 'bat', 'BAT');
      });
      this.assertEvents('after updating the rest');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this2.context, 'foo', 'FOO');
        (0, _metal.set)(_this2.context, 'bar', 'BAR');
        (0, _metal.set)(_this2.context, 'baz', 'BAZ');
        (0, _metal.set)(_this2.context, 'bat', 'BAT');
      });
      this.assertEvents('after reset');
    };

    _proto.assertEvents = function assertEvents(label) {
      var initialRender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var actual = this.actual,
          expected = this.expected;
      this.assert.strictEqual(actual.before.length, actual.after.length, label + ": before and after callbacks should be balanced");

      this._assertEvents(label + " (before):", actual.before, expected.before, initialRender);

      this._assertEvents(label + " (after):", actual.before, expected.before, initialRender);

      this.resetEvents();
    };

    _proto._assertEvents = function _assertEvents(label, actual, expected, initialRender) {
      var _this3 = this;

      this.assert.equal(actual.length, expected.length, label + ": expected " + expected.length + " and got " + actual.length);
      actual.forEach(function (payload, i) {
        return _this3.assertPayload(payload, expected[i], initialRender);
      });
    };

    _proto.assertPayload = function assertPayload(payload, component, initialRender) {
      this.assert.equal(payload.object, component.toString(), 'payload.object');
      this.assert.ok(payload.containerKey, 'the container key should be present');
      this.assert.equal(payload.containerKey, component._debugContainerKey, 'payload.containerKey');
      this.assert.equal(payload.view, component, 'payload.view');
      this.assert.strictEqual(payload.initialRender, initialRender, 'payload.initialRender');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/components/life-cycle-test", ["ember-babel", "internal-test-helpers", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/runtime", "@ember/-internals/views", "@ember/-internals/utils", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _runloop, _metal, _runtime, _views, _utils, _helpers) {
  "use strict";

  function _templateObject12() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#each items as |item|}}\n        {{#parent-component itemId=item.id}}{{item.id}}{{/parent-component}}\n      {{/each}}\n      {{#if model.shouldShow}}\n        {{#parent-component itemId=6}}6{{/parent-component}}\n      {{/if}}\n      {{#if model.shouldShow}}\n        {{#parent-component itemId=7}}7{{/parent-component}}\n      {{/if}}\n    "]);

    _templateObject12 = function () {
      return data;
    };

    return data;
  }

  function _templateObject11() {
    const data = _taggedTemplateLiteralLoose(["\n      {{yield}}\n      <ul>\n        {{#nested-component nestedId=(concat itemId '-A')}}A{{/nested-component}}\n        {{#nested-component nestedId=(concat itemId '-B')}}B{{/nested-component}}\n      </ul>\n    "]);

    _templateObject11 = function () {
      return data;
    };

    return data;
  }

  function _templateObject10() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#each items as |item|}}\n        ", "\n      {{else}}\n        ", "\n      {{/each}}\n    "]);

    _templateObject10 = function () {
      return data;
    };

    return data;
  }

  function _templateObject9() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#nested-item}}Nothing to see here{{/nested-item}}\n    "]);

    _templateObject9 = function () {
      return data;
    };

    return data;
  }

  function _templateObject8() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#nested-item}}Item: {{count}}{{/nested-item}}\n    "]);

    _templateObject8 = function () {
      return data;
    };

    return data;
  }

  function _templateObject7() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        Bottom: {{", "}}\n      </div>"]);

    _templateObject7 = function () {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        Middle: ", "\n      </div>"]);

    _templateObject6 = function () {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        Top: ", "\n      </div>"]);

    _templateObject5 = function () {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        ", "|\n        ", "|\n        ", "\n      </div>"]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        Website: {{", "}}\n      </div>"]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        Name: {{", "}}|\n        ", "\n      </div>"]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        Twitter: {{", "}}|\n        ", "\n      </div>"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  var LifeCycleHooksTest =
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(LifeCycleHooksTest, _RenderingTestCase);

    function LifeCycleHooksTest() {
      var _this;

      _this = _RenderingTestCase.apply(this, arguments) || this;
      _this.hooks = [];
      _this.components = {};
      _this.componentRegistry = [];
      _this.teardownAssertions = [];
      _this.viewRegistry = _this.owner.lookup('-view-registry:main');
      return _this;
    }

    var _proto = LifeCycleHooksTest.prototype;

    _proto.afterEach = function afterEach() {
      _RenderingTestCase.prototype.afterEach.call(this);

      for (var i = 0; i < this.teardownAssertions.length; i++) {
        this.teardownAssertions[i]();
      }
    };

    _proto.getBootOptions = function getBootOptions() {
      return {
        isInteractive: this.isInteractive
      };
    }
    /* abstract */
    ;
    /* abstract */


    _proto.invocationFor = function invocationFor()
    /* name, namedArgs = {} */
    {
      throw new Error('Not implemented: `invocationFor`');
    }
    /* abstract */
    ;

    _proto.attrFor = function attrFor()
    /* name */
    {
      throw new Error('Not implemented: `attrFor`');
    };

    _proto.assertRegisteredViews = function assertRegisteredViews(label) {
      var viewRegistry = this.viewRegistry;
      var topLevelId = (0, _views.getViewId)(this.component);
      var actual = Object.keys(viewRegistry).sort().filter(function (id) {
        return id !== topLevelId;
      });

      if (this.isInteractive) {
        var expected = this.componentRegistry.sort();
        this.assert.deepEqual(actual, expected, 'registered views - ' + label);
      } else {
        this.assert.deepEqual(actual, [], 'no views should be registered for non-interactive mode');
      }
    };

    _proto.registerComponent = function registerComponent(name, _ref) {
      var _this2 = this;

      var _ref$template = _ref.template,
          template = _ref$template === void 0 ? null : _ref$template;

      var pushComponent = function (instance) {
        _this2.components[name] = instance;

        _this2.componentRegistry.push((0, _views.getViewId)(instance));
      };

      var removeComponent = function (instance) {
        var index = _this2.componentRegistry.indexOf(instance);

        _this2.componentRegistry.splice(index, 1);

        delete _this2.components[name];
      };

      var pushHook = function (hookName, args) {
        _this2.hooks.push(hook(name, hookName, args));
      };

      var assertParentView = function (hookName, instance) {
        _this2.assert.ok(instance.parentView, "parentView should be present in " + hookName);

        if (hookName === 'willDestroyElement') {
          _this2.assert.ok(instance.parentView.childViews.indexOf(instance) !== -1, "view is still connected to parentView in " + hookName);
        }
      };

      var assertElement = function (hookName, instance) {
        var inDOM = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

        if (instance.tagName === '') {
          return;
        }

        _this2.assert.ok((0, _views.getViewElement)(instance), "element should be present on " + instance + " during " + hookName);

        if (_this2.isInteractive) {
          _this2.assert.ok(instance.element, "this.element should be present on " + instance + " during " + hookName);

          _this2.assert.equal(document.body.contains(instance.element), inDOM, "element for " + instance + " " + (inDOM ? 'should' : 'should not') + " be in the DOM during " + hookName);
        } else {
          _this2.assert.throws(function () {
            return instance.element;
          }, /Accessing `this.element` is not allowed in non-interactive environments/);
        }
      };

      var assertNoElement = function (hookName, instance) {
        _this2.assert.strictEqual((0, _views.getViewElement)(instance), null, "element should not be present in " + hookName);

        if (_this2.isInteractive) {
          _this2.assert.strictEqual(instance.element, null, "this.element should not be present in " + hookName);
        } else {
          _this2.assert.throws(function () {
            return instance.element;
          }, /Accessing `this.element` is not allowed in non-interactive environments/);
        }
      };

      var assertState = function (hookName, expectedState, instance) {
        _this2.assert.equal(instance._state, expectedState, "within " + hookName + " the expected _state is " + expectedState);
      };

      var isInteractive = this.isInteractive;
      var ComponentClass = this.ComponentClass.extend({
        init: function () {
          var _this3 = this;

          this._super.apply(this, arguments);

          this.isInitialRender = true;
          this.componentName = name;
          pushHook('init');
          pushComponent(this);
          assertParentView('init', this);
          assertNoElement('init', this);
          assertState('init', 'preRender', this);
          this.on('init', function () {
            return pushHook('on(init)');
          });
          (0, _runloop.schedule)('afterRender', function () {
            _this3.isInitialRender = false;
          });
        },
        didReceiveAttrs: function (options) {
          pushHook('didReceiveAttrs', options);
          assertParentView('didReceiveAttrs', this);

          if (this.isInitialRender) {
            assertNoElement('didReceiveAttrs', this);
            assertState('didReceiveAttrs', 'preRender', this);
          } else {
            assertElement('didReceiveAttrs', this);

            if (isInteractive) {
              assertState('didReceiveAttrs', 'inDOM', this);
            } else {
              assertState('didReceiveAttrs', 'hasElement', this);
            }
          }
        },
        willInsertElement: function () {
          pushHook('willInsertElement');
          assertParentView('willInsertElement', this);
          assertElement('willInsertElement', this, false);
          assertState('willInsertElement', 'hasElement', this);
        },
        willRender: function () {
          pushHook('willRender');
          assertParentView('willRender', this);

          if (this.isInitialRender) {
            assertNoElement('willRender', this, false);
            assertState('willRender', 'preRender', this);
          } else {
            assertElement('willRender', this);
            assertState('willRender', 'inDOM', this);
          }
        },
        didInsertElement: function () {
          pushHook('didInsertElement');
          assertParentView('didInsertElement', this);
          assertElement('didInsertElement', this);
          assertState('didInsertElement', 'inDOM', this);
        },
        didRender: function () {
          pushHook('didRender');
          assertParentView('didRender', this);
          assertElement('didRender', this);
          assertState('didRender', 'inDOM', this);
        },
        didUpdateAttrs: function (options) {
          pushHook('didUpdateAttrs', options);
          assertParentView('didUpdateAttrs', this);

          if (isInteractive) {
            assertState('didUpdateAttrs', 'inDOM', this);
          } else {
            assertState('didUpdateAttrs', 'hasElement', this);
          }
        },
        willUpdate: function (options) {
          pushHook('willUpdate', options);
          assertParentView('willUpdate', this);
          assertElement('willUpdate', this);
          assertState('willUpdate', 'inDOM', this);
        },
        didUpdate: function (options) {
          pushHook('didUpdate', options);
          assertParentView('didUpdate', this);
          assertElement('didUpdate', this);
          assertState('didUpdate', 'inDOM', this);
        },
        willDestroyElement: function () {
          pushHook('willDestroyElement');
          assertParentView('willDestroyElement', this);
          assertElement('willDestroyElement', this);
          assertState('willDestroyElement', 'inDOM', this);
        },
        willClearRender: function () {
          pushHook('willClearRender');
          assertParentView('willClearRender', this);
          assertElement('willClearRender', this);
          assertState('willClearRender', 'inDOM', this);
        },
        didDestroyElement: function () {
          pushHook('didDestroyElement');
          assertNoElement('didDestroyElement', this);
          assertState('didDestroyElement', 'destroying', this);
        },
        willDestroy: function () {
          pushHook('willDestroy');
          removeComponent(this);

          this._super.apply(this, arguments);
        }
      });

      _RenderingTestCase.prototype.registerComponent.call(this, name, {
        ComponentClass: ComponentClass,
        template: template
      });
    };

    _proto.assertHooks = function assertHooks(_ref2) {
      var label = _ref2.label,
          interactive = _ref2.interactive,
          nonInteractive = _ref2.nonInteractive;
      var rawHooks = this.isInteractive ? interactive : nonInteractive;
      var hooks = rawHooks.map(function (raw) {
        return hook.apply(void 0, raw);
      });
      this.assert.deepEqual(json(this.hooks), json(hooks), label);
      this.hooks = [];
    };

    _proto['@test lifecycle hooks are invoked in a predictable order'] = function testLifecycleHooksAreInvokedInAPredictableOrder() {
      var _this4 = this;

      var _this$boundHelpers = this.boundHelpers,
          attr = _this$boundHelpers.attr,
          invoke = _this$boundHelpers.invoke;
      this.registerComponent('the-top', {
        template: (0, _internalTestHelpers.strip)(_templateObject(), attr('twitter'), invoke('the-middle', {
          name: string('Tom Dale')
        }))
      });
      this.registerComponent('the-middle', {
        template: (0, _internalTestHelpers.strip)(_templateObject2(), attr('name'), invoke('the-bottom', {
          website: string('tomdale.net')
        }))
      });
      this.registerComponent('the-bottom', {
        template: (0, _internalTestHelpers.strip)(_templateObject3(), attr('website'))
      });
      this.render(invoke('the-top', {
        twitter: expr('twitter')
      }), {
        twitter: '@tomdale'
      });
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertRegisteredViews('intial render');
      this.assertHooks({
        label: 'after initial render',
        interactive: [// Sync hooks
        ['the-top', 'init'], ['the-top', 'on(init)'], ['the-top', 'didReceiveAttrs'], ['the-top', 'willRender'], ['the-top', 'willInsertElement'], ['the-middle', 'init'], ['the-middle', 'on(init)'], ['the-middle', 'didReceiveAttrs'], ['the-middle', 'willRender'], ['the-middle', 'willInsertElement'], ['the-bottom', 'init'], ['the-bottom', 'on(init)'], ['the-bottom', 'didReceiveAttrs'], ['the-bottom', 'willRender'], ['the-bottom', 'willInsertElement'], // Async hooks
        ['the-bottom', 'didInsertElement'], ['the-bottom', 'didRender'], ['the-middle', 'didInsertElement'], ['the-middle', 'didRender'], ['the-top', 'didInsertElement'], ['the-top', 'didRender']],
        nonInteractive: [// Sync hooks
        ['the-top', 'init'], ['the-top', 'on(init)'], ['the-top', 'didReceiveAttrs'], ['the-middle', 'init'], ['the-middle', 'on(init)'], ['the-middle', 'didReceiveAttrs'], ['the-bottom', 'init'], ['the-bottom', 'on(init)'], ['the-bottom', 'didReceiveAttrs']]
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.components['the-bottom'].rerender();
      });
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertHooks({
        label: 'after no-op rerender (bottom)',
        interactive: [// Sync hooks
        ['the-top', 'willUpdate'], ['the-top', 'willRender'], ['the-middle', 'willUpdate'], ['the-middle', 'willRender'], ['the-bottom', 'willUpdate'], ['the-bottom', 'willRender'], // Async hooks
        ['the-bottom', 'didUpdate'], ['the-bottom', 'didRender'], ['the-middle', 'didUpdate'], ['the-middle', 'didRender'], ['the-top', 'didUpdate'], ['the-top', 'didRender']],
        nonInteractive: []
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.components['the-middle'].rerender();
      });
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertHooks({
        label: 'after no-op rerender (middle)',
        interactive: [// Sync hooks
        ['the-top', 'willUpdate'], ['the-top', 'willRender'], ['the-middle', 'willUpdate'], ['the-middle', 'willRender'], // Async hooks
        ['the-middle', 'didUpdate'], ['the-middle', 'didRender'], ['the-top', 'didUpdate'], ['the-top', 'didRender']],
        nonInteractive: []
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.components['the-top'].rerender();
      });
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertHooks({
        label: 'after no-op rerender (top)',
        interactive: [// Sync hooks
        ['the-top', 'willUpdate'], ['the-top', 'willRender'], // Async hooks
        ['the-top', 'didUpdate'], ['the-top', 'didRender']],
        nonInteractive: []
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'twitter', '@horsetomdale');
      });
      this.assertText('Twitter: @horsetomdale|Name: Tom Dale|Website: tomdale.net'); // Because the `twitter` attr is only used by the topmost component,
      // and not passed down, we do not expect to see lifecycle hooks
      // called for child components. If the `didReceiveAttrs` hook used
      // the new attribute to rerender itself imperatively, that would result
      // in lifecycle hooks being invoked for the child.

      this.assertHooks({
        label: 'after update',
        interactive: [// Sync hooks
        ['the-top', 'didUpdateAttrs'], ['the-top', 'didReceiveAttrs'], ['the-top', 'willUpdate'], ['the-top', 'willRender'], // Async hooks
        ['the-top', 'didUpdate'], ['the-top', 'didRender']],
        nonInteractive: [// Sync hooks
        ['the-top', 'didUpdateAttrs'], ['the-top', 'didReceiveAttrs']]
      });
      this.teardownAssertions.push(function () {
        _this4.assertHooks({
          label: 'destroy',
          interactive: [['the-top', 'willDestroyElement'], ['the-top', 'willClearRender'], ['the-middle', 'willDestroyElement'], ['the-middle', 'willClearRender'], ['the-bottom', 'willDestroyElement'], ['the-bottom', 'willClearRender'], ['the-top', 'didDestroyElement'], ['the-middle', 'didDestroyElement'], ['the-bottom', 'didDestroyElement'], ['the-top', 'willDestroy'], ['the-middle', 'willDestroy'], ['the-bottom', 'willDestroy']],
          nonInteractive: [['the-top', 'willDestroy'], ['the-middle', 'willDestroy'], ['the-bottom', 'willDestroy']]
        });

        _this4.assertRegisteredViews('after destroy');
      });
    };

    _proto['@test lifecycle hooks are invoked in a correct sibling order'] = function testLifecycleHooksAreInvokedInACorrectSiblingOrder() {
      var _this5 = this;

      var _this$boundHelpers2 = this.boundHelpers,
          attr = _this$boundHelpers2.attr,
          invoke = _this$boundHelpers2.invoke;
      this.registerComponent('the-parent', {
        template: (0, _internalTestHelpers.strip)(_templateObject4(), invoke('the-first-child', {
          twitter: expr(attr('twitter'))
        }), invoke('the-second-child', {
          name: expr(attr('name'))
        }), invoke('the-last-child', {
          website: expr(attr('website'))
        }))
      });
      this.registerComponent('the-first-child', {
        template: "Twitter: {{" + attr('twitter') + "}}"
      });
      this.registerComponent('the-second-child', {
        template: "Name: {{" + attr('name') + "}}"
      });
      this.registerComponent('the-last-child', {
        template: "Website: {{" + attr('website') + "}}"
      });
      this.render(invoke('the-parent', {
        twitter: expr('twitter'),
        name: expr('name'),
        website: expr('website')
      }), {
        twitter: '@tomdale',
        name: 'Tom Dale',
        website: 'tomdale.net'
      });
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertRegisteredViews('intial render');
      this.assertHooks({
        label: 'after initial render',
        interactive: [// Sync hooks
        ['the-parent', 'init'], ['the-parent', 'on(init)'], ['the-parent', 'didReceiveAttrs'], ['the-parent', 'willRender'], ['the-parent', 'willInsertElement'], ['the-first-child', 'init'], ['the-first-child', 'on(init)'], ['the-first-child', 'didReceiveAttrs'], ['the-first-child', 'willRender'], ['the-first-child', 'willInsertElement'], ['the-second-child', 'init'], ['the-second-child', 'on(init)'], ['the-second-child', 'didReceiveAttrs'], ['the-second-child', 'willRender'], ['the-second-child', 'willInsertElement'], ['the-last-child', 'init'], ['the-last-child', 'on(init)'], ['the-last-child', 'didReceiveAttrs'], ['the-last-child', 'willRender'], ['the-last-child', 'willInsertElement'], // Async hooks
        ['the-first-child', 'didInsertElement'], ['the-first-child', 'didRender'], ['the-second-child', 'didInsertElement'], ['the-second-child', 'didRender'], ['the-last-child', 'didInsertElement'], ['the-last-child', 'didRender'], ['the-parent', 'didInsertElement'], ['the-parent', 'didRender']],
        nonInteractive: [// Sync hooks
        ['the-parent', 'init'], ['the-parent', 'on(init)'], ['the-parent', 'didReceiveAttrs'], ['the-first-child', 'init'], ['the-first-child', 'on(init)'], ['the-first-child', 'didReceiveAttrs'], ['the-second-child', 'init'], ['the-second-child', 'on(init)'], ['the-second-child', 'didReceiveAttrs'], ['the-last-child', 'init'], ['the-last-child', 'on(init)'], ['the-last-child', 'didReceiveAttrs']]
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.components['the-first-child'].rerender();
      });
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertHooks({
        label: 'after no-op rerender (first child)',
        interactive: [// Sync hooks
        ['the-parent', 'willUpdate'], ['the-parent', 'willRender'], ['the-first-child', 'willUpdate'], ['the-first-child', 'willRender'], // Async hooks
        ['the-first-child', 'didUpdate'], ['the-first-child', 'didRender'], ['the-parent', 'didUpdate'], ['the-parent', 'didRender']],
        nonInteractive: []
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.components['the-second-child'].rerender();
      });
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertHooks({
        label: 'after no-op rerender (second child)',
        interactive: [// Sync hooks
        ['the-parent', 'willUpdate'], ['the-parent', 'willRender'], ['the-second-child', 'willUpdate'], ['the-second-child', 'willRender'], // Async hooks
        ['the-second-child', 'didUpdate'], ['the-second-child', 'didRender'], ['the-parent', 'didUpdate'], ['the-parent', 'didRender']],
        nonInteractive: []
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.components['the-last-child'].rerender();
      });
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertHooks({
        label: 'after no-op rerender (last child)',
        interactive: [// Sync hooks
        ['the-parent', 'willUpdate'], ['the-parent', 'willRender'], ['the-last-child', 'willUpdate'], ['the-last-child', 'willRender'], // Async hooks
        ['the-last-child', 'didUpdate'], ['the-last-child', 'didRender'], ['the-parent', 'didUpdate'], ['the-parent', 'didRender']],
        nonInteractive: []
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.components['the-parent'].rerender();
      });
      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertHooks({
        label: 'after no-op rerender (parent)',
        interactive: [// Sync hooks
        ['the-parent', 'willUpdate'], ['the-parent', 'willRender'], // Async hooks
        ['the-parent', 'didUpdate'], ['the-parent', 'didRender']],
        nonInteractive: []
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.setProperties)(_this5.context, {
          twitter: '@horsetomdale',
          name: 'Horse Tom Dale',
          website: 'horsetomdale.net'
        });
      });
      this.assertText('Twitter: @horsetomdale|Name: Horse Tom Dale|Website: horsetomdale.net');
      this.assertHooks({
        label: 'after update',
        interactive: [// Sync hooks
        ['the-parent', 'didUpdateAttrs'], ['the-parent', 'didReceiveAttrs'], ['the-parent', 'willUpdate'], ['the-parent', 'willRender'], ['the-first-child', 'didUpdateAttrs'], ['the-first-child', 'didReceiveAttrs'], ['the-first-child', 'willUpdate'], ['the-first-child', 'willRender'], ['the-second-child', 'didUpdateAttrs'], ['the-second-child', 'didReceiveAttrs'], ['the-second-child', 'willUpdate'], ['the-second-child', 'willRender'], ['the-last-child', 'didUpdateAttrs'], ['the-last-child', 'didReceiveAttrs'], ['the-last-child', 'willUpdate'], ['the-last-child', 'willRender'], // Async hooks
        ['the-first-child', 'didUpdate'], ['the-first-child', 'didRender'], ['the-second-child', 'didUpdate'], ['the-second-child', 'didRender'], ['the-last-child', 'didUpdate'], ['the-last-child', 'didRender'], ['the-parent', 'didUpdate'], ['the-parent', 'didRender']],
        nonInteractive: [// Sync hooks
        ['the-parent', 'didUpdateAttrs'], ['the-parent', 'didReceiveAttrs'], ['the-first-child', 'didUpdateAttrs'], ['the-first-child', 'didReceiveAttrs'], ['the-second-child', 'didUpdateAttrs'], ['the-second-child', 'didReceiveAttrs'], ['the-last-child', 'didUpdateAttrs'], ['the-last-child', 'didReceiveAttrs']]
      });
      this.teardownAssertions.push(function () {
        _this5.assertHooks({
          label: 'destroy',
          interactive: [['the-parent', 'willDestroyElement'], ['the-parent', 'willClearRender'], ['the-first-child', 'willDestroyElement'], ['the-first-child', 'willClearRender'], ['the-second-child', 'willDestroyElement'], ['the-second-child', 'willClearRender'], ['the-last-child', 'willDestroyElement'], ['the-last-child', 'willClearRender'], ['the-parent', 'didDestroyElement'], ['the-first-child', 'didDestroyElement'], ['the-second-child', 'didDestroyElement'], ['the-last-child', 'didDestroyElement'], ['the-parent', 'willDestroy'], ['the-first-child', 'willDestroy'], ['the-second-child', 'willDestroy'], ['the-last-child', 'willDestroy']],
          nonInteractive: [['the-parent', 'willDestroy'], ['the-first-child', 'willDestroy'], ['the-second-child', 'willDestroy'], ['the-last-child', 'willDestroy']]
        });

        _this5.assertRegisteredViews('after destroy');
      });
    };

    _proto['@test passing values through attrs causes lifecycle hooks to fire if the attribute values have changed'] = function testPassingValuesThroughAttrsCausesLifecycleHooksToFireIfTheAttributeValuesHaveChanged() {
      var _this6 = this;

      var _this$boundHelpers3 = this.boundHelpers,
          attr = _this$boundHelpers3.attr,
          invoke = _this$boundHelpers3.invoke;
      this.registerComponent('the-top', {
        template: (0, _internalTestHelpers.strip)(_templateObject5(), invoke('the-middle', {
          twitterTop: expr(attr('twitter'))
        }))
      });
      this.registerComponent('the-middle', {
        template: (0, _internalTestHelpers.strip)(_templateObject6(), invoke('the-bottom', {
          twitterMiddle: expr(attr('twitterTop'))
        }))
      });
      this.registerComponent('the-bottom', {
        template: (0, _internalTestHelpers.strip)(_templateObject7(), attr('twitterMiddle'))
      });
      this.render(invoke('the-top', {
        twitter: expr('twitter')
      }), {
        twitter: '@tomdale'
      });
      this.assertText('Top: Middle: Bottom: @tomdale');
      this.assertRegisteredViews('intial render');
      this.assertHooks({
        label: 'after initial render',
        interactive: [// Sync hooks
        ['the-top', 'init'], ['the-top', 'on(init)'], ['the-top', 'didReceiveAttrs'], ['the-top', 'willRender'], ['the-top', 'willInsertElement'], ['the-middle', 'init'], ['the-middle', 'on(init)'], ['the-middle', 'didReceiveAttrs'], ['the-middle', 'willRender'], ['the-middle', 'willInsertElement'], ['the-bottom', 'init'], ['the-bottom', 'on(init)'], ['the-bottom', 'didReceiveAttrs'], ['the-bottom', 'willRender'], ['the-bottom', 'willInsertElement'], // Async hooks
        ['the-bottom', 'didInsertElement'], ['the-bottom', 'didRender'], ['the-middle', 'didInsertElement'], ['the-middle', 'didRender'], ['the-top', 'didInsertElement'], ['the-top', 'didRender']],
        nonInteractive: [// Sync hooks
        ['the-top', 'init'], ['the-top', 'on(init)'], ['the-top', 'didReceiveAttrs'], ['the-middle', 'init'], ['the-middle', 'on(init)'], ['the-middle', 'didReceiveAttrs'], ['the-bottom', 'init'], ['the-bottom', 'on(init)'], ['the-bottom', 'didReceiveAttrs']]
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'twitter', '@horsetomdale');
      });
      this.assertText('Top: Middle: Bottom: @horsetomdale'); // Because the `twitter` attr is used by the all of the components,
      // the lifecycle hooks are invoked for all components.

      this.assertHooks({
        label: 'after updating (root)',
        interactive: [// Sync hooks
        ['the-top', 'didUpdateAttrs'], ['the-top', 'didReceiveAttrs'], ['the-top', 'willUpdate'], ['the-top', 'willRender'], ['the-middle', 'didUpdateAttrs'], ['the-middle', 'didReceiveAttrs'], ['the-middle', 'willUpdate'], ['the-middle', 'willRender'], ['the-bottom', 'didUpdateAttrs'], ['the-bottom', 'didReceiveAttrs'], ['the-bottom', 'willUpdate'], ['the-bottom', 'willRender'], // Async hooks
        ['the-bottom', 'didUpdate'], ['the-bottom', 'didRender'], ['the-middle', 'didUpdate'], ['the-middle', 'didRender'], ['the-top', 'didUpdate'], ['the-top', 'didRender']],
        nonInteractive: [// Sync hooks
        ['the-top', 'didUpdateAttrs'], ['the-top', 'didReceiveAttrs'], ['the-middle', 'didUpdateAttrs'], ['the-middle', 'didReceiveAttrs'], ['the-bottom', 'didUpdateAttrs'], ['the-bottom', 'didReceiveAttrs']]
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.rerender();
      });
      this.assertText('Top: Middle: Bottom: @horsetomdale'); // In this case, because the attrs are passed down, all child components are invoked.

      this.assertHooks({
        label: 'after no-op rernder (root)',
        interactive: [],
        nonInteractive: []
      });
      this.teardownAssertions.push(function () {
        _this6.assertHooks({
          label: 'destroy',
          interactive: [['the-top', 'willDestroyElement'], ['the-top', 'willClearRender'], ['the-middle', 'willDestroyElement'], ['the-middle', 'willClearRender'], ['the-bottom', 'willDestroyElement'], ['the-bottom', 'willClearRender'], ['the-top', 'didDestroyElement'], ['the-middle', 'didDestroyElement'], ['the-bottom', 'didDestroyElement'], ['the-top', 'willDestroy'], ['the-middle', 'willDestroy'], ['the-bottom', 'willDestroy']],
          nonInteractive: [['the-top', 'willDestroy'], ['the-middle', 'willDestroy'], ['the-bottom', 'willDestroy']]
        });

        _this6.assertRegisteredViews('after destroy');
      });
    };

    _proto['@test components rendered from `{{each}}` have correct life-cycle hooks to be called'] = function testComponentsRenderedFromEachHaveCorrectLifeCycleHooksToBeCalled() {
      var _this7 = this;

      var invoke = this.boundHelpers.invoke;
      this.registerComponent('nested-item', {
        template: "{{yield}}"
      });
      this.registerComponent('an-item', {
        template: (0, _internalTestHelpers.strip)(_templateObject8())
      });
      this.registerComponent('no-items', {
        template: (0, _internalTestHelpers.strip)(_templateObject9())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject10(), invoke('an-item', {
        count: expr('item')
      }), invoke('no-items')), {
        items: [1, 2, 3, 4, 5]
      });
      this.assertText('Item: 1Item: 2Item: 3Item: 4Item: 5');
      this.assertRegisteredViews('intial render');

      var initialHooks = function () {
        var ret = [['an-item', 'init'], ['an-item', 'on(init)'], ['an-item', 'didReceiveAttrs']];

        if (_this7.isInteractive) {
          ret.push(['an-item', 'willRender'], ['an-item', 'willInsertElement']);
        }

        ret.push(['nested-item', 'init'], ['nested-item', 'on(init)'], ['nested-item', 'didReceiveAttrs']);

        if (_this7.isInteractive) {
          ret.push(['nested-item', 'willRender'], ['nested-item', 'willInsertElement']);
        }

        return ret;
      };

      var initialAfterRenderHooks = function () {
        if (_this7.isInteractive) {
          return [['nested-item', 'didInsertElement'], ['nested-item', 'didRender'], ['an-item', 'didInsertElement'], ['an-item', 'didRender']];
        } else {
          return [];
        }
      };

      this.assertHooks({
        label: 'after initial render',
        interactive: [].concat(initialHooks(1), initialHooks(2), initialHooks(3), initialHooks(4), initialHooks(5), initialAfterRenderHooks(5), initialAfterRenderHooks(4), initialAfterRenderHooks(3), initialAfterRenderHooks(2), initialAfterRenderHooks(1)),
        nonInteractive: [].concat(initialHooks(1), initialHooks(2), initialHooks(3), initialHooks(4), initialHooks(5), initialAfterRenderHooks(5), initialAfterRenderHooks(4), initialAfterRenderHooks(3), initialAfterRenderHooks(2), initialAfterRenderHooks(1))
      }); // TODO: Is this correct? Should childViews be populated in non-interactive mode?

      if (this.isInteractive) {
        this.assert.equal(this.component.childViews.length, 5, 'childViews precond');
      }

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'items', []);
      }); // TODO: Is this correct? Should childViews be populated in non-interactive mode?

      if (this.isInteractive) {
        this.assert.equal(this.component.childViews.length, 1, 'childViews updated');
      }

      this.assertText('Nothing to see here');
      this.assertHooks({
        label: 'reset to empty array',
        interactive: [['an-item', 'willDestroyElement'], ['an-item', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['an-item', 'willDestroyElement'], ['an-item', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['an-item', 'willDestroyElement'], ['an-item', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['an-item', 'willDestroyElement'], ['an-item', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['an-item', 'willDestroyElement'], ['an-item', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['no-items', 'init'], ['no-items', 'on(init)'], ['no-items', 'didReceiveAttrs'], ['no-items', 'willRender'], ['no-items', 'willInsertElement'], ['nested-item', 'init'], ['nested-item', 'on(init)'], ['nested-item', 'didReceiveAttrs'], ['nested-item', 'willRender'], ['nested-item', 'willInsertElement'], ['an-item', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['an-item', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['an-item', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['an-item', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['an-item', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['nested-item', 'didInsertElement'], ['nested-item', 'didRender'], ['no-items', 'didInsertElement'], ['no-items', 'didRender'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy']],
        nonInteractive: [['no-items', 'init'], ['no-items', 'on(init)'], ['no-items', 'didReceiveAttrs'], ['nested-item', 'init'], ['nested-item', 'on(init)'], ['nested-item', 'didReceiveAttrs'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy']]
      });
      this.teardownAssertions.push(function () {
        _this7.assertHooks({
          label: 'destroy',
          interactive: [['no-items', 'willDestroyElement'], ['no-items', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['no-items', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['no-items', 'willDestroy'], ['nested-item', 'willDestroy']],
          nonInteractive: [['no-items', 'willDestroy'], ['nested-item', 'willDestroy']]
        });

        _this7.assertRegisteredViews('after destroy');
      });
    };

    (0, _emberBabel.createClass)(LifeCycleHooksTest, [{
      key: "isInteractive",
      get: function () {
        return true;
      }
    }, {
      key: "ComponentClass",
      get: function () {
        throw new Error('Not implemented: `ComponentClass`');
      }
    }, {
      key: "boundHelpers",
      get: function () {
        return {
          invoke: bind(this.invocationFor, this),
          attr: bind(this.attrFor, this)
        };
      }
    }]);
    return LifeCycleHooksTest;
  }(_internalTestHelpers.RenderingTestCase);

  var CurlyComponentsTest =
  /*#__PURE__*/
  function (_LifeCycleHooksTest) {
    (0, _emberBabel.inheritsLoose)(CurlyComponentsTest, _LifeCycleHooksTest);

    function CurlyComponentsTest() {
      return _LifeCycleHooksTest.apply(this, arguments) || this;
    }

    var _proto2 = CurlyComponentsTest.prototype;

    _proto2.invocationFor = function invocationFor(name) {
      var _this8 = this;

      var namedArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var attrs = Object.keys(namedArgs).map(function (k) {
        return k + "=" + _this8.val(namedArgs[k]);
      }).join(' ');
      return "{{" + name + " " + attrs + "}}";
    };

    _proto2.attrFor = function attrFor(name) {
      return "" + name;
    }
    /* private */
    ;

    _proto2.val = function val(value) {
      if (value.isString) {
        return JSON.stringify(value.value);
      } else if (value.isExpr) {
        return "(readonly " + value.value + ")";
      } else {
        throw new Error("Unknown value: " + value);
      }
    };

    (0, _emberBabel.createClass)(CurlyComponentsTest, [{
      key: "ComponentClass",
      get: function () {
        return _helpers.Component;
      }
    }]);
    return CurlyComponentsTest;
  }(LifeCycleHooksTest);

  (0, _internalTestHelpers.moduleFor)('Components test: interactive lifecycle hooks (curly components)',
  /*#__PURE__*/
  function (_CurlyComponentsTest) {
    (0, _emberBabel.inheritsLoose)(_class, _CurlyComponentsTest);

    function _class() {
      return _CurlyComponentsTest.apply(this, arguments) || this;
    }

    (0, _emberBabel.createClass)(_class, [{
      key: "isInteractive",
      get: function () {
        return true;
      }
    }]);
    return _class;
  }(CurlyComponentsTest));
  (0, _internalTestHelpers.moduleFor)('Components test: non-interactive lifecycle hooks (curly components)',
  /*#__PURE__*/
  function (_CurlyComponentsTest2) {
    (0, _emberBabel.inheritsLoose)(_class2, _CurlyComponentsTest2);

    function _class2() {
      return _CurlyComponentsTest2.apply(this, arguments) || this;
    }

    (0, _emberBabel.createClass)(_class2, [{
      key: "isInteractive",
      get: function () {
        return false;
      }
    }]);
    return _class2;
  }(CurlyComponentsTest));
  (0, _internalTestHelpers.moduleFor)('Components test: interactive lifecycle hooks (tagless curly components)',
  /*#__PURE__*/
  function (_CurlyComponentsTest3) {
    (0, _emberBabel.inheritsLoose)(_class3, _CurlyComponentsTest3);

    function _class3() {
      return _CurlyComponentsTest3.apply(this, arguments) || this;
    }

    (0, _emberBabel.createClass)(_class3, [{
      key: "ComponentClass",
      get: function () {
        return _helpers.Component.extend({
          tagName: ''
        });
      }
    }, {
      key: "isInteractive",
      get: function () {
        return true;
      }
    }]);
    return _class3;
  }(CurlyComponentsTest));
  (0, _internalTestHelpers.moduleFor)('Components test: non-interactive lifecycle hooks (tagless curly components)',
  /*#__PURE__*/
  function (_CurlyComponentsTest4) {
    (0, _emberBabel.inheritsLoose)(_class4, _CurlyComponentsTest4);

    function _class4() {
      return _CurlyComponentsTest4.apply(this, arguments) || this;
    }

    (0, _emberBabel.createClass)(_class4, [{
      key: "ComponentClass",
      get: function () {
        return _helpers.Component.extend({
          tagName: ''
        });
      }
    }, {
      key: "isInteractive",
      get: function () {
        return false;
      }
    }]);
    return _class4;
  }(CurlyComponentsTest));
  (0, _internalTestHelpers.moduleFor)('Run loop and lifecycle hooks',
  /*#__PURE__*/
  function (_RenderingTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class5, _RenderingTestCase2);

    function _class5() {
      return _RenderingTestCase2.apply(this, arguments) || this;
    }

    var _proto3 = _class5.prototype;

    _proto3['@test afterRender set'] = function testAfterRenderSet() {
      var _this10 = this;

      var ComponentClass = _helpers.Component.extend({
        width: '5',
        didInsertElement: function () {
          var _this9 = this;

          (0, _runloop.schedule)('afterRender', function () {
            _this9.set('width', '10');
          });
        }
      });

      var template = "{{width}}";
      this.registerComponent('foo-bar', {
        ComponentClass: ComponentClass,
        template: template
      });
      this.render('{{foo-bar}}');
      this.assertText('10');
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.rerender();
      });
      this.assertText('10');
    };

    _proto3['@test afterRender set on parent'] = function testAfterRenderSetOnParent() {
      var _this12 = this;

      var ComponentClass = _helpers.Component.extend({
        didInsertElement: function () {
          var _this11 = this;

          (0, _runloop.schedule)('afterRender', function () {
            var parent = _this11.get('parent');

            parent.set('foo', 'wat');
          });
        }
      });

      var template = "{{foo}}";
      this.registerComponent('foo-bar', {
        ComponentClass: ComponentClass,
        template: template
      });
      this.render('{{foo-bar parent=this foo=foo}}');
      this.assertText('wat');
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.rerender();
      });
      this.assertText('wat');
    };

    _proto3['@test `willRender` can set before render (GH#14458)'] = function testWillRenderCanSetBeforeRenderGH14458() {
      var ComponentClass = _helpers.Component.extend({
        tagName: 'a',
        customHref: 'http://google.com',
        attributeBindings: ['customHref:href'],
        willRender: function () {
          this.set('customHref', 'http://willRender.com');
        }
      });

      var template = "Hello World";
      this.registerComponent('foo-bar', {
        ComponentClass: ComponentClass,
        template: template
      });
      this.render("{{foo-bar id=\"foo\"}}");
      this.assertElement(this.firstChild, {
        tagName: 'a',
        attrs: {
          id: 'foo',
          href: 'http://willRender.com',
          class: (0, _internalTestHelpers.classes)('ember-view')
        }
      });
    };

    _proto3['@test that thing about destroying'] = function testThatThingAboutDestroying(assert) {
      var _this13 = this;

      var ParentDestroyedElements = [];
      var ChildDestroyedElements = [];

      var ParentComponent = _helpers.Component.extend({
        willDestroyElement: function () {
          ParentDestroyedElements.push({
            id: this.itemId,
            name: 'parent-component',
            hasParent: Boolean(this.element.parentNode),
            nextSibling: Boolean(this.element.nextSibling),
            previousSibling: Boolean(this.element.previousSibling)
          });
        }
      });

      var PartentTemplate = (0, _internalTestHelpers.strip)(_templateObject11());

      var NestedComponent = _helpers.Component.extend({
        willDestroyElement: function () {
          ChildDestroyedElements.push({
            id: this.nestedId,
            name: 'nested-component',
            hasParent: Boolean(this.element.parentNode),
            nextSibling: Boolean(this.element.nextSibling),
            previousSibling: Boolean(this.element.previousSibling)
          });
        }
      });

      var NestedTemplate = "{{yield}}";
      this.registerComponent('parent-component', {
        ComponentClass: ParentComponent,
        template: PartentTemplate
      });
      this.registerComponent('nested-component', {
        ComponentClass: NestedComponent,
        template: NestedTemplate
      });
      var array = (0, _runtime.A)([{
        id: 1
      }, {
        id: 2
      }, {
        id: 3
      }, {
        id: 4
      }, {
        id: 5
      }]);
      this.render((0, _internalTestHelpers.strip)(_templateObject12()), {
        items: array,
        model: {
          shouldShow: true
        }
      });
      this.assertText('1AB2AB3AB4AB5AB6AB7AB');
      (0, _internalTestHelpers.runTask)(function () {
        array.removeAt(2);
        array.removeAt(2);
        (0, _metal.set)(_this13.context, 'model.shouldShow', false);
      });
      this.assertText('1AB2AB5AB');
      assertDestroyHooks(assert, [].concat(ParentDestroyedElements), [{
        id: 3,
        hasParent: true,
        nextSibling: true,
        previousSibling: true
      }, {
        id: 4,
        hasParent: true,
        nextSibling: true,
        previousSibling: true
      }, {
        id: 6,
        hasParent: true,
        nextSibling: true,
        previousSibling: true
      }, {
        id: 7,
        hasParent: true,
        nextSibling: false,
        previousSibling: true
      }]);
      assertDestroyHooks(assert, [].concat(ChildDestroyedElements), [{
        id: '3-A',
        hasParent: true,
        nextSibling: true,
        previousSibling: false
      }, {
        id: '3-B',
        hasParent: true,
        nextSibling: false,
        previousSibling: true
      }, {
        id: '4-A',
        hasParent: true,
        nextSibling: true,
        previousSibling: false
      }, {
        id: '4-B',
        hasParent: true,
        nextSibling: false,
        previousSibling: true
      }, {
        id: '6-A',
        hasParent: true,
        nextSibling: true,
        previousSibling: false
      }, {
        id: '6-B',
        hasParent: true,
        nextSibling: false,
        previousSibling: true
      }, {
        id: '7-A',
        hasParent: true,
        nextSibling: true,
        previousSibling: false
      }, {
        id: '7-B',
        hasParent: true,
        nextSibling: false,
        previousSibling: true
      }]);
    };

    _proto3['@test lifecycle hooks exist on the base class'] = function testLifecycleHooksExistOnTheBaseClass(assert) {
      // Make sure we get the finalized component prototype
      var prototype = _helpers.Component.proto();

      assert.equal(typeof prototype.didDestroyElement, 'function', 'didDestroyElement exists');
      assert.equal(typeof prototype.didInsertElement, 'function', 'didInsertElement exists');
      assert.equal(typeof prototype.didReceiveAttrs, 'function', 'didReceiveAttrs exists');
      assert.equal(typeof prototype.didRender, 'function', 'didRender exists');
      assert.equal(typeof prototype.didUpdate, 'function', 'didUpdate exists');
      assert.equal(typeof prototype.didUpdateAttrs, 'function', 'didUpdateAttrs exists');
      assert.equal(typeof prototype.willClearRender, 'function', 'willClearRender exists');
      assert.equal(typeof prototype.willDestroy, 'function', 'willDestroy exists');
      assert.equal(typeof prototype.willDestroyElement, 'function', 'willDestroyElement exists');
      assert.equal(typeof prototype.willInsertElement, 'function', 'willInsertElement exists');
      assert.equal(typeof prototype.willRender, 'function', 'willRender exists');
      assert.equal(typeof prototype.willUpdate, 'function', 'willUpdate exists');
    };

    return _class5;
  }(_internalTestHelpers.RenderingTestCase));

  if (!_views.jQueryDisabled) {
    (0, _internalTestHelpers.moduleFor)('Run loop and lifecycle hooks - jQuery only',
    /*#__PURE__*/
    function (_RenderingTestCase3) {
      (0, _emberBabel.inheritsLoose)(_class6, _RenderingTestCase3);

      function _class6() {
        return _RenderingTestCase3.apply(this, arguments) || this;
      }

      var _proto4 = _class6.prototype;

      _proto4['@test lifecycle hooks have proper access to this.$()'] = function testLifecycleHooksHaveProperAccessToThis$(assert) {
        assert.expect(7);
        var component;

        var FooBarComponent = _helpers.Component.extend({
          tagName: 'div',
          init: function () {
            assert.notOk(this.$(), 'no access to element via this.$() on init() enter');

            this._super.apply(this, arguments);

            assert.notOk(this.$(), 'no access to element via this.$() after init() finished');
          },
          willInsertElement: function () {
            component = this;
            assert.ok(this.$(), 'willInsertElement has access to element via this.$()');
          },
          didInsertElement: function () {
            assert.ok(this.$(), 'didInsertElement has access to element via this.$()');
          },
          willDestroyElement: function () {
            assert.ok(this.$(), 'willDestroyElement has access to element via this.$()');
          },
          didDestroyElement: function () {
            assert.notOk(this.$(), 'didDestroyElement does not have access to element via this.$()');
          }
        });

        this.registerComponent('foo-bar', {
          ComponentClass: FooBarComponent,
          template: 'hello'
        });
        var owner = this.owner;
        expectDeprecation(function () {
          var comp = owner.lookup('component:foo-bar');
          (0, _internalTestHelpers.runAppend)(comp);
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _utils.tryInvoke)(component, 'destroy');
          });
        }, 'Using this.$() in a component has been deprecated, consider using this.element');
        (0, _internalTestHelpers.runTask)(function () {
          return (0, _utils.tryInvoke)(component, 'destroy');
        });
      };

      return _class6;
    }(_internalTestHelpers.RenderingTestCase));
  }

  function assertDestroyHooks(assert, _actual, _expected) {
    _expected.forEach(function (expected, i) {
      var name = expected.name;
      assert.equal(expected.id, _actual[i].id, name + " id is the same");
      assert.equal(expected.hasParent, _actual[i].hasParent, name + " has parent node");
      assert.equal(expected.nextSibling, _actual[i].nextSibling, name + " has next sibling node");
      assert.equal(expected.previousSibling, _actual[i].previousSibling, name + " has previous sibling node");
    });
  }

  function bind(func, thisArg) {
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return func.apply(thisArg, args);
    };
  }

  function string(value) {
    return {
      isString: true,
      value: value
    };
  }

  function expr(value) {
    return {
      isExpr: true,
      value: value
    };
  }

  function hook(name, hook) {
    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        attrs = _ref3.attrs,
        oldAttrs = _ref3.oldAttrs,
        newAttrs = _ref3.newAttrs;

    return {
      name: name,
      hook: hook,
      args: {
        attrs: attrs,
        oldAttrs: oldAttrs,
        newAttrs: newAttrs
      }
    };
  }

  function json(serializable) {
    return JSON.parse(JSON.stringify(serializable));
  }
});
enifed("@ember/-internals/glimmer/tests/integration/components/link-to/query-params-angle-test", ["ember-babel", "@ember/controller", "@ember/-internals/runtime", "@ember/-internals/routing", "internal-test-helpers"], function (_emberBabel, _controller, _runtime, _routing, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  if (true
  /* EMBER_GLIMMER_ANGLE_BRACKET_BUILT_INS */
  ) {
      (0, _internalTestHelpers.moduleFor)('<LinkTo /> component with query-params (rendering)',
      /*#__PURE__*/
      function (_ApplicationTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

        function _class() {
          var _this;

          _this = _ApplicationTestCase.apply(this, arguments) || this;

          _this.add('controller:index', _controller.default.extend({
            queryParams: ['foo'],
            foo: '123',
            bar: 'yes'
          }));

          return _this;
        }

        var _proto = _class.prototype;

        _proto['@test populates href with fully supplied query param values'] = function testPopulatesHrefWithFullySuppliedQueryParamValues() {
          var _this2 = this;

          this.addTemplate('index', "<LinkTo @route='index' @query={{hash foo='456' bar='NAW'}}>Index</LinkTo>");
          return this.visit('/').then(function () {
            _this2.assertComponentElement(_this2.firstChild, {
              tagName: 'a',
              attrs: {
                href: '/?bar=NAW&foo=456'
              },
              content: 'Index'
            });
          });
        };

        _proto['@test populates href with partially supplied query param values, but omits if value is default value'] = function testPopulatesHrefWithPartiallySuppliedQueryParamValuesButOmitsIfValueIsDefaultValue() {
          var _this3 = this;

          this.addTemplate('index', "<LinkTo @route='index' @query={{hash foo='123'}}>Index</LinkTo>");
          return this.visit('/').then(function () {
            _this3.assertComponentElement(_this3.firstChild, {
              tagName: 'a',
              attrs: {
                href: '/',
                class: (0, _internalTestHelpers.classes)('ember-view active')
              },
              content: 'Index'
            });
          });
        };

        return _class;
      }(_internalTestHelpers.ApplicationTestCase));
      (0, _internalTestHelpers.moduleFor)('<LinkTo /> component with query params (routing)',
      /*#__PURE__*/
      function (_ApplicationTestCase2) {
        (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase2);

        function _class2() {
          var _this4;

          _this4 = _ApplicationTestCase2.call(this) || this;
          var indexProperties = {
            foo: '123',
            bar: 'abc'
          };

          _this4.add('controller:index', _controller.default.extend({
            queryParams: ['foo', 'bar', 'abool'],
            foo: indexProperties.foo,
            bar: indexProperties.bar,
            boundThing: 'OMG',
            abool: true
          }));

          _this4.add('controller:about', _controller.default.extend({
            queryParams: ['baz', 'bat'],
            baz: 'alex',
            bat: 'borf'
          }));

          _this4.indexProperties = indexProperties;
          return _this4;
        }

        var _proto2 = _class2.prototype;

        _proto2.shouldNotBeActive = function shouldNotBeActive(assert, selector) {
          this.checkActive(assert, selector, false);
        };

        _proto2.shouldBeActive = function shouldBeActive(assert, selector) {
          this.checkActive(assert, selector, true);
        };

        _proto2.getController = function getController(name) {
          return this.applicationInstance.lookup("controller:" + name);
        };

        _proto2.checkActive = function checkActive(assert, selector, active) {
          var classList = this.$(selector)[0].className;
          assert.equal(classList.indexOf('active') > -1, active, selector + ' active should be ' + active.toString());
        };

        _proto2["@test doesn't update controller QP properties on current route when invoked"] = function (assert) {
          var _this5 = this;

          this.addTemplate('index', "<LinkTo id='the-link' @route='index'>Index</LinkTo>");
          return this.visit('/').then(function () {
            _this5.click('#the-link');

            var indexController = _this5.getController('index');

            assert.deepEqual(indexController.getProperties('foo', 'bar'), _this5.indexProperties, 'controller QP properties do not update');
          });
        };

        _proto2["@test doesn't update controller QP properties on current route when invoked (empty query-params obj)"] = function (assert) {
          var _this6 = this;

          this.addTemplate('index', "<LinkTo id='the-link' @route='index' @query={{hash}}>Index</LinkTo>");
          return this.visit('/').then(function () {
            _this6.click('#the-link');

            var indexController = _this6.getController('index');

            assert.deepEqual(indexController.getProperties('foo', 'bar'), _this6.indexProperties, 'controller QP properties do not update');
          });
        };

        _proto2["@test doesn't update controller QP properties on current route when invoked (empty query-params obj, inferred route)"] = function (assert) {
          var _this7 = this;

          this.addTemplate('index', "<LinkTo id='the-link' @query={{hash}}>Index</LinkTo>");
          return this.visit('/').then(function () {
            _this7.click('#the-link');

            var indexController = _this7.getController('index');

            assert.deepEqual(indexController.getProperties('foo', 'bar'), _this7.indexProperties, 'controller QP properties do not update');
          });
        };

        _proto2['@test updates controller QP properties on current route when invoked'] = function testUpdatesControllerQPPropertiesOnCurrentRouteWhenInvoked(assert) {
          var _this8 = this;

          this.addTemplate('index', "\n          <LinkTo id=\"the-link\" @route='index' @query={{hash foo='456'}}>\n            Index\n          </LinkTo>\n          ");
          return this.visit('/').then(function () {
            _this8.click('#the-link');

            var indexController = _this8.getController('index');

            assert.deepEqual(indexController.getProperties('foo', 'bar'), {
              foo: '456',
              bar: 'abc'
            }, 'controller QP properties updated');
          });
        };

        _proto2['@test updates controller QP properties on current route when invoked (inferred route)'] = function testUpdatesControllerQPPropertiesOnCurrentRouteWhenInvokedInferredRoute(assert) {
          var _this9 = this;

          this.addTemplate('index', "\n          <LinkTo id=\"the-link\" @query={{hash foo='456'}}>\n            Index\n          </LinkTo>\n          ");
          return this.visit('/').then(function () {
            _this9.click('#the-link');

            var indexController = _this9.getController('index');

            assert.deepEqual(indexController.getProperties('foo', 'bar'), {
              foo: '456',
              bar: 'abc'
            }, 'controller QP properties updated');
          });
        };

        _proto2['@test updates controller QP properties on other route after transitioning to that route'] = function testUpdatesControllerQPPropertiesOnOtherRouteAfterTransitioningToThatRoute(assert) {
          var _this10 = this;

          this.router.map(function () {
            this.route('about');
          });
          this.addTemplate('index', "\n          <LinkTo id=\"the-link\" @route=\"about\" @query={{hash baz='lol'}}>\n            About\n          </LinkTo>\n          ");
          return this.visit('/').then(function () {
            var theLink = _this10.$('#the-link');

            assert.equal(theLink.attr('href'), '/about?baz=lol');
            (0, _internalTestHelpers.runTask)(function () {
              return _this10.click('#the-link');
            });

            var aboutController = _this10.getController('about');

            assert.deepEqual(aboutController.getProperties('baz', 'bat'), {
              baz: 'lol',
              bat: 'borf'
            }, 'about controller QP properties updated');
          });
        };

        _proto2['@test generates proper href for `LinkTo` with no @route after transitioning to an error route GH#17963'] = function testGeneratesProperHrefForLinkToWithNoRouteAfterTransitioningToAnErrorRouteGH17963(assert) {
          var _this11 = this;

          this.router.map(function () {
            this.route('bad');
          });
          this.add('controller:application', _controller.default.extend({
            queryParams: ['baz']
          }));
          this.add('route:bad', _routing.Route.extend({
            model: function () {
              throw new Error('bad!');
            }
          }));
          this.addTemplate('error', "Error: {{model.message}}");
          this.addTemplate('application', "\n          <LinkTo id=\"bad-link\" @route=\"bad\">\n            Bad\n          </LinkTo>\n\n          <LinkTo id=\"good-link\" @query={{hash baz='lol'}}>\n            Good\n          </LinkTo>\n\n          {{outlet}}\n          ");
          return this.visit('/').then(
          /*#__PURE__*/
          _asyncToGenerator(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee() {
            var goodLink;
            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  assert.equal(_this11.$('#good-link').length, 1, 'good-link should be in the DOM');
                  assert.equal(_this11.$('#bad-link').length, 1, 'bad-link should be in the DOM');
                  goodLink = _this11.$('#good-link');
                  assert.equal(goodLink.attr('href'), '/?baz=lol');
                  return _context.abrupt("return", _this11.visit('/bad'));

                case 5:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }))).then(function () {
            assert.equal(_this11.$('#good-link').length, 1, 'good-link should be in the DOM');
            assert.equal(_this11.$('#bad-link').length, 1, 'bad-link should be in the DOM');

            var goodLink = _this11.$('#good-link'); // should still be / because we never entered /bad (it errored before being fully entered)
            // and error states do not get represented in the URL, so we are _effectively_ still
            // on /


            assert.equal(goodLink.attr('href'), '/?baz=lol');
            (0, _internalTestHelpers.runTask)(function () {
              return _this11.click('#good-link');
            });

            var applicationController = _this11.getController('application');

            assert.deepEqual(applicationController.getProperties('baz'), {
              baz: 'lol'
            }, 'index controller QP properties updated');
          });
        };

        _proto2['@test supplied QP properties can be bound'] = function testSuppliedQPPropertiesCanBeBound(assert) {
          var _this12 = this;

          this.addTemplate('index', "\n          <LinkTo id=\"the-link\" @query={{hash foo=boundThing}}>\n            Index\n          </LinkTo>\n          ");
          return this.visit('/').then(function () {
            var indexController = _this12.getController('index');

            var theLink = _this12.$('#the-link');

            assert.equal(theLink.attr('href'), '/?foo=OMG');
            (0, _internalTestHelpers.runTask)(function () {
              return indexController.set('boundThing', 'ASL');
            });
            assert.equal(theLink.attr('href'), '/?foo=ASL');
          });
        };

        _proto2['@test supplied QP properties can be bound (booleans)'] = function testSuppliedQPPropertiesCanBeBoundBooleans(assert) {
          var _this13 = this;

          this.addTemplate('index', "\n          <LinkTo id=\"the-link\" @query={{hash abool=boundThing}}>\n            Index\n          </LinkTo>\n          ");
          return this.visit('/').then(function () {
            var indexController = _this13.getController('index');

            var theLink = _this13.$('#the-link');

            assert.equal(theLink.attr('href'), '/?abool=OMG');
            (0, _internalTestHelpers.runTask)(function () {
              return indexController.set('boundThing', false);
            });
            assert.equal(theLink.attr('href'), '/?abool=false');

            _this13.click('#the-link');

            assert.deepEqual(indexController.getProperties('foo', 'bar', 'abool'), {
              foo: '123',
              bar: 'abc',
              abool: false
            }, 'bound bool QP properties update');
          });
        };

        _proto2['@test href updates when unsupplied controller QP props change'] =
        /*#__PURE__*/
        function () {
          var _testHrefUpdatesWhenUnsuppliedControllerQPPropsChange = _asyncToGenerator(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee2(assert) {
            var indexController, theLink;
            return regeneratorRuntime.wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  this.addTemplate('index', "\n          <LinkTo id=\"the-link\" @query={{hash foo='lol'}}>\n            Index\n          </LinkTo>\n          ");
                  _context2.next = 3;
                  return this.visit('/');

                case 3:
                  indexController = this.getController('index');
                  theLink = this.$('#the-link');
                  assert.equal(theLink.attr('href'), '/?foo=lol');
                  indexController.set('bar', 'BORF');
                  _context2.next = 9;
                  return (0, _internalTestHelpers.runLoopSettled)();

                case 9:
                  assert.equal(theLink.attr('href'), '/?bar=BORF&foo=lol');
                  indexController.set('foo', 'YEAH');
                  _context2.next = 13;
                  return (0, _internalTestHelpers.runLoopSettled)();

                case 13:
                  assert.equal(theLink.attr('href'), '/?bar=BORF&foo=lol');

                case 14:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this);
          }));

          function testHrefUpdatesWhenUnsuppliedControllerQPPropsChange(_x) {
            return _testHrefUpdatesWhenUnsuppliedControllerQPPropsChange.apply(this, arguments);
          }

          return testHrefUpdatesWhenUnsuppliedControllerQPPropsChange;
        }();

        _proto2['@test The <LinkTo /> component with only query params always transitions to the current route with the query params applied'] = function testTheLinkToComponentWithOnlyQueryParamsAlwaysTransitionsToTheCurrentRouteWithTheQueryParamsApplied(assert) {
          var _this14 = this; // Test harness for bug #12033


          this.addTemplate('cars', "\n          <LinkTo id='create-link' @route='cars.create'>Create new car</LinkTo>\n          <LinkTo id='page2-link' @query={{hash page='2'}}>Page 2</LinkTo>\n          {{outlet}}\n          ");
          this.addTemplate('cars.create', "<LinkTo id='close-link' @route='cars'>Close create form</LinkTo>");
          this.router.map(function () {
            this.route('cars', function () {
              this.route('create');
            });
          });
          this.add('controller:cars', _controller.default.extend({
            queryParams: ['page'],
            page: 1
          }));
          return this.visit('/cars/create').then(function () {
            var router = _this14.appRouter;

            var carsController = _this14.getController('cars');

            assert.equal(router.currentRouteName, 'cars.create');
            (0, _internalTestHelpers.runTask)(function () {
              return _this14.click('#close-link');
            });
            assert.equal(router.currentRouteName, 'cars.index');
            assert.equal(router.get('url'), '/cars');
            assert.equal(carsController.get('page'), 1, 'The page query-param is 1');
            (0, _internalTestHelpers.runTask)(function () {
              return _this14.click('#page2-link');
            });
            assert.equal(router.currentRouteName, 'cars.index', 'The active route is still cars');
            assert.equal(router.get('url'), '/cars?page=2', 'The url has been updated');
            assert.equal(carsController.get('page'), 2, 'The query params have been updated');
          });
        };

        _proto2['@test the <LinkTo /> component applies activeClass when query params are not changed'] = function testTheLinkToComponentAppliesActiveClassWhenQueryParamsAreNotChanged(assert) {
          var _this15 = this;

          this.addTemplate('index', "\n          <LinkTo id='cat-link' @query={{hash foo='cat'}}>Index</LinkTo>\n          <LinkTo id='dog-link' @query={{hash foo='dog'}}>Index</LinkTo>\n          <LinkTo id='change-nothing' @route='index'>Index</LinkTo>\n          ");
          this.addTemplate('search', "\n          <LinkTo id='same-search' @query={{hash search='same'}}>Index</LinkTo>\n          <LinkTo id='change-search' @query={{hash search='change'}}>Index</LinkTo>\n          <LinkTo id='same-search-add-archive' @query={{hash search='same' archive=true}}>Index</LinkTo>\n          <LinkTo id='only-add-archive' @query={{hash archive=true}}>Index</LinkTo>\n          <LinkTo id='both-same' @query={{hash search='same' archive=true}}>Index</LinkTo>\n          <LinkTo id='change-one' @query={{hash search='different' archive=true}}>Index</LinkTo>\n          <LinkTo id='remove-one' @query={{hash search='different' archive=false}}>Index</LinkTo>\n          {{outlet}}\n          ");
          this.addTemplate('search.results', "\n          <LinkTo id='same-sort-child-only' @query={{hash sort='title'}}>Index</LinkTo>\n          <LinkTo id='same-search-parent-only' @query={{hash search='same'}}>Index</LinkTo>\n          <LinkTo id='change-search-parent-only' @query={{hash search='change'}}>Index</LinkTo>\n          <LinkTo id='same-search-same-sort-child-and-parent' @query={{hash search='same' sort='title'}}>Index</LinkTo>\n          <LinkTo id='same-search-different-sort-child-and-parent' @query={{hash search='same' sort='author'}}>Index</LinkTo>\n          <LinkTo id='change-search-same-sort-child-and-parent' @query={{hash search='change' sort='title'}}>Index</LinkTo>\n          <LinkTo id='dog-link' @query={{hash foo='dog'}}>Index</LinkTo>\n          ");
          this.router.map(function () {
            this.route('search', function () {
              this.route('results');
            });
          });
          this.add('controller:search', _controller.default.extend({
            queryParams: ['search', 'archive'],
            search: '',
            archive: false
          }));
          this.add('controller:search.results', _controller.default.extend({
            queryParams: ['sort', 'showDetails'],
            sort: 'title',
            showDetails: true
          }));
          return this.visit('/').then(function () {
            _this15.shouldNotBeActive(assert, '#cat-link');

            _this15.shouldNotBeActive(assert, '#dog-link');

            return _this15.visit('/?foo=cat');
          }).then(function () {
            _this15.shouldBeActive(assert, '#cat-link');

            _this15.shouldNotBeActive(assert, '#dog-link');

            return _this15.visit('/?foo=dog');
          }).then(function () {
            _this15.shouldBeActive(assert, '#dog-link');

            _this15.shouldNotBeActive(assert, '#cat-link');

            _this15.shouldBeActive(assert, '#change-nothing');

            return _this15.visit('/search?search=same');
          }).then(function () {
            _this15.shouldBeActive(assert, '#same-search');

            _this15.shouldNotBeActive(assert, '#change-search');

            _this15.shouldNotBeActive(assert, '#same-search-add-archive');

            _this15.shouldNotBeActive(assert, '#only-add-archive');

            _this15.shouldNotBeActive(assert, '#remove-one');

            return _this15.visit('/search?search=same&archive=true');
          }).then(function () {
            _this15.shouldBeActive(assert, '#both-same');

            _this15.shouldNotBeActive(assert, '#change-one');

            return _this15.visit('/search/results?search=same&sort=title&showDetails=true');
          }).then(function () {
            _this15.shouldBeActive(assert, '#same-sort-child-only');

            _this15.shouldBeActive(assert, '#same-search-parent-only');

            _this15.shouldNotBeActive(assert, '#change-search-parent-only');

            _this15.shouldBeActive(assert, '#same-search-same-sort-child-and-parent');

            _this15.shouldNotBeActive(assert, '#same-search-different-sort-child-and-parent');

            _this15.shouldNotBeActive(assert, '#change-search-same-sort-child-and-parent');
          });
        };

        _proto2['@test the <LinkTo /> component applies active class when query-param is a number'] = function testTheLinkToComponentAppliesActiveClassWhenQueryParamIsANumber(assert) {
          var _this16 = this;

          this.addTemplate('index', "\n          <LinkTo id='page-link' @query={{hash page=pageNumber}}>\n            Index\n          </LinkTo>\n          ");
          this.add('controller:index', _controller.default.extend({
            queryParams: ['page'],
            page: 1,
            pageNumber: 5
          }));
          return this.visit('/').then(function () {
            _this16.shouldNotBeActive(assert, '#page-link');

            return _this16.visit('/?page=5');
          }).then(function () {
            _this16.shouldBeActive(assert, '#page-link');
          });
        };

        _proto2['@test the <LinkTo /> component applies active class when query-param is an array'] = function testTheLinkToComponentAppliesActiveClassWhenQueryParamIsAnArray(assert) {
          var _this17 = this;

          this.addTemplate('index', "\n          <LinkTo id='array-link' @query={{hash pages=pagesArray}}>Index</LinkTo>\n          <LinkTo id='bigger-link' @query={{hash pages=biggerArray}}>Index</LinkTo>\n          <LinkTo id='empty-link' @query={{hash pages=emptyArray}}>Index</LinkTo>\n          ");
          this.add('controller:index', _controller.default.extend({
            queryParams: ['pages'],
            pages: [],
            pagesArray: [1, 2],
            biggerArray: [1, 2, 3],
            emptyArray: []
          }));
          return this.visit('/').then(function () {
            _this17.shouldNotBeActive(assert, '#array-link');

            return _this17.visit('/?pages=%5B1%2C2%5D');
          }).then(function () {
            _this17.shouldBeActive(assert, '#array-link');

            _this17.shouldNotBeActive(assert, '#bigger-link');

            _this17.shouldNotBeActive(assert, '#empty-link');

            return _this17.visit('/?pages=%5B2%2C1%5D');
          }).then(function () {
            _this17.shouldNotBeActive(assert, '#array-link');

            _this17.shouldNotBeActive(assert, '#bigger-link');

            _this17.shouldNotBeActive(assert, '#empty-link');

            return _this17.visit('/?pages=%5B1%2C2%2C3%5D');
          }).then(function () {
            _this17.shouldBeActive(assert, '#bigger-link');

            _this17.shouldNotBeActive(assert, '#array-link');

            _this17.shouldNotBeActive(assert, '#empty-link');
          });
        };

        _proto2['@test the <LinkTo /> component applies active class to the parent route'] = function testTheLinkToComponentAppliesActiveClassToTheParentRoute(assert) {
          var _this18 = this;

          this.router.map(function () {
            this.route('parent', function () {
              this.route('child');
            });
          });
          this.addTemplate('application', "\n          <LinkTo id='parent-link' @route='parent'>Parent</LinkTo>\n          <LinkTo id='parent-child-link' @route='parent.child'>Child</LinkTo>\n          <LinkTo id='parent-link-qp' @route='parent' @query={{hash foo=cat}}>Parent</LinkTo>\n          {{outlet}}\n          ");
          this.add('controller:parent.child', _controller.default.extend({
            queryParams: ['foo'],
            foo: 'bar'
          }));
          return this.visit('/').then(function () {
            _this18.shouldNotBeActive(assert, '#parent-link');

            _this18.shouldNotBeActive(assert, '#parent-child-link');

            _this18.shouldNotBeActive(assert, '#parent-link-qp');

            return _this18.visit('/parent/child?foo=dog');
          }).then(function () {
            _this18.shouldBeActive(assert, '#parent-link');

            _this18.shouldNotBeActive(assert, '#parent-link-qp');
          });
        };

        _proto2['@test The <LinkTo /> component disregards query-params in activeness computation when current-when is specified'] =
        /*#__PURE__*/
        function () {
          var _testTheLinkToComponentDisregardsQueryParamsInActivenessComputationWhenCurrentWhenIsSpecified = _asyncToGenerator(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee3(assert) {
            var appLink, router, parentController;
            return regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  this.router.map(function () {
                    this.route('parent');
                  });
                  this.addTemplate('application', "\n          <LinkTo id='app-link' @route='parent' @query={{hash page=1}} @current-when='parent'>\n            Parent\n          </LinkTo>\n          {{outlet}}\n          ");
                  this.addTemplate('parent', "\n          <LinkTo id='parent-link' @route='parent' @query={{hash page=1}} @current-when='parent'>\n            Parent\n          </LinkTo>\n          {{outlet}}\n          ");
                  this.add('controller:parent', _controller.default.extend({
                    queryParams: ['page'],
                    page: 1
                  }));
                  _context3.next = 6;
                  return this.visit('/');

                case 6:
                  appLink = this.$('#app-link');
                  assert.equal(appLink.attr('href'), '/parent');
                  this.shouldNotBeActive(assert, '#app-link');
                  _context3.next = 11;
                  return this.visit('/parent?page=2');

                case 11:
                  appLink = this.$('#app-link');
                  router = this.appRouter;
                  assert.equal(appLink.attr('href'), '/parent');
                  this.shouldBeActive(assert, '#app-link');
                  assert.equal(this.$('#parent-link').attr('href'), '/parent');
                  this.shouldBeActive(assert, '#parent-link');
                  parentController = this.getController('parent');
                  assert.equal(parentController.get('page'), 2);
                  parentController.set('page', 3);
                  _context3.next = 22;
                  return (0, _internalTestHelpers.runLoopSettled)();

                case 22:
                  assert.equal(router.get('location.path'), '/parent?page=3');
                  this.shouldBeActive(assert, '#app-link');
                  this.shouldBeActive(assert, '#parent-link');
                  this.click('#app-link');
                  _context3.next = 28;
                  return (0, _internalTestHelpers.runLoopSettled)();

                case 28:
                  assert.equal(router.get('location.path'), '/parent');

                case 29:
                case "end":
                  return _context3.stop();
              }
            }, _callee3, this);
          }));

          function testTheLinkToComponentDisregardsQueryParamsInActivenessComputationWhenCurrentWhenIsSpecified(_x2) {
            return _testTheLinkToComponentDisregardsQueryParamsInActivenessComputationWhenCurrentWhenIsSpecified.apply(this, arguments);
          }

          return testTheLinkToComponentDisregardsQueryParamsInActivenessComputationWhenCurrentWhenIsSpecified;
        }();

        _proto2['@test the <LinkTo /> component default query params while in active transition regression test'] = function testTheLinkToComponentDefaultQueryParamsWhileInActiveTransitionRegressionTest(assert) {
          var _this19 = this;

          this.router.map(function () {
            this.route('foos');
            this.route('bars');
          });

          var foos = _runtime.RSVP.defer();

          var bars = _runtime.RSVP.defer();

          this.addTemplate('application', "\n          <LinkTo id='foos-link' @route='foos'>Foos</LinkTo>\n          <LinkTo id='baz-foos-link' @route='foos' @query={{hash baz=true}}>Baz Foos</LinkTo>\n          <LinkTo id='bars-link' @route='bars' @query={{hash quux=true}}>Quux Bars</LinkTo>\n          ");
          this.add('controller:foos', _controller.default.extend({
            queryParams: ['status'],
            baz: false
          }));
          this.add('route:foos', _routing.Route.extend({
            model: function () {
              return foos.promise;
            }
          }));
          this.add('controller:bars', _controller.default.extend({
            queryParams: ['status'],
            quux: false
          }));
          this.add('route:bars', _routing.Route.extend({
            model: function () {
              return bars.promise;
            }
          }));
          return this.visit('/').then(function () {
            var router = _this19.appRouter;

            var foosLink = _this19.$('#foos-link');

            var barsLink = _this19.$('#bars-link');

            var bazLink = _this19.$('#baz-foos-link');

            assert.equal(foosLink.attr('href'), '/foos');
            assert.equal(bazLink.attr('href'), '/foos?baz=true');
            assert.equal(barsLink.attr('href'), '/bars?quux=true');
            assert.equal(router.get('location.path'), '/');

            _this19.shouldNotBeActive(assert, '#foos-link');

            _this19.shouldNotBeActive(assert, '#baz-foos-link');

            _this19.shouldNotBeActive(assert, '#bars-link');

            (0, _internalTestHelpers.runTask)(function () {
              return barsLink.click();
            });

            _this19.shouldNotBeActive(assert, '#bars-link');

            (0, _internalTestHelpers.runTask)(function () {
              return foosLink.click();
            });

            _this19.shouldNotBeActive(assert, '#foos-link');

            (0, _internalTestHelpers.runTask)(function () {
              return foos.resolve();
            });
            assert.equal(router.get('location.path'), '/foos');

            _this19.shouldBeActive(assert, '#foos-link');
          });
        };

        return _class2;
      }(_internalTestHelpers.ApplicationTestCase));
    }
});
enifed("@ember/-internals/glimmer/tests/integration/components/link-to/query-params-curly-test", ["ember-babel", "@ember/controller", "@ember/-internals/runtime", "@ember/-internals/routing", "internal-test-helpers"], function (_emberBabel, _controller, _runtime, _routing, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('{{link-to}} component with query-params (rendering)',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.apply(this, arguments) || this;

      _this.add('controller:index', _controller.default.extend({
        queryParams: ['foo'],
        foo: '123',
        bar: 'yes'
      }));

      return _this;
    }

    var _proto = _class.prototype;

    _proto['@test populates href with fully supplied query param values'] = function testPopulatesHrefWithFullySuppliedQueryParamValues() {
      var _this2 = this;

      this.addTemplate('index', "{{#link-to 'index' (query-params foo='456' bar='NAW')}}Index{{/link-to}}");
      return this.visit('/').then(function () {
        _this2.assertComponentElement(_this2.firstChild, {
          tagName: 'a',
          attrs: {
            href: '/?bar=NAW&foo=456'
          },
          content: 'Index'
        });
      });
    };

    _proto['@test populates href with partially supplied query param values, but omits if value is default value'] = function testPopulatesHrefWithPartiallySuppliedQueryParamValuesButOmitsIfValueIsDefaultValue() {
      var _this3 = this;

      this.addTemplate('index', "{{#link-to 'index' (query-params foo='123')}}Index{{/link-to}}");
      return this.visit('/').then(function () {
        _this3.assertComponentElement(_this3.firstChild, {
          tagName: 'a',
          attrs: {
            href: '/',
            class: (0, _internalTestHelpers.classes)('ember-view active')
          },
          content: 'Index'
        });
      });
    };

    _proto['@feature(ember-glimmer-angle-bracket-built-ins) `(query-params)` must be used in conjunction with `{{link-to}}'] =
    /*#__PURE__*/
    function () {
      var _featureEmberGlimmerAngleBracketBuiltInsQueryParamsMustBeUsedInConjunctionWithLinkTo = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var promise;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.addTemplate('index', "{{#let (query-params foo='456' bar='NAW') as |qp|}}{{link-to 'Index' 'index' qp}}{{/let}}"); // TODO If we visit this page at all in production mode, it'll fail for
              // entirely different reasons than what this test is trying to test.

              promise = true
              /* DEBUG */
              ? this.visit('/') : null;
              _context.next = 4;
              return assert.rejectsAssertion(promise, /The `\(query-params\)` helper can only be used when invoking the `{{link-to}}` component\./);

            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function featureEmberGlimmerAngleBracketBuiltInsQueryParamsMustBeUsedInConjunctionWithLinkTo(_x) {
        return _featureEmberGlimmerAngleBracketBuiltInsQueryParamsMustBeUsedInConjunctionWithLinkTo.apply(this, arguments);
      }

      return featureEmberGlimmerAngleBracketBuiltInsQueryParamsMustBeUsedInConjunctionWithLinkTo;
    }();

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('{{link-to}} component with query params (routing)',
  /*#__PURE__*/
  function (_ApplicationTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase2);

    function _class2() {
      var _this4;

      _this4 = _ApplicationTestCase2.apply(this, arguments) || this;
      var indexProperties = {
        foo: '123',
        bar: 'abc'
      };

      _this4.add('controller:index', _controller.default.extend({
        queryParams: ['foo', 'bar', 'abool'],
        foo: indexProperties.foo,
        bar: indexProperties.bar,
        boundThing: 'OMG',
        abool: true
      }));

      _this4.add('controller:about', _controller.default.extend({
        queryParams: ['baz', 'bat'],
        baz: 'alex',
        bat: 'borf'
      }));

      _this4.indexProperties = indexProperties;
      return _this4;
    }

    var _proto2 = _class2.prototype;

    _proto2.shouldNotBeActive = function shouldNotBeActive(assert, selector) {
      this.checkActive(assert, selector, false);
    };

    _proto2.shouldBeActive = function shouldBeActive(assert, selector) {
      this.checkActive(assert, selector, true);
    };

    _proto2.getController = function getController(name) {
      return this.applicationInstance.lookup("controller:" + name);
    };

    _proto2.checkActive = function checkActive(assert, selector, active) {
      var classList = this.$(selector)[0].className;
      assert.equal(classList.indexOf('active') > -1, active, selector + ' active should be ' + active.toString());
    };

    _proto2["@test doesn't update controller QP properties on current route when invoked"] = function (assert) {
      var _this5 = this;

      this.addTemplate('index', "{{#link-to 'index' id='the-link'}}Index{{/link-to}}");
      return this.visit('/').then(function () {
        _this5.click('#the-link');

        var indexController = _this5.getController('index');

        assert.deepEqual(indexController.getProperties('foo', 'bar'), _this5.indexProperties, 'controller QP properties do not update');
      });
    };

    _proto2["@test doesn't update controller QP properties on current route when invoked (empty query-params obj)"] = function (assert) {
      var _this6 = this;

      this.addTemplate('index', "{{#link-to 'index' (query-params) id='the-link'}}Index{{/link-to}}");
      return this.visit('/').then(function () {
        _this6.click('#the-link');

        var indexController = _this6.getController('index');

        assert.deepEqual(indexController.getProperties('foo', 'bar'), _this6.indexProperties, 'controller QP properties do not update');
      });
    };

    _proto2["@test doesn't update controller QP properties on current route when invoked (empty query-params obj, inferred route)"] = function (assert) {
      var _this7 = this;

      this.addTemplate('index', "{{#link-to (query-params) id='the-link'}}Index{{/link-to}}");
      return this.visit('/').then(function () {
        _this7.click('#the-link');

        var indexController = _this7.getController('index');

        assert.deepEqual(indexController.getProperties('foo', 'bar'), _this7.indexProperties, 'controller QP properties do not update');
      });
    };

    _proto2['@test updates controller QP properties on current route when invoked'] = function testUpdatesControllerQPPropertiesOnCurrentRouteWhenInvoked(assert) {
      var _this8 = this;

      this.addTemplate('index', "\n        {{#link-to 'index' (query-params foo='456') id=\"the-link\"}}\n          Index\n        {{/link-to}}\n        ");
      return this.visit('/').then(function () {
        _this8.click('#the-link');

        var indexController = _this8.getController('index');

        assert.deepEqual(indexController.getProperties('foo', 'bar'), {
          foo: '456',
          bar: 'abc'
        }, 'controller QP properties updated');
      });
    };

    _proto2['@test updates controller QP properties on current route when invoked (inferred route)'] = function testUpdatesControllerQPPropertiesOnCurrentRouteWhenInvokedInferredRoute(assert) {
      var _this9 = this;

      this.addTemplate('index', "\n        {{#link-to (query-params foo='456') id=\"the-link\"}}\n          Index\n        {{/link-to}}\n        ");
      return this.visit('/').then(function () {
        _this9.click('#the-link');

        var indexController = _this9.getController('index');

        assert.deepEqual(indexController.getProperties('foo', 'bar'), {
          foo: '456',
          bar: 'abc'
        }, 'controller QP properties updated');
      });
    };

    _proto2['@test updates controller QP properties on other route after transitioning to that route'] = function testUpdatesControllerQPPropertiesOnOtherRouteAfterTransitioningToThatRoute(assert) {
      var _this10 = this;

      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n        {{#link-to 'about' (query-params baz='lol') id='the-link'}}\n          About\n        {{/link-to}}\n        ");
      return this.visit('/').then(function () {
        var theLink = _this10.$('#the-link');

        assert.equal(theLink.attr('href'), '/about?baz=lol');
        (0, _internalTestHelpers.runTask)(function () {
          return _this10.click('#the-link');
        });

        var aboutController = _this10.getController('about');

        assert.deepEqual(aboutController.getProperties('baz', 'bat'), {
          baz: 'lol',
          bat: 'borf'
        }, 'about controller QP properties updated');
      });
    };

    _proto2['@test supplied QP properties can be bound'] = function testSuppliedQPPropertiesCanBeBound(assert) {
      var _this11 = this;

      this.addTemplate('index', "{{#link-to (query-params foo=boundThing) id='the-link'}}Index{{/link-to}}");
      return this.visit('/').then(function () {
        var indexController = _this11.getController('index');

        var theLink = _this11.$('#the-link');

        assert.equal(theLink.attr('href'), '/?foo=OMG');
        (0, _internalTestHelpers.runTask)(function () {
          return indexController.set('boundThing', 'ASL');
        });
        assert.equal(theLink.attr('href'), '/?foo=ASL');
      });
    };

    _proto2['@test supplied QP properties can be bound (booleans)'] = function testSuppliedQPPropertiesCanBeBoundBooleans(assert) {
      var _this12 = this;

      this.addTemplate('index', "\n        {{#link-to (query-params abool=boundThing) id='the-link'}}\n          Index\n        {{/link-to}}\n        ");
      return this.visit('/').then(function () {
        var indexController = _this12.getController('index');

        var theLink = _this12.$('#the-link');

        assert.equal(theLink.attr('href'), '/?abool=OMG');
        (0, _internalTestHelpers.runTask)(function () {
          return indexController.set('boundThing', false);
        });
        assert.equal(theLink.attr('href'), '/?abool=false');

        _this12.click('#the-link');

        assert.deepEqual(indexController.getProperties('foo', 'bar', 'abool'), {
          foo: '123',
          bar: 'abc',
          abool: false
        }, 'bound bool QP properties update');
      });
    };

    _proto2['@test href updates when unsupplied controller QP props change'] =
    /*#__PURE__*/
    function () {
      var _testHrefUpdatesWhenUnsuppliedControllerQPPropsChange = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        var indexController, theLink;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              this.addTemplate('index', "{{#link-to (query-params foo='lol') id='the-link'}}Index{{/link-to}}");
              _context2.next = 3;
              return this.visit('/');

            case 3:
              indexController = this.getController('index');
              theLink = this.$('#the-link');
              assert.equal(theLink.attr('href'), '/?foo=lol');
              indexController.set('bar', 'BORF');
              _context2.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              assert.equal(theLink.attr('href'), '/?bar=BORF&foo=lol');
              indexController.set('foo', 'YEAH');
              _context2.next = 13;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 13:
              assert.equal(theLink.attr('href'), '/?bar=BORF&foo=lol');

            case 14:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testHrefUpdatesWhenUnsuppliedControllerQPPropsChange(_x2) {
        return _testHrefUpdatesWhenUnsuppliedControllerQPPropsChange.apply(this, arguments);
      }

      return testHrefUpdatesWhenUnsuppliedControllerQPPropsChange;
    }();

    _proto2['@test The {{link-to}} with only query params always transitions to the current route with the query params applied'] = function testTheLinkToWithOnlyQueryParamsAlwaysTransitionsToTheCurrentRouteWithTheQueryParamsApplied(assert) {
      var _this13 = this; // Test harness for bug #12033


      this.addTemplate('cars', "\n        {{#link-to 'cars.create' id='create-link'}}Create new car{{/link-to}}\n        {{#link-to (query-params page='2') id='page2-link'}}Page 2{{/link-to}}\n        {{outlet}}\n        ");
      this.addTemplate('cars.create', "{{#link-to 'cars' id='close-link'}}Close create form{{/link-to}}");
      this.router.map(function () {
        this.route('cars', function () {
          this.route('create');
        });
      });
      this.add('controller:cars', _controller.default.extend({
        queryParams: ['page'],
        page: 1
      }));
      return this.visit('/cars/create').then(function () {
        var router = _this13.appRouter;

        var carsController = _this13.getController('cars');

        assert.equal(router.currentRouteName, 'cars.create');
        (0, _internalTestHelpers.runTask)(function () {
          return _this13.click('#close-link');
        });
        assert.equal(router.currentRouteName, 'cars.index');
        assert.equal(router.get('url'), '/cars');
        assert.equal(carsController.get('page'), 1, 'The page query-param is 1');
        (0, _internalTestHelpers.runTask)(function () {
          return _this13.click('#page2-link');
        });
        assert.equal(router.currentRouteName, 'cars.index', 'The active route is still cars');
        assert.equal(router.get('url'), '/cars?page=2', 'The url has been updated');
        assert.equal(carsController.get('page'), 2, 'The query params have been updated');
      });
    };

    _proto2['@test the {{link-to}} applies activeClass when query params are not changed'] = function testTheLinkToAppliesActiveClassWhenQueryParamsAreNotChanged(assert) {
      var _this14 = this;

      this.addTemplate('index', "\n        {{#link-to (query-params foo='cat') id='cat-link'}}Index{{/link-to}}\n        {{#link-to (query-params foo='dog') id='dog-link'}}Index{{/link-to}}\n        {{#link-to 'index' id='change-nothing'}}Index{{/link-to}}\n        ");
      this.addTemplate('search', "\n        {{#link-to (query-params search='same') id='same-search'}}Index{{/link-to}}\n        {{#link-to (query-params search='change') id='change-search'}}Index{{/link-to}}\n        {{#link-to (query-params search='same' archive=true) id='same-search-add-archive'}}Index{{/link-to}}\n        {{#link-to (query-params archive=true) id='only-add-archive'}}Index{{/link-to}}\n        {{#link-to (query-params search='same' archive=true) id='both-same'}}Index{{/link-to}}\n        {{#link-to (query-params search='different' archive=true) id='change-one'}}Index{{/link-to}}\n        {{#link-to (query-params search='different' archive=false) id='remove-one'}}Index{{/link-to}}\n        {{outlet}}\n        ");
      this.addTemplate('search.results', "\n        {{#link-to (query-params sort='title') id='same-sort-child-only'}}Index{{/link-to}}\n        {{#link-to (query-params search='same') id='same-search-parent-only'}}Index{{/link-to}}\n        {{#link-to (query-params search='change') id='change-search-parent-only'}}Index{{/link-to}}\n        {{#link-to (query-params search='same' sort='title') id='same-search-same-sort-child-and-parent'}}Index{{/link-to}}\n        {{#link-to (query-params search='same' sort='author') id='same-search-different-sort-child-and-parent'}}Index{{/link-to}}\n        {{#link-to (query-params search='change' sort='title') id='change-search-same-sort-child-and-parent'}}Index{{/link-to}}\n        {{#link-to (query-params foo='dog') id='dog-link'}}Index{{/link-to}}\n        ");
      this.router.map(function () {
        this.route('search', function () {
          this.route('results');
        });
      });
      this.add('controller:search', _controller.default.extend({
        queryParams: ['search', 'archive'],
        search: '',
        archive: false
      }));
      this.add('controller:search.results', _controller.default.extend({
        queryParams: ['sort', 'showDetails'],
        sort: 'title',
        showDetails: true
      }));
      return this.visit('/').then(function () {
        _this14.shouldNotBeActive(assert, '#cat-link');

        _this14.shouldNotBeActive(assert, '#dog-link');

        return _this14.visit('/?foo=cat');
      }).then(function () {
        _this14.shouldBeActive(assert, '#cat-link');

        _this14.shouldNotBeActive(assert, '#dog-link');

        return _this14.visit('/?foo=dog');
      }).then(function () {
        _this14.shouldBeActive(assert, '#dog-link');

        _this14.shouldNotBeActive(assert, '#cat-link');

        _this14.shouldBeActive(assert, '#change-nothing');

        return _this14.visit('/search?search=same');
      }).then(function () {
        _this14.shouldBeActive(assert, '#same-search');

        _this14.shouldNotBeActive(assert, '#change-search');

        _this14.shouldNotBeActive(assert, '#same-search-add-archive');

        _this14.shouldNotBeActive(assert, '#only-add-archive');

        _this14.shouldNotBeActive(assert, '#remove-one');

        return _this14.visit('/search?search=same&archive=true');
      }).then(function () {
        _this14.shouldBeActive(assert, '#both-same');

        _this14.shouldNotBeActive(assert, '#change-one');

        return _this14.visit('/search/results?search=same&sort=title&showDetails=true');
      }).then(function () {
        _this14.shouldBeActive(assert, '#same-sort-child-only');

        _this14.shouldBeActive(assert, '#same-search-parent-only');

        _this14.shouldNotBeActive(assert, '#change-search-parent-only');

        _this14.shouldBeActive(assert, '#same-search-same-sort-child-and-parent');

        _this14.shouldNotBeActive(assert, '#same-search-different-sort-child-and-parent');

        _this14.shouldNotBeActive(assert, '#change-search-same-sort-child-and-parent');
      });
    };

    _proto2['@test the {{link-to}} applies active class when query-param is a number'] = function testTheLinkToAppliesActiveClassWhenQueryParamIsANumber(assert) {
      var _this15 = this;

      this.addTemplate('index', "\n        {{#link-to (query-params page=pageNumber) id='page-link'}}\n          Index\n        {{/link-to}}\n        ");
      this.add('controller:index', _controller.default.extend({
        queryParams: ['page'],
        page: 1,
        pageNumber: 5
      }));
      return this.visit('/').then(function () {
        _this15.shouldNotBeActive(assert, '#page-link');

        return _this15.visit('/?page=5');
      }).then(function () {
        _this15.shouldBeActive(assert, '#page-link');
      });
    };

    _proto2['@test the {{link-to}} applies active class when query-param is an array'] = function testTheLinkToAppliesActiveClassWhenQueryParamIsAnArray(assert) {
      var _this16 = this;

      this.addTemplate('index', "\n        {{#link-to (query-params pages=pagesArray) id='array-link'}}Index{{/link-to}}\n        {{#link-to (query-params pages=biggerArray) id='bigger-link'}}Index{{/link-to}}\n        {{#link-to (query-params pages=emptyArray) id='empty-link'}}Index{{/link-to}}\n        ");
      this.add('controller:index', _controller.default.extend({
        queryParams: ['pages'],
        pages: [],
        pagesArray: [1, 2],
        biggerArray: [1, 2, 3],
        emptyArray: []
      }));
      return this.visit('/').then(function () {
        _this16.shouldNotBeActive(assert, '#array-link');

        return _this16.visit('/?pages=%5B1%2C2%5D');
      }).then(function () {
        _this16.shouldBeActive(assert, '#array-link');

        _this16.shouldNotBeActive(assert, '#bigger-link');

        _this16.shouldNotBeActive(assert, '#empty-link');

        return _this16.visit('/?pages=%5B2%2C1%5D');
      }).then(function () {
        _this16.shouldNotBeActive(assert, '#array-link');

        _this16.shouldNotBeActive(assert, '#bigger-link');

        _this16.shouldNotBeActive(assert, '#empty-link');

        return _this16.visit('/?pages=%5B1%2C2%2C3%5D');
      }).then(function () {
        _this16.shouldBeActive(assert, '#bigger-link');

        _this16.shouldNotBeActive(assert, '#array-link');

        _this16.shouldNotBeActive(assert, '#empty-link');
      });
    };

    _proto2['@test the {{link-to}} component applies active class to the parent route'] = function testTheLinkToComponentAppliesActiveClassToTheParentRoute(assert) {
      var _this17 = this;

      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });
      this.addTemplate('application', "\n        {{#link-to 'parent' id='parent-link'}}Parent{{/link-to}}\n        {{#link-to 'parent.child' id='parent-child-link'}}Child{{/link-to}}\n        {{#link-to 'parent' (query-params foo=cat) id='parent-link-qp'}}Parent{{/link-to}}\n        {{outlet}}\n        ");
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['foo'],
        foo: 'bar'
      }));
      return this.visit('/').then(function () {
        _this17.shouldNotBeActive(assert, '#parent-link');

        _this17.shouldNotBeActive(assert, '#parent-child-link');

        _this17.shouldNotBeActive(assert, '#parent-link-qp');

        return _this17.visit('/parent/child?foo=dog');
      }).then(function () {
        _this17.shouldBeActive(assert, '#parent-link');

        _this17.shouldNotBeActive(assert, '#parent-link-qp');
      });
    };

    _proto2['@test The {{link-to}} component disregards query-params in activeness computation when current-when is specified'] =
    /*#__PURE__*/
    function () {
      var _testTheLinkToComponentDisregardsQueryParamsInActivenessComputationWhenCurrentWhenIsSpecified = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(assert) {
        var appLink, router, parentController;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              this.router.map(function () {
                this.route('parent');
              });
              this.addTemplate('application', "\n        {{#link-to 'parent' (query-params page=1) current-when='parent' id='app-link'}}\n          Parent\n        {{/link-to}}\n        {{outlet}}\n        ");
              this.addTemplate('parent', "\n        {{#link-to 'parent' (query-params page=1) current-when='parent' id='parent-link'}}\n          Parent\n        {{/link-to}}\n        {{outlet}}\n        ");
              this.add('controller:parent', _controller.default.extend({
                queryParams: ['page'],
                page: 1
              }));
              _context3.next = 6;
              return this.visit('/');

            case 6:
              appLink = this.$('#app-link');
              assert.equal(appLink.attr('href'), '/parent');
              this.shouldNotBeActive(assert, '#app-link');
              _context3.next = 11;
              return this.visit('/parent?page=2');

            case 11:
              appLink = this.$('#app-link');
              router = this.appRouter;
              assert.equal(appLink.attr('href'), '/parent');
              this.shouldBeActive(assert, '#app-link');
              assert.equal(this.$('#parent-link').attr('href'), '/parent');
              this.shouldBeActive(assert, '#parent-link');
              parentController = this.getController('parent');
              assert.equal(parentController.get('page'), 2);
              parentController.set('page', 3);
              _context3.next = 22;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 22:
              assert.equal(router.get('location.path'), '/parent?page=3');
              this.shouldBeActive(assert, '#app-link');
              this.shouldBeActive(assert, '#parent-link');
              this.click('#app-link');
              _context3.next = 28;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 28:
              assert.equal(router.get('location.path'), '/parent');

            case 29:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function testTheLinkToComponentDisregardsQueryParamsInActivenessComputationWhenCurrentWhenIsSpecified(_x3) {
        return _testTheLinkToComponentDisregardsQueryParamsInActivenessComputationWhenCurrentWhenIsSpecified.apply(this, arguments);
      }

      return testTheLinkToComponentDisregardsQueryParamsInActivenessComputationWhenCurrentWhenIsSpecified;
    }();

    _proto2['@test {{link-to}} default query params while in active transition regression test'] = function testLinkToDefaultQueryParamsWhileInActiveTransitionRegressionTest(assert) {
      var _this18 = this;

      this.router.map(function () {
        this.route('foos');
        this.route('bars');
      });

      var foos = _runtime.RSVP.defer();

      var bars = _runtime.RSVP.defer();

      this.addTemplate('application', "\n        {{link-to 'Foos' 'foos' id='foos-link'}}\n        {{link-to 'Baz Foos' 'foos' (query-params baz=true) id='baz-foos-link'}}\n        {{link-to 'Quux Bars' 'bars' (query-params quux=true) id='bars-link'}}\n        ");
      this.add('controller:foos', _controller.default.extend({
        queryParams: ['status'],
        baz: false
      }));
      this.add('route:foos', _routing.Route.extend({
        model: function () {
          return foos.promise;
        }
      }));
      this.add('controller:bars', _controller.default.extend({
        queryParams: ['status'],
        quux: false
      }));
      this.add('route:bars', _routing.Route.extend({
        model: function () {
          return bars.promise;
        }
      }));
      return this.visit('/').then(function () {
        var router = _this18.appRouter;

        var foosLink = _this18.$('#foos-link');

        var barsLink = _this18.$('#bars-link');

        var bazLink = _this18.$('#baz-foos-link');

        assert.equal(foosLink.attr('href'), '/foos');
        assert.equal(bazLink.attr('href'), '/foos?baz=true');
        assert.equal(barsLink.attr('href'), '/bars?quux=true');
        assert.equal(router.get('location.path'), '/');

        _this18.shouldNotBeActive(assert, '#foos-link');

        _this18.shouldNotBeActive(assert, '#baz-foos-link');

        _this18.shouldNotBeActive(assert, '#bars-link');

        (0, _internalTestHelpers.runTask)(function () {
          return barsLink.click();
        });

        _this18.shouldNotBeActive(assert, '#bars-link');

        (0, _internalTestHelpers.runTask)(function () {
          return foosLink.click();
        });

        _this18.shouldNotBeActive(assert, '#foos-link');

        (0, _internalTestHelpers.runTask)(function () {
          return foos.resolve();
        });
        assert.equal(router.get('location.path'), '/foos');

        _this18.shouldBeActive(assert, '#foos-link');
      });
    };

    _proto2['@test [GH#17869] it does not cause shadowing assertion with `hash` local variable'] = function testGH17869ItDoesNotCauseShadowingAssertionWithHashLocalVariable() {
      var _this19 = this;

      this.router.map(function () {
        this.route('post', {
          path: '/post/:id'
        });
      });
      this.add('controller:post', _controller.default.extend({
        queryParams: ['showComments'],
        showComments: true
      }));
      this.addTemplate('index', "\n        {{#let (hash id=\"1\" title=\"Hello World!\" body=\"Lorem ipsum dolor sit amet...\") as |hash|}}\n          {{#link-to \"post\" hash (query-params showComments=false)}}View Post{{/link-to}}\n        {{/let}}\n        ");
      return this.visit('/').then(function () {
        _this19.assertComponentElement(_this19.element.firstElementChild, {
          tagName: 'a',
          attrs: {
            href: '/post/1?showComments=false',
            class: (0, _internalTestHelpers.classes)('ember-view')
          },
          content: 'View Post'
        });
      });
    };

    return _class2;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/components/link-to/rendering-angle-test", ["ember-babel", "internal-test-helpers", "@ember/controller", "@ember/-internals/metal", "@ember/-internals/glimmer"], function (_emberBabel, _internalTestHelpers, _controller, _metal, _glimmer) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  if (true
  /* EMBER_GLIMMER_ANGLE_BRACKET_BUILT_INS */
  ) {
      (0, _internalTestHelpers.moduleFor)('<LinkTo /> component (rendering tests)',
      /*#__PURE__*/
      function (_ApplicationTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

        function _class() {
          return _ApplicationTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto["@test throws a useful error if you invoke it wrong"] =
        /*#__PURE__*/
        function () {
          var _ref = _asyncToGenerator(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee(assert) {
            var _this;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _this = this;
                  this.addTemplate('application', "<LinkTo id='the-link'>Index</LinkTo>");
                  assert.throwsAssertion(function () {
                    return (0, _internalTestHelpers.runTask)(function () {
                      return _this.visit('/');
                    });
                  }, /You must provide at least one of the `@route`, `@model`, `@models` or `@query` argument to `<LinkTo>`/);
                  _context.next = 5;
                  return (0, _internalTestHelpers.runLoopSettled)();

                case 5:
                case "end":
                  return _context.stop();
              }
            }, _callee, this);
          }));

          return function (_x) {
            return _ref.apply(this, arguments);
          };
        }();

        _proto['@test should be able to be inserted in DOM when the router is not present'] = function testShouldBeAbleToBeInsertedInDOMWhenTheRouterIsNotPresent() {
          var _this2 = this;

          this.addTemplate('application', "<LinkTo @route='index'>Go to Index</LinkTo>");
          return this.visit('/').then(function () {
            _this2.assertText('Go to Index');
          });
        };

        _proto['@test re-renders when title changes'] = function testReRendersWhenTitleChanges() {
          var _this3 = this;

          var controller;
          this.addTemplate('application', "<LinkTo @route='index'>{{title}}</LinkTo>");
          this.add('controller:application', _controller.default.extend({
            init: function () {
              this._super.apply(this, arguments);

              controller = this;
            },
            title: 'foo'
          }));
          return this.visit('/').then(function () {
            _this3.assertText('foo');

            (0, _internalTestHelpers.runTask)(function () {
              return (0, _metal.set)(controller, 'title', 'bar');
            });

            _this3.assertText('bar');
          });
        };

        _proto['@test re-computes active class when params change'] = function testReComputesActiveClassWhenParamsChange(assert) {
          var _this4 = this;

          var controller;
          this.addTemplate('application', '<LinkTo @route={{routeName}}>foo</LinkTo>');
          this.add('controller:application', _controller.default.extend({
            init: function () {
              this._super.apply(this, arguments);

              controller = this;
            },
            routeName: 'index'
          }));
          this.router.map(function () {
            this.route('bar', {
              path: '/bar'
            });
          });
          return this.visit('/bar').then(function () {
            assert.equal(_this4.firstChild.classList.contains('active'), false);
            (0, _internalTestHelpers.runTask)(function () {
              return (0, _metal.set)(controller, 'routeName', 'bar');
            });
            assert.equal(_this4.firstChild.classList.contains('active'), true);
          });
        };

        _proto['@test able to safely extend the built-in component and use the normal path'] = function testAbleToSafelyExtendTheBuiltInComponentAndUseTheNormalPath() {
          var _this5 = this;

          this.addComponent('custom-link-to', {
            ComponentClass: _glimmer.LinkComponent.extend()
          });
          this.addTemplate('application', "<CustomLinkTo @route='index'>{{title}}</CustomLinkTo>");
          this.add('controller:application', _controller.default.extend({
            title: 'Hello'
          }));
          return this.visit('/').then(function () {
            _this5.assertText('Hello');
          });
        };

        return _class;
      }(_internalTestHelpers.ApplicationTestCase));
      (0, _internalTestHelpers.moduleFor)('<LinkTo /> component (rendering tests, without router)',
      /*#__PURE__*/
      function (_RenderingTestCase) {
        (0, _emberBabel.inheritsLoose)(_class2, _RenderingTestCase);

        function _class2() {
          return _RenderingTestCase.apply(this, arguments) || this;
        }

        var _proto2 = _class2.prototype;

        _proto2['@test should be able to be inserted in DOM when the router is not present - block'] = function testShouldBeAbleToBeInsertedInDOMWhenTheRouterIsNotPresentBlock() {
          this.render("<LinkTo @route='index'>Go to Index</LinkTo>");
          this.assertText('Go to Index');
        };

        return _class2;
      }(_internalTestHelpers.RenderingTestCase));
    }
});
enifed("@ember/-internals/glimmer/tests/integration/components/link-to/rendering-curly-test", ["ember-babel", "internal-test-helpers", "@ember/controller", "@ember/-internals/metal", "@ember/-internals/glimmer"], function (_emberBabel, _internalTestHelpers, _controller, _metal, _glimmer) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('{{link-to}} component (rendering tests)',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto["@feature(ember-glimmer-angle-bracket-built-ins) throws a useful error if you invoke it wrong"] = function (assert) {
      var _this = this;

      assert.expect(1);
      expectAssertion(function () {
        _this.addTemplate('application', "{{#link-to id='the-link'}}Index{{/link-to}}");
      }, /You must provide one or more parameters to the `{{link-to}}` component\. \('my-app\/templates\/application\.hbs' @ L1:C0\)/);
    };

    _proto["@feature(!ember-glimmer-angle-bracket-built-ins) throws a useful error if you invoke it wrong"] =
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              assert.expect(1);
              this.addTemplate('application', "{{#link-to id='the-link'}}Index{{/link-to}}");
              _context.next = 4;
              return assert.rejectsAssertion(this.visit('/'), /You must provide one or more parameters to the link-to component/);

            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();

    _proto['@test should be able to be inserted in DOM when the router is not present'] = function testShouldBeAbleToBeInsertedInDOMWhenTheRouterIsNotPresent() {
      var _this2 = this;

      this.addTemplate('application', "{{#link-to 'index'}}Go to Index{{/link-to}}");
      return this.visit('/').then(function () {
        _this2.assertText('Go to Index');
      });
    };

    _proto['@test re-renders when title changes'] = function testReRendersWhenTitleChanges() {
      var _this3 = this;

      var controller;
      this.addTemplate('application', "{{link-to title 'index'}}");
      this.add('controller:application', _controller.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          controller = this;
        },
        title: 'foo'
      }));
      return this.visit('/').then(function () {
        _this3.assertText('foo');

        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(controller, 'title', 'bar');
        });

        _this3.assertText('bar');
      });
    };

    _proto['@test re-computes active class when params change'] = function testReComputesActiveClassWhenParamsChange(assert) {
      var _this4 = this;

      var controller;
      this.addTemplate('application', '{{link-to "foo" routeName}}');
      this.add('controller:application', _controller.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          controller = this;
        },
        routeName: 'index'
      }));
      this.router.map(function () {
        this.route('bar', {
          path: '/bar'
        });
      });
      return this.visit('/bar').then(function () {
        assert.equal(_this4.firstChild.classList.contains('active'), false);
        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(controller, 'routeName', 'bar');
        });
        assert.equal(_this4.firstChild.classList.contains('active'), true);
      });
    };

    _proto['@test escaped inline form (double curlies) escapes link title'] = function testEscapedInlineFormDoubleCurliesEscapesLinkTitle() {
      var _this5 = this;

      this.addTemplate('application', "{{link-to title 'index'}}");
      this.add('controller:application', _controller.default.extend({
        title: '<b>blah</b>'
      }));
      return this.visit('/').then(function () {
        _this5.assertText('<b>blah</b>');
      });
    };

    _proto['@test unescaped inline form (triple curlies) does not escape link title'] = function testUnescapedInlineFormTripleCurliesDoesNotEscapeLinkTitle(assert) {
      var _this6 = this;

      this.addTemplate('application', "{{{link-to title 'index'}}}");
      this.add('controller:application', _controller.default.extend({
        title: '<b>blah</b>'
      }));
      return this.visit('/').then(function () {
        _this6.assertText('blah');

        assert.equal(_this6.$('b').length, 1);
      });
    };

    _proto['@test able to safely extend the built-in component and use the normal path'] = function testAbleToSafelyExtendTheBuiltInComponentAndUseTheNormalPath() {
      var _this7 = this;

      this.addComponent('custom-link-to', {
        ComponentClass: _glimmer.LinkComponent.extend()
      });
      this.addTemplate('application', "{{#custom-link-to 'index'}}{{title}}{{/custom-link-to}}");
      this.add('controller:application', _controller.default.extend({
        title: 'Hello'
      }));
      return this.visit('/').then(function () {
        _this7.assertText('Hello');
      });
    };

    _proto['@test [GH#13432] able to safely extend the built-in component and invoke it inline'] = function testGH13432AbleToSafelyExtendTheBuiltInComponentAndInvokeItInline() {
      var _this8 = this;

      this.addComponent('custom-link-to', {
        ComponentClass: _glimmer.LinkComponent.extend()
      });
      this.addTemplate('application', "{{custom-link-to title 'index'}}");
      this.add('controller:application', _controller.default.extend({
        title: 'Hello'
      }));
      return this.visit('/').then(function () {
        _this8.assertText('Hello');
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('{{link-to}} component (rendering tests, without router)',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class2, _RenderingTestCase);

    function _class2() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test should be able to be inserted in DOM when the router is not present - block'] = function testShouldBeAbleToBeInsertedInDOMWhenTheRouterIsNotPresentBlock() {
      this.render("{{#link-to 'index'}}Go to Index{{/link-to}}");
      this.assertText('Go to Index');
    };

    _proto2['@test should be able to be inserted in DOM when the router is not present - inline'] = function testShouldBeAbleToBeInsertedInDOMWhenTheRouterIsNotPresentInline() {
      this.render("{{link-to 'Go to Index' 'index'}}");
      this.assertText('Go to Index');
    };

    return _class2;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/components/link-to/routing-angle-test", ["ember-babel", "internal-test-helpers", "@ember/controller", "@ember/-internals/runtime", "@ember/-internals/metal", "@ember/instrumentation", "@ember/-internals/routing"], function (_emberBabel, _internalTestHelpers, _controller, _runtime, _metal, _instrumentation, _routing) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  if (true
  /* EMBER_GLIMMER_ANGLE_BRACKET_BUILT_INS */
  ) {
      // IE includes the host name
      function normalizeUrl(url) {
        return url.replace(/https?:\/\/[^\/]+/, '');
      }

      function shouldNotBeActive(assert, element) {
        checkActive(assert, element, false);
      }

      function shouldBeActive(assert, element) {
        checkActive(assert, element, true);
      }

      function checkActive(assert, element, active) {
        var classList = element.attr('class');
        assert.equal(classList.indexOf('active') > -1, active, element + " active should be " + active);
      }

      (0, _internalTestHelpers.moduleFor)('<LinkTo /> component (routing tests)',
      /*#__PURE__*/
      function (_ApplicationTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

        function _class() {
          var _this;

          _this = _ApplicationTestCase.call(this) || this;

          _this.router.map(function () {
            this.route('about');
          });

          _this.addTemplate('index', "\n          <h3 class=\"home\">Home</h3>\n          <LinkTo @route='about' id='about-link'>About</LinkTo>\n          <LinkTo @route='index' id='self-link'>Self</LinkTo>\n          ");

          _this.addTemplate('about', "\n          <h3 class=\"about\">About</h3>\n          <LinkTo @route='index' id='home-link'>Home</LinkTo>\n          <LinkTo @route='about' id='self-link'>Self</LinkTo>\n          ");

          return _this;
        }

        var _proto = _class.prototype;

        _proto['@test The <LinkTo /> component navigates into the named route'] = function testTheLinkToComponentNavigatesIntoTheNamedRoute(assert) {
          var _this2 = this;

          return this.visit('/').then(function () {
            assert.equal(_this2.$('h3.home').length, 1, 'The home template was rendered');
            assert.equal(_this2.$('#self-link.active').length, 1, 'The self-link was rendered with active class');
            assert.equal(_this2.$('#about-link:not(.active)').length, 1, 'The other link was rendered without active class');
            return _this2.click('#about-link');
          }).then(function () {
            assert.equal(_this2.$('h3.about').length, 1, 'The about template was rendered');
            assert.equal(_this2.$('#self-link.active').length, 1, 'The self-link was rendered with active class');
            assert.equal(_this2.$('#home-link:not(.active)').length, 1, 'The other link was rendered without active class');
          });
        };

        _proto["@test the <LinkTo /> component doesn't add an href when the tagName isn't 'a'"] = function (assert) {
          var _this3 = this;

          this.addTemplate('index', "<LinkTo @route='about' id='about-link' @tagName='div'>About</LinkTo>");
          return this.visit('/').then(function () {
            assert.equal(_this3.$('#about-link').attr('href'), undefined, 'there is no href attribute');
          });
        };

        _proto["@test the <LinkTo /> component applies a 'disabled' class when disabled"] = function (assert) {
          var _this4 = this;

          this.addTemplate('index', "\n          <LinkTo id=\"about-link-static\" @route=\"about\" @disabledWhen=\"shouldDisable\">About</LinkTo>\n          <LinkTo id=\"about-link-dynamic\" @route=\"about\" @disabledWhen={{dynamicDisabledWhen}}>About</LinkTo>\n          ");
          this.add('controller:index', _controller.default.extend({
            shouldDisable: true,
            dynamicDisabledWhen: 'shouldDisable'
          }));
          return this.visit('/').then(function () {
            assert.equal(_this4.$('#about-link-static.disabled').length, 1, 'The static link is disabled when its disabledWhen is true');
            assert.equal(_this4.$('#about-link-dynamic.disabled').length, 1, 'The dynamic link is disabled when its disabledWhen is true');

            var controller = _this4.applicationInstance.lookup('controller:index');

            (0, _internalTestHelpers.runTask)(function () {
              return controller.set('dynamicDisabledWhen', false);
            });
            assert.equal(_this4.$('#about-link-dynamic.disabled').length, 0, 'The dynamic link is re-enabled when its disabledWhen becomes false');
          });
        };

        _proto["@test the <LinkTo /> component doesn't apply a 'disabled' class if disabledWhen is not provided"] = function (assert) {
          var _this5 = this;

          this.addTemplate('index', "<LinkTo id=\"about-link\" @route=\"about\">About</LinkTo>");
          return this.visit('/').then(function () {
            assert.ok(!_this5.$('#about-link').hasClass('disabled'), 'The link is not disabled if disabledWhen not provided');
          });
        };

        _proto["@test the <LinkTo /> component supports a custom disabledClass"] = function (assert) {
          var _this6 = this;

          this.addTemplate('index', "<LinkTo id=\"about-link\" @route=\"about\" @disabledWhen={{true}} @disabledClass=\"do-not-want\">About</LinkTo>");
          return this.visit('/').then(function () {
            assert.equal(_this6.$('#about-link.do-not-want').length, 1, 'The link can apply a custom disabled class');
          });
        };

        _proto["@test the <LinkTo /> component supports a custom disabledClass set via bound param"] = function (assert) {
          var _this7 = this;

          this.addTemplate('index', "<LinkTo id=\"about-link\" @route=\"about\" @disabledWhen={{true}} @disabledClass={{disabledClass}}>About</LinkTo>");
          this.add('controller:index', _controller.default.extend({
            disabledClass: 'do-not-want'
          }));
          return this.visit('/').then(function () {
            assert.equal(_this7.$('#about-link.do-not-want').length, 1, 'The link can apply a custom disabled class via bound param');
          });
        };

        _proto["@test the <LinkTo /> component does not respond to clicks when disabledWhen"] = function (assert) {
          var _this8 = this;

          this.addTemplate('index', "<LinkTo id=\"about-link\" @route=\"about\" @disabledWhen={{true}}>About</LinkTo>");
          return this.visit('/').then(function () {
            return _this8.click('#about-link');
          }).then(function () {
            assert.equal(_this8.$('h3.about').length, 0, 'Transitioning did not occur');
          });
        };

        _proto["@test the <LinkTo /> component does not respond to clicks when disabled"] = function (assert) {
          var _this9 = this;

          this.addTemplate('index', "<LinkTo id=\"about-link\" @route=\"about\" @disabled={{true}}>About</LinkTo>");
          return this.visit('/').then(function () {
            return _this9.click('#about-link');
          }).then(function () {
            assert.equal(_this9.$('h3.about').length, 0, 'Transitioning did not occur');
          });
        };

        _proto["@test the <LinkTo /> component responds to clicks according to its disabledWhen bound param"] = function (assert) {
          var _this10 = this;

          this.addTemplate('index', "<LinkTo id=\"about-link\" @route=\"about\" @disabledWhen={{disabledWhen}}>About</LinkTo>");
          this.add('controller:index', _controller.default.extend({
            disabledWhen: true
          }));
          return this.visit('/').then(function () {
            return _this10.click('#about-link');
          }).then(function () {
            assert.equal(_this10.$('h3.about').length, 0, 'Transitioning did not occur');

            var controller = _this10.applicationInstance.lookup('controller:index');

            controller.set('disabledWhen', false);
            return (0, _internalTestHelpers.runLoopSettled)();
          }).then(function () {
            return _this10.click('#about-link');
          }).then(function () {
            assert.equal(_this10.$('h3.about').length, 1, 'Transitioning did occur when disabledWhen became false');
          });
        };

        _proto["@test The <LinkTo /> component supports a custom activeClass"] = function (assert) {
          var _this11 = this;

          this.addTemplate('index', "\n          <h3 class=\"home\">Home</h3>\n          <LinkTo id='about-link' @route='about'>About</LinkTo>\n          <LinkTo id='self-link' @route='index' @activeClass='zomg-active'>Self</LinkTo>\n          ");
          return this.visit('/').then(function () {
            assert.equal(_this11.$('h3.home').length, 1, 'The home template was rendered');
            assert.equal(_this11.$('#self-link.zomg-active').length, 1, 'The self-link was rendered with active class');
            assert.equal(_this11.$('#about-link:not(.active)').length, 1, 'The other link was rendered without active class');
          });
        };

        _proto["@test The <LinkTo /> component supports a custom activeClass from a bound param"] = function (assert) {
          var _this12 = this;

          this.addTemplate('index', "\n          <h3 class=\"home\">Home</h3>\n          <LinkTo id='about-link' @route='about'>About</LinkTo>\n          <LinkTo id='self-link' @route='index' @activeClass={{activeClass}}>Self</LinkTo>\n          ");
          this.add('controller:index', _controller.default.extend({
            activeClass: 'zomg-active'
          }));
          return this.visit('/').then(function () {
            assert.equal(_this12.$('h3.home').length, 1, 'The home template was rendered');
            assert.equal(_this12.$('#self-link.zomg-active').length, 1, 'The self-link was rendered with active class');
            assert.equal(_this12.$('#about-link:not(.active)').length, 1, 'The other link was rendered without active class');
          });
        } // See https://github.com/emberjs/ember.js/issues/17771
        ;

        _proto["@skip The <LinkTo /> component supports 'classNameBindings' with custom values [GH #11699]"] = function (assert) {
          var _this13 = this;

          this.addTemplate('index', "\n          <h3 class=\"home\">Home</h3>\n          <LinkTo id='about-link' @route='about' @classNameBindings='foo:foo-is-true:foo-is-false'>About</LinkTo>\n          ");
          this.add('controller:index', _controller.default.extend({
            foo: false
          }));
          return this.visit('/').then(function () {
            assert.equal(_this13.$('#about-link.foo-is-false').length, 1, 'The about-link was rendered with the falsy class');

            var controller = _this13.applicationInstance.lookup('controller:index');

            (0, _internalTestHelpers.runTask)(function () {
              return controller.set('foo', true);
            });
            assert.equal(_this13.$('#about-link.foo-is-true').length, 1, 'The about-link was rendered with the truthy class after toggling the property');
          });
        };

        return _class;
      }(_internalTestHelpers.ApplicationTestCase));
      (0, _internalTestHelpers.moduleFor)('<LinkTo /> component (routing tests - location hooks)',
      /*#__PURE__*/
      function (_ApplicationTestCase2) {
        (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase2);

        function _class2() {
          var _this14;

          _this14 = _ApplicationTestCase2.call(this) || this;
          _this14.updateCount = 0;
          _this14.replaceCount = 0;
          var testContext = (0, _emberBabel.assertThisInitialized)(_this14);

          _this14.add('location:none', _routing.NoneLocation.extend({
            setURL: function () {
              testContext.updateCount++;
              return this._super.apply(this, arguments);
            },
            replaceURL: function () {
              testContext.replaceCount++;
              return this._super.apply(this, arguments);
            }
          }));

          _this14.router.map(function () {
            this.route('about');
          });

          _this14.addTemplate('index', "\n          <h3 class=\"home\">Home</h3>\n          <LinkTo id='about-link' @route='about'>About</LinkTo>\n          <LinkTo id='self-link' @route='index'>Self</LinkTo>\n          ");

          _this14.addTemplate('about', "\n          <h3 class=\"about\">About</h3>\n          <LinkTo id='home-link' @route='index'>Home</LinkTo>\n          <LinkTo id='self-link' @route='about'>Self</LinkTo>\n          ");

          return _this14;
        }

        var _proto2 = _class2.prototype;

        _proto2.visit = function visit() {
          var _this15 = this;

          return _ApplicationTestCase2.prototype.visit.apply(this, arguments).then(function () {
            _this15.updateCountAfterVisit = _this15.updateCount;
            _this15.replaceCountAfterVisit = _this15.replaceCount;
          });
        };

        _proto2['@test The <LinkTo /> component supports URL replacement'] = function testTheLinkToComponentSupportsURLReplacement(assert) {
          var _this16 = this;

          this.addTemplate('index', "\n          <h3 class=\"home\">Home</h3>\n          <LinkTo id='about-link' @route='about' @replace={{true}}>About</LinkTo>\n          ");
          return this.visit('/').then(function () {
            return _this16.click('#about-link');
          }).then(function () {
            assert.equal(_this16.updateCount, _this16.updateCountAfterVisit, 'setURL should not be called');
            assert.equal(_this16.replaceCount, _this16.replaceCountAfterVisit + 1, 'replaceURL should be called once');
          });
        };

        _proto2['@test The <LinkTo /> component supports URL replacement via replace=boundTruthyThing'] = function testTheLinkToComponentSupportsURLReplacementViaReplaceBoundTruthyThing(assert) {
          var _this17 = this;

          this.addTemplate('index', "\n          <h3 class=\"home\">Home</h3>\n          <LinkTo id='about-link' @route='about' @replace={{boundTruthyThing}}>About</LinkTo>\n          ");
          this.add('controller:index', _controller.default.extend({
            boundTruthyThing: true
          }));
          return this.visit('/').then(function () {
            return _this17.click('#about-link');
          }).then(function () {
            assert.equal(_this17.updateCount, _this17.updateCountAfterVisit, 'setURL should not be called');
            assert.equal(_this17.replaceCount, _this17.replaceCountAfterVisit + 1, 'replaceURL should be called once');
          });
        };

        _proto2['@test The <LinkTo /> component supports setting replace=boundFalseyThing'] = function testTheLinkToComponentSupportsSettingReplaceBoundFalseyThing(assert) {
          var _this18 = this;

          this.addTemplate('index', "\n          <h3 class=\"home\">Home</h3>\n          <LinkTo id='about-link' @route='about' replace={{boundFalseyThing}}>About</LinkTo>\n          ");
          this.add('controller:index', _controller.default.extend({
            boundFalseyThing: false
          }));
          return this.visit('/').then(function () {
            return _this18.click('#about-link');
          }).then(function () {
            assert.equal(_this18.updateCount, _this18.updateCountAfterVisit + 1, 'setURL should be called');
            assert.equal(_this18.replaceCount, _this18.replaceCountAfterVisit, 'replaceURL should not be called');
          });
        };

        return _class2;
      }(_internalTestHelpers.ApplicationTestCase));

      if (false
      /* EMBER_IMPROVED_INSTRUMENTATION */
      ) {
          (0, _internalTestHelpers.moduleFor)('The <LinkTo /> component with EMBER_IMPROVED_INSTRUMENTATION',
          /*#__PURE__*/
          function (_ApplicationTestCase3) {
            (0, _emberBabel.inheritsLoose)(_class3, _ApplicationTestCase3);

            function _class3() {
              var _this19;

              _this19 = _ApplicationTestCase3.call(this) || this;

              _this19.router.map(function () {
                this.route('about');
              });

              _this19.addTemplate('index', "\n            <h3 class=\"home\">Home</h3>\n            <LinkTo id='about-link' @route='about'>About</LinkTo>\n            <LinkTo id='self-link' @route='index'>Self</LinkTo>\n            ");

              _this19.addTemplate('about', "\n            <h3 class=\"about\">About</h3>\n            <LinkTo id='home-link' @route='index'>Home</LinkTo>\n            <LinkTo id='self-link' @route='about'>Self</LinkTo>\n            ");

              return _this19;
            }

            var _proto3 = _class3.prototype;

            _proto3.beforeEach = function beforeEach() {
              return this.visit('/');
            };

            _proto3.afterEach = function afterEach() {
              (0, _instrumentation.reset)();
              return _ApplicationTestCase3.prototype.afterEach.call(this);
            };

            _proto3['@test The <LinkTo /> component fires an interaction event'] = function testTheLinkToComponentFiresAnInteractionEvent(assert) {
              assert.expect(2);
              (0, _instrumentation.subscribe)('interaction.link-to', {
                before: function () {
                  assert.ok(true, 'instrumentation subscriber was called');
                },
                after: function () {
                  assert.ok(true, 'instrumentation subscriber was called');
                }
              });
              return this.click('#about-link');
            };

            _proto3['@test The <LinkTo /> component interaction event includes the route name'] = function testTheLinkToComponentInteractionEventIncludesTheRouteName(assert) {
              assert.expect(2);
              (0, _instrumentation.subscribe)('interaction.link-to', {
                before: function (name, timestamp, _ref) {
                  var routeName = _ref.routeName;
                  assert.equal(routeName, 'about', 'instrumentation subscriber was passed route name');
                },
                after: function (name, timestamp, _ref2) {
                  var routeName = _ref2.routeName;
                  assert.equal(routeName, 'about', 'instrumentation subscriber was passed route name');
                }
              });
              return this.click('#about-link');
            };

            _proto3['@test The <LinkTo /> component interaction event includes the transition in the after hook'] = function testTheLinkToComponentInteractionEventIncludesTheTransitionInTheAfterHook(assert) {
              assert.expect(1);
              (0, _instrumentation.subscribe)('interaction.link-to', {
                before: function () {},
                after: function (name, timestamp, _ref3) {
                  var transition = _ref3.transition;
                  assert.equal(transition.targetName, 'about', 'instrumentation subscriber was passed route name');
                }
              });
              return this.click('#about-link');
            };

            return _class3;
          }(_internalTestHelpers.ApplicationTestCase));
        }

      (0, _internalTestHelpers.moduleFor)('The <LinkTo /> component - nested routes and link-to arguments',
      /*#__PURE__*/
      function (_ApplicationTestCase4) {
        (0, _emberBabel.inheritsLoose)(_class4, _ApplicationTestCase4);

        function _class4() {
          return _ApplicationTestCase4.apply(this, arguments) || this;
        }

        var _proto4 = _class4.prototype;

        _proto4['@test The <LinkTo /> component supports leaving off .index for nested routes'] = function testTheLinkToComponentSupportsLeavingOffIndexForNestedRoutes(assert) {
          var _this20 = this;

          this.router.map(function () {
            this.route('about', function () {
              this.route('item');
            });
          });
          this.addTemplate('about', "<h1>About</h1>{{outlet}}");
          this.addTemplate('about.index', "<div id='index'>Index</div>");
          this.addTemplate('about.item', "<div id='item'><LinkTo @route='about'>About</LinkTo></div>");
          return this.visit('/about/item').then(function () {
            assert.equal(normalizeUrl(_this20.$('#item a').attr('href')), '/about');
          });
        };

        _proto4["@test The <LinkTo /> component supports custom, nested, current-when"] = function (assert) {
          var _this21 = this;

          this.router.map(function () {
            this.route('index', {
              path: '/'
            }, function () {
              this.route('about');
            });
            this.route('item');
          });
          this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
          this.addTemplate('index.about', "<LinkTo id='other-link' @route='item' @current-when='index'>ITEM</LinkTo>");
          return this.visit('/about').then(function () {
            assert.equal(_this21.$('#other-link.active').length, 1, 'The link is active since current-when is a parent route');
          });
        };

        _proto4["@test The <LinkTo /> component does not disregard current-when when it is given explicitly for a route"] = function (assert) {
          var _this22 = this;

          this.router.map(function () {
            this.route('index', {
              path: '/'
            }, function () {
              this.route('about');
            });
            this.route('items', function () {
              this.route('item');
            });
          });
          this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
          this.addTemplate('index.about', "<LinkTo id='other-link' @route='items' @current-when='index'>ITEM</LinkTo>");
          return this.visit('/about').then(function () {
            assert.equal(_this22.$('#other-link.active').length, 1, 'The link is active when current-when is given for explicitly for a route');
          });
        };

        _proto4['@test The <LinkTo /> component does not disregard current-when when it is set via a bound param'] = function testTheLinkToComponentDoesNotDisregardCurrentWhenWhenItIsSetViaABoundParam(assert) {
          var _this23 = this;

          this.router.map(function () {
            this.route('index', {
              path: '/'
            }, function () {
              this.route('about');
            });
            this.route('items', function () {
              this.route('item');
            });
          });
          this.add('controller:index.about', _controller.default.extend({
            currentWhen: 'index'
          }));
          this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
          this.addTemplate('index.about', "<LinkTo id='other-link' @route='items' @current-when={{currentWhen}}>ITEM</LinkTo>");
          return this.visit('/about').then(function () {
            assert.equal(_this23.$('#other-link.active').length, 1, 'The link is active when current-when is given for explicitly for a route');
          });
        };

        _proto4['@test The <LinkTo /> component supports multiple current-when routes'] = function testTheLinkToComponentSupportsMultipleCurrentWhenRoutes(assert) {
          var _this24 = this;

          this.router.map(function () {
            this.route('index', {
              path: '/'
            }, function () {
              this.route('about');
            });
            this.route('item');
            this.route('foo');
          });
          this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
          this.addTemplate('index.about', "<LinkTo id='link1' @route='item' @current-when='item index'>ITEM</LinkTo>");
          this.addTemplate('item', "<LinkTo id='link2' @route='item' @current-when='item index'>ITEM</LinkTo>");
          this.addTemplate('foo', "<LinkTo id='link3' @route='item' @current-when='item index'>ITEM</LinkTo>");
          return this.visit('/about').then(function () {
            assert.equal(_this24.$('#link1.active').length, 1, 'The link is active since current-when contains the parent route');
            return _this24.visit('/item');
          }).then(function () {
            assert.equal(_this24.$('#link2.active').length, 1, 'The link is active since you are on the active route');
            return _this24.visit('/foo');
          }).then(function () {
            assert.equal(_this24.$('#link3.active').length, 0, 'The link is not active since current-when does not contain the active route');
          });
        };

        _proto4['@test The <LinkTo /> component supports boolean values for current-when'] = function testTheLinkToComponentSupportsBooleanValuesForCurrentWhen(assert) {
          var _this25 = this;

          this.router.map(function () {
            this.route('index', {
              path: '/'
            }, function () {
              this.route('about');
            });
            this.route('item');
          });
          this.addTemplate('index.about', "\n          <LinkTo id='index-link' @route='index' @current-when={{isCurrent}}>ITEM</LinkTo>\n          <LinkTo id='about-link' @route='item' @current-when={{true}}>ITEM</LinkTo>\n          ");
          this.add('controller:index.about', _controller.default.extend({
            isCurrent: false
          }));
          return this.visit('/about').then(function () {
            assert.ok(_this25.$('#about-link').hasClass('active'), 'The link is active since current-when is true');
            assert.notOk(_this25.$('#index-link').hasClass('active'), 'The link is not active since current-when is false');

            var controller = _this25.applicationInstance.lookup('controller:index.about');

            (0, _internalTestHelpers.runTask)(function () {
              return controller.set('isCurrent', true);
            });
            assert.ok(_this25.$('#index-link').hasClass('active'), 'The link is active since current-when is true');
          });
        };

        _proto4['@test The <LinkTo /> component defaults to bubbling'] = function testTheLinkToComponentDefaultsToBubbling(assert) {
          var _this26 = this;

          this.addTemplate('about', "\n          <div {{action 'hide'}}>\n            <LinkTo id='about-contact' @route='about.contact'>About</LinkTo>\n          </div>\n          {{outlet}}\n          ");
          this.addTemplate('about.contact', "<h1 id='contact'>Contact</h1>");
          this.router.map(function () {
            this.route('about', function () {
              this.route('contact');
            });
          });
          var hidden = 0;
          this.add('route:about', _routing.Route.extend({
            actions: {
              hide: function () {
                hidden++;
              }
            }
          }));
          return this.visit('/about').then(function () {
            return _this26.click('#about-contact');
          }).then(function () {
            assert.equal(_this26.$('#contact').text(), 'Contact', 'precond - the link worked');
            assert.equal(hidden, 1, 'The link bubbles');
          });
        };

        _proto4["@test The <LinkTo /> component supports bubbles=false"] = function (assert) {
          var _this27 = this;

          this.addTemplate('about', "\n          <div {{action 'hide'}}>\n            <LinkTo id='about-contact' @route='about.contact' @bubbles={{false}}>\n              About\n            </LinkTo>\n          </div>\n          {{outlet}}\n          ");
          this.addTemplate('about.contact', "<h1 id='contact'>Contact</h1>");
          this.router.map(function () {
            this.route('about', function () {
              this.route('contact');
            });
          });
          var hidden = 0;
          this.add('route:about', _routing.Route.extend({
            actions: {
              hide: function () {
                hidden++;
              }
            }
          }));
          return this.visit('/about').then(function () {
            return _this27.click('#about-contact');
          }).then(function () {
            assert.equal(_this27.$('#contact').text(), 'Contact', 'precond - the link worked');
            assert.equal(hidden, 0, "The link didn't bubble");
          });
        };

        _proto4["@test The <LinkTo /> component supports bubbles=boundFalseyThing"] = function (assert) {
          var _this28 = this;

          this.addTemplate('about', "\n          <div {{action 'hide'}}>\n            <LinkTo id='about-contact' @route='about.contact' @bubbles={{boundFalseyThing}}>\n              About\n            </LinkTo>\n          </div>\n          {{outlet}}\n          ");
          this.addTemplate('about.contact', "<h1 id='contact'>Contact</h1>");
          this.add('controller:about', _controller.default.extend({
            boundFalseyThing: false
          }));
          this.router.map(function () {
            this.route('about', function () {
              this.route('contact');
            });
          });
          var hidden = 0;
          this.add('route:about', _routing.Route.extend({
            actions: {
              hide: function () {
                hidden++;
              }
            }
          }));
          return this.visit('/about').then(function () {
            return _this28.click('#about-contact');
          }).then(function () {
            assert.equal(_this28.$('#contact').text(), 'Contact', 'precond - the link worked');
            assert.equal(hidden, 0, "The link didn't bubble");
          });
        };

        _proto4["@test The <LinkTo /> component moves into the named route with context"] = function (assert) {
          var _this29 = this;

          this.router.map(function () {
            this.route('about');
            this.route('item', {
              path: '/item/:id'
            });
          });
          this.addTemplate('about', "\n          <h3 class=\"list\">List</h3>\n          <ul>\n            {{#each model as |person|}}\n              <li>\n                <LinkTo id={{person.id}} @route='item' @model={{person}}>\n                  {{person.name}}\n                </LinkTo>\n              </li>\n            {{/each}}\n          </ul>\n          <LinkTo id='home-link' @route='index'>Home</LinkTo>\n          ");
          this.addTemplate('item', "\n          <h3 class=\"item\">Item</h3>\n          <p>{{model.name}}</p>\n          <LinkTo id='home-link' @route='index'>Home</LinkTo>\n          ");
          this.addTemplate('index', "\n          <h3 class=\"home\">Home</h3>\n          <LinkTo id='about-link' @route='about'>About</LinkTo>\n          ");
          this.add('route:about', _routing.Route.extend({
            model: function () {
              return [{
                id: 'yehuda',
                name: 'Yehuda Katz'
              }, {
                id: 'tom',
                name: 'Tom Dale'
              }, {
                id: 'erik',
                name: 'Erik Brynroflsson'
              }];
            }
          }));
          return this.visit('/about').then(function () {
            assert.equal(_this29.$('h3.list').length, 1, 'The home template was rendered');
            assert.equal(normalizeUrl(_this29.$('#home-link').attr('href')), '/', 'The home link points back at /');
            return _this29.click('#yehuda');
          }).then(function () {
            assert.equal(_this29.$('h3.item').length, 1, 'The item template was rendered');
            assert.equal(_this29.$('p').text(), 'Yehuda Katz', 'The name is correct');
            return _this29.click('#home-link');
          }).then(function () {
            return _this29.click('#about-link');
          }).then(function () {
            assert.equal(normalizeUrl(_this29.$('li a#yehuda').attr('href')), '/item/yehuda');
            assert.equal(normalizeUrl(_this29.$('li a#tom').attr('href')), '/item/tom');
            assert.equal(normalizeUrl(_this29.$('li a#erik').attr('href')), '/item/erik');
            return _this29.click('#erik');
          }).then(function () {
            assert.equal(_this29.$('h3.item').length, 1, 'The item template was rendered');
            assert.equal(_this29.$('p').text(), 'Erik Brynroflsson', 'The name is correct');
          });
        };

        _proto4["@test The <LinkTo /> component binds some anchor html tag common attributes"] = function (assert) {
          var _this30 = this;

          this.addTemplate('index', "\n          <h3 class=\"home\">Home</h3>\n          <LinkTo id='self-link' @route='index' title='title-attr' rel='rel-attr' tabindex='-1'>\n            Self\n          </LinkTo>\n          ");
          return this.visit('/').then(function () {
            var link = _this30.$('#self-link');

            assert.equal(link.attr('title'), 'title-attr', 'The self-link contains title attribute');
            assert.equal(link.attr('rel'), 'rel-attr', 'The self-link contains rel attribute');
            assert.equal(link.attr('tabindex'), '-1', 'The self-link contains tabindex attribute');
          });
        };

        _proto4["@test The <LinkTo /> component supports 'target' attribute"] = function (assert) {
          var _this31 = this;

          this.addTemplate('index', "\n          <h3 class=\"home\">Home</h3>\n          <LinkTo id='self-link' @route='index' target='_blank'>Self</LinkTo>\n          ");
          return this.visit('/').then(function () {
            var link = _this31.$('#self-link');

            assert.equal(link.attr('target'), '_blank', 'The self-link contains `target` attribute');
          });
        };

        _proto4["@test The <LinkTo /> component supports 'target' attribute specified as a bound param"] = function (assert) {
          var _this32 = this;

          this.addTemplate('index', "\n          <h3 class=\"home\">Home</h3>\n          <LinkTo id='self-link' @route='index' target={{boundLinkTarget}}>Self</LinkTo>\n          ");
          this.add('controller:index', _controller.default.extend({
            boundLinkTarget: '_blank'
          }));
          return this.visit('/').then(function () {
            var link = _this32.$('#self-link');

            assert.equal(link.attr('target'), '_blank', 'The self-link contains `target` attribute');
          });
        };

        _proto4["@test the <LinkTo /> component calls preventDefault"] = function (assert) {
          var _this33 = this;

          this.router.map(function () {
            this.route('about');
          });
          this.addTemplate('index', "<LinkTo @route='about' id='about-link'>About</LinkTo>");
          return this.visit('/').then(function () {
            assertNav({
              prevented: true
            }, function () {
              return _this33.$('#about-link').click();
            }, assert);
          });
        };

        _proto4["@test the <LinkTo /> component does not call preventDefault if '@preventDefault={{false}}' is passed as an option"] = function (assert) {
          var _this34 = this;

          this.router.map(function () {
            this.route('about');
          });
          this.addTemplate('index', "<LinkTo id='about-link' @route='about' @preventDefault={{false}}>About</LinkTo>");
          return this.visit('/').then(function () {
            assertNav({
              prevented: false
            }, function () {
              return _this34.$('#about-link').trigger('click');
            }, assert);
          });
        };

        _proto4["@test the <LinkTo /> component does not call preventDefault if '@preventDefault={{boundFalseyThing}}' is passed as an option"] = function (assert) {
          var _this35 = this;

          this.router.map(function () {
            this.route('about');
          });
          this.addTemplate('index', "<LinkTo id='about-link' @route='about' @preventDefault={{boundFalseyThing}}>About</LinkTo>");
          this.add('controller:index', _controller.default.extend({
            boundFalseyThing: false
          }));
          return this.visit('/').then(function () {
            assertNav({
              prevented: false
            }, function () {
              return _this35.$('#about-link').trigger('click');
            }, assert);
          });
        };

        _proto4["@test The <LinkTo /> component does not call preventDefault if 'target' attribute is provided"] = function (assert) {
          var _this36 = this;

          this.addTemplate('index', "\n          <h3 class=\"home\">Home</h3>\n          <LinkTo id='self-link' @route='index' target='_blank'>Self</LinkTo>\n          ");
          return this.visit('/').then(function () {
            assertNav({
              prevented: false
            }, function () {
              return _this36.$('#self-link').click();
            }, assert);
          });
        };

        _proto4["@test The <LinkTo /> component should preventDefault when 'target = _self'"] = function (assert) {
          var _this37 = this;

          this.addTemplate('index', "\n          <h3 class=\"home\">Home</h3>\n          <LinkTo id='self-link' @route='index' target='_self'>Self</LinkTo>\n          ");
          return this.visit('/').then(function () {
            assertNav({
              prevented: true
            }, function () {
              return _this37.$('#self-link').click();
            }, assert);
          });
        };

        _proto4["@test The <LinkTo /> component should not transition if target is not equal to _self or empty"] = function (assert) {
          var _this38 = this;

          this.addTemplate('index', "\n          <LinkTo id='about-link' @route='about' @replace={{true}} target='_blank'>\n            About\n          </LinkTo>\n          ");
          this.router.map(function () {
            this.route('about');
          });
          return this.visit('/').then(function () {
            return _this38.click('#about-link');
          }).then(function () {
            expectDeprecation(function () {
              var currentRouteName = _this38.applicationInstance.lookup('controller:application').get('currentRouteName');

              assert.notEqual(currentRouteName, 'about', 'link-to should not transition if target is not equal to _self or empty');
            }, 'Accessing `currentRouteName` on `controller:application` is deprecated, use the `currentRouteName` property on `service:router` instead.');
          });
        };

        _proto4["@test The <LinkTo /> component accepts string/numeric arguments"] = function (assert) {
          var _this39 = this;

          this.router.map(function () {
            this.route('filter', {
              path: '/filters/:filter'
            });
            this.route('post', {
              path: '/post/:post_id'
            });
            this.route('repo', {
              path: '/repo/:owner/:name'
            });
          });
          this.add('controller:filter', _controller.default.extend({
            filter: 'unpopular',
            repo: {
              owner: 'ember',
              name: 'ember.js'
            },
            post_id: 123
          }));
          this.addTemplate('filter', "\n          <p>{{filter}}</p>\n          <LinkTo id=\"link\" @route=\"filter\" @model=\"unpopular\">Unpopular</LinkTo>\n          <LinkTo id=\"path-link\" @route=\"filter\" @model={{filter}}>Unpopular</LinkTo>\n          <LinkTo id=\"post-path-link\" @route=\"post\" @model={{post_id}}>Post</LinkTo>\n          <LinkTo id=\"post-number-link\" @route=\"post\" @model={{123}}>Post</LinkTo>\n          <LinkTo id=\"repo-object-link\" @route=\"repo\" @model={{repo}}>Repo</LinkTo>\n          ");
          return this.visit('/filters/popular').then(function () {
            assert.equal(normalizeUrl(_this39.$('#link').attr('href')), '/filters/unpopular');
            assert.equal(normalizeUrl(_this39.$('#path-link').attr('href')), '/filters/unpopular');
            assert.equal(normalizeUrl(_this39.$('#post-path-link').attr('href')), '/post/123');
            assert.equal(normalizeUrl(_this39.$('#post-number-link').attr('href')), '/post/123');
            assert.equal(normalizeUrl(_this39.$('#repo-object-link').attr('href')), '/repo/ember/ember.js');
          });
        };

        _proto4["@test Issue 4201 - Shorthand for route.index shouldn't throw errors about context arguments"] = function (assert) {
          var _this40 = this;

          assert.expect(2);
          this.router.map(function () {
            this.route('lobby', function () {
              this.route('index', {
                path: ':lobby_id'
              });
              this.route('list');
            });
          });
          this.add('route:lobby.index', _routing.Route.extend({
            model: function (params) {
              assert.equal(params.lobby_id, 'foobar');
              return params.lobby_id;
            }
          }));
          this.addTemplate('lobby.index', "<LinkTo id='lobby-link' @route='lobby' @model='foobar'>Lobby</LinkTo>");
          this.addTemplate('lobby.list', "<LinkTo id='lobby-link' @route='lobby' @model='foobar'>Lobby</LinkTo>");
          return this.visit('/lobby/list').then(function () {
            return _this40.click('#lobby-link');
          }).then(function () {
            return shouldBeActive(assert, _this40.$('#lobby-link'));
          });
        };

        _proto4["@test Quoteless route param performs property lookup"] = function (assert) {
          var _this41 = this;

          this.router.map(function () {
            this.route('about');
          });
          this.addTemplate('index', "\n          <LinkTo id='string-link' @route='index'>string</LinkTo>\n          <LinkTo id='path-link' @route={{foo}}>path</LinkTo>\n          ");
          this.add('controller:index', _controller.default.extend({
            foo: 'index'
          }));

          var assertEquality = function (href) {
            assert.equal(normalizeUrl(_this41.$('#string-link').attr('href')), '/');
            assert.equal(normalizeUrl(_this41.$('#path-link').attr('href')), href);
          };

          return this.visit('/').then(function () {
            assertEquality('/');

            var controller = _this41.applicationInstance.lookup('controller:index');

            (0, _internalTestHelpers.runTask)(function () {
              return controller.set('foo', 'about');
            });
            assertEquality('/about');
          });
        };

        _proto4["@test The <LinkTo /> component refreshes href element when one of params changes"] = function (assert) {
          var _this42 = this;

          this.router.map(function () {
            this.route('post', {
              path: '/posts/:post_id'
            });
          });
          var post = {
            id: '1'
          };
          var secondPost = {
            id: '2'
          };
          this.addTemplate('index', "<LinkTo id=\"post\" @route=\"post\" @model={{post}}>post</LinkTo>");
          this.add('controller:index', _controller.default.extend());
          return this.visit('/').then(function () {
            var indexController = _this42.applicationInstance.lookup('controller:index');

            (0, _internalTestHelpers.runTask)(function () {
              return indexController.set('post', post);
            });
            assert.equal(normalizeUrl(_this42.$('#post').attr('href')), '/posts/1', 'precond - Link has rendered href attr properly');
            (0, _internalTestHelpers.runTask)(function () {
              return indexController.set('post', secondPost);
            });
            assert.equal(_this42.$('#post').attr('href'), '/posts/2', 'href attr was updated after one of the params had been changed');
            (0, _internalTestHelpers.runTask)(function () {
              return indexController.set('post', null);
            });
            assert.equal(_this42.$('#post').attr('href'), '#', 'href attr becomes # when one of the arguments in nullified');
          });
        };

        _proto4["@test The <LinkTo /> component is active when a route is active"] = function (assert) {
          var _this43 = this;

          this.router.map(function () {
            this.route('about', function () {
              this.route('item');
            });
          });
          this.addTemplate('about', "\n          <div id='about'>\n            <LinkTo id='about-link' @route='about'>About</LinkTo>\n            <LinkTo id='item-link' @route='about.item'>Item</LinkTo>\n            {{outlet}}\n          </div>\n          ");
          return this.visit('/about').then(function () {
            assert.equal(_this43.$('#about-link.active').length, 1, 'The about route link is active');
            assert.equal(_this43.$('#item-link.active').length, 0, 'The item route link is inactive');
            return _this43.visit('/about/item');
          }).then(function () {
            assert.equal(_this43.$('#about-link.active').length, 1, 'The about route link is active');
            assert.equal(_this43.$('#item-link.active').length, 1, 'The item route link is active');
          });
        };

        _proto4["@test The <LinkTo /> component works in an #each'd array of string route names"] = function (assert) {
          var _this44 = this;

          this.router.map(function () {
            this.route('foo');
            this.route('bar');
            this.route('rar');
          });
          this.add('controller:index', _controller.default.extend({
            routeNames: (0, _runtime.A)(['foo', 'bar', 'rar']),
            route1: 'bar',
            route2: 'foo'
          }));
          this.addTemplate('index', "\n          {{#each routeNames as |routeName|}}\n            <LinkTo @route={{routeName}}>{{routeName}}</LinkTo>\n          {{/each}}\n          {{#each routeNames as |r|}}\n            <LinkTo @route={{r}}>{{r}}</LinkTo>\n          {{/each}}\n          <LinkTo @route={{route1}}>a</LinkTo>\n          <LinkTo @route={{route2}}>b</LinkTo>\n          ");

          var linksEqual = function (links, expected) {
            assert.equal(links.length, expected.length, 'Has correct number of links');
            var idx;

            for (idx = 0; idx < links.length; idx++) {
              var href = _this44.$(links[idx]).attr('href'); // Old IE includes the whole hostname as well


              assert.equal(href.slice(-expected[idx].length), expected[idx], "Expected link to be '" + expected[idx] + "', but was '" + href + "'");
            }
          };

          return this.visit('/').then(function () {
            linksEqual(_this44.$('a'), ['/foo', '/bar', '/rar', '/foo', '/bar', '/rar', '/bar', '/foo']);

            var indexController = _this44.applicationInstance.lookup('controller:index');

            (0, _internalTestHelpers.runTask)(function () {
              return indexController.set('route1', 'rar');
            });
            linksEqual(_this44.$('a'), ['/foo', '/bar', '/rar', '/foo', '/bar', '/rar', '/rar', '/foo']);
            (0, _internalTestHelpers.runTask)(function () {
              return indexController.routeNames.shiftObject();
            });
            linksEqual(_this44.$('a'), ['/bar', '/rar', '/bar', '/rar', '/rar', '/foo']);
          });
        };

        _proto4["@test the <LinkTo /> component throws a useful error if you invoke it wrong"] =
        /*#__PURE__*/
        function () {
          var _ref4 = _asyncToGenerator(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee(assert) {
            var _this45;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _this45 = this;
                  assert.expect(1);
                  this.router.map(function () {
                    this.route('post', {
                      path: 'post/:post_id'
                    });
                  });
                  this.addTemplate('application', "<LinkTo @route='post'>Post</LinkTo>");
                  _context.next = 6;
                  return assert.throws(function () {
                    return (0, _internalTestHelpers.runTask)(function () {
                      return _this45.visit('/');
                    });
                  }, /(You attempted to generate a link for the "post" route, but did not pass the models required for generating its dynamic segments.|You must provide param `post_id` to `generate`)/);

                case 6:
                case "end":
                  return _context.stop();
              }
            }, _callee, this);
          }));

          return function (_x) {
            return _ref4.apply(this, arguments);
          };
        }();

        _proto4["@test the <LinkTo /> component does not throw an error if its route has exited"] = function (assert) {
          var _this46 = this;

          assert.expect(0);
          this.router.map(function () {
            this.route('post', {
              path: 'post/:post_id'
            });
          });
          this.addTemplate('application', "\n          <LinkTo id='home-link' @route='index'>Home</LinkTo>\n          <LinkTo id='default-post-link' @route='post' @model={{defaultPost}}>Default Post</LinkTo>\n          {{#if currentPost}}\n            <LinkTo id='current-post-link' @route='post' @model={{currentPost}}>Current Post</LinkTo>\n          {{/if}}\n          ");
          this.add('controller:application', _controller.default.extend({
            defaultPost: {
              id: 1
            },
            postController: (0, _controller.inject)('post'),
            currentPost: (0, _metal.alias)('postController.model')
          }));
          this.add('controller:post', _controller.default.extend());
          this.add('route:post', _routing.Route.extend({
            model: function () {
              return {
                id: 2
              };
            },
            serialize: function (model) {
              return {
                post_id: model.id
              };
            }
          }));
          return this.visit('/').then(function () {
            return _this46.click('#default-post-link');
          }).then(function () {
            return _this46.click('#home-link');
          }).then(function () {
            return _this46.click('#current-post-link');
          }).then(function () {
            return _this46.click('#home-link');
          });
        };

        _proto4["@test the <LinkTo /> component's active property respects changing parent route context"] = function (assert) {
          var _this47 = this;

          this.router.map(function () {
            this.route('things', {
              path: '/things/:name'
            }, function () {
              this.route('other');
            });
          });
          this.addTemplate('application', "\n          <LinkTo id='omg-link' @route='things' @model='omg'>OMG</LinkTo>\n          <LinkTo id='lol-link' @route='things' @model='lol'>LOL</LinkTo>\n          ");
          return this.visit('/things/omg').then(function () {
            shouldBeActive(assert, _this47.$('#omg-link'));
            shouldNotBeActive(assert, _this47.$('#lol-link'));
            return _this47.visit('/things/omg/other');
          }).then(function () {
            shouldBeActive(assert, _this47.$('#omg-link'));
            shouldNotBeActive(assert, _this47.$('#lol-link'));
          });
        };

        _proto4["@test the <LinkTo /> component populates href with default query param values even without query-params object"] = function (assert) {
          var _this48 = this;

          this.add('controller:index', _controller.default.extend({
            queryParams: ['foo'],
            foo: '123'
          }));
          this.addTemplate('index', "<LinkTo id='the-link' @route='index'>Index</LinkTo>");
          return this.visit('/').then(function () {
            assert.equal(_this48.$('#the-link').attr('href'), '/', 'link has right href');
          });
        };

        _proto4["@test the <LinkTo /> component populates href with default query param values with empty query-params object"] = function (assert) {
          var _this49 = this;

          this.add('controller:index', _controller.default.extend({
            queryParams: ['foo'],
            foo: '123'
          }));
          this.addTemplate('index', "<LinkTo id='the-link' @route='index' @query={{hash}}>Index</LinkTo>");
          return this.visit('/').then(function () {
            assert.equal(_this49.$('#the-link').attr('href'), '/', 'link has right href');
          });
        };

        _proto4["@test the <LinkTo /> component with only query-params and a block updates when route changes"] = function (assert) {
          var _this50 = this;

          this.router.map(function () {
            this.route('about');
          });
          this.add('controller:application', _controller.default.extend({
            queryParams: ['foo', 'bar'],
            foo: '123',
            bar: 'yes'
          }));
          this.addTemplate('application', "<LinkTo id='the-link' @query={{hash foo='456' bar='NAW'}}>Index</LinkTo>");
          return this.visit('/').then(function () {
            assert.equal(_this50.$('#the-link').attr('href'), '/?bar=NAW&foo=456', 'link has right href');
            return _this50.visit('/about');
          }).then(function () {
            assert.equal(_this50.$('#the-link').attr('href'), '/about?bar=NAW&foo=456', 'link has right href');
          });
        };

        _proto4['@test [GH#17018] passing model to <LinkTo /> with `hash` helper works'] = function testGH17018PassingModelToLinkToWithHashHelperWorks() {
          var _this51 = this;

          this.router.map(function () {
            this.route('post', {
              path: '/posts/:post_id'
            });
          });
          this.add('route:index', _routing.Route.extend({
            model: function () {
              return _runtime.RSVP.hash({
                user: {
                  name: 'Papa Smurf'
                }
              });
            }
          }));
          this.addTemplate('index', "<LinkTo @route='post' @model={{hash id=\"someId\" user=this.model.user}}>Post</LinkTo>");
          this.addTemplate('post', 'Post: {{this.model.user.name}}');
          return this.visit('/').then(function () {
            _this51.assertComponentElement(_this51.firstChild, {
              tagName: 'a',
              attrs: {
                href: '/posts/someId'
              },
              content: 'Post'
            });

            return _this51.click('a');
          }).then(function () {
            _this51.assertText('Post: Papa Smurf');
          });
        };

        _proto4["@test The <LinkTo /> component can use dynamic params"] = function (assert) {
          var _this52 = this;

          this.router.map(function () {
            this.route('foo', {
              path: 'foo/:some/:thing'
            });
            this.route('bar', {
              path: 'bar/:some/:thing/:else'
            });
          });
          this.add('controller:index', _controller.default.extend({
            init: function () {
              this._super.apply(this, arguments);

              this.dynamicLinkParams = ['foo', 'one', 'two'];
            }
          }));
          this.addTemplate('index', "\n          <h3 class=\"home\">Home</h3>\n          <LinkTo id=\"dynamic-link\" @params={{dynamicLinkParams}}>Dynamic</LinkTo>\n          ");
          return this.visit('/').then(function () {
            var link = _this52.$('#dynamic-link');

            assert.equal(link.attr('href'), '/foo/one/two');

            var controller = _this52.applicationInstance.lookup('controller:index');

            (0, _internalTestHelpers.runTask)(function () {
              controller.set('dynamicLinkParams', ['bar', 'one', 'two', 'three']);
            });
            assert.equal(link.attr('href'), '/bar/one/two/three');
          });
        };

        _proto4["@test GJ: <LinkTo /> to a parent root model hook which performs a 'transitionTo' has correct active class #13256"] = function (assert) {
          var _this53 = this;

          assert.expect(1);
          this.router.map(function () {
            this.route('parent', function () {
              this.route('child');
            });
          });
          this.add('route:parent', _routing.Route.extend({
            afterModel: function () {
              this.transitionTo('parent.child');
            }
          }));
          this.addTemplate('application', "<LinkTo id='parent-link' @route='parent'>Parent</LinkTo>");
          return this.visit('/').then(function () {
            return _this53.click('#parent-link');
          }).then(function () {
            shouldBeActive(assert, _this53.$('#parent-link'));
          });
        };

        return _class4;
      }(_internalTestHelpers.ApplicationTestCase));
      (0, _internalTestHelpers.moduleFor)('The <LinkTo /> component - loading states and warnings',
      /*#__PURE__*/
      function (_ApplicationTestCase5) {
        (0, _emberBabel.inheritsLoose)(_class5, _ApplicationTestCase5);

        function _class5() {
          return _ApplicationTestCase5.apply(this, arguments) || this;
        }

        var _proto5 = _class5.prototype;

        _proto5["@test <LinkTo /> with null/undefined dynamic parameters are put in a loading state"] = function (assert) {
          var _this54 = this;

          assert.expect(19);
          var warningMessage = 'This link is in an inactive loading state because at least one of its models currently has a null/undefined value, or the provided route name is invalid.';
          this.router.map(function () {
            this.route('thing', {
              path: '/thing/:thing_id'
            });
            this.route('about');
          });
          this.addTemplate('index', "\n          <LinkTo id='context-link' @route={{destinationRoute}} @model={{routeContext}} @loadingClass='i-am-loading'>\n            string\n          </LinkTo>\n          <LinkTo id='static-link' @route={{secondRoute}} @loadingClass={{loadingClass}}>\n            string\n          </LinkTo>\n          ");
          this.add('controller:index', _controller.default.extend({
            destinationRoute: null,
            routeContext: null,
            loadingClass: 'i-am-loading'
          }));
          this.add('route:about', _routing.Route.extend({
            activate: function () {
              assert.ok(true, 'About was entered');
            }
          }));

          function assertLinkStatus(link, url) {
            if (url) {
              assert.equal(normalizeUrl(link.attr('href')), url, 'loaded link-to has expected href');
              assert.ok(!link.hasClass('i-am-loading'), 'loaded linkComponent has no loadingClass');
            } else {
              assert.equal(normalizeUrl(link.attr('href')), '#', "unloaded link-to has href='#'");
              assert.ok(link.hasClass('i-am-loading'), 'loading linkComponent has loadingClass');
            }
          }

          var contextLink, staticLink, controller;
          return this.visit('/').then(function () {
            contextLink = _this54.$('#context-link');
            staticLink = _this54.$('#static-link');
            controller = _this54.applicationInstance.lookup('controller:index');
            assertLinkStatus(contextLink);
            assertLinkStatus(staticLink);
            return expectWarning(function () {
              return _this54.click(contextLink[0]);
            }, warningMessage);
          }).then(function () {
            // Set the destinationRoute (context is still null).
            (0, _internalTestHelpers.runTask)(function () {
              return controller.set('destinationRoute', 'thing');
            });
            assertLinkStatus(contextLink); // Set the routeContext to an id

            (0, _internalTestHelpers.runTask)(function () {
              return controller.set('routeContext', '456');
            });
            assertLinkStatus(contextLink, '/thing/456'); // Test that 0 isn't interpreted as falsy.

            (0, _internalTestHelpers.runTask)(function () {
              return controller.set('routeContext', 0);
            });
            assertLinkStatus(contextLink, '/thing/0'); // Set the routeContext to an object

            (0, _internalTestHelpers.runTask)(function () {
              controller.set('routeContext', {
                id: 123
              });
            });
            assertLinkStatus(contextLink, '/thing/123'); // Set the destinationRoute back to null.

            (0, _internalTestHelpers.runTask)(function () {
              return controller.set('destinationRoute', null);
            });
            assertLinkStatus(contextLink);
            return expectWarning(function () {
              return _this54.click(staticLink[0]);
            }, warningMessage);
          }).then(function () {
            (0, _internalTestHelpers.runTask)(function () {
              return controller.set('secondRoute', 'about');
            });
            assertLinkStatus(staticLink, '/about'); // Click the now-active link

            return _this54.click(staticLink[0]);
          });
        };

        return _class5;
      }(_internalTestHelpers.ApplicationTestCase));

      function assertNav(options, callback, assert) {
        var nav = false;

        function check(event) {
          assert.equal(event.defaultPrevented, options.prevented, "expected defaultPrevented=" + options.prevented);
          nav = true;
          event.preventDefault();
        }

        try {
          document.addEventListener('click', check);
          callback();
        } finally {
          document.removeEventListener('click', check);
          assert.ok(nav, 'Expected a link to be clicked');
        }
      }
    }
});
enifed("@ember/-internals/glimmer/tests/integration/components/link-to/routing-curly-test", ["ember-babel", "internal-test-helpers", "@ember/controller", "@ember/-internals/runtime", "@ember/-internals/metal", "@ember/instrumentation", "@ember/-internals/routing"], function (_emberBabel, _internalTestHelpers, _controller, _runtime, _metal, _instrumentation, _routing) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  // IE includes the host name
  function normalizeUrl(url) {
    return url.replace(/https?:\/\/[^\/]+/, '');
  }

  function shouldNotBeActive(assert, element) {
    checkActive(assert, element, false);
  }

  function shouldBeActive(assert, element) {
    checkActive(assert, element, true);
  }

  function checkActive(assert, element, active) {
    var classList = element.attr('class');
    assert.equal(classList.indexOf('active') > -1, active, element + " active should be " + active);
  }

  (0, _internalTestHelpers.moduleFor)('{{link-to}} component (routing tests)',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.call(this) || this;

      _this.router.map(function () {
        this.route('about');
      });

      _this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{#link-to 'about' id='about-link'}}About{{/link-to}}\n        {{#link-to 'index' id='self-link'}}Self{{/link-to}}\n        ");

      _this.addTemplate('about', "\n        <h3 class=\"about\">About</h3>\n        {{#link-to 'index' id='home-link'}}Home{{/link-to}}\n        {{#link-to 'about' id='self-link'}}Self{{/link-to}}\n        ");

      return _this;
    }

    var _proto = _class.prototype;

    _proto['@test The {{link-to}} component navigates into the named route'] = function testTheLinkToComponentNavigatesIntoTheNamedRoute(assert) {
      var _this2 = this;

      return this.visit('/').then(function () {
        assert.equal(_this2.$('h3.home').length, 1, 'The home template was rendered');
        assert.equal(_this2.$('#self-link.active').length, 1, 'The self-link was rendered with active class');
        assert.equal(_this2.$('#about-link:not(.active)').length, 1, 'The other link was rendered without active class');
        return _this2.click('#about-link');
      }).then(function () {
        assert.equal(_this2.$('h3.about').length, 1, 'The about template was rendered');
        assert.equal(_this2.$('#self-link.active').length, 1, 'The self-link was rendered with active class');
        assert.equal(_this2.$('#home-link:not(.active)').length, 1, 'The other link was rendered without active class');
      });
    };

    _proto["@test the {{link-to}} component doesn't add an href when the tagName isn't 'a'"] = function (assert) {
      var _this3 = this;

      this.addTemplate('index', "{{#link-to 'about' id='about-link' tagName='div'}}About{{/link-to}}");
      return this.visit('/').then(function () {
        assert.equal(_this3.$('#about-link').attr('href'), undefined, 'there is no href attribute');
      });
    };

    _proto["@test the {{link-to}} component applies a 'disabled' class when disabled"] = function (assert) {
      var _this4 = this;

      this.addTemplate('index', "\n        {{#link-to \"about\" id=\"about-link-static\" disabledWhen=\"shouldDisable\"}}About{{/link-to}}\n        {{#link-to \"about\" id=\"about-link-dynamic\" disabledWhen=dynamicDisabledWhen}}About{{/link-to}}\n        ");
      this.add('controller:index', _controller.default.extend({
        shouldDisable: true,
        dynamicDisabledWhen: 'shouldDisable'
      }));
      return this.visit('/').then(function () {
        assert.equal(_this4.$('#about-link-static.disabled').length, 1, 'The static link is disabled when its disabledWhen is true');
        assert.equal(_this4.$('#about-link-dynamic.disabled').length, 1, 'The dynamic link is disabled when its disabledWhen is true');

        var controller = _this4.applicationInstance.lookup('controller:index');

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('dynamicDisabledWhen', false);
        });
        assert.equal(_this4.$('#about-link-dynamic.disabled').length, 0, 'The dynamic link is re-enabled when its disabledWhen becomes false');
      });
    };

    _proto["@test the {{link-to}} component doesn't apply a 'disabled' class if disabledWhen is not provided"] = function (assert) {
      var _this5 = this;

      this.addTemplate('index', "{{#link-to \"about\" id=\"about-link\"}}About{{/link-to}}");
      return this.visit('/').then(function () {
        assert.ok(!_this5.$('#about-link').hasClass('disabled'), 'The link is not disabled if disabledWhen not provided');
      });
    };

    _proto["@test the {{link-to}} component supports a custom disabledClass"] = function (assert) {
      var _this6 = this;

      this.addTemplate('index', "{{#link-to \"about\" id=\"about-link\" disabledWhen=true disabledClass=\"do-not-want\"}}About{{/link-to}}");
      return this.visit('/').then(function () {
        assert.equal(_this6.$('#about-link.do-not-want').length, 1, 'The link can apply a custom disabled class');
      });
    };

    _proto["@test the {{link-to}} component supports a custom disabledClass set via bound param"] = function (assert) {
      var _this7 = this;

      this.addTemplate('index', "{{#link-to \"about\" id=\"about-link\" disabledWhen=true disabledClass=disabledClass}}About{{/link-to}}");
      this.add('controller:index', _controller.default.extend({
        disabledClass: 'do-not-want'
      }));
      return this.visit('/').then(function () {
        assert.equal(_this7.$('#about-link.do-not-want').length, 1, 'The link can apply a custom disabled class via bound param');
      });
    };

    _proto["@test the {{link-to}} component does not respond to clicks when disabledWhen"] = function (assert) {
      var _this8 = this;

      this.addTemplate('index', "{{#link-to \"about\" id=\"about-link\" disabledWhen=true}}About{{/link-to}}");
      return this.visit('/').then(function () {
        return _this8.click('#about-link');
      }).then(function () {
        assert.equal(_this8.$('h3.about').length, 0, 'Transitioning did not occur');
      });
    };

    _proto["@test the {{link-to}} component does not respond to clicks when disabled"] = function (assert) {
      var _this9 = this;

      this.addTemplate('index', "{{#link-to \"about\" id=\"about-link\" disabled=true}}About{{/link-to}}");
      return this.visit('/').then(function () {
        return _this9.click('#about-link');
      }).then(function () {
        assert.equal(_this9.$('h3.about').length, 0, 'Transitioning did not occur');
      });
    };

    _proto["@test the {{link-to}} component responds to clicks according to its disabledWhen bound param"] = function (assert) {
      var _this10 = this;

      this.addTemplate('index', "{{#link-to \"about\" id=\"about-link\" disabledWhen=disabledWhen}}About{{/link-to}}");
      this.add('controller:index', _controller.default.extend({
        disabledWhen: true
      }));
      return this.visit('/').then(function () {
        return _this10.click('#about-link');
      }).then(function () {
        assert.equal(_this10.$('h3.about').length, 0, 'Transitioning did not occur');

        var controller = _this10.applicationInstance.lookup('controller:index');

        controller.set('disabledWhen', false);
        return (0, _internalTestHelpers.runLoopSettled)();
      }).then(function () {
        return _this10.click('#about-link');
      }).then(function () {
        assert.equal(_this10.$('h3.about').length, 1, 'Transitioning did occur when disabledWhen became false');
      });
    };

    _proto["@test The {{link-to}} component supports a custom activeClass"] = function (assert) {
      var _this11 = this;

      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{#link-to 'about' id='about-link'}}About{{/link-to}}\n        {{#link-to 'index' id='self-link' activeClass='zomg-active'}}Self{{/link-to}}\n        ");
      return this.visit('/').then(function () {
        assert.equal(_this11.$('h3.home').length, 1, 'The home template was rendered');
        assert.equal(_this11.$('#self-link.zomg-active').length, 1, 'The self-link was rendered with active class');
        assert.equal(_this11.$('#about-link:not(.active)').length, 1, 'The other link was rendered without active class');
      });
    };

    _proto["@test The {{link-to}} component supports a custom activeClass from a bound param"] = function (assert) {
      var _this12 = this;

      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{#link-to 'about' id='about-link'}}About{{/link-to}}\n        {{#link-to 'index' id='self-link' activeClass=activeClass}}Self{{/link-to}}\n        ");
      this.add('controller:index', _controller.default.extend({
        activeClass: 'zomg-active'
      }));
      return this.visit('/').then(function () {
        assert.equal(_this12.$('h3.home').length, 1, 'The home template was rendered');
        assert.equal(_this12.$('#self-link.zomg-active').length, 1, 'The self-link was rendered with active class');
        assert.equal(_this12.$('#about-link:not(.active)').length, 1, 'The other link was rendered without active class');
      });
    };

    _proto["@test The {{link-to}} component supports 'classNameBindings' with custom values [GH #11699]"] = function (assert) {
      var _this13 = this;

      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{#link-to 'about' id='about-link' classNameBindings='foo:foo-is-true:foo-is-false'}}About{{/link-to}}\n        ");
      this.add('controller:index', _controller.default.extend({
        foo: false
      }));
      return this.visit('/').then(function () {
        assert.equal(_this13.$('#about-link.foo-is-false').length, 1, 'The about-link was rendered with the falsy class');

        var controller = _this13.applicationInstance.lookup('controller:index');

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('foo', true);
        });
        assert.equal(_this13.$('#about-link.foo-is-true').length, 1, 'The about-link was rendered with the truthy class after toggling the property');
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('{{link-to}} component (routing tests - location hooks)',
  /*#__PURE__*/
  function (_ApplicationTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase2);

    function _class2() {
      var _this14;

      _this14 = _ApplicationTestCase2.call(this) || this;
      _this14.updateCount = 0;
      _this14.replaceCount = 0;
      var testContext = (0, _emberBabel.assertThisInitialized)(_this14);

      _this14.add('location:none', _routing.NoneLocation.extend({
        setURL: function () {
          testContext.updateCount++;
          return this._super.apply(this, arguments);
        },
        replaceURL: function () {
          testContext.replaceCount++;
          return this._super.apply(this, arguments);
        }
      }));

      _this14.router.map(function () {
        this.route('about');
      });

      _this14.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{#link-to 'about' id='about-link'}}About{{/link-to}}\n        {{#link-to 'index' id='self-link'}}Self{{/link-to}}\n        ");

      _this14.addTemplate('about', "\n        <h3 class=\"about\">About</h3>\n        {{#link-to 'index' id='home-link'}}Home{{/link-to}}\n        {{#link-to 'about' id='self-link'}}Self{{/link-to}}\n        ");

      return _this14;
    }

    var _proto2 = _class2.prototype;

    _proto2.visit = function visit() {
      var _this15 = this;

      return _ApplicationTestCase2.prototype.visit.apply(this, arguments).then(function () {
        _this15.updateCountAfterVisit = _this15.updateCount;
        _this15.replaceCountAfterVisit = _this15.replaceCount;
      });
    };

    _proto2['@test The {{link-to}} component supports URL replacement'] = function testTheLinkToComponentSupportsURLReplacement(assert) {
      var _this16 = this;

      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{#link-to 'about' id='about-link' replace=true}}About{{/link-to}}\n        ");
      return this.visit('/').then(function () {
        return _this16.click('#about-link');
      }).then(function () {
        assert.equal(_this16.updateCount, _this16.updateCountAfterVisit, 'setURL should not be called');
        assert.equal(_this16.replaceCount, _this16.replaceCountAfterVisit + 1, 'replaceURL should be called once');
      });
    };

    _proto2['@test The {{link-to}} component supports URL replacement via replace=boundTruthyThing'] = function testTheLinkToComponentSupportsURLReplacementViaReplaceBoundTruthyThing(assert) {
      var _this17 = this;

      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{#link-to 'about' id='about-link' replace=boundTruthyThing}}About{{/link-to}}\n        ");
      this.add('controller:index', _controller.default.extend({
        boundTruthyThing: true
      }));
      return this.visit('/').then(function () {
        return _this17.click('#about-link');
      }).then(function () {
        assert.equal(_this17.updateCount, _this17.updateCountAfterVisit, 'setURL should not be called');
        assert.equal(_this17.replaceCount, _this17.replaceCountAfterVisit + 1, 'replaceURL should be called once');
      });
    };

    _proto2['@test The {{link-to}} component supports setting replace=boundFalseyThing'] = function testTheLinkToComponentSupportsSettingReplaceBoundFalseyThing(assert) {
      var _this18 = this;

      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{#link-to 'about' id='about-link' replace=boundFalseyThing}}About{{/link-to}}\n        ");
      this.add('controller:index', _controller.default.extend({
        boundFalseyThing: false
      }));
      return this.visit('/').then(function () {
        return _this18.click('#about-link');
      }).then(function () {
        assert.equal(_this18.updateCount, _this18.updateCountAfterVisit + 1, 'setURL should be called');
        assert.equal(_this18.replaceCount, _this18.replaceCountAfterVisit, 'replaceURL should not be called');
      });
    };

    return _class2;
  }(_internalTestHelpers.ApplicationTestCase));

  if (false
  /* EMBER_IMPROVED_INSTRUMENTATION */
  ) {
      (0, _internalTestHelpers.moduleFor)('The {{link-to}} component with EMBER_IMPROVED_INSTRUMENTATION',
      /*#__PURE__*/
      function (_ApplicationTestCase3) {
        (0, _emberBabel.inheritsLoose)(_class3, _ApplicationTestCase3);

        function _class3() {
          var _this19;

          _this19 = _ApplicationTestCase3.call(this) || this;

          _this19.router.map(function () {
            this.route('about');
          });

          _this19.addTemplate('index', "\n          <h3 class=\"home\">Home</h3>\n          {{#link-to 'about' id='about-link'}}About{{/link-to}}\n          {{#link-to 'index' id='self-link'}}Self{{/link-to}}\n          ");

          _this19.addTemplate('about', "\n          <h3 class=\"about\">About</h3>\n          {{#link-to 'index' id='home-link'}}Home{{/link-to}}\n          {{#link-to 'about' id='self-link'}}Self{{/link-to}}\n          ");

          return _this19;
        }

        var _proto3 = _class3.prototype;

        _proto3.beforeEach = function beforeEach() {
          return this.visit('/');
        };

        _proto3.afterEach = function afterEach() {
          (0, _instrumentation.reset)();
          return _ApplicationTestCase3.prototype.afterEach.call(this);
        };

        _proto3['@test The {{link-to}} component fires an interaction event'] = function testTheLinkToComponentFiresAnInteractionEvent(assert) {
          assert.expect(2);
          (0, _instrumentation.subscribe)('interaction.link-to', {
            before: function () {
              assert.ok(true, 'instrumentation subscriber was called');
            },
            after: function () {
              assert.ok(true, 'instrumentation subscriber was called');
            }
          });
          return this.click('#about-link');
        };

        _proto3['@test The {{link-to}} component interaction event includes the route name'] = function testTheLinkToComponentInteractionEventIncludesTheRouteName(assert) {
          assert.expect(2);
          (0, _instrumentation.subscribe)('interaction.link-to', {
            before: function (name, timestamp, _ref) {
              var routeName = _ref.routeName;
              assert.equal(routeName, 'about', 'instrumentation subscriber was passed route name');
            },
            after: function (name, timestamp, _ref2) {
              var routeName = _ref2.routeName;
              assert.equal(routeName, 'about', 'instrumentation subscriber was passed route name');
            }
          });
          return this.click('#about-link');
        };

        _proto3['@test The {{link-to}} component interaction event includes the transition in the after hook'] = function testTheLinkToComponentInteractionEventIncludesTheTransitionInTheAfterHook(assert) {
          assert.expect(1);
          (0, _instrumentation.subscribe)('interaction.link-to', {
            before: function () {},
            after: function (name, timestamp, _ref3) {
              var transition = _ref3.transition;
              assert.equal(transition.targetName, 'about', 'instrumentation subscriber was passed route name');
            }
          });
          return this.click('#about-link');
        };

        return _class3;
      }(_internalTestHelpers.ApplicationTestCase));
    }

  (0, _internalTestHelpers.moduleFor)('The {{link-to}} component - nested routes and link-to arguments',
  /*#__PURE__*/
  function (_ApplicationTestCase4) {
    (0, _emberBabel.inheritsLoose)(_class4, _ApplicationTestCase4);

    function _class4() {
      return _ApplicationTestCase4.apply(this, arguments) || this;
    }

    var _proto4 = _class4.prototype;

    _proto4['@test The {{link-to}} component supports leaving off .index for nested routes'] = function testTheLinkToComponentSupportsLeavingOffIndexForNestedRoutes(assert) {
      var _this20 = this;

      this.router.map(function () {
        this.route('about', function () {
          this.route('item');
        });
      });
      this.addTemplate('about', "<h1>About</h1>{{outlet}}");
      this.addTemplate('about.index', "<div id='index'>Index</div>");
      this.addTemplate('about.item', "<div id='item'>{{#link-to 'about'}}About{{/link-to}}</div>");
      return this.visit('/about/item').then(function () {
        assert.equal(normalizeUrl(_this20.$('#item a').attr('href')), '/about');
      });
    };

    _proto4["@test The {{link-to}} component supports custom, nested, current-when"] = function (assert) {
      var _this21 = this;

      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('item');
      });
      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
      this.addTemplate('index.about', "{{#link-to 'item' id='other-link' current-when='index'}}ITEM{{/link-to}}");
      return this.visit('/about').then(function () {
        assert.equal(_this21.$('#other-link.active').length, 1, 'The link is active since current-when is a parent route');
      });
    };

    _proto4["@test The {{link-to}} component does not disregard current-when when it is given explicitly for a route"] = function (assert) {
      var _this22 = this;

      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('items', function () {
          this.route('item');
        });
      });
      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
      this.addTemplate('index.about', "{{#link-to 'items' id='other-link' current-when='index'}}ITEM{{/link-to}}");
      return this.visit('/about').then(function () {
        assert.equal(_this22.$('#other-link.active').length, 1, 'The link is active when current-when is given for explicitly for a route');
      });
    };

    _proto4['@test The {{link-to}} component does not disregard current-when when it is set via a bound param'] = function testTheLinkToComponentDoesNotDisregardCurrentWhenWhenItIsSetViaABoundParam(assert) {
      var _this23 = this;

      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('items', function () {
          this.route('item');
        });
      });
      this.add('controller:index.about', _controller.default.extend({
        currentWhen: 'index'
      }));
      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
      this.addTemplate('index.about', "{{#link-to 'items' id='other-link' current-when=currentWhen}}ITEM{{/link-to}}");
      return this.visit('/about').then(function () {
        assert.equal(_this23.$('#other-link.active').length, 1, 'The link is active when current-when is given for explicitly for a route');
      });
    };

    _proto4['@test The {{link-to}} component supports multiple current-when routes'] = function testTheLinkToComponentSupportsMultipleCurrentWhenRoutes(assert) {
      var _this24 = this;

      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('item');
        this.route('foo');
      });
      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{outlet}}");
      this.addTemplate('index.about', "{{#link-to 'item' id='link1' current-when='item index'}}ITEM{{/link-to}}");
      this.addTemplate('item', "{{#link-to 'item' id='link2' current-when='item index'}}ITEM{{/link-to}}");
      this.addTemplate('foo', "{{#link-to 'item' id='link3' current-when='item index'}}ITEM{{/link-to}}");
      return this.visit('/about').then(function () {
        assert.equal(_this24.$('#link1.active').length, 1, 'The link is active since current-when contains the parent route');
        return _this24.visit('/item');
      }).then(function () {
        assert.equal(_this24.$('#link2.active').length, 1, 'The link is active since you are on the active route');
        return _this24.visit('/foo');
      }).then(function () {
        assert.equal(_this24.$('#link3.active').length, 0, 'The link is not active since current-when does not contain the active route');
      });
    };

    _proto4['@test The {{link-to}} component supports boolean values for current-when'] = function testTheLinkToComponentSupportsBooleanValuesForCurrentWhen(assert) {
      var _this25 = this;

      this.router.map(function () {
        this.route('index', {
          path: '/'
        }, function () {
          this.route('about');
        });
        this.route('item');
      });
      this.addTemplate('index.about', "\n        {{#link-to 'index' id='index-link' current-when=isCurrent}}index{{/link-to}}\n        {{#link-to 'item' id='about-link' current-when=true}}ITEM{{/link-to}}\n        ");
      this.add('controller:index.about', _controller.default.extend({
        isCurrent: false
      }));
      return this.visit('/about').then(function () {
        assert.ok(_this25.$('#about-link').hasClass('active'), 'The link is active since current-when is true');
        assert.notOk(_this25.$('#index-link').hasClass('active'), 'The link is not active since current-when is false');

        var controller = _this25.applicationInstance.lookup('controller:index.about');

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('isCurrent', true);
        });
        assert.ok(_this25.$('#index-link').hasClass('active'), 'The link is active since current-when is true');
      });
    };

    _proto4['@test The {{link-to}} component defaults to bubbling'] = function testTheLinkToComponentDefaultsToBubbling(assert) {
      var _this26 = this;

      this.addTemplate('about', "\n        <div {{action 'hide'}}>\n          {{#link-to 'about.contact' id='about-contact'}}About{{/link-to}}\n        </div>\n        {{outlet}}\n        ");
      this.addTemplate('about.contact', "<h1 id='contact'>Contact</h1>");
      this.router.map(function () {
        this.route('about', function () {
          this.route('contact');
        });
      });
      var hidden = 0;
      this.add('route:about', _routing.Route.extend({
        actions: {
          hide: function () {
            hidden++;
          }
        }
      }));
      return this.visit('/about').then(function () {
        return _this26.click('#about-contact');
      }).then(function () {
        assert.equal(_this26.$('#contact').text(), 'Contact', 'precond - the link worked');
        assert.equal(hidden, 1, 'The link bubbles');
      });
    };

    _proto4["@test The {{link-to}} component supports bubbles=false"] = function (assert) {
      var _this27 = this;

      this.addTemplate('about', "\n        <div {{action 'hide'}}>\n          {{#link-to 'about.contact' id='about-contact' bubbles=false}}\n            About\n          {{/link-to}}\n        </div>\n        {{outlet}}\n        ");
      this.addTemplate('about.contact', "<h1 id='contact'>Contact</h1>");
      this.router.map(function () {
        this.route('about', function () {
          this.route('contact');
        });
      });
      var hidden = 0;
      this.add('route:about', _routing.Route.extend({
        actions: {
          hide: function () {
            hidden++;
          }
        }
      }));
      return this.visit('/about').then(function () {
        return _this27.click('#about-contact');
      }).then(function () {
        assert.equal(_this27.$('#contact').text(), 'Contact', 'precond - the link worked');
        assert.equal(hidden, 0, "The link didn't bubble");
      });
    };

    _proto4["@test The {{link-to}} component supports bubbles=boundFalseyThing"] = function (assert) {
      var _this28 = this;

      this.addTemplate('about', "\n        <div {{action 'hide'}}>\n          {{#link-to 'about.contact' id='about-contact' bubbles=boundFalseyThing}}\n            About\n          {{/link-to}}\n        </div>\n        {{outlet}}\n        ");
      this.addTemplate('about.contact', "<h1 id='contact'>Contact</h1>");
      this.add('controller:about', _controller.default.extend({
        boundFalseyThing: false
      }));
      this.router.map(function () {
        this.route('about', function () {
          this.route('contact');
        });
      });
      var hidden = 0;
      this.add('route:about', _routing.Route.extend({
        actions: {
          hide: function () {
            hidden++;
          }
        }
      }));
      return this.visit('/about').then(function () {
        return _this28.click('#about-contact');
      }).then(function () {
        assert.equal(_this28.$('#contact').text(), 'Contact', 'precond - the link worked');
        assert.equal(hidden, 0, "The link didn't bubble");
      });
    };

    _proto4["@test The {{link-to}} component moves into the named route with context"] = function (assert) {
      var _this29 = this;

      this.router.map(function () {
        this.route('about');
        this.route('item', {
          path: '/item/:id'
        });
      });
      this.addTemplate('about', "\n        <h3 class=\"list\">List</h3>\n        <ul>\n          {{#each model as |person|}}\n            <li>\n              {{#link-to 'item' person id=person.id}}\n                {{person.name}}\n              {{/link-to}}\n            </li>\n          {{/each}}\n        </ul>\n        {{#link-to 'index' id='home-link'}}Home{{/link-to}}\n        ");
      this.addTemplate('item', "\n        <h3 class=\"item\">Item</h3>\n        <p>{{model.name}}</p>\n        {{#link-to 'index' id='home-link'}}Home{{/link-to}}\n        ");
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{#link-to 'about' id='about-link'}}About{{/link-to}}\n        ");
      this.add('route:about', _routing.Route.extend({
        model: function () {
          return [{
            id: 'yehuda',
            name: 'Yehuda Katz'
          }, {
            id: 'tom',
            name: 'Tom Dale'
          }, {
            id: 'erik',
            name: 'Erik Brynroflsson'
          }];
        }
      }));
      return this.visit('/about').then(function () {
        assert.equal(_this29.$('h3.list').length, 1, 'The home template was rendered');
        assert.equal(normalizeUrl(_this29.$('#home-link').attr('href')), '/', 'The home link points back at /');
        return _this29.click('#yehuda');
      }).then(function () {
        assert.equal(_this29.$('h3.item').length, 1, 'The item template was rendered');
        assert.equal(_this29.$('p').text(), 'Yehuda Katz', 'The name is correct');
        return _this29.click('#home-link');
      }).then(function () {
        return _this29.click('#about-link');
      }).then(function () {
        assert.equal(normalizeUrl(_this29.$('li a#yehuda').attr('href')), '/item/yehuda');
        assert.equal(normalizeUrl(_this29.$('li a#tom').attr('href')), '/item/tom');
        assert.equal(normalizeUrl(_this29.$('li a#erik').attr('href')), '/item/erik');
        return _this29.click('#erik');
      }).then(function () {
        assert.equal(_this29.$('h3.item').length, 1, 'The item template was rendered');
        assert.equal(_this29.$('p').text(), 'Erik Brynroflsson', 'The name is correct');
      });
    };

    _proto4["@test The {{link-to}} component binds some anchor html tag common attributes"] = function (assert) {
      var _this30 = this;

      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{#link-to 'index' id='self-link' title='title-attr' rel='rel-attr' tabindex='-1'}}\n          Self\n        {{/link-to}}\n        ");
      return this.visit('/').then(function () {
        var link = _this30.$('#self-link');

        assert.equal(link.attr('title'), 'title-attr', 'The self-link contains title attribute');
        assert.equal(link.attr('rel'), 'rel-attr', 'The self-link contains rel attribute');
        assert.equal(link.attr('tabindex'), '-1', 'The self-link contains tabindex attribute');
      });
    };

    _proto4["@test The {{link-to}} component supports 'target' attribute"] = function (assert) {
      var _this31 = this;

      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{#link-to 'index' id='self-link' target='_blank'}}Self{{/link-to}}\n        ");
      return this.visit('/').then(function () {
        var link = _this31.$('#self-link');

        assert.equal(link.attr('target'), '_blank', 'The self-link contains `target` attribute');
      });
    };

    _proto4["@test The {{link-to}} component supports 'target' attribute specified as a bound param"] = function (assert) {
      var _this32 = this;

      this.addTemplate('index', "<h3 class=\"home\">Home</h3>{{#link-to 'index' id='self-link' target=boundLinkTarget}}Self{{/link-to}}");
      this.add('controller:index', _controller.default.extend({
        boundLinkTarget: '_blank'
      }));
      return this.visit('/').then(function () {
        var link = _this32.$('#self-link');

        assert.equal(link.attr('target'), '_blank', 'The self-link contains `target` attribute');
      });
    };

    _proto4["@test the {{link-to}} component calls preventDefault"] = function (assert) {
      var _this33 = this;

      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "{{#link-to 'about' id='about-link'}}About{{/link-to}}");
      return this.visit('/').then(function () {
        assertNav({
          prevented: true
        }, function () {
          return _this33.$('#about-link').click();
        }, assert);
      });
    };

    _proto4["@test the {{link-to}} component does not call preventDefault if 'preventDefault=false' is passed as an option"] = function (assert) {
      var _this34 = this;

      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "{{#link-to 'about' id='about-link' preventDefault=false}}About{{/link-to}}");
      return this.visit('/').then(function () {
        assertNav({
          prevented: false
        }, function () {
          return _this34.$('#about-link').trigger('click');
        }, assert);
      });
    };

    _proto4["@test the {{link-to}} component does not call preventDefault if 'preventDefault=boundFalseyThing' is passed as an option"] = function (assert) {
      var _this35 = this;

      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "{{#link-to 'about' id='about-link' preventDefault=boundFalseyThing}}About{{/link-to}}");
      this.add('controller:index', _controller.default.extend({
        boundFalseyThing: false
      }));
      return this.visit('/').then(function () {
        assertNav({
          prevented: false
        }, function () {
          return _this35.$('#about-link').trigger('click');
        }, assert);
      });
    };

    _proto4["@test The {{link-to}} component does not call preventDefault if 'target' attribute is provided"] = function (assert) {
      var _this36 = this;

      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{#link-to 'index' id='self-link' target='_blank'}}Self{{/link-to}}\n        ");
      return this.visit('/').then(function () {
        assertNav({
          prevented: false
        }, function () {
          return _this36.$('#self-link').click();
        }, assert);
      });
    };

    _proto4["@test The {{link-to}} component should preventDefault when 'target = _self'"] = function (assert) {
      var _this37 = this;

      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{#link-to 'index' id='self-link' target='_self'}}Self{{/link-to}}\n        ");
      return this.visit('/').then(function () {
        assertNav({
          prevented: true
        }, function () {
          return _this37.$('#self-link').click();
        }, assert);
      });
    };

    _proto4["@test The {{link-to}} component should not transition if target is not equal to _self or empty"] = function (assert) {
      var _this38 = this;

      this.addTemplate('index', "\n        {{#link-to 'about' id='about-link' replace=true target='_blank'}}\n          About\n        {{/link-to}}\n        ");
      this.router.map(function () {
        this.route('about');
      });
      return this.visit('/').then(function () {
        return _this38.click('#about-link');
      }).then(function () {
        expectDeprecation(function () {
          var currentRouteName = _this38.applicationInstance.lookup('controller:application').get('currentRouteName');

          assert.notEqual(currentRouteName, 'about', 'link-to should not transition if target is not equal to _self or empty');
        }, 'Accessing `currentRouteName` on `controller:application` is deprecated, use the `currentRouteName` property on `service:router` instead.');
      });
    };

    _proto4["@test The {{link-to}} component accepts string/numeric arguments"] = function (assert) {
      var _this39 = this;

      this.router.map(function () {
        this.route('filter', {
          path: '/filters/:filter'
        });
        this.route('post', {
          path: '/post/:post_id'
        });
        this.route('repo', {
          path: '/repo/:owner/:name'
        });
      });
      this.add('controller:filter', _controller.default.extend({
        filter: 'unpopular',
        repo: {
          owner: 'ember',
          name: 'ember.js'
        },
        post_id: 123
      }));
      this.addTemplate('filter', "\n        <p>{{filter}}</p>\n        {{#link-to \"filter\" \"unpopular\" id=\"link\"}}Unpopular{{/link-to}}\n        {{#link-to \"filter\" filter id=\"path-link\"}}Unpopular{{/link-to}}\n        {{#link-to \"post\" post_id id=\"post-path-link\"}}Post{{/link-to}}\n        {{#link-to \"post\" 123 id=\"post-number-link\"}}Post{{/link-to}}\n        {{#link-to \"repo\" repo id=\"repo-object-link\"}}Repo{{/link-to}}\n        ");
      return this.visit('/filters/popular').then(function () {
        assert.equal(normalizeUrl(_this39.$('#link').attr('href')), '/filters/unpopular');
        assert.equal(normalizeUrl(_this39.$('#path-link').attr('href')), '/filters/unpopular');
        assert.equal(normalizeUrl(_this39.$('#post-path-link').attr('href')), '/post/123');
        assert.equal(normalizeUrl(_this39.$('#post-number-link').attr('href')), '/post/123');
        assert.equal(normalizeUrl(_this39.$('#repo-object-link').attr('href')), '/repo/ember/ember.js');
      });
    };

    _proto4["@test Issue 4201 - Shorthand for route.index shouldn't throw errors about context arguments"] = function (assert) {
      var _this40 = this;

      assert.expect(2);
      this.router.map(function () {
        this.route('lobby', function () {
          this.route('index', {
            path: ':lobby_id'
          });
          this.route('list');
        });
      });
      this.add('route:lobby.index', _routing.Route.extend({
        model: function (params) {
          assert.equal(params.lobby_id, 'foobar');
          return params.lobby_id;
        }
      }));
      this.addTemplate('lobby.index', "{{#link-to 'lobby' 'foobar' id='lobby-link'}}Lobby{{/link-to}}");
      this.addTemplate('lobby.list', "{{#link-to 'lobby' 'foobar' id='lobby-link'}}Lobby{{/link-to}}");
      return this.visit('/lobby/list').then(function () {
        return _this40.click('#lobby-link');
      }).then(function () {
        return shouldBeActive(assert, _this40.$('#lobby-link'));
      });
    };

    _proto4["@test Quoteless route param performs property lookup"] = function (assert) {
      var _this41 = this;

      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n        {{#link-to 'index' id='string-link'}}string{{/link-to}}\n        {{#link-to foo id='path-link'}}path{{/link-to}}\n        ");
      this.add('controller:index', _controller.default.extend({
        foo: 'index'
      }));

      var assertEquality = function (href) {
        assert.equal(normalizeUrl(_this41.$('#string-link').attr('href')), '/');
        assert.equal(normalizeUrl(_this41.$('#path-link').attr('href')), href);
      };

      return this.visit('/').then(function () {
        assertEquality('/');

        var controller = _this41.applicationInstance.lookup('controller:index');

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('foo', 'about');
        });
        assertEquality('/about');
      });
    };

    _proto4["@test The {{link-to}} component refreshes href element when one of params changes"] = function (assert) {
      var _this42 = this;

      this.router.map(function () {
        this.route('post', {
          path: '/posts/:post_id'
        });
      });
      var post = {
        id: '1'
      };
      var secondPost = {
        id: '2'
      };
      this.addTemplate('index', "{{#link-to \"post\" post id=\"post\"}}post{{/link-to}}");
      this.add('controller:index', _controller.default.extend());
      return this.visit('/').then(function () {
        var indexController = _this42.applicationInstance.lookup('controller:index');

        (0, _internalTestHelpers.runTask)(function () {
          return indexController.set('post', post);
        });
        assert.equal(normalizeUrl(_this42.$('#post').attr('href')), '/posts/1', 'precond - Link has rendered href attr properly');
        (0, _internalTestHelpers.runTask)(function () {
          return indexController.set('post', secondPost);
        });
        assert.equal(_this42.$('#post').attr('href'), '/posts/2', 'href attr was updated after one of the params had been changed');
        (0, _internalTestHelpers.runTask)(function () {
          return indexController.set('post', null);
        });
        assert.equal(_this42.$('#post').attr('href'), '#', 'href attr becomes # when one of the arguments in nullified');
      });
    };

    _proto4["@test The {{link-to}} component is active when a route is active"] = function (assert) {
      var _this43 = this;

      this.router.map(function () {
        this.route('about', function () {
          this.route('item');
        });
      });
      this.addTemplate('about', "\n        <div id='about'>\n          {{#link-to 'about' id='about-link'}}About{{/link-to}}\n          {{#link-to 'about.item' id='item-link'}}Item{{/link-to}}\n          {{outlet}}\n        </div>\n        ");
      return this.visit('/about').then(function () {
        assert.equal(_this43.$('#about-link.active').length, 1, 'The about route link is active');
        assert.equal(_this43.$('#item-link.active').length, 0, 'The item route link is inactive');
        return _this43.visit('/about/item');
      }).then(function () {
        assert.equal(_this43.$('#about-link.active').length, 1, 'The about route link is active');
        assert.equal(_this43.$('#item-link.active').length, 1, 'The item route link is active');
      });
    };

    _proto4["@test The {{link-to}} component works in an #each'd array of string route names"] = function (assert) {
      var _this44 = this;

      this.router.map(function () {
        this.route('foo');
        this.route('bar');
        this.route('rar');
      });
      this.add('controller:index', _controller.default.extend({
        routeNames: (0, _runtime.A)(['foo', 'bar', 'rar']),
        route1: 'bar',
        route2: 'foo'
      }));
      this.addTemplate('index', "\n        {{#each routeNames as |routeName|}}\n          {{#link-to routeName}}{{routeName}}{{/link-to}}\n        {{/each}}\n        {{#each routeNames as |r|}}\n          {{#link-to r}}{{r}}{{/link-to}}\n        {{/each}}\n        {{#link-to route1}}a{{/link-to}}\n        {{#link-to route2}}b{{/link-to}}\n        ");

      var linksEqual = function (links, expected) {
        assert.equal(links.length, expected.length, 'Has correct number of links');
        var idx;

        for (idx = 0; idx < links.length; idx++) {
          var href = _this44.$(links[idx]).attr('href'); // Old IE includes the whole hostname as well


          assert.equal(href.slice(-expected[idx].length), expected[idx], "Expected link to be '" + expected[idx] + "', but was '" + href + "'");
        }
      };

      return this.visit('/').then(function () {
        linksEqual(_this44.$('a'), ['/foo', '/bar', '/rar', '/foo', '/bar', '/rar', '/bar', '/foo']);

        var indexController = _this44.applicationInstance.lookup('controller:index');

        (0, _internalTestHelpers.runTask)(function () {
          return indexController.set('route1', 'rar');
        });
        linksEqual(_this44.$('a'), ['/foo', '/bar', '/rar', '/foo', '/bar', '/rar', '/rar', '/foo']);
        (0, _internalTestHelpers.runTask)(function () {
          return indexController.routeNames.shiftObject();
        });
        linksEqual(_this44.$('a'), ['/bar', '/rar', '/bar', '/rar', '/rar', '/foo']);
      });
    };

    _proto4["@test The non-block form {{link-to}} component moves into the named route"] = function (assert) {
      var _this45 = this;

      assert.expect(3);
      this.router.map(function () {
        this.route('contact');
      });
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{link-to 'Contact us' 'contact' id='contact-link'}}\n        {{#link-to 'index' id='self-link'}}Self{{/link-to}}\n        ");
      this.addTemplate('contact', "\n        <h3 class=\"contact\">Contact</h3>\n        {{link-to 'Home' 'index' id='home-link'}}\n        {{link-to 'Self' 'contact' id='self-link'}}\n        ");
      return this.visit('/').then(function () {
        return _this45.click('#contact-link');
      }).then(function () {
        assert.equal(_this45.$('h3.contact').length, 1, 'The contact template was rendered');
        assert.equal(_this45.$('#self-link.active').length, 1, 'The self-link was rendered with active class');
        assert.equal(_this45.$('#home-link:not(.active)').length, 1, 'The other link was rendered without active class');
      });
    };

    _proto4["@test The non-block form {{link-to}} component updates the link text when it is a binding"] = function (assert) {
      var _this46 = this;

      assert.expect(8);
      this.router.map(function () {
        this.route('contact');
      });
      this.add('controller:index', _controller.default.extend({
        contactName: 'Jane'
      }));
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{link-to contactName 'contact' id='contact-link'}}\n        {{#link-to 'index' id='self-link'}}Self{{/link-to}}\n        ");
      this.addTemplate('contact', "\n        <h3 class=\"contact\">Contact</h3>\n        {{link-to 'Home' 'index' id='home-link'}}\n        {{link-to 'Self' 'contact' id='self-link'}}\n        ");
      return this.visit('/').then(function () {
        assert.equal(_this46.$('#contact-link').text(), 'Jane', 'The link title is correctly resolved');

        var controller = _this46.applicationInstance.lookup('controller:index');

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('contactName', 'Joe');
        });
        assert.equal(_this46.$('#contact-link').text(), 'Joe', 'The link title is correctly updated when the bound property changes');
        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('contactName', 'Robert');
        });
        assert.equal(_this46.$('#contact-link').text(), 'Robert', 'The link title is correctly updated when the bound property changes a second time');
        return _this46.click('#contact-link');
      }).then(function () {
        assert.equal(_this46.$('h3.contact').length, 1, 'The contact template was rendered');
        assert.equal(_this46.$('#self-link.active').length, 1, 'The self-link was rendered with active class');
        assert.equal(_this46.$('#home-link:not(.active)').length, 1, 'The other link was rendered without active class');
        return _this46.click('#home-link');
      }).then(function () {
        assert.equal(_this46.$('h3.home').length, 1, 'The index template was rendered');
        assert.equal(_this46.$('#contact-link').text(), 'Robert', 'The link title is correctly updated when the route changes');
      });
    };

    _proto4["@test The non-block form {{link-to}} component moves into the named route with context"] = function (assert) {
      var _this47 = this;

      assert.expect(5);
      this.router.map(function () {
        this.route('item', {
          path: '/item/:id'
        });
      });
      this.add('route:index', _routing.Route.extend({
        model: function () {
          return [{
            id: 'yehuda',
            name: 'Yehuda Katz'
          }, {
            id: 'tom',
            name: 'Tom Dale'
          }, {
            id: 'erik',
            name: 'Erik Brynroflsson'
          }];
        }
      }));
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        <ul>\n          {{#each model as |person|}}\n            <li>\n              {{link-to person.name 'item' person id=person.id}}\n            </li>\n          {{/each}}\n        </ul>\n        ");
      this.addTemplate('item', "\n        <h3 class=\"item\">Item</h3>\n        <p>{{model.name}}</p>\n        {{#link-to 'index' id='home-link'}}Home{{/link-to}}\n        ");
      return this.visit('/').then(function () {
        return _this47.click('#yehuda');
      }).then(function () {
        assert.equal(_this47.$('h3.item').length, 1, 'The item template was rendered');
        assert.equal(_this47.$('p').text(), 'Yehuda Katz', 'The name is correct');
        return _this47.click('#home-link');
      }).then(function () {
        assert.equal(normalizeUrl(_this47.$('li a#yehuda').attr('href')), '/item/yehuda');
        assert.equal(normalizeUrl(_this47.$('li a#tom').attr('href')), '/item/tom');
        assert.equal(normalizeUrl(_this47.$('li a#erik').attr('href')), '/item/erik');
      });
    };

    _proto4["@test The non-block form {{link-to}} performs property lookup"] = function (assert) {
      var _this48 = this;

      this.router.map(function () {
        this.route('about');
      });
      this.addTemplate('index', "\n        {{link-to 'string' 'index' id='string-link'}}\n        {{link-to path foo id='path-link'}}\n        ");
      this.add('controller:index', _controller.default.extend({
        foo: 'index'
      }));
      return this.visit('/').then(function () {
        var assertEquality = function (href) {
          assert.equal(normalizeUrl(_this48.$('#string-link').attr('href')), '/');
          assert.equal(normalizeUrl(_this48.$('#path-link').attr('href')), href);
        };

        assertEquality('/');

        var controller = _this48.applicationInstance.lookup('controller:index');

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('foo', 'about');
        });
        assertEquality('/about');
      });
    };

    _proto4["@test The non-block form {{link-to}} protects against XSS"] = function (assert) {
      var _this49 = this;

      this.addTemplate('application', "{{link-to display 'index' id='link'}}");
      this.add('controller:application', _controller.default.extend({
        display: 'blahzorz'
      }));
      return this.visit('/').then(function () {
        assert.equal(_this49.$('#link').text(), 'blahzorz');

        var controller = _this49.applicationInstance.lookup('controller:application');

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('display', '<b>BLAMMO</b>');
        });
        assert.equal(_this49.$('#link').text(), '<b>BLAMMO</b>');
        assert.equal(_this49.$('b').length, 0);
      });
    };

    _proto4["@test the {{link-to}} component throws a useful error if you invoke it wrong"] =
    /*#__PURE__*/
    function () {
      var _ref4 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var _this50;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _this50 = this;
              assert.expect(1);
              this.router.map(function () {
                this.route('post', {
                  path: 'post/:post_id'
                });
              });
              this.addTemplate('application', "{{#link-to 'post'}}Post{{/link-to}}");
              assert.throws(function () {
                return (0, _internalTestHelpers.runTask)(function () {
                  return _this50.visit('/');
                });
              }, /(You attempted to define a `\{\{link-to "post"\}\}` but did not pass the parameters required for generating its dynamic segments.|You must provide param `post_id` to `generate`)/);
              _context.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      return function (_x) {
        return _ref4.apply(this, arguments);
      };
    }();

    _proto4["@test the {{link-to}} component does not throw an error if its route has exited"] = function (assert) {
      var _this51 = this;

      assert.expect(0);
      this.router.map(function () {
        this.route('post', {
          path: 'post/:post_id'
        });
      });
      this.addTemplate('application', "\n        {{#link-to 'index' id='home-link'}}Home{{/link-to}}\n        {{#link-to 'post' defaultPost id='default-post-link'}}Default Post{{/link-to}}\n        {{#if currentPost}}\n          {{#link-to 'post' currentPost id='current-post-link'}}Current Post{{/link-to}}\n        {{/if}}\n        ");
      this.add('controller:application', _controller.default.extend({
        defaultPost: {
          id: 1
        },
        postController: (0, _controller.inject)('post'),
        currentPost: (0, _metal.alias)('postController.model')
      }));
      this.add('controller:post', _controller.default.extend());
      this.add('route:post', _routing.Route.extend({
        model: function () {
          return {
            id: 2
          };
        },
        serialize: function (model) {
          return {
            post_id: model.id
          };
        }
      }));
      return this.visit('/').then(function () {
        return _this51.click('#default-post-link');
      }).then(function () {
        return _this51.click('#home-link');
      }).then(function () {
        return _this51.click('#current-post-link');
      }).then(function () {
        return _this51.click('#home-link');
      });
    };

    _proto4["@test {{link-to}} active property respects changing parent route context"] = function (assert) {
      var _this52 = this;

      this.router.map(function () {
        this.route('things', {
          path: '/things/:name'
        }, function () {
          this.route('other');
        });
      });
      this.addTemplate('application', "\n        {{link-to 'OMG' 'things' 'omg' id='omg-link'}}\n        {{link-to 'LOL' 'things' 'lol' id='lol-link'}}\n        ");
      return this.visit('/things/omg').then(function () {
        shouldBeActive(assert, _this52.$('#omg-link'));
        shouldNotBeActive(assert, _this52.$('#lol-link'));
        return _this52.visit('/things/omg/other');
      }).then(function () {
        shouldBeActive(assert, _this52.$('#omg-link'));
        shouldNotBeActive(assert, _this52.$('#lol-link'));
      });
    };

    _proto4["@test {{link-to}} populates href with default query param values even without query-params object"] = function (assert) {
      var _this53 = this;

      this.add('controller:index', _controller.default.extend({
        queryParams: ['foo'],
        foo: '123'
      }));
      this.addTemplate('index', "{{#link-to 'index' id='the-link'}}Index{{/link-to}}");
      return this.visit('/').then(function () {
        assert.equal(_this53.$('#the-link').attr('href'), '/', 'link has right href');
      });
    };

    _proto4["@test {{link-to}} populates href with default query param values with empty query-params object"] = function (assert) {
      var _this54 = this;

      this.add('controller:index', _controller.default.extend({
        queryParams: ['foo'],
        foo: '123'
      }));
      this.addTemplate('index', "{{#link-to 'index' (query-params) id='the-link'}}Index{{/link-to}}");
      return this.visit('/').then(function () {
        assert.equal(_this54.$('#the-link').attr('href'), '/', 'link has right href');
      });
    };

    _proto4["@test {{link-to}} with only query-params and a block updates when route changes"] = function (assert) {
      var _this55 = this;

      this.router.map(function () {
        this.route('about');
      });
      this.add('controller:application', _controller.default.extend({
        queryParams: ['foo', 'bar'],
        foo: '123',
        bar: 'yes'
      }));
      this.addTemplate('application', "{{#link-to (query-params foo='456' bar='NAW') id='the-link'}}Index{{/link-to}}");
      return this.visit('/').then(function () {
        assert.equal(_this55.$('#the-link').attr('href'), '/?bar=NAW&foo=456', 'link has right href');
        return _this55.visit('/about');
      }).then(function () {
        assert.equal(_this55.$('#the-link').attr('href'), '/about?bar=NAW&foo=456', 'link has right href');
      });
    };

    _proto4["@test Block-less {{link-to}} with only query-params updates when route changes"] = function (assert) {
      var _this56 = this;

      this.router.map(function () {
        this.route('about');
      });
      this.add('controller:application', _controller.default.extend({
        queryParams: ['foo', 'bar'],
        foo: '123',
        bar: 'yes'
      }));
      this.addTemplate('application', "{{link-to \"Index\" (query-params foo='456' bar='NAW') id='the-link'}}");
      return this.visit('/').then(function () {
        assert.equal(_this56.$('#the-link').attr('href'), '/?bar=NAW&foo=456', 'link has right href');
        return _this56.visit('/about');
      }).then(function () {
        assert.equal(_this56.$('#the-link').attr('href'), '/about?bar=NAW&foo=456', 'link has right href');
      });
    };

    _proto4['@test [GH#17018] passing model to link-to with `hash` helper works'] = function testGH17018PassingModelToLinkToWithHashHelperWorks() {
      var _this57 = this;

      this.router.map(function () {
        this.route('post', {
          path: '/posts/:post_id'
        });
      });
      this.add('route:index', _routing.Route.extend({
        model: function () {
          return _runtime.RSVP.hash({
            user: {
              name: 'Papa Smurf'
            }
          });
        }
      }));
      this.addTemplate('index', "{{link-to 'Post' 'post' (hash id=\"someId\" user=this.model.user)}}");
      this.addTemplate('post', 'Post: {{this.model.user.name}}');
      return this.visit('/').then(function () {
        _this57.assertComponentElement(_this57.firstChild, {
          tagName: 'a',
          attrs: {
            href: '/posts/someId'
          },
          content: 'Post'
        });

        return _this57.click('a');
      }).then(function () {
        _this57.assertText('Post: Papa Smurf');
      });
    };

    _proto4["@test The {{link-to}} component can use dynamic params"] = function (assert) {
      var _this58 = this;

      this.router.map(function () {
        this.route('foo', {
          path: 'foo/:some/:thing'
        });
        this.route('bar', {
          path: 'bar/:some/:thing/:else'
        });
      });
      this.add('controller:index', _controller.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.dynamicLinkParams = ['foo', 'one', 'two'];
        }
      }));
      this.addTemplate('index', "\n        <h3 class=\"home\">Home</h3>\n        {{#link-to params=dynamicLinkParams id=\"dynamic-link\"}}Dynamic{{/link-to}}\n        ");
      return this.visit('/').then(function () {
        var link = _this58.$('#dynamic-link');

        assert.equal(link.attr('href'), '/foo/one/two');

        var controller = _this58.applicationInstance.lookup('controller:index');

        (0, _internalTestHelpers.runTask)(function () {
          controller.set('dynamicLinkParams', ['bar', 'one', 'two', 'three']);
        });
        assert.equal(link.attr('href'), '/bar/one/two/three');
      });
    };

    _proto4["@test GJ: {{link-to}} to a parent root model hook which performs a 'transitionTo' has correct active class #13256"] = function (assert) {
      var _this59 = this;

      assert.expect(1);
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });
      this.add('route:parent', _routing.Route.extend({
        afterModel: function () {
          this.transitionTo('parent.child');
        }
      }));
      this.addTemplate('application', "{{link-to 'Parent' 'parent' id='parent-link'}}");
      return this.visit('/').then(function () {
        return _this59.click('#parent-link');
      }).then(function () {
        shouldBeActive(assert, _this59.$('#parent-link'));
      });
    };

    return _class4;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('The {{link-to}} component - loading states and warnings',
  /*#__PURE__*/
  function (_ApplicationTestCase5) {
    (0, _emberBabel.inheritsLoose)(_class5, _ApplicationTestCase5);

    function _class5() {
      return _ApplicationTestCase5.apply(this, arguments) || this;
    }

    var _proto5 = _class5.prototype;

    _proto5["@test {{link-to}} with null/undefined dynamic parameters are put in a loading state"] = function (assert) {
      var _this60 = this;

      assert.expect(19);
      var warningMessage;

      if (true
      /* EMBER_GLIMMER_ANGLE_BRACKET_BUILT_INS */
      ) {
          warningMessage = 'This link is in an inactive loading state because at least one of its models currently has a null/undefined value, or the provided route name is invalid.';
        } else {
        warningMessage = 'This link-to is in an inactive loading state because at least one of its parameters presently has a null/undefined value, or the provided route name is invalid.';
      }

      this.router.map(function () {
        this.route('thing', {
          path: '/thing/:thing_id'
        });
        this.route('about');
      });
      this.addTemplate('index', "\n        {{#link-to destinationRoute routeContext loadingClass='i-am-loading' id='context-link'}}\n          string\n        {{/link-to}}\n        {{#link-to secondRoute loadingClass=loadingClass id='static-link'}}\n          string\n        {{/link-to}}\n        ");
      this.add('controller:index', _controller.default.extend({
        destinationRoute: null,
        routeContext: null,
        loadingClass: 'i-am-loading'
      }));
      this.add('route:about', _routing.Route.extend({
        activate: function () {
          assert.ok(true, 'About was entered');
        }
      }));

      function assertLinkStatus(link, url) {
        if (url) {
          assert.equal(normalizeUrl(link.attr('href')), url, 'loaded link-to has expected href');
          assert.ok(!link.hasClass('i-am-loading'), 'loaded linkComponent has no loadingClass');
        } else {
          assert.equal(normalizeUrl(link.attr('href')), '#', "unloaded link-to has href='#'");
          assert.ok(link.hasClass('i-am-loading'), 'loading linkComponent has loadingClass');
        }
      }

      var contextLink, staticLink, controller;
      return this.visit('/').then(function () {
        contextLink = _this60.$('#context-link');
        staticLink = _this60.$('#static-link');
        controller = _this60.applicationInstance.lookup('controller:index');
        assertLinkStatus(contextLink);
        assertLinkStatus(staticLink);
        return expectWarning(function () {
          return _this60.click(contextLink[0]);
        }, warningMessage);
      }).then(function () {
        // Set the destinationRoute (context is still null).
        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('destinationRoute', 'thing');
        });
        assertLinkStatus(contextLink); // Set the routeContext to an id

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('routeContext', '456');
        });
        assertLinkStatus(contextLink, '/thing/456'); // Test that 0 isn't interpreted as falsy.

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('routeContext', 0);
        });
        assertLinkStatus(contextLink, '/thing/0'); // Set the routeContext to an object

        (0, _internalTestHelpers.runTask)(function () {
          controller.set('routeContext', {
            id: 123
          });
        });
        assertLinkStatus(contextLink, '/thing/123'); // Set the destinationRoute back to null.

        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('destinationRoute', null);
        });
        assertLinkStatus(contextLink);
        return expectWarning(function () {
          return _this60.click(staticLink[0]);
        }, warningMessage);
      }).then(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return controller.set('secondRoute', 'about');
        });
        assertLinkStatus(staticLink, '/about'); // Click the now-active link

        return _this60.click(staticLink[0]);
      });
    };

    return _class5;
  }(_internalTestHelpers.ApplicationTestCase));

  function assertNav(options, callback, assert) {
    var nav = false;

    function check(event) {
      assert.equal(event.defaultPrevented, options.prevented, "expected defaultPrevented=" + options.prevented);
      nav = true;
      event.preventDefault();
    }

    try {
      document.addEventListener('click', check);
      callback();
    } finally {
      document.removeEventListener('click', check);
      assert.ok(nav, 'Expected a link to be clicked');
    }
  }
});
enifed("@ember/-internals/glimmer/tests/integration/components/link-to/transitioning-classes-angle-test", ["ember-babel", "@ember/-internals/runtime", "@ember/-internals/routing", "internal-test-helpers"], function (_emberBabel, _runtime, _routing, _internalTestHelpers) {
  "use strict";

  /* eslint-disable no-inner-declarations */
  // ^^^ remove after unflagging EMBER_GLIMMER_ANGLE_BRACKET_BUILT_INS
  if (true
  /* EMBER_GLIMMER_ANGLE_BRACKET_BUILT_INS */
  ) {
      function assertHasClass(assert, selector, label) {
        var testLabel = selector.attr('id') + " should have class " + label;
        assert.equal(selector.hasClass(label), true, testLabel);
      }

      function assertHasNoClass(assert, selector, label) {
        var testLabel = selector.attr('id') + " should not have class " + label;
        assert.equal(selector.hasClass(label), false, testLabel);
      }

      (0, _internalTestHelpers.moduleFor)('<LinkTo /> component: .transitioning-in .transitioning-out CSS classes',
      /*#__PURE__*/
      function (_ApplicationTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

        function _class() {
          var _this2;

          _this2 = _ApplicationTestCase.call(this) || this;
          _this2.aboutDefer = _runtime.RSVP.defer();
          _this2.otherDefer = _runtime.RSVP.defer();
          _this2.newsDefer = _runtime.RSVP.defer();

          var _this = (0, _emberBabel.assertThisInitialized)(_this2);

          _this2.router.map(function () {
            this.route('about');
            this.route('other');
            this.route('news');
          });

          _this2.add('route:about', _routing.Route.extend({
            model: function () {
              return _this.aboutDefer.promise;
            }
          }));

          _this2.add('route:other', _routing.Route.extend({
            model: function () {
              return _this.otherDefer.promise;
            }
          }));

          _this2.add('route:news', _routing.Route.extend({
            model: function () {
              return _this.newsDefer.promise;
            }
          }));

          _this2.addTemplate('application', "\n          {{outlet}}\n          <LinkTo id='index-link' @route='index'>Index</LinkTo>\n          <LinkTo id='about-link' @route='about'>About</LinkTo>\n          <LinkTo id='other-link' @route='other'>Other</LinkTo>\n          <LinkTo id='news-link' @route='news' @activeClass={{false}}>News</LinkTo>\n          ");

          return _this2;
        }

        var _proto = _class.prototype;

        _proto.beforeEach = function beforeEach() {
          return this.visit('/');
        };

        _proto.afterEach = function afterEach() {
          _ApplicationTestCase.prototype.afterEach.call(this);

          this.aboutDefer = null;
          this.otherDefer = null;
          this.newsDefer = null;
        };

        _proto['@test while a transition is underway'] = function testWhileATransitionIsUnderway(assert) {
          var _this3 = this;

          var $index = this.$('#index-link');
          var $about = this.$('#about-link');
          var $other = this.$('#other-link');
          $about.click();
          assertHasClass(assert, $index, 'active');
          assertHasNoClass(assert, $about, 'active');
          assertHasNoClass(assert, $other, 'active');
          assertHasNoClass(assert, $index, 'ember-transitioning-in');
          assertHasClass(assert, $about, 'ember-transitioning-in');
          assertHasNoClass(assert, $other, 'ember-transitioning-in');
          assertHasClass(assert, $index, 'ember-transitioning-out');
          assertHasNoClass(assert, $about, 'ember-transitioning-out');
          assertHasNoClass(assert, $other, 'ember-transitioning-out');
          (0, _internalTestHelpers.runTask)(function () {
            return _this3.aboutDefer.resolve();
          });
          assertHasNoClass(assert, $index, 'active');
          assertHasClass(assert, $about, 'active');
          assertHasNoClass(assert, $other, 'active');
          assertHasNoClass(assert, $index, 'ember-transitioning-in');
          assertHasNoClass(assert, $about, 'ember-transitioning-in');
          assertHasNoClass(assert, $other, 'ember-transitioning-in');
          assertHasNoClass(assert, $index, 'ember-transitioning-out');
          assertHasNoClass(assert, $about, 'ember-transitioning-out');
          assertHasNoClass(assert, $other, 'ember-transitioning-out');
        };

        _proto['@test while a transition is underway with activeClass is false'] = function testWhileATransitionIsUnderwayWithActiveClassIsFalse(assert) {
          var _this4 = this;

          var $index = this.$('#index-link');
          var $news = this.$('#news-link');
          var $other = this.$('#other-link');
          $news.click();
          assertHasClass(assert, $index, 'active');
          assertHasNoClass(assert, $news, 'active');
          assertHasNoClass(assert, $other, 'active');
          assertHasNoClass(assert, $index, 'ember-transitioning-in');
          assertHasClass(assert, $news, 'ember-transitioning-in');
          assertHasNoClass(assert, $other, 'ember-transitioning-in');
          assertHasClass(assert, $index, 'ember-transitioning-out');
          assertHasNoClass(assert, $news, 'ember-transitioning-out');
          assertHasNoClass(assert, $other, 'ember-transitioning-out');
          (0, _internalTestHelpers.runTask)(function () {
            return _this4.newsDefer.resolve();
          });
          assertHasNoClass(assert, $index, 'active');
          assertHasNoClass(assert, $news, 'active');
          assertHasNoClass(assert, $other, 'active');
          assertHasNoClass(assert, $index, 'ember-transitioning-in');
          assertHasNoClass(assert, $news, 'ember-transitioning-in');
          assertHasNoClass(assert, $other, 'ember-transitioning-in');
          assertHasNoClass(assert, $index, 'ember-transitioning-out');
          assertHasNoClass(assert, $news, 'ember-transitioning-out');
          assertHasNoClass(assert, $other, 'ember-transitioning-out');
        };

        return _class;
      }(_internalTestHelpers.ApplicationTestCase));
      (0, _internalTestHelpers.moduleFor)("<LinkTo /> component: .transitioning-in .transitioning-out CSS classes - nested link-to's",
      /*#__PURE__*/
      function (_ApplicationTestCase2) {
        (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase2);

        function _class2() {
          var _this5;

          _this5 = _ApplicationTestCase2.call(this) || this;
          _this5.aboutDefer = _runtime.RSVP.defer();
          _this5.otherDefer = _runtime.RSVP.defer();

          var _this = (0, _emberBabel.assertThisInitialized)(_this5);

          _this5.router.map(function () {
            this.route('parent-route', function () {
              this.route('about');
              this.route('other');
            });
          });

          _this5.add('route:parent-route.about', _routing.Route.extend({
            model: function () {
              return _this.aboutDefer.promise;
            }
          }));

          _this5.add('route:parent-route.other', _routing.Route.extend({
            model: function () {
              return _this.otherDefer.promise;
            }
          }));

          _this5.addTemplate('application', "\n          {{outlet}}\n          <LinkTo @tagName='li' @route='index'>\n            <LinkTo id='index-link' @route='index'>Index</LinkTo>\n          </LinkTo>\n          <LinkTo @tagName='li' @route='parent-route.about'>\n            <LinkTo id='about-link' @route='parent-route.about'>About</LinkTo>\n          </LinkTo>\n          <LinkTo @tagName='li' @route='parent-route.other'>\n            <LinkTo id='other-link' @route='parent-route.other'>Other</LinkTo>\n          </LinkTo>\n          ");

          return _this5;
        }

        var _proto2 = _class2.prototype;

        _proto2.beforeEach = function beforeEach() {
          return this.visit('/');
        };

        _proto2.resolveAbout = function resolveAbout() {
          var _this6 = this;

          return (0, _internalTestHelpers.runTask)(function () {
            _this6.aboutDefer.resolve();

            _this6.aboutDefer = _runtime.RSVP.defer();
          });
        };

        _proto2.resolveOther = function resolveOther() {
          var _this7 = this;

          return (0, _internalTestHelpers.runTask)(function () {
            _this7.otherDefer.resolve();

            _this7.otherDefer = _runtime.RSVP.defer();
          });
        };

        _proto2.teardown = function teardown() {
          _ApplicationTestCase2.prototype.teardown.call(this);

          this.aboutDefer = null;
          this.otherDefer = null;
        };

        _proto2["@test while a transition is underway with nested link-to's"] = function (assert) {
          // TODO undo changes to this test but currently this test navigates away if navigation
          // outlet is not stable and the second $about.click() is triggered.
          var $about = this.$('#about-link');
          $about.click();
          var $index = this.$('#index-link');
          $about = this.$('#about-link');
          var $other = this.$('#other-link');
          assertHasClass(assert, $index, 'active');
          assertHasNoClass(assert, $about, 'active');
          assertHasNoClass(assert, $about, 'active');
          assertHasNoClass(assert, $index, 'ember-transitioning-in');
          assertHasClass(assert, $about, 'ember-transitioning-in');
          assertHasNoClass(assert, $other, 'ember-transitioning-in');
          assertHasClass(assert, $index, 'ember-transitioning-out');
          assertHasNoClass(assert, $about, 'ember-transitioning-out');
          assertHasNoClass(assert, $other, 'ember-transitioning-out');
          this.resolveAbout();
          $index = this.$('#index-link');
          $about = this.$('#about-link');
          $other = this.$('#other-link');
          assertHasNoClass(assert, $index, 'active');
          assertHasClass(assert, $about, 'active');
          assertHasNoClass(assert, $other, 'active');
          assertHasNoClass(assert, $index, 'ember-transitioning-in');
          assertHasNoClass(assert, $about, 'ember-transitioning-in');
          assertHasNoClass(assert, $other, 'ember-transitioning-in');
          assertHasNoClass(assert, $index, 'ember-transitioning-out');
          assertHasNoClass(assert, $about, 'ember-transitioning-out');
          assertHasNoClass(assert, $other, 'ember-transitioning-out');
          $other.click();
          $index = this.$('#index-link');
          $about = this.$('#about-link');
          $other = this.$('#other-link');
          assertHasNoClass(assert, $index, 'active');
          assertHasClass(assert, $about, 'active');
          assertHasNoClass(assert, $other, 'active');
          assertHasNoClass(assert, $index, 'ember-transitioning-in');
          assertHasNoClass(assert, $about, 'ember-transitioning-in');
          assertHasClass(assert, $other, 'ember-transitioning-in');
          assertHasNoClass(assert, $index, 'ember-transitioning-out');
          assertHasClass(assert, $about, 'ember-transitioning-out');
          assertHasNoClass(assert, $other, 'ember-transitioning-out');
          this.resolveOther();
          $index = this.$('#index-link');
          $about = this.$('#about-link');
          $other = this.$('#other-link');
          assertHasNoClass(assert, $index, 'active');
          assertHasNoClass(assert, $about, 'active');
          assertHasClass(assert, $other, 'active');
          assertHasNoClass(assert, $index, 'ember-transitioning-in');
          assertHasNoClass(assert, $about, 'ember-transitioning-in');
          assertHasNoClass(assert, $other, 'ember-transitioning-in');
          assertHasNoClass(assert, $index, 'ember-transitioning-out');
          assertHasNoClass(assert, $about, 'ember-transitioning-out');
          assertHasNoClass(assert, $other, 'ember-transitioning-out');
          $about.click();
          $index = this.$('#index-link');
          $about = this.$('#about-link');
          $other = this.$('#other-link');
          assertHasNoClass(assert, $index, 'active');
          assertHasNoClass(assert, $about, 'active');
          assertHasClass(assert, $other, 'active');
          assertHasNoClass(assert, $index, 'ember-transitioning-in');
          assertHasClass(assert, $about, 'ember-transitioning-in');
          assertHasNoClass(assert, $other, 'ember-transitioning-in');
          assertHasNoClass(assert, $index, 'ember-transitioning-out');
          assertHasNoClass(assert, $about, 'ember-transitioning-out');
          assertHasClass(assert, $other, 'ember-transitioning-out');
          this.resolveAbout();
          $index = this.$('#index-link');
          $about = this.$('#about-link');
          $other = this.$('#other-link');
          assertHasNoClass(assert, $index, 'active');
          assertHasClass(assert, $about, 'active');
          assertHasNoClass(assert, $other, 'active');
          assertHasNoClass(assert, $index, 'ember-transitioning-in');
          assertHasNoClass(assert, $about, 'ember-transitioning-in');
          assertHasNoClass(assert, $other, 'ember-transitioning-in');
          assertHasNoClass(assert, $index, 'ember-transitioning-out');
          assertHasNoClass(assert, $about, 'ember-transitioning-out');
          assertHasNoClass(assert, $other, 'ember-transitioning-out');
        };

        return _class2;
      }(_internalTestHelpers.ApplicationTestCase));
    }
});
enifed("@ember/-internals/glimmer/tests/integration/components/link-to/transitioning-classes-curly-test", ["ember-babel", "@ember/-internals/runtime", "@ember/-internals/routing", "internal-test-helpers"], function (_emberBabel, _runtime, _routing, _internalTestHelpers) {
  "use strict";

  function assertHasClass(assert, selector, label) {
    var testLabel = selector.attr('id') + " should have class " + label;
    assert.equal(selector.hasClass(label), true, testLabel);
  }

  function assertHasNoClass(assert, selector, label) {
    var testLabel = selector.attr('id') + " should not have class " + label;
    assert.equal(selector.hasClass(label), false, testLabel);
  }

  (0, _internalTestHelpers.moduleFor)('{{link-to}} component: .transitioning-in .transitioning-out CSS classes',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this2;

      _this2 = _ApplicationTestCase.call(this) || this;
      _this2.aboutDefer = _runtime.RSVP.defer();
      _this2.otherDefer = _runtime.RSVP.defer();
      _this2.newsDefer = _runtime.RSVP.defer();

      var _this = (0, _emberBabel.assertThisInitialized)(_this2);

      _this2.router.map(function () {
        this.route('about');
        this.route('other');
        this.route('news');
      });

      _this2.add('route:about', _routing.Route.extend({
        model: function () {
          return _this.aboutDefer.promise;
        }
      }));

      _this2.add('route:other', _routing.Route.extend({
        model: function () {
          return _this.otherDefer.promise;
        }
      }));

      _this2.add('route:news', _routing.Route.extend({
        model: function () {
          return _this.newsDefer.promise;
        }
      }));

      _this2.addTemplate('application', "\n        {{outlet}}\n        {{link-to 'Index' 'index' id='index-link'}}\n        {{link-to 'About' 'about' id='about-link'}}\n        {{link-to 'Other' 'other' id='other-link'}}\n        {{link-to 'News' 'news' activeClass=false id='news-link'}}\n        ");

      return _this2;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      return this.visit('/');
    };

    _proto.afterEach = function afterEach() {
      _ApplicationTestCase.prototype.afterEach.call(this);

      this.aboutDefer = null;
      this.otherDefer = null;
      this.newsDefer = null;
    };

    _proto['@test while a transition is underway'] = function testWhileATransitionIsUnderway(assert) {
      var _this3 = this;

      var $index = this.$('#index-link');
      var $about = this.$('#about-link');
      var $other = this.$('#other-link');
      $about.click();
      assertHasClass(assert, $index, 'active');
      assertHasNoClass(assert, $about, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.aboutDefer.resolve();
      });
      assertHasNoClass(assert, $index, 'active');
      assertHasClass(assert, $about, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasNoClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
    };

    _proto['@test while a transition is underway with activeClass is false'] = function testWhileATransitionIsUnderwayWithActiveClassIsFalse(assert) {
      var _this4 = this;

      var $index = this.$('#index-link');
      var $news = this.$('#news-link');
      var $other = this.$('#other-link');
      $news.click();
      assertHasClass(assert, $index, 'active');
      assertHasNoClass(assert, $news, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasClass(assert, $news, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $news, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.newsDefer.resolve();
      });
      assertHasNoClass(assert, $index, 'active');
      assertHasNoClass(assert, $news, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasNoClass(assert, $news, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $news, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)("{{link-to}} component: .transitioning-in .transitioning-out CSS classes - nested link-to's",
  /*#__PURE__*/
  function (_ApplicationTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase2);

    function _class2() {
      var _this5;

      _this5 = _ApplicationTestCase2.call(this) || this;
      _this5.aboutDefer = _runtime.RSVP.defer();
      _this5.otherDefer = _runtime.RSVP.defer();

      var _this = (0, _emberBabel.assertThisInitialized)(_this5);

      _this5.router.map(function () {
        this.route('parent-route', function () {
          this.route('about');
          this.route('other');
        });
      });

      _this5.add('route:parent-route.about', _routing.Route.extend({
        model: function () {
          return _this.aboutDefer.promise;
        }
      }));

      _this5.add('route:parent-route.other', _routing.Route.extend({
        model: function () {
          return _this.otherDefer.promise;
        }
      }));

      _this5.addTemplate('application', "\n        {{outlet}}\n        {{#link-to 'index' tagName='li'}}\n          {{link-to 'Index' 'index' id='index-link'}}\n        {{/link-to}}\n        {{#link-to 'parent-route.about' tagName='li'}}\n          {{link-to 'About' 'parent-route.about' id='about-link'}}\n        {{/link-to}}\n        {{#link-to 'parent-route.other' tagName='li'}}\n          {{link-to 'Other' 'parent-route.other' id='other-link'}}\n        {{/link-to}}\n        ");

      return _this5;
    }

    var _proto2 = _class2.prototype;

    _proto2.beforeEach = function beforeEach() {
      return this.visit('/');
    };

    _proto2.resolveAbout = function resolveAbout() {
      var _this6 = this;

      return (0, _internalTestHelpers.runTask)(function () {
        _this6.aboutDefer.resolve();

        _this6.aboutDefer = _runtime.RSVP.defer();
      });
    };

    _proto2.resolveOther = function resolveOther() {
      var _this7 = this;

      return (0, _internalTestHelpers.runTask)(function () {
        _this7.otherDefer.resolve();

        _this7.otherDefer = _runtime.RSVP.defer();
      });
    };

    _proto2.teardown = function teardown() {
      _ApplicationTestCase2.prototype.teardown.call(this);

      this.aboutDefer = null;
      this.otherDefer = null;
    };

    _proto2["@test while a transition is underway with nested link-to's"] = function (assert) {
      // TODO undo changes to this test but currently this test navigates away if navigation
      // outlet is not stable and the second $about.click() is triggered.
      var $about = this.$('#about-link');
      $about.click();
      var $index = this.$('#index-link');
      $about = this.$('#about-link');
      var $other = this.$('#other-link');
      assertHasClass(assert, $index, 'active');
      assertHasNoClass(assert, $about, 'active');
      assertHasNoClass(assert, $about, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
      this.resolveAbout();
      $index = this.$('#index-link');
      $about = this.$('#about-link');
      $other = this.$('#other-link');
      assertHasNoClass(assert, $index, 'active');
      assertHasClass(assert, $about, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasNoClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
      $other.click();
      $index = this.$('#index-link');
      $about = this.$('#about-link');
      $other = this.$('#other-link');
      assertHasNoClass(assert, $index, 'active');
      assertHasClass(assert, $about, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasNoClass(assert, $about, 'ember-transitioning-in');
      assertHasClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
      this.resolveOther();
      $index = this.$('#index-link');
      $about = this.$('#about-link');
      $other = this.$('#other-link');
      assertHasNoClass(assert, $index, 'active');
      assertHasNoClass(assert, $about, 'active');
      assertHasClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasNoClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
      $about.click();
      $index = this.$('#index-link');
      $about = this.$('#about-link');
      $other = this.$('#other-link');
      assertHasNoClass(assert, $index, 'active');
      assertHasNoClass(assert, $about, 'active');
      assertHasClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasClass(assert, $other, 'ember-transitioning-out');
      this.resolveAbout();
      $index = this.$('#index-link');
      $about = this.$('#about-link');
      $other = this.$('#other-link');
      assertHasNoClass(assert, $index, 'active');
      assertHasClass(assert, $about, 'active');
      assertHasNoClass(assert, $other, 'active');
      assertHasNoClass(assert, $index, 'ember-transitioning-in');
      assertHasNoClass(assert, $about, 'ember-transitioning-in');
      assertHasNoClass(assert, $other, 'ember-transitioning-in');
      assertHasNoClass(assert, $index, 'ember-transitioning-out');
      assertHasNoClass(assert, $about, 'ember-transitioning-out');
      assertHasNoClass(assert, $other, 'ember-transitioning-out');
    };

    return _class2;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/components/local-lookup-test", ["ember-babel", "internal-test-helpers", "ember-template-compiler", "@ember/-internals/glimmer", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _emberTemplateCompiler, _glimmer, _helpers) {
  "use strict";

  var LocalLookupTest =
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(LocalLookupTest, _RenderingTestCase);

    function LocalLookupTest() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = LocalLookupTest.prototype;

    _proto['@test it can lookup a local template'] = function testItCanLookupALocalTemplate() {
      var _this = this;

      this.registerComponent('x-outer/x-inner', {
        template: 'Nested template says: {{yield}}'
      });
      this.registerComponent('x-outer', {
        template: '{{#x-inner}}Hi!{{/x-inner}}'
      });
      this.render('{{x-outer}}');
      this.assertText('Nested template says: Hi!', 'Initial render works');
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertText('Nested template says: Hi!', 'Re-render works');
    };

    _proto['@test tagless blockless component can lookup local template'] = function testTaglessBlocklessComponentCanLookupLocalTemplate() {
      var _this2 = this;

      this.registerComponent('x-outer/x-inner', {
        template: 'Nested template says: {{yield}}'
      });
      this.registerTemplate('components/x-outer', '{{#x-inner}}Hi!{{/x-inner}}');
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        })
      });
      this.render('{{x-outer}}');
      this.assertText('Nested template says: Hi!', 'Re-render works');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertText('Nested template says: Hi!', 'Re-render works');
    };

    _proto['@test it can lookup a local component template'] = function testItCanLookupALocalComponentTemplate() {
      var _this3 = this;

      this.registerTemplate('components/x-outer/x-inner', 'Nested template says: {{yield}}');
      this.registerTemplate('components/x-outer', '{{#x-inner}}Hi!{{/x-inner}}');
      this.render('{{x-outer}}');
      this.assertText('Nested template says: Hi!', 'Initial render works');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assertText('Nested template says: Hi!', 'Re-render works');
    };

    _proto['@test it can local lookup a dynamic component'] = function testItCanLocalLookupADynamicComponent() {
      var _this4 = this;

      this.registerComponent('foo-bar', {
        template: 'yall finished {{component child}}'
      });
      this.registerComponent('foo-bar/biz-baz', {
        template: 'or yall done?'
      });
      this.render('{{foo-bar child=child}}', {
        child: 'biz-baz'
      });
      this.assertText('yall finished or yall done?');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      this.assertText('yall finished or yall done?');
    };

    _proto['@test it can local lookup a dynamic component from a dynamic component'] = function testItCanLocalLookupADynamicComponentFromADynamicComponent() {
      var _this5 = this;

      this.registerComponent('foo-bar', {
        template: 'yall finished {{component child}}'
      });
      this.registerComponent('foo-bar/biz-baz', {
        template: 'or yall done?'
      });
      this.render('{{component componentName child=child}}', {
        componentName: 'foo-bar',
        child: 'biz-baz'
      });
      this.assertText('yall finished or yall done?');
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.rerender();
      });
      this.assertText('yall finished or yall done?');
    };

    _proto['@test it can local lookup a dynamic component from a passed named argument'] = function testItCanLocalLookupADynamicComponentFromAPassedNamedArgument() {
      var _this6 = this;

      this.registerComponent('parent-foo', {
        template: "yall finished {{global-biz baz=(component 'local-bar')}}"
      });
      this.registerComponent('global-biz', {
        template: 'or {{component baz}}'
      });
      this.registerComponent('parent-foo/local-bar', {
        template: 'yall done?'
      });
      this.render('{{parent-foo}}');
      this.assertText('yall finished or yall done?');
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.rerender();
      });
      this.assertText('yall finished or yall done?');
    };

    _proto['@test it can local lookup a re-wrapped dynamic component from a passed named argument'] = function testItCanLocalLookupAReWrappedDynamicComponentFromAPassedNamedArgument() {
      var _this7 = this;

      this.registerComponent('parent-foo', {
        template: "yall finished {{global-x comp=(component 'local-bar')}}"
      });
      this.registerComponent('global-x', {
        template: "or {{global-y comp=(component comp phrase='done')}}"
      });
      this.registerComponent('global-y', {
        template: "{{component comp}}?"
      });
      this.registerComponent('parent-foo/local-bar', {
        template: 'yall {{phrase}}'
      });
      this.render('{{parent-foo}}');
      this.assertText('yall finished or yall done?');
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.rerender();
      });
      this.assertText('yall finished or yall done?');
    };

    _proto['@test it can nest local lookups of dynamic components from a passed named argument'] = function testItCanNestLocalLookupsOfDynamicComponentsFromAPassedNamedArgument() {
      var _this8 = this;

      this.registerComponent('parent-foo', {
        template: "yall finished {{global-x comp=(component 'local-bar')}}"
      });
      this.registerComponent('global-x', {
        template: "or {{global-y comp=(component comp phrase='done')}}"
      });
      this.registerComponent('global-y', {
        template: "{{component comp}}{{component 'local-bar'}}"
      });
      this.registerComponent('parent-foo/local-bar', {
        template: 'yall {{phrase}}'
      });
      this.registerComponent('global-y/local-bar', {
        template: "?"
      });
      this.render('{{parent-foo}}');
      this.assertText('yall finished or yall done?');
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.rerender();
      });
      this.assertText('yall finished or yall done?');
    };

    _proto['@test it can switch from local to global lookups of dynamic components from a passed named argument'] = function testItCanSwitchFromLocalToGlobalLookupsOfDynamicComponentsFromAPassedNamedArgument() {
      var _this9 = this;

      this.registerComponent('parent-foo', {
        template: "yall finished {{global-x comp=(component bar)}}"
      });
      this.registerComponent('global-x', {
        template: "or yall {{component comp}}"
      });
      this.registerComponent('parent-foo/local-bar', {
        template: 'done?'
      });
      this.registerComponent('global-bar', {
        template: "ready?"
      });
      this.render('{{parent-foo bar=bar}}', {
        bar: 'local-bar'
      });
      this.assertText('yall finished or yall done?');
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.context.set('bar', 'global-bar');
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.rerender();
      });
      this.assertText('yall finished or yall ready?');
    };

    _proto['@test it can lookup a local helper'] = function testItCanLookupALocalHelper() {
      var _this10 = this;

      this.registerHelper('x-outer/x-helper', function () {
        return 'Who dis?';
      });
      this.registerComponent('x-outer', {
        template: 'Who dat? {{x-helper}}'
      });
      this.render('{{x-outer}}');
      this.assertText('Who dat? Who dis?', 'Initial render works');
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.rerender();
      });
      this.assertText('Who dat? Who dis?', 'Re-render works');
    };

    _proto['@test it overrides global helper lookup'] = function testItOverridesGlobalHelperLookup() {
      var _this11 = this;

      this.registerHelper('x-outer/x-helper', function () {
        return 'Who dis?';
      });
      this.registerHelper('x-helper', function () {
        return 'I dunno';
      });
      this.registerComponent('x-outer', {
        template: 'Who dat? {{x-helper}}'
      });
      this.render('{{x-outer}} {{x-helper}}');
      this.assertText('Who dat? Who dis? I dunno', 'Initial render works');
      (0, _internalTestHelpers.runTask)(function () {
        return _this11.rerender();
      });
      this.assertText('Who dat? Who dis? I dunno', 'Re-render works');
    };

    _proto['@test lookup without match issues standard assertion (with local helper name)'] = function testLookupWithoutMatchIssuesStandardAssertionWithLocalHelperName() {
      var _this12 = this;

      this.registerComponent('x-outer', {
        template: '{{#x-inner}}Hi!{{/x-inner}}'
      });
      expectAssertion(function () {
        _this12.render('{{x-outer}}');
      }, /A component or helper named "x-inner" could not be found/);
    };

    _proto['@test overrides global lookup'] = function testOverridesGlobalLookup() {
      var _this13 = this;

      this.registerComponent('x-outer', {
        template: '{{#x-inner}}Hi!{{/x-inner}}'
      });
      this.registerComponent('x-outer/x-inner', {
        template: 'Nested template says (from local): {{yield}}'
      });
      this.registerComponent('x-inner', {
        template: 'Nested template says (from global): {{yield}}'
      });
      this.render('{{#x-inner}}Hi!{{/x-inner}} {{x-outer}} {{#x-outer/x-inner}}Hi!{{/x-outer/x-inner}}');
      this.assertText('Nested template says (from global): Hi! Nested template says (from local): Hi! Nested template says (from local): Hi!');
      (0, _internalTestHelpers.runTask)(function () {
        return _this13.rerender();
      });
      this.assertText('Nested template says (from global): Hi! Nested template says (from local): Hi! Nested template says (from local): Hi!');
    };

    return LocalLookupTest;
  }(_internalTestHelpers.RenderingTestCase); // first run these tests with expandLocalLookup


  function buildResolver() {
    var resolver = {
      resolve: function () {},
      expandLocalLookup: function (fullName, sourceFullName) {
        if (!sourceFullName) {
          return null;
        }

        var _sourceFullName$split = sourceFullName.split(':'),
            sourceType = _sourceFullName$split[0],
            sourceName = _sourceFullName$split[1];

        var _fullName$split = fullName.split(':'),
            type = _fullName$split[0],
            name = _fullName$split[1];

        sourceName = sourceName.replace('my-app/', '');

        if (sourceType === 'template' && sourceName.slice(0, 21) === 'templates/components/') {
          sourceName = sourceName.slice(21);
        }

        name = name.replace('my-app/', '');

        if (type === 'template' && name.slice(0, 11) === 'components/') {
          name = name.slice(11);
          sourceName = "components/" + sourceName;
        }

        sourceName = sourceName.replace('.hbs', '');
        var result = type + ":" + sourceName + "/" + name;
        return result;
      }
    };
    return resolver;
  }

  (0, _internalTestHelpers.moduleFor)('Components test: local lookup with expandLocalLookup feature',
  /*#__PURE__*/
  function (_LocalLookupTest) {
    (0, _emberBabel.inheritsLoose)(_class, _LocalLookupTest);

    function _class() {
      return _LocalLookupTest.apply(this, arguments) || this;
    }

    var _proto2 = _class.prototype;

    _proto2.getResolver = function getResolver() {
      return buildResolver();
    };

    return _class;
  }(LocalLookupTest));

  if (false
  /* EMBER_MODULE_UNIFICATION */
  ) {
      var LocalLookupTestResolver =
      /*#__PURE__*/
      function (_ModuleBasedTestResol) {
        (0, _emberBabel.inheritsLoose)(LocalLookupTestResolver, _ModuleBasedTestResol);

        function LocalLookupTestResolver() {
          return _ModuleBasedTestResol.apply(this, arguments) || this;
        }

        var _proto3 = LocalLookupTestResolver.prototype;

        _proto3.expandLocalLookup = function expandLocalLookup(specifier, source) {
          if (source && source.indexOf('components/') !== -1) {
            var namespace = source.split('components/')[1];

            var _specifier$split = specifier.split(':'),
                type = _specifier$split[0],
                name = _specifier$split[1];

            name = name.replace('components/', '');
            namespace = namespace.replace('.hbs', '');
            return type + ":" + (type === 'template' ? 'components/' : '') + namespace + "/" + name;
          }

          return _ModuleBasedTestResol.prototype.expandLocalLookup.call(this, specifier, source);
        };

        return LocalLookupTestResolver;
      }(_internalTestHelpers.ModuleBasedTestResolver);
      /*
       * This sub-classing changes `registerXXX` methods to use the resolver.
       * Required for testing the module unification-friendly `resolve` call
       * with a `referrer` argument.
       *
       * In theory all these tests can be ported to use the resolver instead of
       * the registry.
       */


      (0, _internalTestHelpers.moduleFor)('Components test: local lookup with resolution referrer',
      /*#__PURE__*/
      function (_LocalLookupTest2) {
        (0, _emberBabel.inheritsLoose)(_class2, _LocalLookupTest2);

        function _class2() {
          return _LocalLookupTest2.apply(this, arguments) || this;
        }

        var _proto4 = _class2.prototype;

        _proto4.getResolver = function getResolver() {
          return new LocalLookupTestResolver();
        };

        _proto4.registerComponent = function registerComponent(name, _ref) {
          var _ref$ComponentClass = _ref.ComponentClass,
              ComponentClass = _ref$ComponentClass === void 0 ? _helpers.Component : _ref$ComponentClass,
              _ref$template = _ref.template,
              template = _ref$template === void 0 ? null : _ref$template;
          var resolver = this.resolver;

          if (ComponentClass) {
            resolver.add("component:" + name, ComponentClass);
          }

          if (typeof template === 'string') {
            resolver.add("template:components/" + name, this.compile(template, {
              moduleName: "my-name/templates/components/" + name + ".hbs"
            }));
          }
        };

        _proto4.registerTemplate = function registerTemplate(name, template) {
          var resolver = this.resolver;

          if (typeof template === 'string') {
            resolver.add("template:" + name, this.compile(template, {
              moduleName: "my-name/templates/" + name + ".hbs"
            }));
          } else {
            throw new Error("Registered template \"" + name + "\" must be a string");
          }
        };

        _proto4.registerHelper = function registerHelper(name, funcOrClassBody) {
          var resolver = this.resolver;
          var type = typeof funcOrClassBody;

          if (type === 'function') {
            resolver.add("helper:" + name, (0, _glimmer.helper)(funcOrClassBody));
          } else if (type === 'object' && type !== null) {
            resolver.add("helper:" + name, _glimmer.Helper.extend(funcOrClassBody));
          } else {
            throw new Error("Cannot register " + funcOrClassBody + " as a helper");
          }
        };

        (0, _emberBabel.createClass)(_class2, [{
          key: "resolver",
          get: function () {
            return this.owner.__registry__.fallback.resolver;
          }
        }]);
        return _class2;
      }(LocalLookupTest));
    }

  if (false
  /* EMBER_MODULE_UNIFICATION */
  ) {
      (0, _internalTestHelpers.moduleFor)('Components test: local lookup with resolution referrer (MU)',
      /*#__PURE__*/
      function (_ApplicationTestCase) {
        (0, _emberBabel.inheritsLoose)(_class3, _ApplicationTestCase);

        function _class3() {
          return _ApplicationTestCase.apply(this, arguments) || this;
        }

        var _proto5 = _class3.prototype;

        _proto5['@test Ensure that the same specifier with two sources does not share a cache key'] = function testEnsureThatTheSameSpecifierWithTwoSourcesDoesNotShareACacheKey(assert) {
          var _this14 = this;

          this.add({
            specifier: 'template:components/x-not-shared',
            source: 'template:my-app/templates/components/x-top.hbs'
          }, (0, _emberTemplateCompiler.compile)('child-x-not-shared'));
          this.add({
            specifier: 'template:components/x-top',
            source: 'template:my-app/templates/application.hbs'
          }, (0, _emberTemplateCompiler.compile)('top-level-x-top ({{x-not-shared}})', {
            moduleName: 'my-app/templates/components/x-top.hbs'
          }));
          this.add({
            specifier: 'template:components/x-not-shared',
            source: 'template:my-app/templates/application.hbs'
          }, (0, _emberTemplateCompiler.compile)('top-level-x-not-shared'));
          this.addTemplate('application', '{{x-not-shared}} {{x-top}} {{x-not-shared}} {{x-top}}');
          return this.visit('/').then(function () {
            assert.equal(_this14.element.textContent, 'top-level-x-not-shared top-level-x-top (child-x-not-shared) top-level-x-not-shared top-level-x-top (child-x-not-shared)');
          });
        };

        return _class3;
      }(_internalTestHelpers.ApplicationTestCase));
    }
});
enifed("@ember/-internals/glimmer/tests/integration/components/namespaced-lookup-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/glimmer"], function (_emberBabel, _internalTestHelpers, _glimmer) {
  "use strict";

  if (false
  /* EMBER_MODULE_UNIFICATION */
  ) {
      (0, _internalTestHelpers.moduleFor)('Namespaced lookup',
      /*#__PURE__*/
      function (_RenderingTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

        function _class() {
          return _RenderingTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto['@test it can render a namespaced component'] = function testItCanRenderANamespacedComponent() {
          var _this = this;

          this.addTemplate({
            specifier: 'template:components/my-component',
            namespace: 'my-addon'
          }, 'namespaced template {{myProp}}');
          this.add({
            specifier: 'component:my-component',
            namespace: 'my-addon'
          }, _glimmer.Component.extend({
            myProp: 'My property'
          }));
          this.addComponent('x-outer', {
            template: '{{my-addon::my-component}}'
          });
          this.render('{{x-outer}}');
          this.assertText('namespaced template My property');
          (0, _internalTestHelpers.runTask)(function () {
            return _this.rerender();
          });
          this.assertText('namespaced template My property');
        };

        _proto['@test it can render a nested namespaced component'] = function testItCanRenderANestedNamespacedComponent() {
          var _this2 = this;

          this.addTemplate({
            specifier: 'template:components/my-component',
            namespace: 'second-addon'
          }, 'second namespaced template');
          this.addTemplate({
            specifier: 'template:components/my-component',
            namespace: 'first-addon'
          }, 'first namespaced template - {{second-addon::my-component}}');
          this.addComponent('x-outer', {
            template: '{{first-addon::my-component}}'
          });
          this.render('{{x-outer}}');
          this.assertText('first namespaced template - second namespaced template');
          (0, _internalTestHelpers.runTask)(function () {
            return _this2.rerender();
          });
          this.assertText('first namespaced template - second namespaced template');
        };

        _proto['@test it can render a nested un-namespaced component'] = function testItCanRenderANestedUnNamespacedComponent() {
          var _this3 = this;

          this.addTemplate({
            specifier: 'template:components/addon-component',
            source: 'template:first-addon/src/ui/components/my-component.hbs'
          }, 'un-namespaced addon template');
          this.addTemplate({
            specifier: 'template:components/my-component',
            moduleName: 'first-addon/src/ui/components/my-component.hbs',
            namespace: 'first-addon'
          }, '{{addon-component}}');
          this.addComponent('x-outer', {
            template: '{{first-addon::my-component}}'
          });
          this.render('{{x-outer}}');
          this.assertText('un-namespaced addon template');
          (0, _internalTestHelpers.runTask)(function () {
            return _this3.rerender();
          });
          this.assertText('un-namespaced addon template');
        };

        _proto['@test it can render a namespaced main component'] = function testItCanRenderANamespacedMainComponent() {
          var _this4 = this;

          this.addTemplate({
            specifier: 'template:components/addon-component',
            soruce: 'template:first-addon/src/ui/components/main.hbs'
          }, 'Nested namespaced component');
          this.addTemplate({
            specifier: 'template:components/first-addon',
            moduleName: 'first-addon/src/ui/components/main.hbs'
          }, '{{addon-component}}');
          this.addComponent('x-outer', {
            template: '{{first-addon}}'
          });
          this.render('{{x-outer}}');
          this.assertText('Nested namespaced component');
          (0, _internalTestHelpers.runTask)(function () {
            return _this4.rerender();
          });
          this.assertText('Nested namespaced component');
        };

        _proto['@test it does not render a main component when using a namespace'] = function testItDoesNotRenderAMainComponentWhenUsingANamespace() {
          var _this5 = this;

          this.addTemplate({
            specifier: 'template:components/main',
            namespace: 'my-addon'
          }, 'namespaced template {{myProp}}');
          this.add({
            specifier: 'component:main',
            namespace: 'my-addon'
          }, _glimmer.Component.extend({
            myProp: 'My property'
          }));
          this.add({
            specifier: 'helper:my-addon',
            namespace: 'empty-namespace'
          }, (0, _glimmer.helper)(function () {
            return 'my helper';
          }));
          this.render('{{empty-namespace::my-addon}}');
          this.assertText('my helper'); // component should be not found

          (0, _internalTestHelpers.runTask)(function () {
            return _this5.rerender();
          });
          this.assertText('my helper');
        };

        _proto['@test it renders a namespaced helper'] = function testItRendersANamespacedHelper() {
          var _this6 = this;

          this.add({
            specifier: 'helper:my-helper',
            namespace: 'my-namespace'
          }, (0, _glimmer.helper)(function () {
            return 'my helper';
          }));
          this.render('{{my-namespace::my-helper}}');
          this.assertText('my helper');
          (0, _internalTestHelpers.runTask)(function () {
            return _this6.rerender();
          });
          this.assertText('my helper');
        };

        return _class;
      }(_internalTestHelpers.RenderingTestCase));
    }
});
enifed("@ember/-internals/glimmer/tests/integration/components/render-to-element-test", [], function () {
  "use strict";
});
enifed("@ember/-internals/glimmer/tests/integration/components/target-action-test", ["ember-babel", "internal-test-helpers", "@ember/polyfills", "@ember/-internals/metal", "@ember/controller", "@ember/-internals/runtime", "@ember/-internals/routing", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _polyfills, _metal, _controller, _runtime, _routing, _helpers) {
  "use strict";

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#component-a}}\n          {{component-b bar=\"derp\"}}\n        {{/component-a}}\n      "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  function expectSendActionDeprecation(fn) {
    expectDeprecation(fn, /You called (.*).sendAction\((.*)\) but Component#sendAction is deprecated. Please use closure actions instead./);
  }

  (0, _internalTestHelpers.moduleFor)('Components test: sendAction',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      var _this;

      _this = _RenderingTestCase.apply(this, arguments) || this;
      _this.actionCounts = {};
      _this.sendCount = 0;
      _this.actionArguments = null;
      var self = (0, _emberBabel.assertThisInitialized)(_this);

      _this.registerComponent('action-delegate', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super();

            self.delegate = this;
            this.name = 'action-delegate';
          }
        })
      });

      return _this;
    }

    var _proto = _class.prototype;

    _proto.renderDelegate = function renderDelegate() {
      var template = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '{{action-delegate}}';
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var root = this;
      context = (0, _polyfills.assign)(context, {
        send: function (actionName) {
          root.sendCount++;
          root.actionCounts[actionName] = root.actionCounts[actionName] || 0;
          root.actionCounts[actionName]++;

          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          root.actionArguments = args;
        }
      });
      this.render(template, context);
    };

    _proto.assertSendCount = function assertSendCount(count) {
      this.assert.equal(this.sendCount, count, "Send was called " + count + " time(s)");
    };

    _proto.assertNamedSendCount = function assertNamedSendCount(actionName, count) {
      this.assert.equal(this.actionCounts[actionName], count, "An action named '" + actionName + "' was sent " + count + " times");
    };

    _proto.assertSentWithArgs = function assertSentWithArgs(expected) {
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'arguments were sent with the action';
      this.assert.deepEqual(this.actionArguments, expected, message);
    };

    _proto['@test Calling sendAction on a component without an action defined does nothing'] = function testCallingSendActionOnAComponentWithoutAnActionDefinedDoesNothing() {
      var _this2 = this;

      this.renderDelegate();
      expectSendActionDeprecation(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this2.delegate.sendAction();
        });
      });
      this.assertSendCount(0);
    };

    _proto['@test Calling sendAction on a component with an action defined calls send on the controller'] = function testCallingSendActionOnAComponentWithAnActionDefinedCallsSendOnTheController() {
      var _this3 = this;

      this.renderDelegate();
      expectSendActionDeprecation(function () {
        (0, _internalTestHelpers.runTask)(function () {
          (0, _metal.set)(_this3.delegate, 'action', 'addItem');

          _this3.delegate.sendAction();
        });
      });
      this.assertSendCount(1);
      this.assertNamedSendCount('addItem', 1);
    };

    _proto['@test Calling sendAction on a component with a function calls the function'] = function testCallingSendActionOnAComponentWithAFunctionCallsTheFunction() {
      var _this4 = this;

      this.assert.expect(2);
      this.renderDelegate();
      expectSendActionDeprecation(function () {
        (0, _internalTestHelpers.runTask)(function () {
          (0, _metal.set)(_this4.delegate, 'action', function () {
            return _this4.assert.ok(true, 'function is called');
          });

          _this4.delegate.sendAction();
        });
      });
    };

    _proto['@test Calling sendAction on a component with a function calls the function with arguments'] = function testCallingSendActionOnAComponentWithAFunctionCallsTheFunctionWithArguments() {
      var _this5 = this;

      this.assert.expect(2);
      var argument = {};
      this.renderDelegate();
      expectSendActionDeprecation(function () {
        (0, _internalTestHelpers.runTask)(function () {
          (0, _metal.set)(_this5.delegate, 'action', function (actualArgument) {
            _this5.assert.deepEqual(argument, actualArgument, 'argument is passed');
          });

          _this5.delegate.sendAction('action', argument);
        });
      });
    } // TODO consolidate these next 2 tests
    ;

    _proto['@test Calling sendAction on a component with a reference attr calls the function with arguments'] = function testCallingSendActionOnAComponentWithAReferenceAttrCallsTheFunctionWithArguments() {
      var _this6 = this;

      this.renderDelegate('{{action-delegate playing=playing}}', {
        playing: null
      });
      expectSendActionDeprecation(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this6.delegate.sendAction();
        });
      });
      this.assertSendCount(0);
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this6.context, 'playing', 'didStartPlaying');
      });
      expectSendActionDeprecation(function () {
        (0, _internalTestHelpers.runTask)(function () {
          _this6.delegate.sendAction('playing');
        });
      });
      this.assertSendCount(1);
      this.assertNamedSendCount('didStartPlaying', 1);
    };

    _proto['@test Calling sendAction on a component with a {{mut}} attr calls the function with arguments'] = function testCallingSendActionOnAComponentWithAMutAttrCallsTheFunctionWithArguments() {
      var _this7 = this;

      this.renderDelegate('{{action-delegate playing=(mut playing)}}', {
        playing: null
      });
      expectSendActionDeprecation(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this7.delegate.sendAction('playing');
        });
      });
      this.assertSendCount(0);
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.delegate.attrs.playing.update('didStartPlaying');
      });
      expectSendActionDeprecation(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this7.delegate.sendAction('playing');
        });
      });
      this.assertSendCount(1);
      this.assertNamedSendCount('didStartPlaying', 1);
    };

    _proto["@test Calling sendAction with a named action uses the component's property as the action name"] = function testCallingSendActionWithANamedActionUsesTheComponentSPropertyAsTheActionName() {
      var _this8 = this;

      this.renderDelegate();
      var component = this.delegate;
      expectSendActionDeprecation(function () {
        (0, _internalTestHelpers.runTask)(function () {
          (0, _metal.set)(_this8.delegate, 'playing', 'didStartPlaying');
          component.sendAction('playing');
        });
      });
      this.assertSendCount(1);
      this.assertNamedSendCount('didStartPlaying', 1);
      expectSendActionDeprecation(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return component.sendAction('playing');
        });
      });
      this.assertSendCount(2);
      this.assertNamedSendCount('didStartPlaying', 2);
      expectSendActionDeprecation(function () {
        (0, _internalTestHelpers.runTask)(function () {
          (0, _metal.set)(component, 'action', 'didDoSomeBusiness');
          component.sendAction();
        });
      });
      this.assertSendCount(3);
      this.assertNamedSendCount('didDoSomeBusiness', 1);
    };

    _proto['@test Calling sendAction when the action name is not a string raises an exception'] = function testCallingSendActionWhenTheActionNameIsNotAStringRaisesAnException() {
      var _this9 = this;

      this.renderDelegate();
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this9.delegate, 'action', {});
        (0, _metal.set)(_this9.delegate, 'playing', {});
      });
      expectSendActionDeprecation(function () {
        expectAssertion(function () {
          return _this9.delegate.sendAction();
        });
      });
      expectSendActionDeprecation(function () {
        expectAssertion(function () {
          return _this9.delegate.sendAction('playing');
        });
      });
    };

    _proto['@test Calling sendAction on a component with contexts'] = function testCallingSendActionOnAComponentWithContexts() {
      var _this10 = this;

      this.renderDelegate();
      var testContext = {
        song: 'She Broke My Ember'
      };
      var firstContext = {
        song: 'She Broke My Ember'
      };
      var secondContext = {
        song: 'My Achey Breaky Ember'
      };
      expectSendActionDeprecation(function () {
        (0, _internalTestHelpers.runTask)(function () {
          (0, _metal.set)(_this10.delegate, 'playing', 'didStartPlaying');

          _this10.delegate.sendAction('playing', testContext);
        });
      });
      this.assertSendCount(1);
      this.assertNamedSendCount('didStartPlaying', 1);
      this.assertSentWithArgs([testContext], 'context was sent with the action');
      expectSendActionDeprecation(function () {
        (0, _internalTestHelpers.runTask)(function () {
          _this10.delegate.sendAction('playing', firstContext, secondContext);
        });
      });
      this.assertSendCount(2);
      this.assertNamedSendCount('didStartPlaying', 2);
      this.assertSentWithArgs([firstContext, secondContext], 'multiple contexts were sent to the action');
    };

    _proto['@test calling sendAction on a component within a block sends to the outer scope GH#14216'] = function testCallingSendActionOnAComponentWithinABlockSendsToTheOuterScopeGH14216(assert) {
      var testContext = this; // overrides default action-delegate so actions can be added

      this.registerComponent('action-delegate', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super();

            testContext.delegate = this;
            this.name = 'action-delegate';
          },
          actions: {
            derp: function (arg1) {
              assert.ok(true, 'action called on action-delgate');
              assert.equal(arg1, 'something special', 'argument passed through properly');
            }
          }
        }),
        template: (0, _internalTestHelpers.strip)(_templateObject())
      });
      this.registerComponent('component-a', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            this.name = 'component-a';
          },
          actions: {
            derp: function () {
              assert.ok(false, 'no! bad scoping!');
            }
          }
        })
      });
      var innerChild;
      this.registerComponent('component-b', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            innerChild = this;
            this.name = 'component-b';
          }
        })
      });
      this.renderDelegate();
      expectSendActionDeprecation(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return innerChild.sendAction('bar', 'something special');
        });
      });
    };

    _proto['@test asserts if called on a destroyed component'] = function testAssertsIfCalledOnADestroyedComponent() {
      var _this11 = this;

      var component;
      this.registerComponent('rip-alley', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super();

            component = this;
          },
          toString: function () {
            return 'component:rip-alley';
          }
        })
      });
      this.render('{{#if shouldRender}}{{rip-alley}}{{/if}}', {
        shouldRender: true
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this11.context, 'shouldRender', false);
      });
      expectAssertion(function () {
        component.sendAction('trigger-me-dead');
      }, "Attempted to call .sendAction() with the action 'trigger-me-dead' on the destroyed object 'component:rip-alley'.");
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
  (0, _internalTestHelpers.moduleFor)('Components test: sendAction to a controller',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase);

    function _class2() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2["@test sendAction should trigger an action on the parent component's controller if it exists"] = function testSendActionShouldTriggerAnActionOnTheParentComponentSControllerIfItExists(assert) {
      var _this12 = this;

      assert.expect(20);
      var component;
      this.router.map(function () {
        this.route('a');
        this.route('b');
        this.route('c', function () {
          this.route('d');
          this.route('e');
        });
      });
      this.addComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            component = this;
          }
        }),
        template: "{{val}}"
      });
      this.add('controller:a', _controller.default.extend({
        send: function (actionName, actionContext) {
          assert.equal(actionName, 'poke', 'send() method was invoked from a top level controller');
          assert.equal(actionContext, 'top', 'action arguments were passed into the top level controller');
        }
      }));
      this.addTemplate('a', '{{foo-bar val="a" poke="poke"}}');
      this.add('route:b', _routing.Route.extend({
        actions: {
          poke: function (actionContext) {
            assert.ok(true, 'Unhandled action sent to route');
            assert.equal(actionContext, 'top no controller');
          }
        }
      }));
      this.addTemplate('b', '{{foo-bar val="b" poke="poke"}}');
      this.add('route:c', _routing.Route.extend({
        actions: {
          poke: function (actionContext) {
            assert.ok(true, 'Unhandled action sent to route');
            assert.equal(actionContext, 'top with nested no controller');
          }
        }
      }));
      this.addTemplate('c', '{{foo-bar val="c" poke="poke"}}{{outlet}}');
      this.add('route:c.d', _routing.Route.extend({}));
      this.add('controller:c.d', _controller.default.extend({
        send: function (actionName, actionContext) {
          assert.equal(actionName, 'poke', 'send() method was invoked from a nested controller');
          assert.equal(actionContext, 'nested', 'action arguments were passed into the nested controller');
        }
      }));
      this.addTemplate('c.d', '{{foo-bar val=".d" poke="poke"}}');
      this.add('route:c.e', _routing.Route.extend({
        actions: {
          poke: function (actionContext) {
            assert.ok(true, 'Unhandled action sent to route');
            assert.equal(actionContext, 'nested no controller');
          }
        }
      }));
      this.addTemplate('c.e', '{{foo-bar val=".e" poke="poke"}}');
      return this.visit('/a').then(function () {
        expectSendActionDeprecation(function () {
          return component.sendAction('poke', 'top');
        });
      }).then(function () {
        _this12.assertText('a');

        return _this12.visit('/b');
      }).then(function () {
        expectSendActionDeprecation(function () {
          return component.sendAction('poke', 'top no controller');
        });
      }).then(function () {
        _this12.assertText('b');

        return _this12.visit('/c');
      }).then(function () {
        expectSendActionDeprecation(function () {
          component.sendAction('poke', 'top with nested no controller');
        });
      }).then(function () {
        _this12.assertText('c');

        return _this12.visit('/c/d');
      }).then(function () {
        expectSendActionDeprecation(function () {
          return component.sendAction('poke', 'nested');
        });
      }).then(function () {
        _this12.assertText('c.d');

        return _this12.visit('/c/e');
      }).then(function () {
        expectSendActionDeprecation(function () {
          return component.sendAction('poke', 'nested no controller');
        });
      }).then(function () {
        return _this12.assertText('c.e');
      });
    };

    _proto2["@test sendAction should not trigger an action in an outlet's controller if a parent component handles it"] = function testSendActionShouldNotTriggerAnActionInAnOutletSControllerIfAParentComponentHandlesIt(assert) {
      assert.expect(2);
      var component;
      this.addComponent('x-parent', {
        ComponentClass: _helpers.Component.extend({
          actions: {
            poke: function () {
              assert.ok(true, 'parent component handled the aciton');
            }
          }
        }),
        template: '{{x-child poke="poke"}}'
      });
      this.addComponent('x-child', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            component = this;
          }
        })
      });
      this.addTemplate('application', '{{x-parent}}');
      this.add('controller:application', _controller.default.extend({
        send: function () {
          throw new Error('controller action should not be called');
        }
      }));
      return this.visit('/').then(function () {
        expectSendActionDeprecation(function () {
          return component.sendAction('poke');
        });
      });
    };

    return _class2;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Components test: sendAction of a closure action',
  /*#__PURE__*/
  function (_RenderingTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class3, _RenderingTestCase2);

    function _class3() {
      return _RenderingTestCase2.apply(this, arguments) || this;
    }

    var _proto3 = _class3.prototype;

    _proto3['@test action should be called'] = function testActionShouldBeCalled(assert) {
      assert.expect(2);
      var component;
      this.registerComponent('inner-component', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            component = this;
          }
        }),
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: _helpers.Component.extend({
          outerSubmit: function () {
            assert.ok(true, 'outerSubmit called');
          }
        }),
        template: '{{inner-component submitAction=(action outerSubmit)}}'
      });
      this.render('{{outer-component}}');
      expectSendActionDeprecation(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return component.sendAction('submitAction');
        });
      });
    };

    _proto3['@test contexts passed to sendAction are appended to the bound arguments on a closure action'] = function testContextsPassedToSendActionAreAppendedToTheBoundArgumentsOnAClosureAction() {
      var first = 'mitch';
      var second = 'martin';
      var third = 'matt';
      var fourth = 'wacky wycats';
      var innerComponent;
      var actualArgs;
      this.registerComponent('inner-component', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            innerComponent = this;
          }
        }),
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: _helpers.Component.extend({
          third: third,
          actions: {
            outerSubmit: function () {
              actualArgs = Array.prototype.slice.call(arguments);
            }
          }
        }),
        template: "{{inner-component innerSubmit=(action (action \"outerSubmit\" \"" + first + "\") \"" + second + "\" third)}}"
      });
      this.render('{{outer-component}}');
      expectSendActionDeprecation(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return innerComponent.sendAction('innerSubmit', fourth);
        });
      });
      this.assert.deepEqual(actualArgs, [first, second, third, fourth], 'action has the correct args');
    };

    return _class3;
  }(_internalTestHelpers.RenderingTestCase));
  (0, _internalTestHelpers.moduleFor)('Components test: send',
  /*#__PURE__*/
  function (_RenderingTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class4, _RenderingTestCase3);

    function _class4() {
      return _RenderingTestCase3.apply(this, arguments) || this;
    }

    var _proto4 = _class4.prototype;

    _proto4['@test sending to undefined actions triggers an error'] = function testSendingToUndefinedActionsTriggersAnError(assert) {
      assert.expect(2);
      var component;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super();

            component = this;
          },
          actions: {
            foo: function (message) {
              assert.equal('bar', message);
            }
          }
        })
      });
      this.render('{{foo-bar}}');
      (0, _internalTestHelpers.runTask)(function () {
        return component.send('foo', 'bar');
      });
      expectAssertion(function () {
        return component.send('baz', 'bar');
      }, /had no action handler for: baz/);
    };

    _proto4['@test `send` will call send from a target if it is defined'] = function testSendWillCallSendFromATargetIfItIsDefined() {
      var _this13 = this;

      var component;
      var target = {
        send: function (message, payload) {
          _this13.assert.equal('foo', message);

          _this13.assert.equal('baz', payload);
        }
      };
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super();

            component = this;
          },
          target: target
        })
      });
      this.render('{{foo-bar}}');
      (0, _internalTestHelpers.runTask)(function () {
        return component.send('foo', 'baz');
      });
    };

    _proto4['@test a handled action can be bubbled to the target for continued processing'] = function testAHandledActionCanBeBubbledToTheTargetForContinuedProcessing() {
      var _this14 = this;

      this.assert.expect(2);
      var component;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            component = this;
          },
          actions: {
            poke: function () {
              _this14.assert.ok(true, 'component action called');

              return true;
            }
          },
          target: _controller.default.extend({
            actions: {
              poke: function () {
                _this14.assert.ok(true, 'action bubbled to controller');
              }
            }
          }).create()
        })
      });
      this.render('{{foo-bar poke="poke"}}');
      (0, _internalTestHelpers.runTask)(function () {
        return component.send('poke');
      });
    };

    _proto4["@test action can be handled by a superclass' actions object"] = function testActionCanBeHandledByASuperclassActionsObject(assert) {
      this.assert.expect(4);
      var component;

      var SuperComponent = _helpers.Component.extend({
        actions: {
          foo: function () {
            assert.ok(true, 'foo');
          },
          bar: function (msg) {
            assert.equal(msg, 'HELLO');
          }
        }
      });

      var BarViewMixin = _metal.Mixin.create({
        actions: {
          bar: function (msg) {
            assert.equal(msg, 'HELLO');

            this._super(msg);
          }
        }
      });

      this.registerComponent('x-index', {
        ComponentClass: SuperComponent.extend(BarViewMixin, {
          init: function () {
            this._super.apply(this, arguments);

            component = this;
          },
          actions: {
            baz: function () {
              assert.ok(true, 'baz');
            }
          }
        })
      });
      this.render('{{x-index}}');
      (0, _internalTestHelpers.runTask)(function () {
        component.send('foo');
        component.send('bar', 'HELLO');
        component.send('baz');
      });
    };

    _proto4['@test actions cannot be provided at create time'] = function testActionsCannotBeProvidedAtCreateTime(assert) {
      this.registerComponent('foo-bar', _helpers.Component.extend());
      var ComponentFactory = this.owner.factoryFor('component:foo-bar');
      expectAssertion(function () {
        ComponentFactory.create({
          actions: {
            foo: function () {
              assert.ok(true, 'foo');
            }
          }
        });
      }, /`actions` must be provided at extend time, not at create time/); // but should be OK on an object that doesn't mix in Ember.ActionHandler

      _runtime.Object.create({
        actions: ['foo']
      });
    };

    _proto4['@test asserts if called on a destroyed component'] = function testAssertsIfCalledOnADestroyedComponent() {
      var _this15 = this;

      var component;
      this.registerComponent('rip-alley', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super();

            component = this;
          },
          toString: function () {
            return 'component:rip-alley';
          }
        })
      });
      this.render('{{#if shouldRender}}{{rip-alley}}{{/if}}', {
        shouldRender: true
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this15.context, 'shouldRender', false);
      });
      expectAssertion(function () {
        component.send('trigger-me-dead');
      }, "Attempted to call .send() with the action 'trigger-me-dead' on the destroyed object 'component:rip-alley'.");
    };

    return _class4;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/components/template-only-components-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/environment"], function (_emberBabel, _internalTestHelpers, _environment) {
  "use strict";

  var TemplateOnlyComponentsTest =
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(TemplateOnlyComponentsTest, _RenderingTestCase);

    function TemplateOnlyComponentsTest() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = TemplateOnlyComponentsTest.prototype;

    _proto.registerComponent = function registerComponent(name, template) {
      _RenderingTestCase.prototype.registerComponent.call(this, name, {
        template: template,
        ComponentClass: null
      });
    };

    return TemplateOnlyComponentsTest;
  }(_internalTestHelpers.RenderingTestCase);

  (0, _internalTestHelpers.moduleFor)('Components test: template-only components (glimmer components)',
  /*#__PURE__*/
  function (_TemplateOnlyComponen) {
    (0, _emberBabel.inheritsLoose)(_class, _TemplateOnlyComponen);

    function _class() {
      var _this;

      _this = _TemplateOnlyComponen.apply(this, arguments) || this;
      _this._TEMPLATE_ONLY_GLIMMER_COMPONENTS = _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS;
      _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = true;
      return _this;
    }

    var _proto2 = _class.prototype;

    _proto2.teardown = function teardown() {
      _TemplateOnlyComponen.prototype.teardown.call(this);

      _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = this._TEMPLATE_ONLY_GLIMMER_COMPONENTS;
    };

    _proto2['@test it can render a template-only component'] = function testItCanRenderATemplateOnlyComponent() {
      this.registerComponent('foo-bar', 'hello');
      this.render('{{foo-bar}}');
      this.assertInnerHTML('hello');
      this.assertStableRerender();
    };

    _proto2['@test it can render named arguments'] = function testItCanRenderNamedArguments() {
      var _this2 = this;

      this.registerComponent('foo-bar', '|{{@foo}}|{{@bar}}|');
      this.render('{{foo-bar foo=foo bar=bar}}', {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertInnerHTML('|foo|bar|');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.context.set('foo', 'FOO');
      });
      this.assertInnerHTML('|FOO|bar|');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.context.set('bar', 'BAR');
      });
      this.assertInnerHTML('|FOO|BAR|');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.context.setProperties({
          foo: 'foo',
          bar: 'bar'
        });
      });
      this.assertInnerHTML('|foo|bar|');
    };

    _proto2['@test it does not reflected arguments as properties'] = function testItDoesNotReflectedArgumentsAsProperties() {
      var _this3 = this;

      this.registerComponent('foo-bar', '|{{foo}}|{{this.bar}}|');
      this.render('{{foo-bar foo=foo bar=bar}}', {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertInnerHTML('|||');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.context.set('foo', 'FOO');
      });
      this.assertInnerHTML('|||');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.context.set('bar', null);
      });
      this.assertInnerHTML('|||');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.context.setProperties({
          foo: 'foo',
          bar: 'bar'
        });
      });
      this.assertInnerHTML('|||');
    };

    _proto2['@test it does not have curly component features'] = function testItDoesNotHaveCurlyComponentFeatures() {
      var _this4 = this;

      this.registerComponent('foo-bar', 'hello');
      this.render('{{foo-bar tagName="p" class=class}}', {
        class: 'foo bar'
      });
      this.assertInnerHTML('hello');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.context.set('class', 'foo');
      });
      this.assertInnerHTML('hello');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.context.set('class', null);
      });
      this.assertInnerHTML('hello');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.context.set('class', 'foo bar');
      });
      this.assertInnerHTML('hello');
    };

    _proto2['@test it has the correct bounds'] = function testItHasTheCorrectBounds() {
      var _this5 = this;

      this.registerComponent('foo-bar', 'hello');
      this.render('outside {{#if this.isShowing}}before {{foo-bar}} after{{/if}} outside', {
        isShowing: true
      });
      this.assertInnerHTML('outside before hello after outside');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.context.set('isShowing', false);
      });
      this.assertInnerHTML('outside <!----> outside');
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.context.set('isShowing', null);
      });
      this.assertInnerHTML('outside <!----> outside');
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.context.set('isShowing', true);
      });
      this.assertInnerHTML('outside before hello after outside');
    };

    return _class;
  }(TemplateOnlyComponentsTest));
  (0, _internalTestHelpers.moduleFor)('Components test: template-only components (curly components)',
  /*#__PURE__*/
  function (_TemplateOnlyComponen2) {
    (0, _emberBabel.inheritsLoose)(_class2, _TemplateOnlyComponen2);

    function _class2() {
      var _this6;

      _this6 = _TemplateOnlyComponen2.apply(this, arguments) || this;
      _this6._TEMPLATE_ONLY_GLIMMER_COMPONENTS = _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS;
      _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = false;
      return _this6;
    }

    var _proto3 = _class2.prototype;

    _proto3.teardown = function teardown() {
      _TemplateOnlyComponen2.prototype.teardown.call(this);

      _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = this._TEMPLATE_ONLY_GLIMMER_COMPONENTS;
    };

    _proto3['@test it can render a template-only component'] = function testItCanRenderATemplateOnlyComponent() {
      this.registerComponent('foo-bar', 'hello');
      this.render('{{foo-bar}}');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      this.assertStableRerender();
    };

    _proto3['@test it can render named arguments'] = function testItCanRenderNamedArguments() {
      var _this7 = this;

      this.registerComponent('foo-bar', '|{{@foo}}|{{@bar}}|');
      this.render('{{foo-bar foo=foo bar=bar}}', {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertComponentElement(this.firstChild, {
        content: '|foo|bar|'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.context.set('foo', 'FOO');
      });
      this.assertComponentElement(this.firstChild, {
        content: '|FOO|bar|'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.context.set('bar', 'BAR');
      });
      this.assertComponentElement(this.firstChild, {
        content: '|FOO|BAR|'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.context.setProperties({
          foo: 'foo',
          bar: 'bar'
        });
      });
      this.assertComponentElement(this.firstChild, {
        content: '|foo|bar|'
      });
    };

    _proto3['@test it renders named arguments as reflected properties'] = function testItRendersNamedArgumentsAsReflectedProperties() {
      var _this8 = this;

      this.registerComponent('foo-bar', '|{{foo}}|{{this.bar}}|');
      this.render('{{foo-bar foo=foo bar=bar}}', {
        foo: 'foo',
        bar: 'bar'
      });
      this.assertComponentElement(this.firstChild, {
        content: '|foo|bar|'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.context.set('foo', 'FOO');
      });
      this.assertComponentElement(this.firstChild, {
        content: '|FOO|bar|'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.context.set('bar', null);
      });
      this.assertComponentElement(this.firstChild, {
        content: '|FOO||'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.context.setProperties({
          foo: 'foo',
          bar: 'bar'
        });
      });
      this.assertComponentElement(this.firstChild, {
        content: '|foo|bar|'
      });
    };

    _proto3['@test it has curly component features'] = function testItHasCurlyComponentFeatures() {
      var _this9 = this;

      this.registerComponent('foo-bar', 'hello');
      this.render('{{foo-bar tagName="p" class=class}}', {
        class: 'foo bar'
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'p',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar ember-view')
        },
        content: 'hello'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.context.set('class', 'foo');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'p',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo ember-view')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.context.set('class', null);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'p',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        },
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.context.set('class', 'foo bar');
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'p',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar ember-view')
        },
        content: 'hello'
      });
    };

    return _class2;
  }(TemplateOnlyComponentsTest));
});
enifed("@ember/-internals/glimmer/tests/integration/components/textarea-angle-test", ["ember-babel", "internal-test-helpers", "@ember/polyfills", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _polyfills, _metal) {
  "use strict";

  if (true
  /* EMBER_GLIMMER_ANGLE_BRACKET_BUILT_INS */
  ) {
      var TextAreaRenderingTest =
      /*#__PURE__*/
      function (_RenderingTestCase) {
        (0, _emberBabel.inheritsLoose)(TextAreaRenderingTest, _RenderingTestCase);

        function TextAreaRenderingTest() {
          return _RenderingTestCase.apply(this, arguments) || this;
        }

        var _proto = TextAreaRenderingTest.prototype;

        _proto.assertTextArea = function assertTextArea() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              attrs = _ref.attrs,
              value = _ref.value;

          var mergedAttrs = (0, _polyfills.assign)({
            class: (0, _internalTestHelpers.classes)('ember-view ember-text-area')
          }, attrs);
          this.assertComponentElement(this.firstChild, {
            tagName: 'textarea',
            attrs: mergedAttrs
          });

          if (value) {
            this.assert.strictEqual(value, this.firstChild.value);
          }
        };

        _proto.triggerEvent = function triggerEvent(type) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var event = document.createEvent('Events');
          event.initEvent(type, true, true);
          (0, _polyfills.assign)(event, options);
          this.firstChild.dispatchEvent(event);
        };

        return TextAreaRenderingTest;
      }(_internalTestHelpers.RenderingTestCase);

      var BoundTextAreaAttributes =
      /*#__PURE__*/
      function () {
        function BoundTextAreaAttributes(cases) {
          this.cases = cases;
        }

        var _proto2 = BoundTextAreaAttributes.prototype;

        _proto2.generate = function generate(_ref2) {
          var _ref3;

          var attribute = _ref2.attribute,
              first = _ref2.first,
              second = _ref2.second;
          return _ref3 = {}, _ref3["@test " + attribute + " (HTML attribute)"] = function () {
            var _attrs,
                _this = this,
                _attrs2,
                _attrs3;

            this.render("<Textarea " + attribute + "={{value}} />", {
              value: first
            });
            this.assertTextArea({
              attrs: (_attrs = {}, _attrs[attribute] = first, _attrs)
            });
            this.assertStableRerender();
            (0, _internalTestHelpers.runTask)(function () {
              return (0, _metal.set)(_this.context, 'value', second);
            });
            this.assertTextArea({
              attrs: (_attrs2 = {}, _attrs2[attribute] = second, _attrs2)
            });
            (0, _internalTestHelpers.runTask)(function () {
              return (0, _metal.set)(_this.context, 'value', first);
            });
            this.assertTextArea({
              attrs: (_attrs3 = {}, _attrs3[attribute] = first, _attrs3)
            });
          }, _ref3["@test @" + attribute + " (named argument)"] = function () {
            var _attrs4,
                _this2 = this,
                _attrs5,
                _attrs6;

            this.render("<Textarea @" + attribute + "={{value}} />", {
              value: first
            });
            this.assertTextArea({
              attrs: (_attrs4 = {}, _attrs4[attribute] = first, _attrs4)
            });
            this.assertStableRerender();
            (0, _internalTestHelpers.runTask)(function () {
              return (0, _metal.set)(_this2.context, 'value', second);
            });
            this.assertTextArea({
              attrs: (_attrs5 = {}, _attrs5[attribute] = second, _attrs5)
            });
            (0, _internalTestHelpers.runTask)(function () {
              return (0, _metal.set)(_this2.context, 'value', first);
            });
            this.assertTextArea({
              attrs: (_attrs6 = {}, _attrs6[attribute] = first, _attrs6)
            });
          }, _ref3;
        };

        return BoundTextAreaAttributes;
      }();

      (0, _internalTestHelpers.applyMixins)(TextAreaRenderingTest, new BoundTextAreaAttributes([{
        attribute: 'placeholder',
        first: 'Stuff here',
        second: 'Other stuff'
      }, {
        attribute: 'name',
        first: 'Stuff here',
        second: 'Other stuff'
      }, {
        attribute: 'title',
        first: 'Stuff here',
        second: 'Other stuff'
      }, {
        attribute: 'maxlength',
        first: '1',
        second: '2'
      }, {
        attribute: 'rows',
        first: '1',
        second: '2'
      }, {
        attribute: 'cols',
        first: '1',
        second: '2'
      }, {
        attribute: 'tabindex',
        first: '1',
        second: '2'
      }]));
      (0, _internalTestHelpers.moduleFor)('Components test: <Textarea>',
      /*#__PURE__*/
      function (_TextAreaRenderingTes) {
        (0, _emberBabel.inheritsLoose)(_class, _TextAreaRenderingTes);

        function _class() {
          return _TextAreaRenderingTes.apply(this, arguments) || this;
        }

        var _proto3 = _class.prototype;

        _proto3['@test Should catch <TextArea />` typo'] = function testShouldCatchTextAreaTypo() {
          var _this3 = this;

          expectAssertion(function () {
            _this3.render('<TextArea />');
          }, 'Could not find component `<TextArea />` (did you mean `<Textarea />`?)');
        };

        _proto3['@test Should insert a <textarea>'] = function testShouldInsertATextarea(assert) {
          this.render('<Textarea />');
          assert.equal(this.$('textarea').length, 1);
          this.assertStableRerender();
        };

        _proto3['@test Should respect disabled (HTML attribute)'] = function testShouldRespectDisabledHTMLAttribute(assert) {
          this.render('<Textarea disabled={{disabled}} />', {
            disabled: true
          });
          assert.ok(this.$('textarea').is(':disabled'));
        };

        _proto3['@test Should respect @disabled (named argument)'] = function testShouldRespectDisabledNamedArgument(assert) {
          this.render('<Textarea @disabled={{disabled}} />', {
            disabled: true
          });
          assert.ok(this.$('textarea').is(':disabled'));
        };

        _proto3['@test Should respect disabled (HTML attribute) when false'] = function testShouldRespectDisabledHTMLAttributeWhenFalse(assert) {
          this.render('<Textarea disabled={{disabled}} />', {
            disabled: false
          });
          assert.ok(this.$('textarea').is(':not(:disabled)'));
        };

        _proto3['@test Should respect @disabled (named argument) when false'] = function testShouldRespectDisabledNamedArgumentWhenFalse(assert) {
          this.render('<Textarea @disabled={{disabled}} />', {
            disabled: false
          });
          assert.ok(this.$('textarea').is(':not(:disabled)'));
        };

        _proto3['@test Should become disabled (HTML attribute) when the context changes'] = function testShouldBecomeDisabledHTMLAttributeWhenTheContextChanges(assert) {
          var _this4 = this;

          this.render('<Textarea disabled={{disabled}} />');
          assert.ok(this.$('textarea').is(':not(:disabled)'));
          this.assertStableRerender();
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this4.context, 'disabled', true);
          });
          assert.ok(this.$('textarea').is(':disabled'));
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this4.context, 'disabled', false);
          });
          assert.ok(this.$('textarea').is(':not(:disabled)'));
        };

        _proto3['@test Should become @disabled (named argument) when the context changes'] = function testShouldBecomeDisabledNamedArgumentWhenTheContextChanges(assert) {
          var _this5 = this;

          this.render('<Textarea @disabled={{disabled}} />');
          assert.ok(this.$('textarea').is(':not(:disabled)'));
          this.assertStableRerender();
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this5.context, 'disabled', true);
          });
          assert.ok(this.$('textarea').is(':disabled'));
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this5.context, 'disabled', false);
          });
          assert.ok(this.$('textarea').is(':not(:disabled)'));
        };

        _proto3['@test Should bind its contents to the specified @value'] = function testShouldBindItsContentsToTheSpecifiedValue() {
          var _this6 = this;

          this.render('<Textarea @value={{model.val}} />', {
            model: {
              val: 'A beautiful day in Seattle'
            }
          });
          this.assertTextArea({
            value: 'A beautiful day in Seattle'
          });
          this.assertStableRerender();
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this6.context, 'model.val', 'Auckland');
          });
          this.assertTextArea({
            value: 'Auckland'
          });
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this6.context, 'model', {
              val: 'A beautiful day in Seattle'
            });
          });
          this.assertTextArea({
            value: 'A beautiful day in Seattle'
          });
        };

        _proto3['@test GH#14001 Should correctly handle an empty string bound value'] = function testGH14001ShouldCorrectlyHandleAnEmptyStringBoundValue() {
          var _this7 = this;

          this.render('<Textarea @value={{message}} />', {
            message: ''
          });
          this.assert.strictEqual(this.firstChild.value, '');
          this.assertStableRerender();
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this7.context, 'message', 'hello');
          });
          this.assert.strictEqual(this.firstChild.value, 'hello');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this7.context, 'message', '');
          });
          this.assert.strictEqual(this.firstChild.value, '');
        };

        _proto3['@test should update the @value for `cut` / `input` / `change` events'] = function testShouldUpdateTheValueForCutInputChangeEvents() {
          var _this8 = this;

          this.render('<Textarea @value={{model.val}} />', {
            model: {
              val: 'A beautiful day in Seattle'
            }
          });
          this.assertTextArea({
            value: 'A beautiful day in Seattle'
          });
          this.assertStableRerender();
          (0, _internalTestHelpers.runTask)(function () {
            _this8.firstChild.value = 'Auckland';

            _this8.triggerEvent('cut');
          });
          this.assertTextArea({
            value: 'Auckland'
          });
          (0, _internalTestHelpers.runTask)(function () {
            _this8.firstChild.value = 'Hope';

            _this8.triggerEvent('paste');
          });
          this.assertTextArea({
            value: 'Hope'
          });
          (0, _internalTestHelpers.runTask)(function () {
            _this8.firstChild.value = 'Boston';

            _this8.triggerEvent('input');
          });
          this.assertTextArea({
            value: 'Boston'
          });
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this8.context, 'model', {
              val: 'A beautiful day in Seattle'
            });
          });
          this.assertTextArea({
            value: 'A beautiful day in Seattle'
          });
        };

        return _class;
      }(TextAreaRenderingTest));
    } else {
    (0, _internalTestHelpers.moduleFor)('Components test: <Textarea>',
    /*#__PURE__*/
    function (_RenderingTestCase2) {
      (0, _emberBabel.inheritsLoose)(_class2, _RenderingTestCase2);

      function _class2() {
        return _RenderingTestCase2.apply(this, arguments) || this;
      }

      var _proto4 = _class2.prototype;

      _proto4['@test it is not allowed'] = function testItIsNotAllowed() {
        var _this9 = this;

        expectAssertion(function () {
          _this9.render("<Textarea />");
        }, 'Invoking `{{textarea}}` using angle bracket syntax or `component` helper is not yet supported.');
      };

      return _class2;
    }(_internalTestHelpers.RenderingTestCase));
  }
});
enifed("@ember/-internals/glimmer/tests/integration/components/textarea-curly-test", ["ember-babel", "internal-test-helpers", "@ember/polyfills", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _polyfills, _metal) {
  "use strict";

  var TextAreaRenderingTest =
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(TextAreaRenderingTest, _RenderingTestCase);

    function TextAreaRenderingTest() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = TextAreaRenderingTest.prototype;

    _proto.assertTextArea = function assertTextArea() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          attrs = _ref.attrs,
          value = _ref.value;

      var mergedAttrs = (0, _polyfills.assign)({
        class: (0, _internalTestHelpers.classes)('ember-view ember-text-area')
      }, attrs);
      this.assertComponentElement(this.firstChild, {
        tagName: 'textarea',
        attrs: mergedAttrs
      });

      if (value) {
        this.assert.strictEqual(value, this.firstChild.value);
      }
    };

    _proto.triggerEvent = function triggerEvent(type) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var event = document.createEvent('Events');
      event.initEvent(type, true, true);
      (0, _polyfills.assign)(event, options);
      this.firstChild.dispatchEvent(event);
    };

    return TextAreaRenderingTest;
  }(_internalTestHelpers.RenderingTestCase);

  var BoundTextAreaAttributes =
  /*#__PURE__*/
  function () {
    function BoundTextAreaAttributes(cases) {
      this.cases = cases;
    }

    var _proto2 = BoundTextAreaAttributes.prototype;

    _proto2.generate = function generate(_ref2) {
      var _ref3;

      var attribute = _ref2.attribute,
          first = _ref2.first,
          second = _ref2.second;
      return _ref3 = {}, _ref3["@test " + attribute] = function () {
        var _attrs,
            _this = this,
            _attrs2,
            _attrs3;

        this.render("{{textarea " + attribute + "=value}}", {
          value: first
        });
        this.assertTextArea({
          attrs: (_attrs = {}, _attrs[attribute] = first, _attrs)
        });
        this.assertStableRerender();
        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(_this.context, 'value', second);
        });
        this.assertTextArea({
          attrs: (_attrs2 = {}, _attrs2[attribute] = second, _attrs2)
        });
        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(_this.context, 'value', first);
        });
        this.assertTextArea({
          attrs: (_attrs3 = {}, _attrs3[attribute] = first, _attrs3)
        });
      }, _ref3;
    };

    return BoundTextAreaAttributes;
  }();

  (0, _internalTestHelpers.applyMixins)(TextAreaRenderingTest, new BoundTextAreaAttributes([{
    attribute: 'placeholder',
    first: 'Stuff here',
    second: 'Other stuff'
  }, {
    attribute: 'name',
    first: 'Stuff here',
    second: 'Other stuff'
  }, {
    attribute: 'title',
    first: 'Stuff here',
    second: 'Other stuff'
  }, {
    attribute: 'maxlength',
    first: '1',
    second: '2'
  }, {
    attribute: 'rows',
    first: '1',
    second: '2'
  }, {
    attribute: 'cols',
    first: '1',
    second: '2'
  }, {
    attribute: 'tabindex',
    first: '1',
    second: '2'
  }]));
  (0, _internalTestHelpers.moduleFor)('Components test: {{textarea}}',
  /*#__PURE__*/
  function (_TextAreaRenderingTes) {
    (0, _emberBabel.inheritsLoose)(_class, _TextAreaRenderingTes);

    function _class() {
      return _TextAreaRenderingTes.apply(this, arguments) || this;
    }

    var _proto3 = _class.prototype;

    _proto3['@test Should insert a textarea'] = function testShouldInsertATextarea(assert) {
      this.render('{{textarea}}');
      assert.equal(this.$('textarea').length, 1);
      this.assertStableRerender();
    };

    _proto3['@test Should respect disabled'] = function testShouldRespectDisabled(assert) {
      this.render('{{textarea disabled=disabled}}', {
        disabled: true
      });
      assert.ok(this.$('textarea').is(':disabled'));
    };

    _proto3['@test Should respect disabled when false'] = function testShouldRespectDisabledWhenFalse(assert) {
      this.render('{{textarea disabled=disabled}}', {
        disabled: false
      });
      assert.ok(this.$('textarea').is(':not(:disabled)'));
    };

    _proto3['@test Should become disabled when the context changes'] = function testShouldBecomeDisabledWhenTheContextChanges(assert) {
      var _this2 = this;

      this.render('{{textarea disabled=disabled}}');
      assert.ok(this.$('textarea').is(':not(:disabled)'));
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'disabled', true);
      });
      assert.ok(this.$('textarea').is(':disabled'));
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'disabled', false);
      });
      assert.ok(this.$('textarea').is(':not(:disabled)'));
    };

    _proto3['@test Should bind its contents to the specified value'] = function testShouldBindItsContentsToTheSpecifiedValue() {
      var _this3 = this;

      this.render('{{textarea value=model.val}}', {
        model: {
          val: 'A beautiful day in Seattle'
        }
      });
      this.assertTextArea({
        value: 'A beautiful day in Seattle'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'model.val', 'Auckland');
      });
      this.assertTextArea({
        value: 'Auckland'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'model', {
          val: 'A beautiful day in Seattle'
        });
      });
      this.assertTextArea({
        value: 'A beautiful day in Seattle'
      });
    };

    _proto3['@test GH#14001 Should correctly handle an empty string bound value'] = function testGH14001ShouldCorrectlyHandleAnEmptyStringBoundValue() {
      var _this4 = this;

      this.render('{{textarea value=message}}', {
        message: ''
      });
      this.assert.strictEqual(this.firstChild.value, '');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'message', 'hello');
      });
      this.assert.strictEqual(this.firstChild.value, 'hello');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'message', '');
      });
      this.assert.strictEqual(this.firstChild.value, '');
    };

    _proto3['@test should update the value for `cut` / `input` / `change` events'] = function testShouldUpdateTheValueForCutInputChangeEvents() {
      var _this5 = this;

      this.render('{{textarea value=model.val}}', {
        model: {
          val: 'A beautiful day in Seattle'
        }
      });
      this.assertTextArea({
        value: 'A beautiful day in Seattle'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        _this5.firstChild.value = 'Auckland';

        _this5.triggerEvent('cut');
      });
      this.assertTextArea({
        value: 'Auckland'
      });
      (0, _internalTestHelpers.runTask)(function () {
        _this5.firstChild.value = 'Hope';

        _this5.triggerEvent('paste');
      });
      this.assertTextArea({
        value: 'Hope'
      });
      (0, _internalTestHelpers.runTask)(function () {
        _this5.firstChild.value = 'Boston';

        _this5.triggerEvent('input');
      });
      this.assertTextArea({
        value: 'Boston'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'model', {
          val: 'A beautiful day in Seattle'
        });
      });
      this.assertTextArea({
        value: 'A beautiful day in Seattle'
      });
    };

    return _class;
  }(TextAreaRenderingTest));
});
enifed("@ember/-internals/glimmer/tests/integration/components/to-string-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/glimmer"], function (_emberBabel, _internalTestHelpers, _glimmer) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('built-in component toString',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(AbstractAppendTest, _RenderingTestCase);

    function AbstractAppendTest() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = AbstractAppendTest.prototype;

    _proto['@test text-field has the correct toString value'] = function testTextFieldHasTheCorrectToStringValue(assert) {
      assert.strictEqual(_glimmer.TextField.toString(), '@ember/component/text-field');
    };

    _proto['@test checkbox has the correct toString value'] = function testCheckboxHasTheCorrectToStringValue(assert) {
      assert.strictEqual(_glimmer.Checkbox.toString(), '@ember/component/checkbox');
    };

    _proto['@test text-area has the correct toString value'] = function testTextAreaHasTheCorrectToStringValue(assert) {
      assert.strictEqual(_glimmer.TextArea.toString(), '@ember/component/text-area');
    };

    _proto['@test component has the correct toString value'] = function testComponentHasTheCorrectToStringValue(assert) {
      assert.strictEqual(_glimmer.Component.toString(), '@ember/component');
    };

    _proto['@test LinkTo has the correct toString value'] = function testLinkToHasTheCorrectToStringValue(assert) {
      assert.strictEqual(_glimmer.LinkComponent.toString(), '@ember/routing/link-component');
    };

    return AbstractAppendTest;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/components/tracked-test", ["ember-babel", "@ember/-internals/runtime", "@ember/-internals/metal", "internal-test-helpers", "@ember/-internals/glimmer/tests/utils/glimmerish-component", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _runtime, _metal, _internalTestHelpers, _glimmerishComponent, _helpers) {
  "use strict";

  function _templateObject7() {
    const data = _taggedTemplateLiteralLoose(["\n          <Person as |p update|>\n            <button onclick={{update}}>\n              {{p.full}}\n            </button>\n          </Person>\n        "]);

    _templateObject7 = function () {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    const data = _taggedTemplateLiteralLoose(["\n            {{yield this.person (action this.updatePerson)}}\n          "]);

    _templateObject6 = function () {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    const data = _taggedTemplateLiteralLoose(["\n          <Person as |name update|>\n            <button onclick={{update}}>\n              {{name}}\n            </button>\n          </Person>\n        "]);

    _templateObject5 = function () {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    const data = _taggedTemplateLiteralLoose(["\n            {{yield this.full (action this.updatePerson)}}\n          "]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["\n            <div id=\"child\">{{this.person.full}}</div>\n            <button onclick={{action this.updatePerson}}></button>\n          "]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n            <div id=\"parent\">{{this.person.full}}</div>\n            <Child @person={{this.person}}/>\n          "]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n            <button {{action this.addNumber}}>\n              {{#each this.numbers as |num|}}{{num}}{{/each}}\n            </button>\n          "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }

    return desc;
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');
  }

  if (false
  /* EMBER_METAL_TRACKED_PROPERTIES */
  ) {
      (0, _internalTestHelpers.moduleFor)('Component Tracked Properties',
      /*#__PURE__*/
      function (_RenderingTestCase) {
        (0, _emberBabel.inheritsLoose)(_class2, _RenderingTestCase);

        function _class2() {
          return _RenderingTestCase.apply(this, arguments) || this;
        }

        var _proto = _class2.prototype;

        _proto['@test simple test using glimmerish component'] = function testSimpleTestUsingGlimmerishComponent() {
          var _this = this;

          var _class, _descriptor, _descriptor2, _temp;

          var personId = 0;
          var Person = (_class = (_temp = function Person(first, last) {
            _initializerDefineProperty(this, "first", _descriptor, this);

            _initializerDefineProperty(this, "last", _descriptor2, this);

            this.id = personId++;
            this.first = first;
            this.last = last;
          }, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, "first", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: null
          }), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "last", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: null
          })), _class);

          var PersonComponent =
          /*#__PURE__*/
          function (_GlimmerishComponent) {
            (0, _emberBabel.inheritsLoose)(PersonComponent, _GlimmerishComponent);

            function PersonComponent() {
              return _GlimmerishComponent.apply(this, arguments) || this;
            }

            (0, _emberBabel.createClass)(PersonComponent, [{
              key: "person",
              get: function () {
                return new Person(this.args.first, this.args.last);
              }
            }]);
            return PersonComponent;
          }(_glimmerishComponent.default);

          this.registerComponent('person-wrapper', {
            ComponentClass: PersonComponent,
            template: '{{@first}} {{@last}} | {{this.person.first}} {{this.person.last}}'
          });
          this.render('<PersonWrapper @first={{first}} @last={{last}} />', {
            first: 'robert',
            last: 'jackson'
          });
          this.assertText('robert jackson | robert jackson');
          (0, _internalTestHelpers.runTask)(function () {
            return _this.context.set('first', 'max');
          });
          this.assertText('max jackson | max jackson');
        };

        _proto['@test tracked properties that are uninitialized do not throw an error'] = function testTrackedPropertiesThatAreUninitializedDoNotThrowAnError() {
          var _this2 = this;

          var CountComponent = _helpers.Component.extend({
            count: (0, _metal.tracked)(),
            increment: function () {
              if (!this.count) {
                this.count = 0;
              }

              this.count++;
            }
          });

          this.registerComponent('counter', {
            ComponentClass: CountComponent,
            template: '<button {{action this.increment}}>{{this.count}}</button>'
          });
          this.render('<Counter />');
          this.assertText('');
          (0, _internalTestHelpers.runTask)(function () {
            return _this2.$('button').click();
          });
          this.assertText('1');
        };

        _proto['@test tracked properties rerender when updated'] = function testTrackedPropertiesRerenderWhenUpdated() {
          var _this3 = this;

          var CountComponent = _helpers.Component.extend({
            count: (0, _metal.tracked)({
              value: 0
            }),
            increment: function () {
              this.count++;
            }
          });

          this.registerComponent('counter', {
            ComponentClass: CountComponent,
            template: '<button {{action this.increment}}>{{this.count}}</button>'
          });
          this.render('<Counter />');
          this.assertText('0');
          (0, _internalTestHelpers.runTask)(function () {
            return _this3.$('button').click();
          });
          this.assertText('1');
        };

        _proto['@test tracked properties rerender when updated outside of a runloop'] = function testTrackedPropertiesRerenderWhenUpdatedOutsideOfARunloop(assert) {
          var _this5 = this;

          var done = assert.async();

          var CountComponent = _helpers.Component.extend({
            count: (0, _metal.tracked)({
              value: 0
            }),
            increment: function () {
              var _this4 = this;

              setTimeout(function () {
                _this4.count++;
              }, 100);
            }
          });

          this.registerComponent('counter', {
            ComponentClass: CountComponent,
            template: '<button {{action this.increment}}>{{this.count}}</button>'
          });
          this.render('<Counter />');
          this.assertText('0'); // intentionally outside of a runTask

          this.$('button').click();
          setTimeout(function () {
            _this5.assertText('1');

            done();
          }, 200);
        };

        _proto['@test nested tracked properties rerender when updated'] = function testNestedTrackedPropertiesRerenderWhenUpdated() {
          var _this6 = this;

          var Counter = _runtime.Object.extend({
            count: (0, _metal.tracked)({
              value: 0
            })
          });

          var CountComponent = _helpers.Component.extend({
            counter: Counter.create(),
            increment: function () {
              this.counter.count++;
            }
          });

          this.registerComponent('counter', {
            ComponentClass: CountComponent,
            template: '<button {{action this.increment}}>{{this.counter.count}}</button>'
          });
          this.render('<Counter />');
          this.assertText('0');
          (0, _internalTestHelpers.runTask)(function () {
            return _this6.$('button').click();
          });
          this.assertText('1');
        };

        _proto['@test array properties rerender when updated'] = function testArrayPropertiesRerenderWhenUpdated() {
          var _this7 = this;

          var NumListComponent = _helpers.Component.extend({
            numbers: (0, _metal.tracked)({
              initializer: function () {
                return (0, _runtime.A)([1, 2, 3]);
              }
            }),
            addNumber: function () {
              this.numbers.pushObject(4);
            }
          });

          this.registerComponent('num-list', {
            ComponentClass: NumListComponent,
            template: (0, _internalTestHelpers.strip)(_templateObject())
          });
          this.render('<NumList />');
          this.assertText('123');
          (0, _internalTestHelpers.runTask)(function () {
            return _this7.$('button').click();
          });
          this.assertText('1234');
        };

        _proto['@test getters update when dependent properties are invalidated'] = function testGettersUpdateWhenDependentPropertiesAreInvalidated() {
          var _this8 = this;

          var CountComponent = _helpers.Component.extend({
            count: (0, _metal.tracked)({
              value: 0
            }),
            countAlias: (0, _metal.nativeDescDecorator)({
              get: function () {
                return this.count;
              }
            }),
            increment: function () {
              this.count++;
            }
          });

          this.registerComponent('counter', {
            ComponentClass: CountComponent,
            template: '<button {{action this.increment}}>{{this.countAlias}}</button>'
          });
          this.render('<Counter />');
          this.assertText('0');
          (0, _internalTestHelpers.runTask)(function () {
            return _this8.$('button').click();
          });
          this.assertText('1');
        };

        _proto['@test nested getters update when dependent properties are invalidated'] = function testNestedGettersUpdateWhenDependentPropertiesAreInvalidated() {
          var _this9 = this;

          var Counter = _runtime.Object.extend({
            count: (0, _metal.tracked)({
              value: 0
            }),
            countAlias: (0, _metal.nativeDescDecorator)({
              get: function () {
                return this.count;
              }
            })
          });

          var CountComponent = _helpers.Component.extend({
            counter: Counter.create(),
            increment: function () {
              this.counter.count++;
            }
          });

          this.registerComponent('counter', {
            ComponentClass: CountComponent,
            template: '<button {{action this.increment}}>{{this.counter.countAlias}}</button>'
          });
          this.render('<Counter />');
          this.assertText('0');
          (0, _internalTestHelpers.runTask)(function () {
            return _this9.$('button').click();
          });
          this.assertText('1');
        };

        _proto['@test tracked object passed down through components updates correctly'] = function testTrackedObjectPassedDownThroughComponentsUpdatesCorrectly(assert) {
          var _this10 = this;

          var Person = _runtime.Object.extend({
            first: (0, _metal.tracked)({
              value: 'Rob'
            }),
            last: (0, _metal.tracked)({
              value: 'Jackson'
            }),
            full: (0, _metal.nativeDescDecorator)({
              get: function () {
                return this.first + " " + this.last;
              }
            })
          });

          var ParentComponent = _helpers.Component.extend({
            person: Person.create()
          });

          var ChildComponent = _helpers.Component.extend({
            updatePerson: function () {
              this.person.first = 'Kris';
              this.person.last = 'Selden';
            }
          });

          this.registerComponent('parent', {
            ComponentClass: ParentComponent,
            template: (0, _internalTestHelpers.strip)(_templateObject2())
          });
          this.registerComponent('child', {
            ComponentClass: ChildComponent,
            template: (0, _internalTestHelpers.strip)(_templateObject3())
          });
          this.render('<Parent />');
          assert.equal(this.$('#parent').text(), 'Rob Jackson');
          assert.equal(this.$('#child').text(), 'Rob Jackson');
          (0, _internalTestHelpers.runTask)(function () {
            return _this10.$('button').click();
          });
          assert.equal(this.$('#parent').text(), 'Kris Selden');
          assert.equal(this.$('#child').text(), 'Kris Selden');
        };

        _proto['@test yielded getters update correctly'] = function testYieldedGettersUpdateCorrectly() {
          var _this11 = this;

          var PersonComponent = _helpers.Component.extend({
            first: (0, _metal.tracked)({
              value: 'Rob'
            }),
            last: (0, _metal.tracked)({
              value: 'Jackson'
            }),
            full: (0, _metal.nativeDescDecorator)({
              get: function () {
                return this.first + " " + this.last;
              }
            }),
            updatePerson: function () {
              this.first = 'Kris';
              this.last = 'Selden';
            }
          });

          this.registerComponent('person', {
            ComponentClass: PersonComponent,
            template: (0, _internalTestHelpers.strip)(_templateObject4())
          });
          this.render((0, _internalTestHelpers.strip)(_templateObject5()));
          this.assertText('Rob Jackson');
          (0, _internalTestHelpers.runTask)(function () {
            return _this11.$('button').click();
          });
          this.assertText('Kris Selden');
        };

        _proto['@test yielded nested getters update correctly'] = function testYieldedNestedGettersUpdateCorrectly() {
          var _this12 = this;

          var Person = _runtime.Object.extend({
            first: (0, _metal.tracked)({
              value: 'Rob'
            }),
            last: (0, _metal.tracked)({
              value: 'Jackson'
            }),
            full: (0, _metal.nativeDescDecorator)({
              get: function () {
                return this.first + " " + this.last;
              }
            })
          });

          var PersonComponent = _helpers.Component.extend({
            person: Person.create(),
            updatePerson: function () {
              this.person.first = 'Kris';
              this.person.last = 'Selden';
            }
          });

          this.registerComponent('person', {
            ComponentClass: PersonComponent,
            template: (0, _internalTestHelpers.strip)(_templateObject6())
          });
          this.render((0, _internalTestHelpers.strip)(_templateObject7()));
          this.assertText('Rob Jackson');
          (0, _internalTestHelpers.runTask)(function () {
            return _this12.$('button').click();
          });
          this.assertText('Kris Selden');
        };

        return _class2;
      }(_internalTestHelpers.RenderingTestCase));

      if (false
      /* EMBER_CUSTOM_COMPONENT_ARG_PROXY */
      ) {
          (0, _internalTestHelpers.moduleFor)('Component Tracked Properties w/ Args Proxy',
          /*#__PURE__*/
          function (_RenderingTestCase2) {
            (0, _emberBabel.inheritsLoose)(_class4, _RenderingTestCase2);

            function _class4() {
              return _RenderingTestCase2.apply(this, arguments) || this;
            }

            var _proto2 = _class4.prototype;

            _proto2['@test downstream property changes do not invalidate upstream component getters/arguments'] = function testDownstreamPropertyChangesDoNotInvalidateUpstreamComponentGettersArguments(assert) {
              var _this14 = this;

              var _class3, _descriptor3, _temp2;

              var outerRenderCount = 0;
              var innerRenderCount = 0;

              var OuterComponent =
              /*#__PURE__*/
              function (_GlimmerishComponent2) {
                (0, _emberBabel.inheritsLoose)(OuterComponent, _GlimmerishComponent2);

                function OuterComponent() {
                  return _GlimmerishComponent2.apply(this, arguments) || this;
                }

                (0, _emberBabel.createClass)(OuterComponent, [{
                  key: "count",
                  get: function () {
                    outerRenderCount++;
                    return this.args.count;
                  }
                }]);
                return OuterComponent;
              }(_glimmerishComponent.default);

              var InnerComponent = (_class3 = (_temp2 =
              /*#__PURE__*/
              function (_GlimmerishComponent3) {
                (0, _emberBabel.inheritsLoose)(InnerComponent, _GlimmerishComponent3);

                function InnerComponent() {
                  var _this13;

                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }

                  _this13 = _GlimmerishComponent3.call.apply(_GlimmerishComponent3, [this].concat(args)) || this;

                  _initializerDefineProperty((0, _emberBabel.assertThisInitialized)(_this13), "count", _descriptor3, (0, _emberBabel.assertThisInitialized)(_this13));

                  return _this13;
                }

                var _proto3 = InnerComponent.prototype;

                _proto3.updateInnerCount = function updateInnerCount() {
                  this.count++;
                };

                (0, _emberBabel.createClass)(InnerComponent, [{
                  key: "combinedCounts",
                  get: function () {
                    innerRenderCount++;
                    return this.args.count + this.count;
                  }
                }]);
                return InnerComponent;
              }(_glimmerishComponent.default), _temp2), _descriptor3 = _applyDecoratedDescriptor(_class3.prototype, "count", [_metal.tracked], {
                configurable: true,
                enumerable: true,
                writable: true,
                initializer: function () {
                  return 0;
                }
              }), _class3);
              this.registerComponent('outer', {
                ComponentClass: OuterComponent,
                template: '<Inner @count={{this.count}}/>'
              });
              this.registerComponent('inner', {
                ComponentClass: InnerComponent,
                template: '<button {{action this.updateInnerCount}}>{{this.combinedCounts}}</button>'
              });
              this.render('<Outer @count={{this.count}}/>', {
                count: 0
              });
              this.assertText('0');
              assert.equal(outerRenderCount, 1);
              assert.equal(innerRenderCount, 1);
              (0, _internalTestHelpers.runTask)(function () {
                return _this14.$('button').click();
              });
              this.assertText('1');
              assert.equal(outerRenderCount, 1, 'updating inner component does not cause outer component to rerender');
              assert.equal(innerRenderCount, 2, 'updating inner component causes inner component to rerender');
              (0, _internalTestHelpers.runTask)(function () {
                return _this14.context.set('count', 1);
              });
              this.assertText('2');
              assert.equal(outerRenderCount, 2, 'outer component updates based on context');
              assert.equal(innerRenderCount, 3, 'inner component updates based on outer component');
            };

            return _class4;
          }(_internalTestHelpers.RenderingTestCase));
        }
    }
});
enifed("@ember/-internals/glimmer/tests/integration/components/utils-test", ["ember-babel", "internal-test-helpers", "@ember/controller", "@ember/-internals/views", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _controller, _views, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('View tree tests',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.apply(this, arguments) || this;

      _this.addComponent('x-tagless', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: '<div id="{{id}}">[{{id}}] {{#if isShowing}}{{yield}}{{/if}}</div>'
      });

      _this.addComponent('x-toggle', {
        ComponentClass: _helpers.Component.extend({
          isExpanded: true,
          click: function () {
            this.toggleProperty('isExpanded');
            return false;
          }
        }),
        template: '[{{id}}] {{#if isExpanded}}{{yield}}{{/if}}'
      });

      var ToggleController = _controller.default.extend({
        isExpanded: true,
        actions: {
          toggle: function () {
            this.toggleProperty('isExpanded');
          }
        }
      });

      _this.add('controller:application', ToggleController);

      _this.addTemplate('application', "\n      {{x-tagless id=\"root-1\"}}\n\n      {{#x-toggle id=\"root-2\"}}\n        {{x-toggle id=\"inner-1\"}}\n\n        {{#x-toggle id=\"inner-2\"}}\n          {{x-toggle id=\"inner-3\"}}\n        {{/x-toggle}}\n      {{/x-toggle}}\n\n      <button id=\"toggle-application\" {{action \"toggle\"}}>Toggle</button>\n\n      {{#if isExpanded}}\n        {{x-toggle id=\"root-3\"}}\n      {{/if}}\n\n      {{outlet}}\n    ");

      _this.add('controller:index', ToggleController.extend({
        isExpanded: false
      }));

      _this.addTemplate('index', "\n      {{x-tagless id=\"root-4\"}}\n\n      {{#x-toggle id=\"root-5\" isExpanded=false}}\n        {{x-toggle id=\"inner-4\"}}\n\n        {{#x-toggle id=\"inner-5\"}}\n          {{x-toggle id=\"inner-6\"}}\n        {{/x-toggle}}\n      {{/x-toggle}}\n\n      <button id=\"toggle-index\" {{action \"toggle\"}}>Toggle</button>\n\n      {{#if isExpanded}}\n        {{x-toggle id=\"root-6\"}}\n      {{/if}}\n    ");

      _this.addTemplate('zomg', "\n      {{x-tagless id=\"root-7\"}}\n\n      {{#x-toggle id=\"root-8\"}}\n        {{x-toggle id=\"inner-7\"}}\n\n        {{#x-toggle id=\"inner-8\"}}\n          {{x-toggle id=\"inner-9\"}}\n        {{/x-toggle}}\n      {{/x-toggle}}\n\n      {{#x-toggle id=\"root-9\"}}\n        {{outlet}}\n      {{/x-toggle}}\n    ");

      _this.addTemplate('zomg.lol', "\n      {{x-toggle id=\"inner-10\"}}\n    ");

      _this.router.map(function () {
        this.route('zomg', function () {
          this.route('lol');
        });
      });

      return _this;
    }

    var _proto = _class.prototype;

    _proto['@test getRootViews'] = function testGetRootViews() {
      var _this2 = this;

      return this.visit('/').then(function () {
        _this2.assertRootViews(['root-1', 'root-2', 'root-3', 'root-4', 'root-5']);

        (0, _internalTestHelpers.runTask)(function () {
          return _this2.$('#toggle-application').click();
        });

        _this2.assertRootViews(['root-1', 'root-2', 'root-4', 'root-5']);

        (0, _internalTestHelpers.runTask)(function () {
          _this2.$('#toggle-application').click();

          _this2.$('#toggle-index').click();
        });

        _this2.assertRootViews(['root-1', 'root-2', 'root-3', 'root-4', 'root-5', 'root-6']);

        return _this2.visit('/zomg/lol');
      }).then(function () {
        _this2.assertRootViews(['root-1', 'root-2', 'root-3', 'root-7', 'root-8', 'root-9']);

        return _this2.visit('/');
      }).then(function () {
        _this2.assertRootViews(['root-1', 'root-2', 'root-3', 'root-4', 'root-5', 'root-6']);
      });
    };

    _proto.assertRootViews = function assertRootViews(ids) {
      var owner = this.applicationInstance;
      var actual = (0, _views.getRootViews)(owner).map(function (view) {
        return view.id;
      }).sort();
      var expected = ids.sort();
      this.assert.deepEqual(actual, expected, 'root views');
    };

    _proto['@test getChildViews'] = function testGetChildViews() {
      var _this3 = this;

      return this.visit('/').then(function () {
        _this3.assertChildViews('root-2', ['inner-1', 'inner-2']);

        _this3.assertChildViews('root-5', []);

        _this3.assertChildViews('inner-2', ['inner-3']);

        (0, _internalTestHelpers.runTask)(function () {
          return _this3.$('#root-2').click();
        });

        _this3.assertChildViews('root-2', []);

        (0, _internalTestHelpers.runTask)(function () {
          return _this3.$('#root-5').click();
        });

        _this3.assertChildViews('root-5', ['inner-4', 'inner-5']);

        _this3.assertChildViews('inner-5', ['inner-6']);

        return _this3.visit('/zomg');
      }).then(function () {
        _this3.assertChildViews('root-2', []);

        _this3.assertChildViews('root-8', ['inner-7', 'inner-8']);

        _this3.assertChildViews('inner-8', ['inner-9']);

        _this3.assertChildViews('root-9', []);

        (0, _internalTestHelpers.runTask)(function () {
          return _this3.$('#root-8').click();
        });

        _this3.assertChildViews('root-8', []);

        return _this3.visit('/zomg/lol');
      }).then(function () {
        _this3.assertChildViews('root-2', []);

        _this3.assertChildViews('root-8', []);

        _this3.assertChildViews('root-9', ['inner-10']);

        return _this3.visit('/');
      }).then(function () {
        _this3.assertChildViews('root-2', []);

        _this3.assertChildViews('root-5', []);

        (0, _internalTestHelpers.runTask)(function () {
          return _this3.$('#root-2').click();
        });
        (0, _internalTestHelpers.runTask)(function () {
          return _this3.$('#inner-2').click();
        });

        _this3.assertChildViews('root-2', ['inner-1', 'inner-2']);

        _this3.assertChildViews('inner-2', []);
      });
    };

    _proto['@test getChildViews does not return duplicates'] = function testGetChildViewsDoesNotReturnDuplicates() {
      var _this4 = this;

      return this.visit('/').then(function () {
        _this4.assertChildViews('root-2', ['inner-1', 'inner-2']);

        (0, _internalTestHelpers.runTask)(function () {
          return _this4.$('#root-2').click();
        });
        (0, _internalTestHelpers.runTask)(function () {
          return _this4.$('#root-2').click();
        });
        (0, _internalTestHelpers.runTask)(function () {
          return _this4.$('#root-2').click();
        });
        (0, _internalTestHelpers.runTask)(function () {
          return _this4.$('#root-2').click();
        });
        (0, _internalTestHelpers.runTask)(function () {
          return _this4.$('#root-2').click();
        });
        (0, _internalTestHelpers.runTask)(function () {
          return _this4.$('#root-2').click();
        });
        (0, _internalTestHelpers.runTask)(function () {
          return _this4.$('#root-2').click();
        });
        (0, _internalTestHelpers.runTask)(function () {
          return _this4.$('#root-2').click();
        });
        (0, _internalTestHelpers.runTask)(function () {
          return _this4.$('#root-2').click();
        });
        (0, _internalTestHelpers.runTask)(function () {
          return _this4.$('#root-2').click();
        });

        _this4.assertChildViews('root-2', ['inner-1', 'inner-2']);
      });
    };

    _proto.assertChildViews = function assertChildViews(parentId, childIds) {
      var parentView = this.viewFor(parentId);
      var childViews = (0, _views.getChildViews)(parentView);
      var actual = childViews.map(function (view) {
        return view.id;
      }).sort();
      var expected = childIds.sort();
      this.assert.deepEqual(actual, expected, "child views for #" + parentId);
    };

    _proto.viewFor = function viewFor(id) {
      var owner = this.applicationInstance;
      var registry = owner.lookup('-view-registry:main');
      return registry[id];
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
  var hasGetClientRects, hasGetBoundingClientRect;
  var ClientRectListCtor, ClientRectCtor;

  (function () {
    if (document.createRange) {
      var range = document.createRange();

      if (range.getClientRects) {
        var clientRectsList = range.getClientRects();
        hasGetClientRects = true;
        ClientRectListCtor = clientRectsList && clientRectsList.constructor;
      }

      if (range.getBoundingClientRect) {
        var clientRect = range.getBoundingClientRect();
        hasGetBoundingClientRect = true;
        ClientRectCtor = clientRect && clientRect.constructor;
      }
    }
  })();

  (0, _internalTestHelpers.moduleFor)('Bounds tests',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class2, _RenderingTestCase);

    function _class2() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test getViewBounds on a regular component'] = function testGetViewBoundsOnARegularComponent(assert) {
      var component;
      this.registerComponent('hi-mom', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            component = this;
          }
        }),
        template: "<p>Hi, mom!</p>"
      });
      this.render("{{hi-mom}}");

      var _getViewBounds = (0, _views.getViewBounds)(component),
          parentElement = _getViewBounds.parentElement,
          firstNode = _getViewBounds.firstNode,
          lastNode = _getViewBounds.lastNode;

      assert.equal(parentElement, this.element, 'a regular component should have the right parentElement');
      assert.equal(firstNode, component.element, 'a regular component should have a single node that is its element');
      assert.equal(lastNode, component.element, 'a regular component should have a single node that is its element');
    };

    _proto2['@test getViewBounds on a tagless component'] = function testGetViewBoundsOnATaglessComponent(assert) {
      var component;
      this.registerComponent('hi-mom', {
        ComponentClass: _helpers.Component.extend({
          tagName: '',
          init: function () {
            this._super.apply(this, arguments);

            component = this;
          }
        }),
        template: "<span id=\"start-node\">Hi,</span> <em id=\"before-end-node\">mom</em>!"
      });
      this.render("{{hi-mom}}");

      var _getViewBounds2 = (0, _views.getViewBounds)(component),
          parentElement = _getViewBounds2.parentElement,
          firstNode = _getViewBounds2.firstNode,
          lastNode = _getViewBounds2.lastNode;

      assert.equal(parentElement, this.element, 'a tagless component should have the right parentElement');
      assert.equal(firstNode, this.$('#start-node')[0], 'a tagless component should have a range enclosing all of its nodes');
      assert.equal(lastNode, this.$('#before-end-node')[0].nextSibling, 'a tagless component should have a range enclosing all of its nodes');
    };

    _proto2['@test getViewClientRects'] = function testGetViewClientRects(assert) {
      if (!hasGetClientRects || !ClientRectListCtor) {
        assert.ok(true, 'The test environment does not support the DOM API required to run this test.');
        return;
      }

      var component;
      this.registerComponent('hi-mom', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            component = this;
          }
        }),
        template: "<p>Hi, mom!</p>"
      });
      this.render("{{hi-mom}}");
      assert.ok((0, _views.getViewClientRects)(component) instanceof ClientRectListCtor);
    };

    _proto2['@test getViewBoundingClientRect'] = function testGetViewBoundingClientRect(assert) {
      if (!hasGetBoundingClientRect || !ClientRectCtor) {
        assert.ok(true, 'The test environment does not support the DOM API required to run this test.');
        return;
      }

      var component;
      this.registerComponent('hi-mom', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            component = this;
          }
        }),
        template: "<p>Hi, mom!</p>"
      });
      this.render("{{hi-mom}}");
      assert.ok((0, _views.getViewBoundingClientRect)(component) instanceof ClientRectCtor);
    };

    return _class2;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/components/web-component-fallback-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _metal) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Components test: web component fallback',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test custom elements are rendered'] = function testCustomElementsAreRendered() {
      var template = "<foo-bar some-attr=\"123\">hello</foo-bar>";
      this.render(template);
      this.assertHTML(template);
      this.assertStableRerender();
    };

    _proto['@test custom elements can have bound attributes'] = function testCustomElementsCanHaveBoundAttributes() {
      var _this = this;

      var template = "<foo-bar some-attr=\"{{name}}\">hello</foo-bar>";
      this.render(template, {
        name: 'Robert'
      });
      this.assertHTML("<foo-bar some-attr=\"Robert\">hello</foo-bar>");
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'name', 'Kris');
      });
      this.assertHTML("<foo-bar some-attr=\"Kris\">hello</foo-bar>");
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'name', 'Robert');
      });
      this.assertHTML("<foo-bar some-attr=\"Robert\">hello</foo-bar>");
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/components/will-destroy-element-hook-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Component willDestroyElement hook',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test it calls willDestroyElement when removed by if'] = function testItCallsWillDestroyElementWhenRemovedByIf(assert) {
      var _this = this;

      var didInsertElementCount = 0;
      var willDestroyElementCount = 0;

      var FooBarComponent = _helpers.Component.extend({
        didInsertElement: function () {
          didInsertElementCount++;
          assert.notEqual(this.element.parentNode, null, 'precond component is in DOM');
        },
        willDestroyElement: function () {
          willDestroyElementCount++;
          assert.notEqual(this.element.parentNode, null, 'has not been removed from DOM yet');
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'hello'
      });
      this.render('{{#if switch}}{{foo-bar}}{{/if}}', {
        switch: true
      });
      assert.equal(didInsertElementCount, 1, 'didInsertElement was called once');
      this.assertComponentElement(this.firstChild, {
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'switch', false);
      });
      assert.equal(willDestroyElementCount, 1, 'willDestroyElement was called once');
      this.assertText('');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/content-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/debug", "@ember/object/computed", "@ember/-internals/runtime", "@ember/-internals/utils", "@ember/-internals/views", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _debug, _computed, _runtime, _utils, _views, _helpers) {
  "use strict";

  /* globals EmberDev */
  (0, _internalTestHelpers.moduleFor)('Static content tests',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test it can render a static text node'] = function testItCanRenderAStaticTextNode() {
      var _this = this;

      this.render('hello');
      var text1 = this.assertTextNode(this.firstChild, 'hello');
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      var text2 = this.assertTextNode(this.firstChild, 'hello');
      this.assertSameNode(text1, text2);
    };

    _proto['@test it can render a static element'] = function testItCanRenderAStaticElement() {
      var _this2 = this;

      this.render('<p>hello</p>');
      var p1 = this.assertElement(this.firstChild, {
        tagName: 'p'
      });
      var text1 = this.assertTextNode(this.firstChild.firstChild, 'hello');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      var p2 = this.assertElement(this.firstChild, {
        tagName: 'p'
      });
      var text2 = this.assertTextNode(this.firstChild.firstChild, 'hello');
      this.assertSameNode(p1, p2);
      this.assertSameNode(text1, text2);
    };

    _proto['@test it can render a static template'] = function testItCanRenderAStaticTemplate() {
      var _this3 = this;

      var template = "\n      <div class=\"header\">\n        <h1>Welcome to Ember.js</h1>\n      </div>\n      <div class=\"body\">\n        <h2>Why you should use Ember.js?</h2>\n        <ol>\n          <li>It's great</li>\n          <li>It's awesome</li>\n          <li>It's Ember.js</li>\n        </ol>\n      </div>\n      <div class=\"footer\">\n        Ember.js is free, open source and always will be.\n      </div>\n    ";
      this.render(template);
      this.assertHTML(template);
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assertHTML(template);
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));

  var DynamicContentTest =
  /*#__PURE__*/
  function (_RenderingTestCase2) {
    (0, _emberBabel.inheritsLoose)(DynamicContentTest, _RenderingTestCase2);

    function DynamicContentTest() {
      return _RenderingTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = DynamicContentTest.prototype;
    /* abstract */

    _proto2.renderPath = function renderPath()
    /* path, context = {} */
    {
      throw new Error('Not implemented: `renderValues`');
    };

    _proto2.assertIsEmpty = function assertIsEmpty() {
      this.assert.strictEqual(this.firstChild, null);
    }
    /* abstract */
    ;

    _proto2.assertContent = function assertContent()
    /* content */
    {
      throw new Error('Not implemented: `assertContent`');
    };

    _proto2['@test it can render a dynamic path'] = function testItCanRenderADynamicPath() {
      var _this4 = this;

      this.renderPath('message', {
        message: 'hello'
      });
      this.assertContent('hello');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'message', 'goodbye');
      });
      this.assertContent('goodbye');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'message', 'hello');
      });
      this.assertContent('hello');
      this.assertInvariants();
    };

    _proto2['@test resolves the string length properly'] = function testResolvesTheStringLengthProperly() {
      var _this5 = this;

      this.render('<p>{{foo.length}}</p>', {
        foo: undefined
      });
      this.assertHTML('<p></p>');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'foo', 'foo');
      });
      this.assertHTML('<p>3</p>');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'foo', '');
      });
      this.assertHTML('<p>0</p>');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'foo', undefined);
      });
      this.assertHTML('<p></p>');
    };

    _proto2['@test resolves the array length properly'] = function testResolvesTheArrayLengthProperly() {
      var _this6 = this;

      this.render('<p>{{foo.length}}</p>', {
        foo: undefined
      });
      this.assertHTML('<p></p>');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'foo', [1, 2, 3]);
      });
      this.assertHTML('<p>3</p>');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'foo', []);
      });
      this.assertHTML('<p>0</p>');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'foo', undefined);
      });
      this.assertHTML('<p></p>');
    };

    _proto2['@test it can render a capitalized path with no deprecation'] = function testItCanRenderACapitalizedPathWithNoDeprecation() {
      var _this7 = this;

      expectNoDeprecation();
      this.renderPath('CaptializedPath', {
        CaptializedPath: 'no deprecation'
      });
      this.assertContent('no deprecation');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'CaptializedPath', 'still no deprecation');
      });
      this.assertContent('still no deprecation');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'CaptializedPath', 'no deprecation');
      });
      this.assertContent('no deprecation');
      this.assertInvariants();
    };

    _proto2['@test it can render undefined dynamic paths'] = function testItCanRenderUndefinedDynamicPaths() {
      var _this8 = this;

      this.renderPath('name', {});
      this.assertIsEmpty();
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this8.context, 'name', 'foo-bar');
      });
      this.assertContent('foo-bar');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this8.context, 'name', undefined);
      });
      this.assertIsEmpty();
    };

    _proto2['@test it can render a deeply nested dynamic path'] = function testItCanRenderADeeplyNestedDynamicPath() {
      var _this9 = this;

      this.renderPath('a.b.c.d.e.f', {
        a: {
          b: {
            c: {
              d: {
                e: {
                  f: 'hello'
                }
              }
            }
          }
        }
      });
      this.assertContent('hello');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this9.context, 'a.b.c.d.e.f', 'goodbye');
      });
      this.assertContent('goodbye');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this9.context, 'a.b.c.d', {
          e: {
            f: 'aloha'
          }
        });
      });
      this.assertContent('aloha');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this9.context, 'a', {
          b: {
            c: {
              d: {
                e: {
                  f: 'hello'
                }
              }
            }
          }
        });
      });
      this.assertContent('hello');
      this.assertInvariants();
    };

    _proto2['@test it can render a computed property'] = function testItCanRenderAComputedProperty() {
      var _this10 = this;

      var Formatter = _runtime.Object.extend({
        formattedMessage: (0, _metal.computed)('message', function () {
          return this.get('message').toUpperCase();
        })
      });

      var m = Formatter.create({
        message: 'hello'
      });
      this.renderPath('m.formattedMessage', {
        m: m
      });
      this.assertContent('HELLO');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(m, 'message', 'goodbye');
      });
      this.assertContent('GOODBYE');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'm', Formatter.create({
          message: 'hello'
        }));
      });
      this.assertContent('HELLO');
      this.assertInvariants();
    };

    _proto2['@test it can render a computed property with nested dependency'] = function testItCanRenderAComputedPropertyWithNestedDependency() {
      var _this11 = this;

      var Formatter = _runtime.Object.extend({
        formattedMessage: (0, _metal.computed)('messenger.message', function () {
          return this.get('messenger.message').toUpperCase();
        })
      });

      var m = Formatter.create({
        messenger: {
          message: 'hello'
        }
      });
      this.renderPath('m.formattedMessage', {
        m: m
      });
      this.assertContent('HELLO');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(m, 'messenger.message', 'goodbye');
      });
      this.assertContent('GOODBYE');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'm', Formatter.create({
          messenger: {
            message: 'hello'
          }
        }));
      });
      this.assertContent('HELLO');
      this.assertInvariants();
    };

    _proto2['@test it can read from a proxy object'] = function testItCanReadFromAProxyObject() {
      var _this12 = this;

      this.renderPath('proxy.name', {
        proxy: _runtime.ObjectProxy.create({
          content: {
            name: 'Tom Dale'
          }
        })
      });
      this.assertContent('Tom Dale');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'proxy.content.name', 'Yehuda Katz');
      });
      this.assertContent('Yehuda Katz');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'proxy.content', {
          name: 'Godfrey Chan'
        });
      });
      this.assertContent('Godfrey Chan');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'proxy.name', 'Stefan Penner');
      });
      this.assertContent('Stefan Penner');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'proxy.content', null);
      });
      this.assertIsEmpty();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'proxy', _runtime.ObjectProxy.create({
          content: {
            name: 'Tom Dale'
          }
        }));
      });
      this.assertContent('Tom Dale');
      this.assertInvariants();
    };

    _proto2['@test it can read from a nested path in a proxy object'] = function testItCanReadFromANestedPathInAProxyObject() {
      var _this13 = this;

      this.renderPath('proxy.name.last', {
        proxy: _runtime.ObjectProxy.create({
          content: {
            name: {
              first: 'Tom',
              last: 'Dale'
            }
          }
        })
      });
      this.assertContent('Dale');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'proxy.content.name.last', 'Cruise');
      });
      this.assertContent('Cruise');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'proxy.content.name.first', 'Suri');
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'proxy.content.name', {
          first: 'Yehuda',
          last: 'Katz'
        });
      });
      this.assertContent('Katz');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'proxy.content', {
          name: {
            first: 'Godfrey',
            last: 'Chan'
          }
        });
      });
      this.assertContent('Chan');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'proxy.name', {
          first: 'Stefan',
          last: 'Penner'
        });
      });
      this.assertContent('Penner');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'proxy', null);
      });
      this.assertIsEmpty();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'proxy', _runtime.ObjectProxy.create({
          content: {
            name: {
              first: 'Tom',
              last: 'Dale'
            }
          }
        }));
      });
      this.assertContent('Dale');
      this.assertInvariants();
    };

    _proto2['@test it can read from a path flipping between a proxy and a real object'] = function testItCanReadFromAPathFlippingBetweenAProxyAndARealObject() {
      var _this14 = this;

      this.renderPath('proxyOrObject.name.last', {
        proxyOrObject: _runtime.ObjectProxy.create({
          content: {
            name: {
              first: 'Tom',
              last: 'Dale'
            }
          }
        })
      });
      this.assertContent('Dale');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'proxyOrObject', {
          name: {
            first: 'Tom',
            last: 'Dale'
          }
        });
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'proxyOrObject.name.last', 'Cruise');
      });
      this.assertContent('Cruise');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'proxyOrObject.name.first', 'Suri');
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'proxyOrObject', {
          name: {
            first: 'Yehuda',
            last: 'Katz'
          }
        });
      });
      this.assertContent('Katz');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'proxyOrObject', _runtime.ObjectProxy.create({
          content: {
            name: {
              first: 'Godfrey',
              last: 'Chan'
            }
          }
        }));
      });
      this.assertContent('Chan');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'proxyOrObject.content.name', {
          first: 'Stefan',
          last: 'Penner'
        });
      });
      this.assertContent('Penner');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'proxyOrObject', null);
      });
      this.assertIsEmpty();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'proxyOrObject', _runtime.ObjectProxy.create({
          content: {
            name: {
              first: 'Tom',
              last: 'Dale'
            }
          }
        }));
      });
      this.assertContent('Dale');
      this.assertInvariants();
    };

    _proto2['@test it can read from a path flipping between a real object and a proxy'] = function testItCanReadFromAPathFlippingBetweenARealObjectAndAProxy() {
      var _this15 = this;

      this.renderPath('objectOrProxy.name.last', {
        objectOrProxy: {
          name: {
            first: 'Tom',
            last: 'Dale'
          }
        }
      });
      this.assertContent('Dale');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'objectOrProxy', _runtime.ObjectProxy.create({
          content: {
            name: {
              first: 'Tom',
              last: 'Dale'
            }
          }
        }));
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'objectOrProxy.content.name.last', 'Cruise');
      });
      this.assertContent('Cruise');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'objectOrProxy.content.name.first', 'Suri');
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'objectOrProxy.content', {
          name: {
            first: 'Yehuda',
            last: 'Katz'
          }
        });
      });
      this.assertContent('Katz');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'objectOrProxy', {
          name: {
            first: 'Godfrey',
            last: 'Chan'
          }
        });
      });
      this.assertContent('Chan');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'objectOrProxy.name', {
          first: 'Stefan',
          last: 'Penner'
        });
      });
      this.assertContent('Penner');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'objectOrProxy', null);
      });
      this.assertIsEmpty();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'objectOrProxy', {
          name: {
            first: 'Tom',
            last: 'Dale'
          }
        });
      });
      this.assertContent('Dale');
      this.assertInvariants();
    };

    _proto2['@test it can read from a null object'] = function testItCanReadFromANullObject() {
      var _this16 = this;

      var nullObject = Object.create(null);
      nullObject['message'] = 'hello';
      this.renderPath('nullObject.message', {
        nullObject: nullObject
      });
      this.assertContent('hello');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(nullObject, 'message', 'goodbye');
      });
      this.assertContent('goodbye');
      this.assertInvariants();
      nullObject = Object.create(null);
      nullObject['message'] = 'hello';
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this16.context, 'nullObject', nullObject);
      });
      this.assertContent('hello');
      this.assertInvariants();
    };

    _proto2['@test it can render a readOnly property of a path'] = function testItCanRenderAReadOnlyPropertyOfAPath() {
      var _this17 = this;

      var Messenger = _runtime.Object.extend({
        message: (0, _computed.readOnly)('a.b.c')
      });

      var messenger = Messenger.create({
        a: {
          b: {
            c: 'hello'
          }
        }
      });
      this.renderPath('messenger.message', {
        messenger: messenger
      });
      this.assertContent('hello');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(messenger, 'a.b.c', 'hi');
      });
      this.assertContent('hi');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this17.context, 'messenger.a.b', {
          c: 'goodbye'
        });
      });
      this.assertContent('goodbye');
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this17.context, 'messenger', {
          message: 'hello'
        });
      });
      this.assertContent('hello');
      this.assertInvariants();
    };

    _proto2['@test it can render a property on a function'] = function testItCanRenderAPropertyOnAFunction() {
      var func = function () {};

      func.aProp = 'this is a property on a function';
      this.renderPath('func.aProp', {
        func: func
      });
      this.assertContent('this is a property on a function');
      this.assertStableRerender(); // runTask(() => set(func, 'aProp', 'still a property on a function'));
      // this.assertContent('still a property on a function');
      // this.assertInvariants();
      // func = () => {};
      // func.aProp = 'a prop on a new function';
      // runTask(() => set(this.context, 'func', func));
      // this.assertContent('a prop on a new function');
      // this.assertInvariants();
    };

    return DynamicContentTest;
  }(_internalTestHelpers.RenderingTestCase);

  var EMPTY = {};

  var ContentTestGenerator =
  /*#__PURE__*/
  function () {
    function ContentTestGenerator(cases) {
      var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '@test';
      this.cases = cases;
      this.tag = tag;
    }

    var _proto3 = ContentTestGenerator.prototype;

    _proto3.generate = function generate(_ref) {
      var value = _ref[0],
          expected = _ref[1],
          label = _ref[2];
      var tag = this.tag;
      label = label || value;

      if (expected === EMPTY) {
        var _ref2;

        return _ref2 = {}, _ref2[tag + " rendering " + label] = function () {
          var _this18 = this;

          this.renderPath('value', {
            value: value
          });
          this.assertIsEmpty();
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this18.context, 'value', 'hello');
          });
          this.assertContent('hello');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this18.context, 'value', value);
          });
          this.assertIsEmpty();
        }, _ref2;
      } else {
        var _ref3;

        return _ref3 = {}, _ref3[tag + " rendering " + label] = function () {
          var _this19 = this;

          this.renderPath('value', {
            value: value
          });
          this.assertContent(expected);
          this.assertStableRerender();
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this19.context, 'value', 'hello');
          });
          this.assertContent('hello');
          this.assertInvariants();
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this19.context, 'value', value);
          });
          this.assertContent(expected);
          this.assertInvariants();
        }, _ref3;
      }
    };

    return ContentTestGenerator;
  }();

  var SharedContentTestCases = new ContentTestGenerator([['foo', 'foo'], [0, '0'], [-0, '0', '-0'], [1, '1'], [-1, '-1'], [0.0, '0', '0.0'], [0.5, '0.5'], [undefined, EMPTY], [null, EMPTY], [true, 'true'], [false, 'false'], [NaN, 'NaN'], [new Date(2000, 0, 1), String(new Date(2000, 0, 1)), 'a Date object'], [Infinity, 'Infinity'], [1 / -0, '-Infinity'], [{
    foo: 'bar'
  }, '[object Object]', "{ foo: 'bar' }"], [{
    toString: function () {
      return 'foo';
    }
  }, 'foo', 'an object with a custom toString function'], [{
    valueOf: function () {
      return 1;
    }
  }, '[object Object]', 'an object with a custom valueOf function'], // Escaping tests
  ['<b>Max</b><b>James</b>', '<b>Max</b><b>James</b>']]);
  var GlimmerContentTestCases = new ContentTestGenerator([[Object.create(null), EMPTY, 'an object with no toString']]);

  if (_utils.HAS_NATIVE_SYMBOL) {
    GlimmerContentTestCases.cases.push([Symbol('debug'), 'Symbol(debug)', 'a symbol']);
  }

  (0, _internalTestHelpers.applyMixins)(DynamicContentTest, SharedContentTestCases, GlimmerContentTestCases);
  (0, _internalTestHelpers.moduleFor)('Dynamic content tests (content position)',
  /*#__PURE__*/
  function (_DynamicContentTest) {
    (0, _emberBabel.inheritsLoose)(_class2, _DynamicContentTest);

    function _class2() {
      return _DynamicContentTest.apply(this, arguments) || this;
    }

    var _proto4 = _class2.prototype;

    _proto4.renderPath = function renderPath(path) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.render("{{" + path + "}}", context);
    };

    _proto4.assertContent = function assertContent(content) {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one text node');
      this.assertTextNode(this.firstChild, content); // this.takeSnapshot();
    };

    _proto4['@test it can render empty safe strings [GH#16314]'] = function testItCanRenderEmptySafeStringsGH16314() {
      var _this20 = this;

      this.render('before {{value}} after', {
        value: (0, _helpers.htmlSafe)('hello')
      });
      this.assertHTML('before hello after');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this20.context, 'value', (0, _helpers.htmlSafe)(''));
      });
      this.assertHTML('before <!----> after');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this20.context, 'value', (0, _helpers.htmlSafe)('hello'));
      });
      this.assertHTML('before hello after');
    };

    return _class2;
  }(DynamicContentTest));
  (0, _internalTestHelpers.moduleFor)('Dynamic content tests (content concat)',
  /*#__PURE__*/
  function (_DynamicContentTest2) {
    (0, _emberBabel.inheritsLoose)(_class3, _DynamicContentTest2);

    function _class3() {
      return _DynamicContentTest2.apply(this, arguments) || this;
    }

    var _proto5 = _class3.prototype;

    _proto5.renderPath = function renderPath(path) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.render("{{concat \"\" " + path + " \"\"}}", context);
    };

    _proto5.assertContent = function assertContent(content) {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one text node');
      this.assertTextNode(this.firstChild, content);
    };

    return _class3;
  }(DynamicContentTest));
  (0, _internalTestHelpers.moduleFor)('Dynamic content tests (inside an element)',
  /*#__PURE__*/
  function (_DynamicContentTest3) {
    (0, _emberBabel.inheritsLoose)(_class4, _DynamicContentTest3);

    function _class4() {
      return _DynamicContentTest3.apply(this, arguments) || this;
    }

    var _proto6 = _class4.prototype;

    _proto6.renderPath = function renderPath(path) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.render("<p>{{" + path + "}}</p>", context);
    };

    _proto6.assertIsEmpty = function assertIsEmpty() {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one <p> tag');
      this.assertElement(this.firstChild, {
        tagName: 'p'
      });
      this.assertText('');
    };

    _proto6.assertContent = function assertContent(content) {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one <p> tag');
      this.assertElement(this.firstChild, {
        tagName: 'p'
      });
      this.assertText(content);
    };

    return _class4;
  }(DynamicContentTest));
  (0, _internalTestHelpers.moduleFor)('Dynamic content tests (attribute position)',
  /*#__PURE__*/
  function (_DynamicContentTest4) {
    (0, _emberBabel.inheritsLoose)(_class5, _DynamicContentTest4);

    function _class5() {
      return _DynamicContentTest4.apply(this, arguments) || this;
    }

    var _proto7 = _class5.prototype;

    _proto7.renderPath = function renderPath(path) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.render("<div data-foo=\"{{" + path + "}}\"></div>", context);
    };

    _proto7.assertIsEmpty = function assertIsEmpty() {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one <div> tag');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: ''
      });
    };

    _proto7.assertContent = function assertContent(content) {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one <div> tag');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          'data-foo': content
        },
        content: ''
      });
    };

    return _class5;
  }(DynamicContentTest));

  var TrustedContentTest =
  /*#__PURE__*/
  function (_DynamicContentTest5) {
    (0, _emberBabel.inheritsLoose)(TrustedContentTest, _DynamicContentTest5);

    function TrustedContentTest() {
      return _DynamicContentTest5.apply(this, arguments) || this;
    }

    var _proto8 = TrustedContentTest.prototype;

    _proto8.assertIsEmpty = function assertIsEmpty() {
      this.assert.strictEqual(this.firstChild, null);
    };

    _proto8.assertContent = function assertContent(content) {
      this.assertHTML(content);
    };

    _proto8.assertStableRerender = function assertStableRerender() {
      var _this21 = this;

      this.takeSnapshot();
      (0, _internalTestHelpers.runTask)(function () {
        return _this21.rerender();
      });

      _DynamicContentTest5.prototype.assertInvariants.call(this);
    };

    _proto8.assertInvariants = function assertInvariants() {// If it's not stable, we will wipe out all the content and replace them,
      // so there are no invariants
    };

    return TrustedContentTest;
  }(DynamicContentTest);

  (0, _internalTestHelpers.moduleFor)('Dynamic content tests (trusted)',
  /*#__PURE__*/
  function (_TrustedContentTest) {
    (0, _emberBabel.inheritsLoose)(_class6, _TrustedContentTest);

    function _class6() {
      return _TrustedContentTest.apply(this, arguments) || this;
    }

    var _proto9 = _class6.prototype;

    _proto9.renderPath = function renderPath(path) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.render("{{{" + path + "}}}", context);
    };

    _proto9['@test updating trusted curlies'] = function testUpdatingTrustedCurlies() {
      var _this22 = this;

      this.render('{{{htmlContent}}}{{{nested.htmlContent}}}', {
        htmlContent: '<b>Max</b>',
        nested: {
          htmlContent: '<b>James</b>'
        }
      });
      this.assertContent('<b>Max</b><b>James</b>');
      (0, _internalTestHelpers.runTask)(function () {
        return _this22.rerender();
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this22.context, 'htmlContent', '<i>M</i><u>a</u><s>x</s>');
      });
      this.assertContent('<i>M</i><u>a</u><s>x</s><b>James</b>');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this22.context, 'nested.htmlContent', 'Jammie');
      });
      this.assertContent('<i>M</i><u>a</u><s>x</s>Jammie');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this22.context, 'htmlContent', '<b>Max</b>');
        (0, _metal.set)(_this22.context, 'nested', {
          htmlContent: '<i>James</i>'
        });
      });
      this.assertContent('<b>Max</b><i>James</i>');
    };

    _proto9['@test empty content in trusted curlies [GH#14978]'] = function testEmptyContentInTrustedCurliesGH14978() {
      var _this23 = this;

      this.render('before {{{value}}} after', {
        value: 'hello'
      });
      this.assertContent('before hello after');
      (0, _internalTestHelpers.runTask)(function () {
        return _this23.rerender();
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this23.context, 'value', undefined);
      });
      this.assertContent('before <!----> after');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this23.context, 'value', 'hello');
      });
      this.assertContent('before hello after');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this23.context, 'value', null);
      });
      this.assertContent('before <!----> after');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this23.context, 'value', 'hello');
      });
      this.assertContent('before hello after');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this23.context, 'value', '');
      });
      this.assertContent('before <!----> after');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this23.context, 'value', 'hello');
      });
      this.assertContent('before hello after');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this23.context, 'value', (0, _helpers.htmlSafe)(''));
      });
      this.assertContent('before <!----> after');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this23.context, 'value', 'hello');
      });
      this.assertContent('before hello after');
    };

    return _class6;
  }(TrustedContentTest));
  (0, _internalTestHelpers.moduleFor)('Dynamic content tests (integration)',
  /*#__PURE__*/
  function (_RenderingTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class7, _RenderingTestCase3);

    function _class7() {
      return _RenderingTestCase3.apply(this, arguments) || this;
    }

    var _proto10 = _class7.prototype;

    _proto10['@test it can render a dynamic template'] = function testItCanRenderADynamicTemplate() {
      var _this24 = this;

      var template = "\n      <div class=\"header\">\n        <h1>Welcome to {{framework}}</h1>\n      </div>\n      <div class=\"body\">\n        <h2>Why you should use {{framework}}?</h2>\n        <ol>\n          <li>It's great</li>\n          <li>It's awesome</li>\n          <li>It's {{framework}}</li>\n        </ol>\n      </div>\n      <div class=\"footer\">\n        {{framework}} is free, open source and always will be.\n      </div>\n    ";
      var ember = "\n      <div class=\"header\">\n        <h1>Welcome to Ember.js</h1>\n      </div>\n      <div class=\"body\">\n        <h2>Why you should use Ember.js?</h2>\n        <ol>\n          <li>It's great</li>\n          <li>It's awesome</li>\n          <li>It's Ember.js</li>\n        </ol>\n      </div>\n      <div class=\"footer\">\n        Ember.js is free, open source and always will be.\n      </div>\n    ";
      var react = "\n      <div class=\"header\">\n        <h1>Welcome to React</h1>\n      </div>\n      <div class=\"body\">\n        <h2>Why you should use React?</h2>\n        <ol>\n          <li>It's great</li>\n          <li>It's awesome</li>\n          <li>It's React</li>\n        </ol>\n      </div>\n      <div class=\"footer\">\n        React is free, open source and always will be.\n      </div>\n    ";
      this.render(template, {
        framework: 'Ember.js'
      });
      this.assertHTML(ember);
      (0, _internalTestHelpers.runTask)(function () {
        return _this24.rerender();
      });
      this.assertHTML(ember);
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this24.context, 'framework', 'React');
      });
      this.assertHTML(react);
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this24.context, 'framework', 'Ember.js');
      });
      this.assertHTML(ember);
    };

    _proto10['@test it should evaluate to nothing if part of the path is `undefined`'] = function testItShouldEvaluateToNothingIfPartOfThePathIsUndefined() {
      var _this25 = this;

      this.render('{{foo.bar.baz.bizz}}', {
        foo: {}
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return _this25.rerender();
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this25.context, 'foo', {
          bar: {
            baz: {
              bizz: 'Hey!'
            }
          }
        });
      });
      this.assertText('Hey!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this25.context, 'foo', {});
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this25.context, 'foo', {
          bar: {
            baz: {
              bizz: 'Hello!'
            }
          }
        });
      });
      this.assertText('Hello!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this25.context, 'foo', {});
      });
      this.assertText('');
    };

    _proto10['@test it should evaluate to nothing if part of the path is a primative'] = function testItShouldEvaluateToNothingIfPartOfThePathIsAPrimative() {
      var _this26 = this;

      this.render('{{foo.bar.baz.bizz}}', {
        foo: {
          bar: true
        }
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return _this26.rerender();
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this26.context, 'foo', {
          bar: false
        });
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this26.context, 'foo', {
          bar: 'Haha'
        });
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this26.context, 'foo', {
          bar: null
        });
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this26.context, 'foo', {
          bar: undefined
        });
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this26.context, 'foo', {
          bar: 1
        });
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this26.context, 'foo', {
          bar: {
            baz: {
              bizz: 'Hello!'
            }
          }
        });
      });
      this.assertText('Hello!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this26.context, 'foo', {
          bar: true
        });
      });
      this.assertText('');
    };

    _proto10['@test can set dynamic href'] = function testCanSetDynamicHref() {
      var _this27 = this;

      this.render('<a href={{model.url}}>Example</a>', {
        model: {
          url: 'http://example.com'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'a',
        content: 'Example',
        attrs: {
          href: 'http://example.com'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this27.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'a',
        content: 'Example',
        attrs: {
          href: 'http://example.com'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this27.context, 'model.url', 'http://linkedin.com');
      });
      this.assertElement(this.firstChild, {
        tagName: 'a',
        content: 'Example',
        attrs: {
          href: 'http://linkedin.com'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this27.context, 'model', {
          url: 'http://example.com'
        });
      });
      this.assertElement(this.firstChild, {
        tagName: 'a',
        content: 'Example',
        attrs: {
          href: 'http://example.com'
        }
      });
    };

    _proto10['@test quoteless class attributes update correctly'] = function testQuotelessClassAttributesUpdateCorrectly() {
      var _this28 = this;

      this.render('<div class={{if fooBar "foo-bar"}}>hello</div>', {
        fooBar: true
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo-bar')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this28.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo-bar')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this28.context, 'fooBar', false);
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this28.context, 'fooBar', true);
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo-bar')
        }
      });
    };

    _proto10['@test quoted class attributes update correctly'] = function testQuotedClassAttributesUpdateCorrectly(assert) {
      var _this29 = this;

      this.render('<div class="{{if fooBar "foo-bar"}}">hello</div>', {
        fooBar: true
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo-bar')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this29.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo-bar')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this29.context, 'fooBar', false);
      });
      assert.equal(this.firstChild.className, '');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this29.context, 'fooBar', true);
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo-bar')
        }
      });
    };

    _proto10['@test unquoted class attribute can contain multiple classes'] = function testUnquotedClassAttributeCanContainMultipleClasses() {
      var _this30 = this;

      this.render('<div class={{model.classes}}>hello</div>', {
        model: {
          classes: 'foo bar baz'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar baz')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this30.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar baz')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this30.context, 'model.classes', 'fizz bizz');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('fizz bizz')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this30.context, 'model', {
          classes: 'foo bar baz'
        });
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar baz')
        }
      });
    };

    _proto10['@test unquoted class attribute'] = function testUnquotedClassAttribute() {
      var _this31 = this;

      this.render('<div class={{model.foo}}>hello</div>', {
        model: {
          foo: 'foo'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this31.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this31.context, 'model.foo', 'fizz');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('fizz')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this31.context, 'model', {
          foo: 'foo'
        });
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo')
        }
      });
    };

    _proto10['@test quoted class attribute'] = function testQuotedClassAttribute() {
      var _this32 = this;

      this.render('<div class="{{model.foo}}">hello</div>', {
        model: {
          foo: 'foo'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this32.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this32.context, 'model.foo', 'fizz');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('fizz')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this32.context, 'model', {
          foo: 'foo'
        });
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo')
        }
      });
    };

    _proto10['@test quoted class attribute can contain multiple classes'] = function testQuotedClassAttributeCanContainMultipleClasses() {
      var _this33 = this;

      this.render('<div class="{{model.classes}}">hello</div>', {
        model: {
          classes: 'foo bar baz'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar baz')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this33.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar baz')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this33.context, 'model.classes', 'fizz bizz');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('fizz bizz')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this33.context, 'model', {
          classes: 'foo bar baz'
        });
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar baz')
        }
      });
    };

    _proto10['@test class attribute concats bound values'] = function testClassAttributeConcatsBoundValues() {
      var _this34 = this;

      this.render('<div class="{{model.foo}} {{model.bar}} {{model.bizz}}">hello</div>', {
        model: {
          foo: 'foo',
          bar: 'bar',
          bizz: 'bizz'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar bizz')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this34.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar bizz')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this34.context, 'model.foo', 'fizz');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('fizz bar bizz')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this34.context, 'model.bar', null);
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('fizz bizz')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this34.context, 'model', {
          foo: 'foo',
          bar: 'bar',
          bizz: 'bizz'
        });
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar bizz')
        }
      });
    };

    _proto10['@test class attribute accepts nested helpers, and updates'] = function testClassAttributeAcceptsNestedHelpersAndUpdates() {
      var _this35 = this;

      this.render("<div class=\"{{if model.hasSize model.size}} {{if model.hasShape model.shape}}\">hello</div>", {
        model: {
          size: 'large',
          hasSize: true,
          hasShape: false,
          shape: 'round'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('large')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this35.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('large')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this35.context, 'model.hasShape', true);
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('large round')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this35.context, 'model.hasSize', false);
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('round')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this35.context, 'model', {
          size: 'large',
          hasSize: true,
          hasShape: false,
          shape: 'round'
        });
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('large')
        }
      });
    };

    _proto10['@test Multiple dynamic classes'] = function testMultipleDynamicClasses() {
      var _this36 = this;

      this.render('<div class="{{model.foo}} {{model.bar}} {{model.fizz}} {{model.baz}}">hello</div>', {
        model: {
          foo: 'foo',
          bar: 'bar',
          fizz: 'fizz',
          baz: 'baz'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar fizz baz')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this36.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar fizz baz')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this36.context, 'model.foo', null);
        (0, _metal.set)(_this36.context, 'model.fizz', null);
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('bar baz')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this36.context, 'model', {
          foo: 'foo',
          bar: 'bar',
          fizz: 'fizz',
          baz: 'baz'
        });
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: (0, _internalTestHelpers.classes)('foo bar fizz baz')
        }
      });
    };

    _proto10['@test classes are ordered: See issue #9912'] = function testClassesAreOrderedSeeIssue9912() {
      var _this37 = this;

      this.render('<div class="{{model.foo}}  static   {{model.bar}}">hello</div>', {
        model: {
          foo: 'foo',
          bar: 'bar'
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: 'foo  static   bar'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this37.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: 'foo  static   bar'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this37.context, 'model.bar', null);
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: 'foo  static   '
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this37.context, 'model', {
          foo: 'foo',
          bar: 'bar'
        });
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: 'hello',
        attrs: {
          class: 'foo  static   bar'
        }
      });
    };

    return _class7;
  }(_internalTestHelpers.RenderingTestCase));
  var warnings, originalWarn;

  var StyleTest =
  /*#__PURE__*/
  function (_RenderingTestCase4) {
    (0, _emberBabel.inheritsLoose)(StyleTest, _RenderingTestCase4);

    function StyleTest() {
      var _this38;

      _this38 = _RenderingTestCase4.apply(this, arguments) || this;
      warnings = [];
      originalWarn = (0, _debug.getDebugFunction)('warn');
      (0, _debug.setDebugFunction)('warn', function (message, test) {
        if (!test) {
          warnings.push(message);
        }
      });
      return _this38;
    }

    var _proto11 = StyleTest.prototype;

    _proto11.teardown = function teardown() {
      _RenderingTestCase4.prototype.teardown.apply(this, arguments);

      (0, _debug.setDebugFunction)('warn', originalWarn);
    };

    _proto11.assertStyleWarning = function assertStyleWarning(style) {
      this.assert.deepEqual(warnings, [(0, _views.constructStyleDeprecationMessage)(style)]);
    };

    _proto11.assertNoWarning = function assertNoWarning() {
      this.assert.deepEqual(warnings, []);
    };

    return StyleTest;
  }(_internalTestHelpers.RenderingTestCase);

  (0, _internalTestHelpers.moduleFor)('Inline style tests',
  /*#__PURE__*/
  function (_StyleTest) {
    (0, _emberBabel.inheritsLoose)(_class8, _StyleTest);

    function _class8() {
      return _StyleTest.apply(this, arguments) || this;
    }

    var _proto12 = _class8.prototype;

    _proto12['@test can set dynamic style'] = function testCanSetDynamicStyle() {
      var _this39 = this;

      this.render('<div style={{model.style}}></div>', {
        model: {
          style: (0, _helpers.htmlSafe)('width: 60px;')
        }
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: '',
        attrs: {
          style: 'width: 60px;'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this39.rerender();
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: '',
        attrs: {
          style: 'width: 60px;'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this39.context, 'model.style', 'height: 60px;');
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: '',
        attrs: {
          style: 'height: 60px;'
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this39.context, 'model.style', null);
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: '',
        attrs: {}
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this39.context, 'model', {
          style: 'width: 60px;'
        });
      });
      this.assertElement(this.firstChild, {
        tagName: 'div',
        content: '',
        attrs: {
          style: 'width: 60px;'
        }
      });
    };

    return _class8;
  }(StyleTest));

  if (!EmberDev.runningProdBuild) {
    (0, _internalTestHelpers.moduleFor)('Inline style tests - warnings',
    /*#__PURE__*/
    function (_StyleTest2) {
      (0, _emberBabel.inheritsLoose)(_class9, _StyleTest2);

      function _class9() {
        return _StyleTest2.apply(this, arguments) || this;
      }

      var _proto13 = _class9.prototype;

      _proto13['@test specifying <div style={{userValue}}></div> generates a warning'] = function testSpecifyingDivStyleUserValueDivGeneratesAWarning() {
        var userValue = 'width: 42px';
        this.render('<div style={{userValue}}></div>', {
          userValue: userValue
        });
        this.assertStyleWarning(userValue);
      };

      _proto13['@test specifying `attributeBindings: ["style"]` generates a warning'] = function testSpecifyingAttributeBindingsStyleGeneratesAWarning() {
        var FooBarComponent = _helpers.Component.extend({
          attributeBindings: ['style']
        });

        this.registerComponent('foo-bar', {
          ComponentClass: FooBarComponent,
          template: 'hello'
        });
        var userValue = 'width: 42px';
        this.render('{{foo-bar style=userValue}}', {
          userValue: userValue
        });
        this.assertStyleWarning(userValue);
      };

      _proto13['@test specifying `<div style={{{userValue}}}></div>` works properly without a warning'] = function testSpecifyingDivStyleUserValueDivWorksProperlyWithoutAWarning() {
        this.render('<div style={{{userValue}}}></div>', {
          userValue: 'width: 42px'
        });
        this.assertNoWarning();
      };

      _proto13['@test specifying `<div style={{userValue}}></div>` works properly with a SafeString'] = function testSpecifyingDivStyleUserValueDivWorksProperlyWithASafeString() {
        this.render('<div style={{userValue}}></div>', {
          userValue: new _helpers.SafeString('width: 42px')
        });
        this.assertNoWarning();
      };

      _proto13['@test null value do not generate htmlsafe warning'] = function testNullValueDoNotGenerateHtmlsafeWarning() {
        this.render('<div style={{userValue}}></div>', {
          userValue: null
        });
        this.assertNoWarning();
      };

      _proto13['@test undefined value do not generate htmlsafe warning'] = function testUndefinedValueDoNotGenerateHtmlsafeWarning() {
        this.render('<div style={{userValue}}></div>');
        this.assertNoWarning();
      };

      _proto13['@test no warnings are triggered when a safe string is quoted'] = function testNoWarningsAreTriggeredWhenASafeStringIsQuoted() {
        this.render('<div style="{{userValue}}"></div>', {
          userValue: new _helpers.SafeString('width: 42px')
        });
        this.assertNoWarning();
      };

      _proto13['@test binding warning is triggered when an unsafe string is quoted'] = function testBindingWarningIsTriggeredWhenAnUnsafeStringIsQuoted() {
        var userValue = 'width: 42px';
        this.render('<div style="{{userValue}}"></div>', {
          userValue: userValue
        });
        this.assertStyleWarning(userValue);
      };

      _proto13['@test binding warning is triggered when a safe string for a complete property is concatenated in place'] = function testBindingWarningIsTriggeredWhenASafeStringForACompletePropertyIsConcatenatedInPlace() {
        var userValue = 'width: 42px';
        this.render('<div style="color: green; {{userValue}}"></div>', {
          userValue: new _helpers.SafeString('width: 42px')
        });
        this.assertStyleWarning("color: green; " + userValue);
      };

      _proto13['@test binding warning is triggered when a safe string for a value is concatenated in place'] = function testBindingWarningIsTriggeredWhenASafeStringForAValueIsConcatenatedInPlace() {
        var userValue = '42px';
        this.render('<div style="color: green; width: {{userValue}}"></div>', {
          userValue: new _helpers.SafeString(userValue)
        });
        this.assertStyleWarning("color: green; width: " + userValue);
      };

      _proto13['@test binding warning is triggered when a safe string for a property name is concatenated in place'] = function testBindingWarningIsTriggeredWhenASafeStringForAPropertyNameIsConcatenatedInPlace() {
        var userValue = 'width';
        this.render('<div style="color: green; {{userProperty}}: 42px"></div>', {
          userProperty: new _helpers.SafeString(userValue)
        });
        this.assertStyleWarning("color: green; " + userValue + ": 42px");
      };

      return _class9;
    }(StyleTest));
  }
});
enifed("@ember/-internals/glimmer/tests/integration/custom-component-manager-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime", "@ember/-internals/metal", "@ember/-internals/glimmer"], function (_emberBabel, _internalTestHelpers, _runtime, _metal, _glimmer) {
  "use strict";

  var BasicComponentManager = _runtime.Object.extend({
    capabilities: (0, _glimmer.capabilities)('3.4'),
    createComponent: function (factory, args) {
      return factory.create({
        args: args
      });
    },
    updateComponent: function (component, args) {
      (0, _metal.set)(component, 'args', args);
    },
    getContext: function (component) {
      return component;
    }
  });
  /* eslint-disable */


  function createBasicManager(owner) {
    return BasicComponentManager.create({
      owner: owner
    });
  }

  function createInstrumentedManager(owner) {
    return InstrumentedComponentManager.create({
      owner: owner
    });
  }
  /* eslint-enable */


  var InstrumentedComponentManager;

  var ComponentManagerTest =
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(ComponentManagerTest, _RenderingTestCase);

    function ComponentManagerTest(assert) {
      var _this;

      _this = _RenderingTestCase.apply(this, arguments) || this;
      InstrumentedComponentManager = _runtime.Object.extend({
        capabilities: (0, _glimmer.capabilities)('3.4', {
          destructor: true,
          asyncLifecycleCallbacks: true
        }),
        createComponent: function (factory, args) {
          assert.step('createComponent');
          return factory.create({
            args: args
          });
        },
        updateComponent: function (component, args) {
          assert.step('updateComponent');
          (0, _metal.set)(component, 'args', args);
        },
        destroyComponent: function (component) {
          assert.step('destroyComponent');
          component.destroy();
        },
        getContext: function (component) {
          assert.step('getContext');
          return component;
        },
        didCreateComponent: function (component) {
          assert.step('didCreateComponent');
          component.didRender();
        },
        didUpdateComponent: function (component) {
          assert.step('didUpdateComponent');
          component.didUpdate();
        }
      });
      return _this;
    }

    return ComponentManagerTest;
  }(_internalTestHelpers.RenderingTestCase);

  (0, _internalTestHelpers.moduleFor)('Component Manager - Curly Invocation',
  /*#__PURE__*/
  function (_ComponentManagerTest) {
    (0, _emberBabel.inheritsLoose)(_class, _ComponentManagerTest);

    function _class() {
      return _ComponentManagerTest.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test the string based version of setComponentManager is deprecated'] = function testTheStringBasedVersionOfSetComponentManagerIsDeprecated() {
      expectDeprecation(function () {
        (0, _glimmer.setComponentManager)('basic', _runtime.Object.extend({
          greeting: 'hello'
        }));
      }, 'Passing the name of the component manager to "setupComponentManager" is deprecated. Please pass a function that produces an instance of the manager.');
    };

    _proto['@test it can render a basic component with custom component manager'] = function testItCanRenderABasicComponentWithCustomComponentManager() {
      var ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _runtime.Object.extend({
        greeting: 'hello'
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{greeting}} world</p>",
        ComponentClass: ComponentClass
      });
      this.render('{{foo-bar}}');
      this.assertHTML("<p>hello world</p>");
    };

    _proto['@test it can render a basic component with custom component manager with a factory'] = function testItCanRenderABasicComponentWithCustomComponentManagerWithAFactory() {
      var ComponentClass = (0, _glimmer.setComponentManager)(function () {
        return BasicComponentManager.create();
      }, _runtime.Object.extend({
        greeting: 'hello'
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{greeting}} world</p>",
        ComponentClass: ComponentClass
      });
      this.render('{{foo-bar}}');
      this.assertHTML("<p>hello world</p>");
    };

    _proto['@test it can have no template context'] = function testItCanHaveNoTemplateContext() {
      var ComponentClass = (0, _glimmer.setComponentManager)(function () {
        return _runtime.Object.create({
          capabilities: (0, _glimmer.capabilities)('3.4'),
          createComponent: function () {
            return null;
          },
          updateComponent: function () {},
          getContext: function () {
            return null;
          }
        });
      }, {});
      this.registerComponent('foo-bar', {
        template: "<p>{{@greeting}} world</p>",
        ComponentClass: ComponentClass
      });
      this.render('{{foo-bar greeting="hello"}}');
      this.assertHTML("<p>hello world</p>");
    };

    _proto['@test it can discover component manager through inheritance - ES Classes'] = function testItCanDiscoverComponentManagerThroughInheritanceESClasses() {
      var Base = function Base() {};

      (0, _glimmer.setComponentManager)(function () {
        return _runtime.Object.create({
          capabilities: (0, _glimmer.capabilities)('3.4'),
          createComponent: function (Factory, args) {
            return new Factory(args);
          },
          updateComponent: function () {},
          getContext: function (component) {
            return component;
          }
        });
      }, Base);

      var Child =
      /*#__PURE__*/
      function (_Base) {
        (0, _emberBabel.inheritsLoose)(Child, _Base);

        function Child() {
          return _Base.apply(this, arguments) || this;
        }

        return Child;
      }(Base);

      var Grandchild =
      /*#__PURE__*/
      function (_Child) {
        (0, _emberBabel.inheritsLoose)(Grandchild, _Child);

        function Grandchild() {
          var _this2;

          _this2 = _Child.call(this) || this;
          _this2.name = 'grandchild';
          return _this2;
        }

        return Grandchild;
      }(Child);

      this.registerComponent('foo-bar', {
        template: "{{this.name}}",
        ComponentClass: Grandchild
      });
      this.render('{{foo-bar}}');
      this.assertHTML("grandchild");
    };

    _proto['@test it can discover component manager through inheritance - Ember Object'] = function testItCanDiscoverComponentManagerThroughInheritanceEmberObject() {
      var Parent = (0, _glimmer.setComponentManager)(createBasicManager, _runtime.Object.extend());
      var Child = Parent.extend();
      var Grandchild = Child.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.name = 'grandchild';
        }
      });
      this.registerComponent('foo-bar', {
        template: "{{this.name}}",
        ComponentClass: Grandchild
      });
      this.render('{{foo-bar}}');
      this.assertHTML("grandchild");
    };

    _proto['@test it can customize the template context'] = function testItCanCustomizeTheTemplateContext() {
      var customContext = {
        greeting: 'goodbye'
      };
      var ComponentClass = (0, _glimmer.setComponentManager)(function () {
        return _runtime.Object.create({
          capabilities: (0, _glimmer.capabilities)('3.4'),
          createComponent: function (factory) {
            return factory.create();
          },
          getContext: function () {
            return customContext;
          },
          updateComponent: function () {}
        });
      }, _runtime.Object.extend({
        greeting: 'hello',
        count: 1234
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{greeting}} world {{count}}</p>",
        ComponentClass: ComponentClass
      });
      this.render('{{foo-bar}}');
      this.assertHTML("<p>goodbye world </p>");
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(customContext, 'greeting', 'sayonara');
      });
      this.assertHTML("<p>sayonara world </p>");
    };

    _proto['@test it can set arguments on the component instance'] = function testItCanSetArgumentsOnTheComponentInstance() {
      var ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _runtime.Object.extend({
        salutation: (0, _metal.computed)('args.named.firstName', 'args.named.lastName', function () {
          return this.args.named.firstName + ' ' + this.args.named.lastName;
        })
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{salutation}}</p>",
        ComponentClass: ComponentClass
      });
      this.render('{{foo-bar firstName="Yehuda" lastName="Katz"}}');
      this.assertHTML("<p>Yehuda Katz</p>");
    };

    _proto['@test arguments are updated if they change'] = function testArgumentsAreUpdatedIfTheyChange() {
      var _this3 = this;

      var ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _runtime.Object.extend({
        salutation: (0, _metal.computed)('args.named.firstName', 'args.named.lastName', function () {
          return this.args.named.firstName + ' ' + this.args.named.lastName;
        })
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{salutation}}</p>",
        ComponentClass: ComponentClass
      });
      this.render('{{foo-bar firstName=firstName lastName=lastName}}', {
        firstName: 'Yehuda',
        lastName: 'Katz'
      });
      this.assertHTML("<p>Yehuda Katz</p>");
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.setProperties)(_this3.context, {
          firstName: 'Chad',
          lastName: 'Hietala'
        });
      });
      this.assertHTML("<p>Chad Hietala</p>");
    };

    _proto['@test it can set positional params on the component instance'] = function testItCanSetPositionalParamsOnTheComponentInstance() {
      var ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _runtime.Object.extend({
        salutation: (0, _metal.computed)('args.positional', function () {
          return this.args.positional[0] + ' ' + this.args.positional[1];
        })
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{salutation}}</p>",
        ComponentClass: ComponentClass
      });
      this.render('{{foo-bar "Yehuda" "Katz"}}');
      this.assertHTML("<p>Yehuda Katz</p>");
    };

    _proto['@test positional params are updated if they change'] = function testPositionalParamsAreUpdatedIfTheyChange() {
      var _this4 = this;

      var ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _runtime.Object.extend({
        salutation: (0, _metal.computed)('args.positional', function () {
          return this.args.positional[0] + ' ' + this.args.positional[1];
        })
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{salutation}}</p>",
        ComponentClass: ComponentClass
      });
      this.render('{{foo-bar firstName lastName}}', {
        firstName: 'Yehuda',
        lastName: 'Katz'
      });
      this.assertHTML("<p>Yehuda Katz</p>");
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.setProperties)(_this4.context, {
          firstName: 'Chad',
          lastName: 'Hietala'
        });
      });
      this.assertHTML("<p>Chad Hietala</p>");
    };

    _proto['@test it can opt-in to running destructor'] = function testItCanOptInToRunningDestructor(assert) {
      var _this5 = this;

      var ComponentClass = (0, _glimmer.setComponentManager)(function () {
        return _runtime.Object.create({
          capabilities: (0, _glimmer.capabilities)('3.4', {
            destructor: true
          }),
          createComponent: function (factory) {
            assert.step('createComponent');
            return factory.create();
          },
          getContext: function (component) {
            return component;
          },
          updateComponent: function () {},
          destroyComponent: function (component) {
            assert.step('destroyComponent');
            component.destroy();
          }
        });
      }, _runtime.Object.extend({
        greeting: 'hello',
        destroy: function () {
          assert.step('component.destroy()');

          this._super.apply(this, arguments);
        }
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{greeting}} world</p>",
        ComponentClass: ComponentClass
      });
      this.render('{{#if show}}{{foo-bar}}{{/if}}', {
        show: true
      });
      this.assertHTML("<p>hello world</p>");
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.context.set('show', false);
      });
      this.assertText('');
      assert.verifySteps(['createComponent', 'destroyComponent', 'component.destroy()']);
    };

    _proto['@test it can opt-in to running async lifecycle hooks'] = function testItCanOptInToRunningAsyncLifecycleHooks(assert) {
      var _this6 = this;

      var ComponentClass = (0, _glimmer.setComponentManager)(function () {
        return _runtime.Object.create({
          capabilities: (0, _glimmer.capabilities)('3.4', {
            asyncLifecycleCallbacks: true
          }),
          createComponent: function (factory, args) {
            assert.step('createComponent');
            return factory.create({
              args: args
            });
          },
          updateComponent: function (component, args) {
            assert.step('updateComponent');
            (0, _metal.set)(component, 'args', args);
          },
          destroyComponent: function (component) {
            assert.step('destroyComponent');
            component.destroy();
          },
          getContext: function (component) {
            assert.step('getContext');
            return component;
          },
          didCreateComponent: function () {
            assert.step('didCreateComponent');
          },
          didUpdateComponent: function () {
            assert.step('didUpdateComponent');
          }
        });
      }, _runtime.Object.extend({
        greeting: 'hello'
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{greeting}} {{@name}}</p>",
        ComponentClass: ComponentClass
      });
      this.render('{{foo-bar name=name}}', {
        name: 'world'
      });
      this.assertHTML("<p>hello world</p>");
      assert.verifySteps(['createComponent', 'getContext', 'didCreateComponent']);
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.context.set('name', 'max');
      });
      this.assertHTML("<p>hello max</p>");
      assert.verifySteps(['updateComponent', 'didUpdateComponent']);
    };

    return _class;
  }(ComponentManagerTest));
  (0, _internalTestHelpers.moduleFor)('Component Manager - Angle Invocation',
  /*#__PURE__*/
  function (_ComponentManagerTest2) {
    (0, _emberBabel.inheritsLoose)(_class2, _ComponentManagerTest2);

    function _class2() {
      return _ComponentManagerTest2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test it can render a basic component with custom component manager'] = function testItCanRenderABasicComponentWithCustomComponentManager() {
      var ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _runtime.Object.extend({
        greeting: 'hello'
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{greeting}} world</p>",
        ComponentClass: ComponentClass
      });
      this.render('<FooBar />');
      this.assertHTML("<p>hello world</p>");
    };

    _proto2['@test it can set arguments on the component instance'] = function testItCanSetArgumentsOnTheComponentInstance() {
      var ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _runtime.Object.extend({
        salutation: (0, _metal.computed)('args.named.firstName', 'args.named.lastName', function () {
          return this.args.named.firstName + ' ' + this.args.named.lastName;
        })
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{salutation}}</p>",
        ComponentClass: ComponentClass
      });
      this.render('<FooBar @firstName="Yehuda" @lastName="Katz" />');
      this.assertHTML("<p>Yehuda Katz</p>");
    };

    _proto2['@test it can pass attributes'] = function testItCanPassAttributes() {
      var ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _runtime.Object.extend());
      this.registerComponent('foo-bar', {
        template: "<p ...attributes>Hello world!</p>",
        ComponentClass: ComponentClass
      });
      this.render('<FooBar data-test="foo" />');
      this.assertHTML("<p data-test=\"foo\">Hello world!</p>");
    };

    _proto2['@test arguments are updated if they change'] = function testArgumentsAreUpdatedIfTheyChange() {
      var _this7 = this;

      var ComponentClass = (0, _glimmer.setComponentManager)(createBasicManager, _runtime.Object.extend({
        salutation: (0, _metal.computed)('args.named.firstName', 'args.named.lastName', function () {
          return this.args.named.firstName + ' ' + this.args.named.lastName;
        })
      }));
      this.registerComponent('foo-bar', {
        template: "<p>{{salutation}}</p>",
        ComponentClass: ComponentClass
      });
      this.render('<FooBar @firstName={{firstName}} @lastName={{lastName}} />', {
        firstName: 'Yehuda',
        lastName: 'Katz'
      });
      this.assertHTML("<p>Yehuda Katz</p>");
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.setProperties)(_this7.context, {
          firstName: 'Chad',
          lastName: 'Hietala'
        });
      });
      this.assertHTML("<p>Chad Hietala</p>");
    };

    _proto2['@test updating attributes triggers didUpdateComponent'] = function testUpdatingAttributesTriggersDidUpdateComponent(assert) {
      var _this8 = this;

      var TestManager = _runtime.Object.extend({
        capabilities: (0, _glimmer.capabilities)('3.4', {
          destructor: true,
          asyncLifecycleCallbacks: true
        }),
        createComponent: function (factory, args) {
          assert.step('createComponent');
          return factory.create({
            args: args
          });
        },
        updateComponent: function (component, args) {
          assert.step('updateComponent');
          (0, _metal.set)(component, 'args', args);
        },
        destroyComponent: function (component) {
          component.destroy();
        },
        getContext: function (component) {
          assert.step('getContext');
          return component;
        },
        didCreateComponent: function (component) {
          assert.step('didCreateComponent');
          component.didRender();
        },
        didUpdateComponent: function (component) {
          assert.step('didUpdateComponent');
          component.didUpdate();
        }
      });

      var ComponentClass = (0, _glimmer.setComponentManager)(function () {
        return TestManager.create();
      }, _runtime.Object.extend({
        didRender: function () {},
        didUpdate: function () {}
      }));
      this.registerComponent('foo-bar', {
        template: "<p ...attributes>Hello world!</p>",
        ComponentClass: ComponentClass
      });
      this.render('<FooBar data-test={{value}} />', {
        value: 'foo'
      });
      this.assertHTML("<p data-test=\"foo\">Hello world!</p>");
      assert.verifySteps(['createComponent', 'getContext', 'didCreateComponent']);
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.context.set('value', 'bar');
      });
      assert.verifySteps(['didUpdateComponent']);
    };

    return _class2;
  }(ComponentManagerTest));
});
enifed("@ember/-internals/glimmer/tests/integration/custom-modifier-manager-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime", "@ember/-internals/glimmer", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _runtime, _glimmer, _metal) {
  "use strict";

  var ModifierManagerTest =
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(ModifierManagerTest, _RenderingTestCase);

    function ModifierManagerTest() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    return ModifierManagerTest;
  }(_internalTestHelpers.RenderingTestCase);

  var CustomModifierManager =
  /*#__PURE__*/
  function () {
    function CustomModifierManager(owner) {
      this.owner = owner;
    }

    var _proto = CustomModifierManager.prototype;

    _proto.createModifier = function createModifier(factory, args) {
      return factory.create(args);
    };

    _proto.installModifier = function installModifier(instance, element, args) {
      instance.element = element;
      var positional = args.positional,
          named = args.named;
      instance.didInsertElement(positional, named);
    };

    _proto.updateModifier = function updateModifier(instance, args) {
      var positional = args.positional,
          named = args.named;
      instance.didUpdate(positional, named);
    };

    _proto.destroyModifier = function destroyModifier(instance) {
      instance.willDestroyElement();
    };

    return CustomModifierManager;
  }();

  (0, _internalTestHelpers.moduleFor)('Basic Custom Modifier Manager',
  /*#__PURE__*/
  function (_ModifierManagerTest) {
    (0, _emberBabel.inheritsLoose)(_class, _ModifierManagerTest);

    function _class() {
      return _ModifierManagerTest.apply(this, arguments) || this;
    }

    var _proto2 = _class.prototype;

    _proto2['@test can register a custom element modifier and render it'] = function testCanRegisterACustomElementModifierAndRenderIt(assert) {
      var ModifierClass = (0, _glimmer.setModifierManager)(function (owner) {
        return new CustomModifierManager(owner);
      }, _runtime.Object.extend({
        didInsertElement: function () {},
        didUpdate: function () {},
        willDestroyElement: function () {}
      }));
      this.registerModifier('foo-bar', ModifierClass.extend({
        didInsertElement: function () {
          assert.ok(true, 'Called didInsertElement');
        }
      }));
      this.render('<h1 {{foo-bar}}>hello world</h1>');
      this.assertHTML("<h1>hello world</h1>");
    };

    _proto2['@test custom lifecycle hooks'] = function testCustomLifecycleHooks(assert) {
      var _this = this;

      assert.expect(9);
      var ModifierClass = (0, _glimmer.setModifierManager)(function (owner) {
        return new CustomModifierManager(owner);
      }, _runtime.Object.extend({
        didInsertElement: function () {},
        didUpdate: function () {},
        willDestroyElement: function () {}
      }));
      this.registerModifier('foo-bar', ModifierClass.extend({
        didUpdate: function (_ref) {
          var truthy = _ref[0];
          assert.ok(true, 'Called didUpdate');
          assert.equal(truthy, 'true', 'gets updated args');
        },
        didInsertElement: function (_ref2) {
          var truthy = _ref2[0];
          assert.ok(true, 'Called didInsertElement');
          assert.equal(truthy, true, 'gets initial args');
        },
        willDestroyElement: function () {
          assert.ok(true, 'Called willDestroyElement');
        }
      }));
      this.render('{{#if truthy}}<h1 {{foo-bar truthy}}>hello world</h1>{{/if}}', {
        truthy: true
      });
      this.assertHTML("<h1>hello world</h1>");
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'truthy', 'true');
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'truthy', false);
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'truthy', true);
      });
    };

    _proto2['@test associates manager even through an inheritance structure'] = function testAssociatesManagerEvenThroughAnInheritanceStructure(assert) {
      assert.expect(5);
      var ModifierClass = (0, _glimmer.setModifierManager)(function (owner) {
        return new CustomModifierManager(owner);
      }, _runtime.Object.extend({
        didInsertElement: function () {},
        didUpdate: function () {},
        willDestroyElement: function () {}
      }));
      ModifierClass = ModifierClass.extend({
        didInsertElement: function (_ref3) {
          var truthy = _ref3[0];

          this._super.apply(this, arguments);

          assert.ok(true, 'Called didInsertElement');
          assert.equal(truthy, true, 'gets initial args');
        }
      });
      this.registerModifier('foo-bar', ModifierClass.extend({
        didInsertElement: function (_ref4) {
          var truthy = _ref4[0];

          this._super.apply(this, arguments);

          assert.ok(true, 'Called didInsertElement');
          assert.equal(truthy, true, 'gets initial args');
        }
      }));
      this.render('<h1 {{foo-bar truthy}}>hello world</h1>', {
        truthy: true
      });
      this.assertHTML("<h1>hello world</h1>");
    };

    _proto2['@test can give consistent access to underlying DOM element'] = function testCanGiveConsistentAccessToUnderlyingDOMElement(assert) {
      var _this2 = this;

      assert.expect(4);
      var ModifierClass = (0, _glimmer.setModifierManager)(function (owner) {
        return new CustomModifierManager(owner);
      }, _runtime.Object.extend({
        didInsertElement: function () {},
        didUpdate: function () {},
        willDestroyElement: function () {}
      }));
      this.registerModifier('foo-bar', ModifierClass.extend({
        savedElement: undefined,
        didInsertElement: function () {
          assert.equal(this.element.tagName, 'H1');
          this.set('savedElement', this.element);
        },
        didUpdate: function () {
          assert.equal(this.element, this.savedElement);
        },
        willDestroyElement: function () {
          assert.equal(this.element, this.savedElement);
        }
      }));
      this.render('<h1 {{foo-bar truthy}}>hello world</h1>', {
        truthy: true
      });
      this.assertHTML("<h1>hello world</h1>");
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'truthy', 'true');
      });
    };

    return _class;
  }(ModifierManagerTest));
});
enifed("@ember/-internals/glimmer/tests/integration/event-dispatcher-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/glimmer/tests/utils/helpers", "@ember/runloop", "@ember/instrumentation", "@ember/-internals/views", "@ember/-internals/utils"], function (_emberBabel, _internalTestHelpers, _helpers, _runloop, _instrumentation, _views, _utils) {
  "use strict";

  var canDataTransfer = Boolean(document.createEvent('HTMLEvents').dataTransfer);

  function fireNativeWithDataTransfer(node, type, dataTransfer) {
    var event = document.createEvent('HTMLEvents');
    event.initEvent(type, true, true);
    event.dataTransfer = dataTransfer;
    node.dispatchEvent(event);
  }

  (0, _internalTestHelpers.moduleFor)('EventDispatcher',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test events bubble view hierarchy for form elements'] = function testEventsBubbleViewHierarchyForFormElements(assert) {
      var _this = this;

      var receivedEvent;
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          change: function (event) {
            receivedEvent = event;
          }
        }),
        template: "<input id=\"is-done\" type=\"checkbox\">"
      });
      this.render("{{x-foo}}");
      (0, _internalTestHelpers.runTask)(function () {
        return _this.$('#is-done').trigger('change');
      });
      assert.ok(receivedEvent, 'change event was triggered');
      assert.strictEqual(receivedEvent.target, this.$('#is-done')[0]);
    };

    _proto['@test case insensitive events'] = function testCaseInsensitiveEvents(assert) {
      var _this2 = this;

      var receivedEvent;
      this.registerComponent('x-bar', {
        ComponentClass: _helpers.Component.extend({
          clicked: function (event) {
            receivedEvent = event;
          }
        }),
        template: "<button id=\"is-done\" onclick={{action clicked}}>my button</button>"
      });
      this.render("{{x-bar}}");
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.$('#is-done').trigger('click');
      });
      assert.ok(receivedEvent, 'change event was triggered');
      assert.strictEqual(receivedEvent.target, this.$('#is-done')[0]);
    };

    _proto['@test case sensitive events'] = function testCaseSensitiveEvents(assert) {
      var _this3 = this;

      var receivedEvent;
      this.registerComponent('x-bar', {
        ComponentClass: _helpers.Component.extend({
          clicked: function (event) {
            receivedEvent = event;
          }
        }),
        template: "<button id=\"is-done\" onClick={{action clicked}}>my button</button>"
      });
      this.render("{{x-bar}}");
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.$('#is-done').trigger('click');
      });
      assert.ok(receivedEvent, 'change event was triggered');
      assert.strictEqual(receivedEvent.target, this.$('#is-done')[0]);
    };

    _proto['@test events bubble to parent view'] = function testEventsBubbleToParentView(assert) {
      var _this4 = this;

      var receivedEvent;
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          change: function (event) {
            receivedEvent = event;
          }
        }),
        template: "{{yield}}"
      });
      this.registerComponent('x-bar', {
        ComponentClass: _helpers.Component.extend({
          change: function () {}
        }),
        template: "<input id=\"is-done\" type=\"checkbox\">"
      });
      this.render("{{#x-foo}}{{x-bar}}{{/x-foo}}");
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.$('#is-done').trigger('change');
      });
      assert.ok(receivedEvent, 'change event was triggered');
      assert.strictEqual(receivedEvent.target, this.$('#is-done')[0]);
    };

    _proto['@test events bubbling up can be prevented by returning false'] = function testEventsBubblingUpCanBePreventedByReturningFalse(assert) {
      var _this5 = this;

      var hasReceivedEvent;
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          change: function () {
            hasReceivedEvent = true;
          }
        }),
        template: "{{yield}}"
      });
      this.registerComponent('x-bar', {
        ComponentClass: _helpers.Component.extend({
          change: function () {
            return false;
          }
        }),
        template: "<input id=\"is-done\" type=\"checkbox\">"
      });
      this.render("{{#x-foo}}{{x-bar}}{{/x-foo}}");
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.$('#is-done').trigger('change');
      });
      assert.notOk(hasReceivedEvent, 'change event has not been received');
    };

    _proto['@test events bubbling up can be prevented by calling stopPropagation()'] = function testEventsBubblingUpCanBePreventedByCallingStopPropagation(assert) {
      var _this6 = this;

      var hasReceivedEvent;
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          change: function () {
            hasReceivedEvent = true;
          }
        }),
        template: "{{yield}}"
      });
      this.registerComponent('x-bar', {
        ComponentClass: _helpers.Component.extend({
          change: function (e) {
            e.stopPropagation();
          }
        }),
        template: "<input id=\"is-done\" type=\"checkbox\">"
      });
      this.render("{{#x-foo}}{{x-bar}}{{/x-foo}}");
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.$('#is-done').trigger('change');
      });
      assert.notOk(hasReceivedEvent, 'change event has not been received');
    };

    _proto['@test event handlers are wrapped in a run loop'] = function testEventHandlersAreWrappedInARunLoop(assert) {
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          change: function () {
            assert.ok((0, _runloop.getCurrentRunLoop)(), 'a run loop should have started');
          }
        }),
        template: "<input id=\"is-done\" type=\"checkbox\">"
      });
      this.render("{{x-foo}}");
      this.$('#is-done').trigger('click');
    };

    _proto['@test delegated event listeners work for mouseEnter/Leave'] = function testDelegatedEventListenersWorkForMouseEnterLeave(assert) {
      var _this7 = this;

      var receivedEnterEvents = [];
      var receivedLeaveEvents = [];
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          mouseEnter: function (event) {
            receivedEnterEvents.push(event);
          },
          mouseLeave: function (event) {
            receivedLeaveEvents.push(event);
          }
        }),
        template: "<div id=\"inner\"></div>"
      });
      this.render("{{x-foo id=\"outer\"}}");
      var parent = this.element;
      var outer = this.$('#outer')[0];
      var inner = this.$('#inner')[0]; // mouse moves over #outer

      (0, _internalTestHelpers.runTask)(function () {
        _this7.$(outer).trigger('mouseenter', {
          canBubble: false,
          relatedTarget: parent
        });

        _this7.$(outer).trigger('mouseover', {
          relatedTarget: parent
        });

        _this7.$(parent).trigger('mouseout', {
          relatedTarget: outer
        });
      });
      assert.equal(receivedEnterEvents.length, 1, 'mouseenter event was triggered');
      assert.strictEqual(receivedEnterEvents[0].target, outer); // mouse moves over #inner

      (0, _internalTestHelpers.runTask)(function () {
        _this7.$(inner).trigger('mouseover', {
          relatedTarget: outer
        });

        _this7.$(outer).trigger('mouseout', {
          relatedTarget: inner
        });
      });
      assert.equal(receivedEnterEvents.length, 1, 'mouseenter event was not triggered again'); // mouse moves out of #inner

      (0, _internalTestHelpers.runTask)(function () {
        _this7.$(inner).trigger('mouseout', {
          relatedTarget: outer
        });

        _this7.$(outer).trigger('mouseover', {
          relatedTarget: inner
        });
      });
      assert.equal(receivedLeaveEvents.length, 0, 'mouseleave event was not triggered'); // mouse moves out of #outer

      (0, _internalTestHelpers.runTask)(function () {
        _this7.$(outer).trigger('mouseleave', {
          canBubble: false,
          relatedTarget: parent
        });

        _this7.$(outer).trigger('mouseout', {
          relatedTarget: parent
        });

        _this7.$(parent).trigger('mouseover', {
          relatedTarget: outer
        });
      });
      assert.equal(receivedLeaveEvents.length, 1, 'mouseleave event was triggered');
      assert.strictEqual(receivedLeaveEvents[0].target, outer);
    };

    _proto['@test delegated event listeners work for mouseEnter on SVG elements'] = function testDelegatedEventListenersWorkForMouseEnterOnSVGElements(assert) {
      var _this8 = this;

      var receivedEnterEvents = [];
      var receivedLeaveEvents = [];
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          tagName: 'svg',
          mouseEnter: function (event) {
            receivedEnterEvents.push(event);
          },
          mouseLeave: function (event) {
            receivedLeaveEvents.push(event);
          }
        }),
        template: "<g id=\"inner\"></g>"
      });
      this.render("{{x-foo id=\"outer\"}}");
      var parent = this.element;
      var outer = this.$('#outer')[0];
      var inner = this.$('#inner')[0]; // mouse moves over #outer

      (0, _internalTestHelpers.runTask)(function () {
        _this8.$(outer).trigger('mouseenter', {
          canBubble: false,
          relatedTarget: parent
        });

        _this8.$(outer).trigger('mouseover', {
          relatedTarget: parent
        });

        _this8.$(parent).trigger('mouseout', {
          relatedTarget: outer
        });
      });
      assert.equal(receivedEnterEvents.length, 1, 'mouseenter event was triggered');
      assert.strictEqual(receivedEnterEvents[0].target, outer); // mouse moves over #inner

      (0, _internalTestHelpers.runTask)(function () {
        _this8.$(inner).trigger('mouseover', {
          relatedTarget: outer
        });

        _this8.$(outer).trigger('mouseout', {
          relatedTarget: inner
        });
      });
      assert.equal(receivedEnterEvents.length, 1, 'mouseenter event was not triggered again'); // mouse moves out of #inner

      (0, _internalTestHelpers.runTask)(function () {
        _this8.$(inner).trigger('mouseout', {
          relatedTarget: outer
        });

        _this8.$(outer).trigger('mouseover', {
          relatedTarget: inner
        });
      });
      assert.equal(receivedLeaveEvents.length, 0, 'mouseleave event was not triggered'); // mouse moves out of #outer

      (0, _internalTestHelpers.runTask)(function () {
        _this8.$(outer).trigger('mouseleave', {
          canBubble: false,
          relatedTarget: parent
        });

        _this8.$(outer).trigger('mouseout', {
          relatedTarget: parent
        });

        _this8.$(parent).trigger('mouseover', {
          relatedTarget: outer
        });
      });
      assert.equal(receivedLeaveEvents.length, 1, 'mouseleave event was triggered');
      assert.strictEqual(receivedLeaveEvents[0].target, outer);
    };

    _proto['@test delegated event listeners work for mouseEnter/Leave with skipped events'] = function testDelegatedEventListenersWorkForMouseEnterLeaveWithSkippedEvents(assert) {
      var _this9 = this;

      var receivedEnterEvents = [];
      var receivedLeaveEvents = [];
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          mouseEnter: function (event) {
            receivedEnterEvents.push(event);
          },
          mouseLeave: function (event) {
            receivedLeaveEvents.push(event);
          }
        }),
        template: "<div id=\"inner\"></div>"
      });
      this.render("{{x-foo id=\"outer\"}}");
      var parent = this.element;
      var outer = this.$('#outer')[0];
      var inner = this.$('#inner')[0]; // we replicate fast mouse movement, where mouseover is fired directly in #inner, skipping #outer

      (0, _internalTestHelpers.runTask)(function () {
        _this9.$(outer).trigger('mouseenter', {
          canBubble: false,
          relatedTarget: parent
        });

        _this9.$(inner).trigger('mouseover', {
          relatedTarget: parent
        });

        _this9.$(parent).trigger('mouseout', {
          relatedTarget: inner
        });
      });
      assert.equal(receivedEnterEvents.length, 1, 'mouseenter event was triggered');
      assert.strictEqual(receivedEnterEvents[0].target, inner); // mouse moves out of #outer

      (0, _internalTestHelpers.runTask)(function () {
        _this9.$(outer).trigger('mouseleave', {
          canBubble: false,
          relatedTarget: parent
        });

        _this9.$(inner).trigger('mouseout', {
          relatedTarget: parent
        });

        _this9.$(parent).trigger('mouseover', {
          relatedTarget: inner
        });
      });
      assert.equal(receivedLeaveEvents.length, 1, 'mouseleave event was triggered');
      assert.strictEqual(receivedLeaveEvents[0].target, inner);
    };

    _proto['@test delegated event listeners work for mouseEnter/Leave with skipped events and subcomponent'] = function testDelegatedEventListenersWorkForMouseEnterLeaveWithSkippedEventsAndSubcomponent(assert) {
      var _this10 = this;

      var receivedEnterEvents = [];
      var receivedLeaveEvents = [];
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          mouseEnter: function (event) {
            receivedEnterEvents.push(event);
          },
          mouseLeave: function (event) {
            receivedLeaveEvents.push(event);
          }
        }),
        template: "{{yield}}"
      });
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend(),
        template: ""
      });
      this.render("{{#x-outer id=\"outer\"}}{{x-inner id=\"inner\"}}{{/x-outer}}");
      var parent = this.element;
      var outer = this.$('#outer')[0];
      var inner = this.$('#inner')[0]; // we replicate fast mouse movement, where mouseover is fired directly in #inner, skipping #outer

      (0, _internalTestHelpers.runTask)(function () {
        _this10.$(outer).trigger('mouseenter', {
          canBubble: false,
          relatedTarget: parent
        });

        _this10.$(inner).trigger('mouseover', {
          relatedTarget: parent
        });

        _this10.$(parent).trigger('mouseout', {
          relatedTarget: inner
        });
      });
      assert.equal(receivedEnterEvents.length, 1, 'mouseenter event was triggered');
      assert.strictEqual(receivedEnterEvents[0].target, inner); // mouse moves out of #inner

      (0, _internalTestHelpers.runTask)(function () {
        _this10.$(outer).trigger('mouseleave', {
          canBubble: false,
          relatedTarget: parent
        });

        _this10.$(inner).trigger('mouseout', {
          relatedTarget: parent
        });

        _this10.$(parent).trigger('mouseover', {
          relatedTarget: inner
        });
      });
      assert.equal(receivedLeaveEvents.length, 1, 'mouseleave event was triggered');
      assert.strictEqual(receivedLeaveEvents[0].target, inner);
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
  (0, _internalTestHelpers.moduleFor)('EventDispatcher#setup',
  /*#__PURE__*/
  function (_RenderingTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _RenderingTestCase2);

    function _class2() {
      var _this11;

      _this11 = _RenderingTestCase2.apply(this, arguments) || this;

      var dispatcher = _this11.owner.lookup('event_dispatcher:main');

      (0, _runloop.run)(dispatcher, 'destroy');

      _this11.owner.__container__.reset('event_dispatcher:main');

      _this11.dispatcher = _this11.owner.lookup('event_dispatcher:main');
      return _this11;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test additional events can be specified'] = function testAdditionalEventsCanBeSpecified(assert) {
      this.dispatcher.setup({
        myevent: 'myEvent'
      });
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          myEvent: function () {
            assert.ok(true, 'custom event was triggered');
          }
        }),
        template: "<p>Hello!</p>"
      });
      this.render("{{x-foo}}");
      this.$('div').trigger('myevent');
    };

    _proto2['@test a rootElement can be specified'] = function testARootElementCanBeSpecified(assert) {
      this.element.innerHTML = '<div id="app"></div>'; // this.$().append('<div id="app"></div>');

      this.dispatcher.setup({
        myevent: 'myEvent'
      }, '#app');
      assert.ok(this.$('#app').hasClass('ember-application'), 'custom rootElement was used');
      assert.equal(this.dispatcher.rootElement, '#app', 'the dispatchers rootElement was updated');
    };

    _proto2['@test default events can be disabled via `customEvents`'] = function testDefaultEventsCanBeDisabledViaCustomEvents(assert) {
      this.dispatcher.setup({
        click: null
      });
      this.registerComponent('x-foo', {
        ComponentClass: _helpers.Component.extend({
          click: function () {
            assert.ok(false, 'click method was called');
          },
          null: function () {
            assert.ok(false, 'null method was called');
          },
          doubleClick: function () {
            assert.ok(true, 'a non-disabled event is still handled properly');
          }
        }),
        template: "<p>Hello!</p>"
      });
      this.render("{{x-foo}}");
      this.$('div').trigger('click');
      this.$('div').trigger('dblclick');
    };

    _proto2['@test throws if specified rootElement does not exist'] = function testThrowsIfSpecifiedRootElementDoesNotExist(assert) {
      var _this12 = this;

      assert.throws(function () {
        _this12.dispatcher.setup({
          myevent: 'myEvent'
        }, '#app');
      });
    };

    return _class2;
  }(_internalTestHelpers.RenderingTestCase));

  if (false
  /* EMBER_IMPROVED_INSTRUMENTATION */
  ) {
      (0, _internalTestHelpers.moduleFor)('EventDispatcher - Instrumentation',
      /*#__PURE__*/
      function (_RenderingTestCase3) {
        (0, _emberBabel.inheritsLoose)(_class3, _RenderingTestCase3);

        function _class3() {
          return _RenderingTestCase3.apply(this, arguments) || this;
        }

        var _proto3 = _class3.prototype;

        _proto3.teardown = function teardown() {
          _RenderingTestCase3.prototype.teardown.call(this);

          (0, _instrumentation.reset)();
        };

        _proto3['@test instruments triggered events'] = function testInstrumentsTriggeredEvents(assert) {
          var clicked = 0;
          this.registerComponent('x-foo', {
            ComponentClass: _helpers.Component.extend({
              click: function () {
                clicked++;
              }
            }),
            template: "<p>hello</p>"
          });
          this.render("{{x-foo}}");
          this.$('div').trigger('click');
          assert.equal(clicked, 1, 'precond - the click handler was invoked');
          var clickInstrumented = 0;
          (0, _instrumentation.subscribe)('interaction.click', {
            before: function () {
              clickInstrumented++;
              assert.equal(clicked, 1, 'invoked before event is handled');
            },
            after: function () {
              clickInstrumented++;
              assert.equal(clicked, 2, 'invoked after event is handled');
            }
          });
          var keypressInstrumented = 0;
          (0, _instrumentation.subscribe)('interaction.keypress', {
            before: function () {
              keypressInstrumented++;
            },
            after: function () {
              keypressInstrumented++;
            }
          });
          this.$('div').trigger('click');
          this.$('div').trigger('change');
          assert.equal(clicked, 2, 'precond - The click handler was invoked');
          assert.equal(clickInstrumented, 2, 'The click was instrumented');
          assert.strictEqual(keypressInstrumented, 0, 'The keypress was not instrumented');
        };

        return _class3;
      }(_internalTestHelpers.RenderingTestCase));
    }

  if (canDataTransfer) {
    (0, _internalTestHelpers.moduleFor)('EventDispatcher - Event Properties',
    /*#__PURE__*/
    function (_RenderingTestCase4) {
      (0, _emberBabel.inheritsLoose)(_class4, _RenderingTestCase4);

      function _class4() {
        return _RenderingTestCase4.apply(this, arguments) || this;
      }

      var _proto4 = _class4.prototype;

      _proto4['@test dataTransfer property is added to drop event'] = function testDataTransferPropertyIsAddedToDropEvent(assert) {
        var receivedEvent;
        this.registerComponent('x-foo', {
          ComponentClass: _helpers.Component.extend({
            drop: function (event) {
              receivedEvent = event;
            }
          })
        });
        this.render("{{x-foo}}");
        fireNativeWithDataTransfer(this.$('div')[0], 'drop', 'success');
        assert.equal(receivedEvent.dataTransfer, 'success');
      };

      return _class4;
    }(_internalTestHelpers.RenderingTestCase));
  }

  if (_views.jQueryDisabled) {
    (0, _internalTestHelpers.moduleFor)('EventDispatcher#native-events',
    /*#__PURE__*/
    function (_RenderingTestCase5) {
      (0, _emberBabel.inheritsLoose)(_class5, _RenderingTestCase5);

      function _class5() {
        return _RenderingTestCase5.apply(this, arguments) || this;
      }

      var _proto5 = _class5.prototype;

      _proto5['@test native events are passed when jQuery is not present'] = function testNativeEventsArePassedWhenJQueryIsNotPresent(assert) {
        var _this13 = this;

        var receivedEvent;
        this.registerComponent('x-foo', {
          ComponentClass: _helpers.Component.extend({
            click: function (event) {
              receivedEvent = event;
            }
          }),
          template: "<button id=\"foo\">bar</button>"
        });
        this.render("{{x-foo}}");
        (0, _internalTestHelpers.runTask)(function () {
          return _this13.$('#foo').click();
        });
        assert.ok(receivedEvent, 'click event was triggered');
        assert.notOk(receivedEvent.originalEvent, 'event is not a jQuery.Event');
      };

      _proto5['@test native event on text node does not throw on hasAttribute [ISSUE #16730]'] = function testNativeEventOnTextNodeDoesNotThrowOnHasAttributeISSUE16730(assert) {
        this.registerComponent('x-foo', {
          ComponentClass: _helpers.Component.extend({
            actions: {
              someAction: function () {}
            }
          }),
          template: "<a id=\"inner\" href=\"#\" {{action 'someAction'}}>test</a>"
        });
        this.render("{{x-foo id=\"outer\"}}");
        var node = this.$('#inner')[0].childNodes[0];
        (0, _internalTestHelpers.runTask)(function () {
          var event = document.createEvent('HTMLEvents');
          event.initEvent('mousemove', true, true);
          node.dispatchEvent(event);
        });
        assert.ok(true);
      };

      return _class5;
    }(_internalTestHelpers.RenderingTestCase));
  } else {
    (0, _internalTestHelpers.moduleFor)('EventDispatcher#jquery-events',
    /*#__PURE__*/
    function (_RenderingTestCase6) {
      (0, _emberBabel.inheritsLoose)(_class6, _RenderingTestCase6);

      function _class6() {
        return _RenderingTestCase6.apply(this, arguments) || this;
      }

      var _proto6 = _class6.prototype;

      _proto6.beforeEach = function beforeEach() {
        this.jqueryIntegration = window.ENV._JQUERY_INTEGRATION;
      };

      _proto6.afterEach = function afterEach() {
        window.ENV._JQUERY_INTEGRATION = this.jqueryIntegration;
      };

      _proto6['@test jQuery events are passed when jQuery is present'] = function testJQueryEventsArePassedWhenJQueryIsPresent(assert) {
        var _this14 = this;

        var receivedEvent;
        this.registerComponent('x-foo', {
          ComponentClass: _helpers.Component.extend({
            click: function (event) {
              receivedEvent = event;
            }
          }),
          template: "<button id=\"foo\">bar</button>"
        });
        this.render("{{x-foo}}");
        (0, _internalTestHelpers.runTask)(function () {
          return _this14.$('#foo').click();
        });
        assert.ok(receivedEvent, 'click event was triggered');
        assert.ok(receivedEvent instanceof _views.jQuery.Event, 'event is a jQuery.Event');
      };

      _proto6["@" + (_utils.HAS_NATIVE_PROXY ? 'test' : 'skip') + " accessing jQuery.Event#originalEvent is deprecated"] = function (assert) {
        var _this15 = this;

        var receivedEvent;
        this.registerComponent('x-foo', {
          ComponentClass: _helpers.Component.extend({
            click: function (event) {
              receivedEvent = event;
            }
          }),
          template: "<button id=\"foo\">bar</button>"
        });
        this.render("{{x-foo}}");
        (0, _internalTestHelpers.runTask)(function () {
          return _this15.$('#foo').click();
        });
        expectDeprecation(function () {
          var _receivedEvent = receivedEvent,
              originalEvent = _receivedEvent.originalEvent;
          assert.ok(originalEvent, 'jQuery event has originalEvent property');
          assert.equal(originalEvent.type, 'click', 'properties of originalEvent are available');
        }, 'Accessing jQuery.Event specific properties is deprecated. Either use the ember-jquery-legacy addon to normalize events to native events, or explicitly opt into jQuery integration using @ember/optional-features.');
      };

      _proto6['@test other jQuery.Event properties do not trigger deprecation'] = function testOtherJQueryEventPropertiesDoNotTriggerDeprecation(assert) {
        var _this16 = this;

        var receivedEvent;
        this.registerComponent('x-foo', {
          ComponentClass: _helpers.Component.extend({
            click: function (event) {
              receivedEvent = event;
            }
          }),
          template: "<button id=\"foo\">bar</button>"
        });
        this.render("{{x-foo}}");
        (0, _internalTestHelpers.runTask)(function () {
          return _this16.$('#foo').click();
        });
        expectNoDeprecation(function () {
          receivedEvent.stopPropagation();
          receivedEvent.stopImmediatePropagation();
          receivedEvent.preventDefault();
          assert.ok(receivedEvent.bubbles, 'properties of jQuery event are available');
          assert.equal(receivedEvent.type, 'click', 'properties of jQuery event are available');
        });
      };

      _proto6['@test accessing jQuery.Event#originalEvent does not trigger deprecations when jquery integration is explicitly enabled'] = function testAccessingJQueryEventOriginalEventDoesNotTriggerDeprecationsWhenJqueryIntegrationIsExplicitlyEnabled(assert) {
        var _this17 = this;

        var receivedEvent;
        window.ENV._JQUERY_INTEGRATION = true;
        this.registerComponent('x-foo', {
          ComponentClass: _helpers.Component.extend({
            click: function (event) {
              receivedEvent = event;
            }
          }),
          template: "<button id=\"foo\">bar</button>"
        });
        this.render("{{x-foo}}");
        (0, _internalTestHelpers.runTask)(function () {
          return _this17.$('#foo').click();
        });
        expectNoDeprecation(function () {
          var _receivedEvent2 = receivedEvent,
              originalEvent = _receivedEvent2.originalEvent;
          assert.ok(originalEvent, 'jQuery event has originalEvent property');
          assert.equal(originalEvent.type, 'click', 'properties of originalEvent are available');
        });
      };

      _proto6["@" + (_utils.HAS_NATIVE_PROXY && true
      /* DEBUG */
      ? 'test' : 'skip') + " accessing jQuery.Event#__originalEvent does not trigger deprecations to support ember-jquery-legacy"] = function (assert) {
        var _this18 = this;

        var receivedEvent;
        this.registerComponent('x-foo', {
          ComponentClass: _helpers.Component.extend({
            click: function (event) {
              receivedEvent = event;
            }
          }),
          template: "<button id=\"foo\">bar</button>"
        });
        this.render("{{x-foo}}");
        (0, _internalTestHelpers.runTask)(function () {
          return _this18.$('#foo').click();
        });
        expectNoDeprecation(function () {
          var _receivedEvent3 = receivedEvent,
              originalEvent = _receivedEvent3.__originalEvent;
          assert.ok(originalEvent, 'jQuery event has __originalEvent property');
          assert.equal(originalEvent.type, 'click', 'properties of __originalEvent are available');
        });
      };

      return _class6;
    }(_internalTestHelpers.RenderingTestCase));
  }
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/-class-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _metal) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{-class}}',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test casts binding to dasherized class'] = function testCastsBindingToDasherizedClass() {
      var _this = this;

      this.registerComponent('foo-bar', {
        template: ''
      });
      this.render("{{foo-bar class=(-class someTruth \"someTruth\")}}", {
        someTruth: true
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('some-truth ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('some-truth ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'someTruth', false);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'someTruth', true);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('some-truth ember-view')
        }
      });
    };

    _proto['@tests casts leaf path of binding to dasherized class'] = function testsCastsLeafPathOfBindingToDasherizedClass() {
      var _this2 = this;

      this.registerComponent('foo-bar', {
        template: ''
      });
      this.render("{{foo-bar class=(-class model.someTruth \"someTruth\")}}", {
        model: {
          someTruth: true
        }
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('some-truth ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('some-truth ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'model.someTruth', false);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('ember-view')
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'model', {
          someTruth: true
        });
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: (0, _internalTestHelpers.classes)('some-truth ember-view')
        }
      });
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/array-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _helpers) {
  "use strict";

  function _templateObject11() {
    const data = _taggedTemplateLiteralLoose(["{{foo-bar people=(array \"Tom\" personTwo)}}"]);

    _templateObject11 = function () {
      return data;
    };

    return data;
  }

  function _templateObject10() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#each people as |personName|}}\n          {{personName}},\n        {{/each}}"]);

    _templateObject10 = function () {
      return data;
    };

    return data;
  }

  function _templateObject9() {
    const data = _taggedTemplateLiteralLoose(["{{foo-bar people=(array \"Tom\" personTwo)}}"]);

    _templateObject9 = function () {
      return data;
    };

    return data;
  }

  function _templateObject8() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#each people as |personName|}}\n          {{personName}},\n        {{/each}}"]);

    _templateObject8 = function () {
      return data;
    };

    return data;
  }

  function _templateObject7() {
    const data = _taggedTemplateLiteralLoose(["{{#foo-bar personTwo=model.personTwo as |values|}}\n              {{#each values.people as |personName|}}\n                {{personName}},\n              {{/each}}\n            {{/foo-bar}}"]);

    _templateObject7 = function () {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#foo-bar as |values|}}\n        {{#each values.people as |personName|}}\n          {{personName}}\n        {{/each}}\n      {{/foo-bar}}"]);

    _templateObject6 = function () {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    const data = _taggedTemplateLiteralLoose(["{{#with (array (array personOne personTwo)) as |listOfPeople|}}\n              {{#each listOfPeople as |people|}}\n                List:\n                {{#each people as |personName|}}\n                  {{personName}},\n                {{/each}}\n              {{/each}}\n            {{/with}}"]);

    _templateObject5 = function () {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    const data = _taggedTemplateLiteralLoose(["{{#with (array personOne personTwo) as |people|}}\n              {{#each people as |personName|}}\n                {{personName}},\n              {{/each}}\n            {{/with}}"]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["{{#with (array personOne) as |people|}}\n              {{#each people as |personName|}}\n                {{personName}}\n              {{/each}}\n            {{/with}}"]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with (array \"Sergio\" \"Robert\") as |people|}}\n        {{#each people as |personName|}}\n          {{personName}},\n        {{/each}}\n      {{/with}}"]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with (array \"Sergio\") as |people|}}\n        {{#each people as |personName|}}\n          {{personName}}\n        {{/each}}\n      {{/with}}"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{array}}',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test returns an array'] = function testReturnsAnArray() {
      this.render((0, _internalTestHelpers.strip)(_templateObject()));
      this.assertText('Sergio');
      this.assertStableRerender();
    };

    _proto['@test can have more than one value'] = function testCanHaveMoreThanOneValue() {
      this.render((0, _internalTestHelpers.strip)(_templateObject2()));
      this.assertText('Sergio,Robert,');
      this.assertStableRerender();
    };

    _proto['@test binds values when variables are used'] = function testBindsValuesWhenVariablesAreUsed() {
      var _this = this;

      this.render((0, _internalTestHelpers.strip)(_templateObject3()), {
        personOne: 'Tom'
      });
      this.assertText('Tom');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'personOne', 'Yehuda');
      });
      this.assertText('Yehuda');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'personOne', 'Tom');
      });
      this.assertText('Tom');
    };

    _proto['@test binds multiple values when variables are used'] = function testBindsMultipleValuesWhenVariablesAreUsed() {
      var _this2 = this;

      this.render((0, _internalTestHelpers.strip)(_templateObject4()), {
        personOne: 'Tom',
        personTwo: 'Yehuda'
      });
      this.assertText('Tom,Yehuda,');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'personOne', 'Sergio');
      });
      this.assertText('Sergio,Yehuda,');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'personTwo', 'Tom');
      });
      this.assertText('Sergio,Tom,');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this2.context, 'personOne', 'Tom');
        (0, _metal.set)(_this2.context, 'personTwo', 'Yehuda');
      });
      this.assertText('Tom,Yehuda,');
    };

    _proto['@test array helpers can be nested'] = function testArrayHelpersCanBeNested() {
      var _this3 = this;

      this.render((0, _internalTestHelpers.strip)(_templateObject5()), {
        personOne: 'Tom',
        personTwo: 'Yehuda'
      });
      this.assertText('List:Tom,Yehuda,');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'personOne', 'Chad');
      });
      this.assertText('List:Chad,Yehuda,');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'personTwo', 'Balint');
      });
      this.assertText('List:Chad,Balint,');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this3.context, 'personOne', 'Tom');
        (0, _metal.set)(_this3.context, 'personTwo', 'Yehuda');
      });
      this.assertText('List:Tom,Yehuda,');
    };

    _proto['@test should yield hash of an array of internal properties'] = function testShouldYieldHashOfAnArrayOfInternalProperties() {
      var fooBarInstance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          fooBarInstance = this;
          this.model = {
            personOne: 'Chad'
          };
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{yield (hash people=(array model.personOne))}}"
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject6()));
      this.assertText('Chad');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(fooBarInstance, 'model.personOne', 'Godfrey');
      });
      this.assertText('Godfrey');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(fooBarInstance, 'model', {
          personOne: 'Chad'
        });
      });
      this.assertText('Chad');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(fooBarInstance, 'model.personOne', 'Godfrey');
      });
      this.assertText('Godfrey');
    };

    _proto['@test should yield hash of an array of internal and external properties'] = function testShouldYieldHashOfAnArrayOfInternalAndExternalProperties() {
      var _this4 = this;

      var fooBarInstance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          fooBarInstance = this;
          this.model = {
            personOne: 'Chad'
          };
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{yield (hash people=(array model.personOne personTwo))}}"
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject7()), {
        model: {
          personTwo: 'Tom'
        }
      });
      this.assertText('Chad,Tom,');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(fooBarInstance, 'model.personOne', 'Godfrey');
        (0, _metal.set)(_this4.context, 'model.personTwo', 'Yehuda');
      });
      this.assertText('Godfrey,Yehuda,');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(fooBarInstance, 'model', {
          personOne: 'Chad'
        });
        (0, _metal.set)(_this4.context, 'model', {
          personTwo: 'Tom'
        });
      });
      this.assertText('Chad,Tom,');
    };

    _proto['@test should render when passing as argument to a component invocation'] = function testShouldRenderWhenPassingAsArgumentToAComponentInvocation() {
      var _this5 = this;

      var FooBarComponent = _helpers.Component.extend({});

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject8())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject9()), {
        personTwo: 'Chad'
      });
      this.assertText('Tom,Chad,');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'personTwo', 'Godfrey');
      });
      this.assertText('Tom,Godfrey,');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'personTwo', 'Chad');
      });
      this.assertText('Tom,Chad,');
    };

    _proto['@test should return an entirely new array when any argument change'] = function testShouldReturnAnEntirelyNewArrayWhenAnyArgumentChange() {
      var _this6 = this;

      var fooBarInstance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          fooBarInstance = this;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject10())
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject11()), {
        personTwo: 'Chad'
      });
      var firstArray = fooBarInstance.people;
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'personTwo', 'Godfrey');
      });
      this.assert.ok(firstArray !== fooBarInstance.people, 'should have created an entirely new array');
    };

    _proto['@test capture array values in JS to assert deep equal'] = function testCaptureArrayValuesInJSToAssertDeepEqual() {
      var _this7 = this;

      var captured;
      this.registerHelper('capture', function (_ref) {
        var array = _ref[0];
        captured = array;
        return 'captured';
      });
      this.render("{{capture (array 'Tom' personTwo)}}", {
        personTwo: 'Godfrey'
      });
      this.assert.deepEqual(captured, ['Tom', 'Godfrey']);
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'personTwo', 'Robert');
      });
      this.assert.deepEqual(captured, ['Tom', 'Robert']);
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'personTwo', 'Godfrey');
      });
      this.assert.deepEqual(captured, ['Tom', 'Godfrey']);
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/closure-action-test", ["ember-babel", "internal-test-helpers", "@ember/instrumentation", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _instrumentation, _runloop, _metal, _helpers) {
  "use strict";

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n        <div id=\"counter\">clicked: {{clicked}}; foo: {{foo}}</div>\n\n        {{click-me id=\"string-action\" onClick=(action \"on-click\")}}\n        {{click-me id=\"function-action\" onClick=(action onClick)}}\n        {{click-me id=\"mut-action\" onClick=(action (mut clicked))}}\n      "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  if (false
  /* EMBER_IMPROVED_INSTRUMENTATION */
  ) {
      (0, _internalTestHelpers.moduleFor)('Helpers test: closure {{action}} improved instrumentation',
      /*#__PURE__*/
      function (_RenderingTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

        function _class() {
          return _RenderingTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto.subscribe = function subscribe(eventName, options) {
          this.subscriber = (0, _instrumentation.subscribe)(eventName, options);
        };

        _proto.teardown = function teardown() {
          if (this.subscriber) {
            (0, _instrumentation.unsubscribe)(this.subscriber);
          }

          _RenderingTestCase.prototype.teardown.call(this);
        };

        _proto['@test interaction event subscriber should be passed parameters'] = function testInteractionEventSubscriberShouldBePassedParameters() {
          var _this = this;

          var actionParam = 'So krispy';
          var beforeParameters = [];
          var afterParameters = [];

          var InnerComponent = _helpers.Component.extend({
            actions: {
              fireAction: function () {
                this.attrs.submit(actionParam);
              }
            }
          });

          var OuterComponent = _helpers.Component.extend({
            outerSubmit: function () {}
          });

          this.registerComponent('inner-component', {
            ComponentClass: InnerComponent,
            template: '<button id="instrument-button" {{action "fireAction"}}>What it do</button>'
          });
          this.registerComponent('outer-component', {
            ComponentClass: OuterComponent,
            template: '{{inner-component submit=(action outerSubmit)}}'
          });
          this.subscribe('interaction.ember-action', {
            before: function (name, timestamp, payload) {
              beforeParameters.push(payload.args);
            },
            after: function (name, timestamp, payload) {
              afterParameters.push(payload.args);
            }
          });
          this.render("{{outer-component}}");
          (0, _internalTestHelpers.runTask)(function () {
            _this.$('#instrument-button').trigger('click');
          });
          this.assert.deepEqual(beforeParameters, [[], [actionParam]], 'instrumentation subscriber before function was passed closure action parameters');
          this.assert.deepEqual(afterParameters, [[actionParam], []], 'instrumentation subscriber after function was passed closure action parameters');
        };

        _proto['@test interaction event subscriber should be passed target'] = function testInteractionEventSubscriberShouldBePassedTarget() {
          var _this2 = this;

          var beforeParameters = [];
          var afterParameters = [];

          var InnerComponent = _helpers.Component.extend({
            myProperty: 'inner-thing',
            actions: {
              fireAction: function () {
                this.attrs.submit();
              }
            }
          });

          var OuterComponent = _helpers.Component.extend({
            myProperty: 'outer-thing',
            outerSubmit: function () {}
          });

          this.registerComponent('inner-component', {
            ComponentClass: InnerComponent,
            template: '<button id="instrument-button" {{action "fireAction"}}>What it do</button>'
          });
          this.registerComponent('outer-component', {
            ComponentClass: OuterComponent,
            template: '{{inner-component submit=(action outerSubmit)}}'
          });
          this.subscribe('interaction.ember-action', {
            before: function (name, timestamp, payload) {
              beforeParameters.push(payload.target.get('myProperty'));
            },
            after: function (name, timestamp, payload) {
              afterParameters.push(payload.target.get('myProperty'));
            }
          });
          this.render("{{outer-component}}");
          (0, _internalTestHelpers.runTask)(function () {
            _this2.$('#instrument-button').trigger('click');
          });
          this.assert.deepEqual(beforeParameters, ['inner-thing', 'outer-thing'], 'instrumentation subscriber before function was passed target');
          this.assert.deepEqual(afterParameters, ['outer-thing', 'inner-thing'], 'instrumentation subscriber after function was passed target');
        };

        _proto['@test instrumented action should return value'] = function testInstrumentedActionShouldReturnValue() {
          var _this3 = this;

          var returnedValue = 'Chris P is so krispy';
          var actualReturnedValue;

          var InnerComponent = _helpers.Component.extend({
            actions: {
              fireAction: function () {
                actualReturnedValue = this.attrs.submit();
              }
            }
          });

          var OuterComponent = _helpers.Component.extend({
            outerSubmit: function () {
              return returnedValue;
            }
          });

          this.registerComponent('inner-component', {
            ComponentClass: InnerComponent,
            template: '<button id="instrument-button" {{action "fireAction"}}>What it do</button>'
          });
          this.registerComponent('outer-component', {
            ComponentClass: OuterComponent,
            template: '{{inner-component submit=(action outerSubmit)}}'
          });
          this.subscribe('interaction.ember-action', {
            before: function () {},
            after: function () {}
          });
          this.render("{{outer-component}}");
          (0, _internalTestHelpers.runTask)(function () {
            _this3.$('#instrument-button').trigger('click');
          });
          this.assert.equal(actualReturnedValue, returnedValue, 'action can return to caller');
        };

        return _class;
      }(_internalTestHelpers.RenderingTestCase));
    }

  (0, _internalTestHelpers.moduleFor)('Helpers test: closure {{action}}',
  /*#__PURE__*/
  function (_RenderingTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _RenderingTestCase2);

    function _class2() {
      return _RenderingTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test action should be called'] = function testActionShouldBeCalled() {
      var outerActionCalled = false;
      var component;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        fireAction: function () {
          this.attrs.submit();
        }
      });

      var OuterComponent = _helpers.Component.extend({
        outerSubmit: function () {
          outerActionCalled = true;
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action outerSubmit)}}'
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        component.fireAction();
      });
      this.assert.ok(outerActionCalled, 'the action was called');
    };

    _proto2['@test an error is triggered when bound action function is undefined'] = function testAnErrorIsTriggeredWhenBoundActionFunctionIsUndefined() {
      var _this4 = this;

      this.registerComponent('inner-component', {
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        template: '{{inner-component submit=(action somethingThatIsUndefined)}}'
      });
      expectAssertion(function () {
        _this4.render('{{outer-component}}');
      }, /Action passed is null or undefined in \(action[^)]*\) from .*\./);
    };

    _proto2['@test an error is triggered when bound action being passed in is a non-function'] = function testAnErrorIsTriggeredWhenBoundActionBeingPassedInIsANonFunction() {
      var _this5 = this;

      this.registerComponent('inner-component', {
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: _helpers.Component.extend({
          nonFunctionThing: {}
        }),
        template: '{{inner-component submit=(action nonFunctionThing)}}'
      });
      expectAssertion(function () {
        _this5.render('{{outer-component}}');
      }, /An action could not be made for `.*` in .*\. Please confirm that you are using either a quoted action name \(i\.e\. `\(action '.*'\)`\) or a function available in .*\./);
    };

    _proto2['@test [#12718] a nice error is shown when a bound action function is undefined and it is passed as attrs.foo'] = function test12718ANiceErrorIsShownWhenABoundActionFunctionIsUndefinedAndItIsPassedAsAttrsFoo() {
      var _this6 = this;

      this.registerComponent('inner-component', {
        template: '<button id="inner-button" {{action (action attrs.external-action)}}>Click me</button>'
      });
      this.registerComponent('outer-component', {
        template: '{{inner-component}}'
      });
      expectAssertion(function () {
        _this6.render('{{outer-component}}');
      }, /Action passed is null or undefined in \(action[^)]*\) from .*\./);
    };

    _proto2['@test action value is returned'] = function testActionValueIsReturned() {
      var expectedValue = 'terrible tom';
      var returnedValue;
      var innerComponent;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          innerComponent = this;
        },
        fireAction: function () {
          returnedValue = this.attrs.submit();
        }
      });

      var OuterComponent = _helpers.Component.extend({
        outerSubmit: function () {
          return expectedValue;
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action outerSubmit)}}'
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        innerComponent.fireAction();
      });
      this.assert.equal(returnedValue, expectedValue, 'action can return to caller');
    };

    _proto2['@test action should be called on the correct scope'] = function testActionShouldBeCalledOnTheCorrectScope() {
      var innerComponent;
      var outerComponent;
      var actualComponent;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit();
        }
      });

      var OuterComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          outerComponent = this;
        },
        isOuterComponent: true,
        outerSubmit: function () {
          actualComponent = this;
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action outerSubmit)}}'
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        innerComponent.fireAction();
      });
      this.assert.equal(actualComponent, outerComponent, 'action has the correct context');
      this.assert.ok(actualComponent.isOuterComponent, 'action has the correct context');
    };

    _proto2['@test arguments to action are passed, curry'] = function testArgumentsToActionArePassedCurry() {
      var first = 'mitch';
      var second = 'martin';
      var third = 'matt';
      var fourth = 'wacky wycats';
      var innerComponent;
      var actualArgs;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit(fourth);
        }
      });

      var OuterComponent = _helpers.Component.extend({
        third: third,
        outerSubmit: function () {
          // eslint-disable-line no-unused-vars
          actualArgs = Array.prototype.slice.call(arguments);
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action (action outerSubmit \"" + first + "\") \"" + second + "\" third)}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        innerComponent.fireAction();
      });
      this.assert.deepEqual(actualArgs, [first, second, third, fourth], 'action has the correct args');
    };

    _proto2['@test `this` can be passed as an argument'] = function testThisCanBePassedAsAnArgument() {
      var value = {};
      var component;
      var innerComponent;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit();
        }
      });

      var OuterComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        actions: {
          outerAction: function (incomingValue) {
            value = incomingValue;
          }
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action "outerAction" this)}}'
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        innerComponent.fireAction();
      });
      this.assert.strictEqual(value, component, 'the component is passed at `this`');
    };

    _proto2['@test arguments to action are bound'] = function testArgumentsToActionAreBound() {
      var value = 'lazy leah';
      var innerComponent;
      var outerComponent;
      var actualArg;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit();
        }
      });

      var OuterComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          outerComponent = this;
        },
        value: '',
        outerSubmit: function (incomingValue) {
          actualArg = incomingValue;
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action outerSubmit value)}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        innerComponent.fireAction();
      });
      this.assert.strictEqual(actualArg, '', 'action has the correct first arg');
      (0, _internalTestHelpers.runTask)(function () {
        outerComponent.set('value', value);
      });
      (0, _internalTestHelpers.runTask)(function () {
        innerComponent.fireAction();
      });
      this.assert.strictEqual(actualArg, value, 'action has the correct first arg');
    };

    _proto2['@test array arguments are passed correctly to action'] = function testArrayArgumentsArePassedCorrectlyToAction() {
      var first = 'foo';
      var second = [3, 5];
      var third = [4, 9];
      var actualFirst;
      var actualSecond;
      var actualThird;
      var innerComponent;
      var outerComponent;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit(second, third);
        }
      });

      var OuterComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          outerComponent = this;
        },
        outerSubmit: function (incomingFirst, incomingSecond, incomingThird) {
          actualFirst = incomingFirst;
          actualSecond = incomingSecond;
          actualThird = incomingThird;
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action outerSubmit first)}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        outerComponent.set('first', first);
        outerComponent.set('second', second);
      });
      (0, _internalTestHelpers.runTask)(function () {
        innerComponent.fireAction();
      });
      this.assert.equal(actualFirst, first, 'action has the correct first arg');
      this.assert.equal(actualSecond, second, 'action has the correct second arg');
      this.assert.equal(actualThird, third, 'action has the correct third arg');
    };

    _proto2['@test mut values can be wrapped in actions, are settable'] = function testMutValuesCanBeWrappedInActionsAreSettable() {
      var newValue = 'trollin trek';
      var innerComponent;
      var outerComponent;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit(newValue);
        }
      });

      var OuterComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          outerComponent = this;
        },
        outerMut: 'patient peter'
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action (mut outerMut))}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        innerComponent.fireAction();
      });
      this.assert.equal(outerComponent.get('outerMut'), newValue, 'mut value is set');
    };

    _proto2['@test mut values can be wrapped in actions, are settable with a curry'] = function testMutValuesCanBeWrappedInActionsAreSettableWithACurry() {
      var newValue = 'trollin trek';
      var innerComponent;
      var outerComponent;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit();
        }
      });

      var OuterComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          outerComponent = this;
        },
        outerMut: 'patient peter'
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action (mut outerMut) '" + newValue + "')}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        innerComponent.fireAction();
      });
      this.assert.equal(outerComponent.get('outerMut'), newValue, 'mut value is set');
    };

    _proto2['@test action can create closures over actions'] = function testActionCanCreateClosuresOverActions() {
      var first = 'raging robert';
      var second = 'mild machty';
      var returnValue = 'butch brian';
      var actualFirst;
      var actualSecond;
      var actualReturnedValue;
      var innerComponent;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          innerComponent = this;
        },
        fireAction: function () {
          actualReturnedValue = this.attrs.submit(second);
        }
      });

      var OuterComponent = _helpers.Component.extend({
        actions: {
          outerAction: function (incomingFirst, incomingSecond) {
            actualFirst = incomingFirst;
            actualSecond = incomingSecond;
            return returnValue;
          }
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action 'outerAction' '" + first + "')}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        innerComponent.fireAction();
      });
      this.assert.equal(actualReturnedValue, returnValue, 'return value is present');
      this.assert.equal(actualFirst, first, 'first argument is correct');
      this.assert.equal(actualSecond, second, 'second argument is correct');
    };

    _proto2['@test provides a helpful error if an action is not present'] = function testProvidesAHelpfulErrorIfAnActionIsNotPresent() {
      var _this7 = this;

      var InnerComponent = _helpers.Component.extend({});

      var OuterComponent = _helpers.Component.extend({
        actions: {
          something: function () {// this is present to ensure `actions` hash is present
            // a different error is triggered if `actions` is missing
            // completely
          }
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action 'doesNotExist')}}"
      });
      expectAssertion(function () {
        _this7.render('{{outer-component}}');
      }, /An action named 'doesNotExist' was not found in /);
    };

    _proto2['@test provides a helpful error if actions hash is not present'] = function testProvidesAHelpfulErrorIfActionsHashIsNotPresent() {
      var _this8 = this;

      var InnerComponent = _helpers.Component.extend({});

      var OuterComponent = _helpers.Component.extend({});

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action 'doesNotExist')}}"
      });
      expectAssertion(function () {
        _this8.render('{{outer-component}}');
      }, /An action named 'doesNotExist' was not found in /);
    };

    _proto2['@test action can create closures over actions with target'] = function testActionCanCreateClosuresOverActionsWithTarget() {
      var innerComponent;
      var actionCalled = false;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit();
        }
      });

      var OuterComponent = _helpers.Component.extend({
        otherComponent: (0, _metal.computed)(function () {
          return {
            actions: {
              outerAction: function () {
                actionCalled = true;
              }
            }
          };
        })
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action 'outerAction' target=otherComponent)}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        innerComponent.fireAction();
      });
      this.assert.ok(actionCalled, 'action called on otherComponent');
    };

    _proto2['@test value can be used with action over actions'] = function testValueCanBeUsedWithActionOverActions() {
      var newValue = 'yelping yehuda';
      var innerComponent;
      var actualValue;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit({
            readProp: newValue
          });
        }
      });

      var OuterComponent = _helpers.Component.extend({
        outerContent: {
          readProp: newValue
        },
        actions: {
          outerAction: function (incomingValue) {
            actualValue = incomingValue;
          }
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action 'outerAction' value=\"readProp\")}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        innerComponent.fireAction();
      });
      this.assert.equal(actualValue, newValue, 'value is read');
    };

    _proto2['@test action will read the value of a first property'] = function testActionWillReadTheValueOfAFirstProperty() {
      var newValue = 'irate igor';
      var innerComponent;
      var actualValue;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit({
            readProp: newValue
          });
        }
      });

      var OuterComponent = _helpers.Component.extend({
        outerAction: function (incomingValue) {
          actualValue = incomingValue;
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action outerAction value=\"readProp\")}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        innerComponent.fireAction();
      });
      this.assert.equal(actualValue, newValue, 'property is read');
    };

    _proto2['@test action will read the value of a curried first argument property'] = function testActionWillReadTheValueOfACurriedFirstArgumentProperty() {
      var newValue = 'kissing kris';
      var innerComponent;
      var actualValue;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit();
        }
      });

      var OuterComponent = _helpers.Component.extend({
        objectArgument: {
          readProp: newValue
        },
        outerAction: function (incomingValue) {
          actualValue = incomingValue;
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action outerAction objectArgument value=\"readProp\")}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        innerComponent.fireAction();
      });
      this.assert.equal(actualValue, newValue, 'property is read');
    };

    _proto2['@test action closure does not get auto-mut wrapped'] = function testActionClosureDoesNotGetAutoMutWrapped(assert) {
      var first = 'raging robert';
      var second = 'mild machty';
      var returnValue = 'butch brian';
      var innerComponent;
      var actualFirst;
      var actualSecond;
      var actualReturnedValue;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          innerComponent = this;
        },
        fireAction: function () {
          this.get('submit')(second);
          this.get('attrs-submit')(second);
          var attrsSubmitReturnValue = this.attrs['attrs-submit'](second);
          var submitReturnValue = this.attrs.submit(second);
          assert.equal(attrsSubmitReturnValue, submitReturnValue, 'both attrs.foo and foo should behave the same');
          return submitReturnValue;
        }
      });

      var MiddleComponent = _helpers.Component.extend({});

      var OuterComponent = _helpers.Component.extend({
        actions: {
          outerAction: function (incomingFirst, incomingSecond) {
            actualFirst = incomingFirst;
            actualSecond = incomingSecond;
            return returnValue;
          }
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('middle-component', {
        ComponentClass: MiddleComponent,
        template: "{{inner-component attrs-submit=attrs.submit submit=submit}}"
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{middle-component submit=(action 'outerAction' '" + first + "')}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        actualReturnedValue = innerComponent.fireAction();
      });
      this.assert.equal(actualFirst, first, 'first argument is correct');
      this.assert.equal(actualSecond, second, 'second argument is correct');
      this.assert.equal(actualReturnedValue, returnValue, 'return value is present');
    };

    _proto2['@test action should be called within a run loop'] = function testActionShouldBeCalledWithinARunLoop() {
      var innerComponent;
      var capturedRunLoop;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit();
        }
      });

      var OuterComponent = _helpers.Component.extend({
        actions: {
          submit: function () {
            capturedRunLoop = (0, _runloop.getCurrentRunLoop)();
          }
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action 'submit')}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        innerComponent.fireAction();
      });
      this.assert.ok(capturedRunLoop, 'action is called within a run loop');
    };

    _proto2['@test objects that define INVOKE can be casted to actions'] = function testObjectsThatDefineINVOKECanBeCastedToActions() {
      var innerComponent;
      var actionArgs;
      var invokableArgs;

      var InnerComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          innerComponent = this;
        },
        fireAction: function () {
          actionArgs = this.attrs.submit(4, 5, 6);
        }
      });

      var OuterComponent = _helpers.Component.extend({
        foo: 123,
        submitTask: (0, _metal.computed)(function () {
          var _this9 = this,
              _ref;

          return _ref = {}, _ref[_helpers.INVOKE] = function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            invokableArgs = args;
            return _this9.foo;
          }, _ref;
        })
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: "{{inner-component submit=(action submitTask 1 2 3)}}"
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        innerComponent.fireAction();
      });
      this.assert.equal(actionArgs, 123);
      this.assert.deepEqual(invokableArgs, [1, 2, 3, 4, 5, 6]);
    };

    _proto2['@test closure action with `(mut undefinedThing)` works properly [GH#13959]'] = function testClosureActionWithMutUndefinedThingWorksProperlyGH13959() {
      var _this10 = this;

      var component;

      var ExampleComponent = _helpers.Component.extend({
        label: undefined,
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button onclick={{action (mut label) "Clicked!"}}>{{if label label "Click me"}}</button>'
      });
      this.render('{{example-component}}');
      this.assertText('Click me');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        _this10.$('button').click();
      });
      this.assertText('Clicked!');
      (0, _internalTestHelpers.runTask)(function () {
        component.set('label', 'Dun clicked');
      });
      this.assertText('Dun clicked');
      (0, _internalTestHelpers.runTask)(function () {
        _this10.$('button').click();
      });
      this.assertText('Clicked!');
      (0, _internalTestHelpers.runTask)(function () {
        component.set('label', undefined);
      });
      this.assertText('Click me');
    };

    _proto2['@test closure actions does not cause component hooks to fire unnecessarily [GH#14305] [GH#14654]'] = function testClosureActionsDoesNotCauseComponentHooksToFireUnnecessarilyGH14305GH14654(assert) {
      var _this12 = this;

      var clicked = 0;
      var didReceiveAttrsFired = 0;

      var ClickMeComponent = _helpers.Component.extend({
        tagName: 'button',
        click: function () {
          this.get('onClick').call(undefined, ++clicked);
        },
        didReceiveAttrs: function () {
          didReceiveAttrsFired++;
        }
      });

      this.registerComponent('click-me', {
        ComponentClass: ClickMeComponent
      });
      var outer;

      var OuterComponent = _helpers.Component.extend({
        clicked: 0,
        actions: {
          'on-click': function () {
            this.incrementProperty('clicked');
          }
        },
        init: function () {
          var _this11 = this;

          this._super();

          outer = this;
          this.set('onClick', function () {
            return _this11.incrementProperty('clicked');
          });
        }
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject())
      });
      this.render('{{outer-component foo=foo}}', {
        foo: 1
      });
      this.assertText('clicked: 0; foo: 1');
      assert.equal(didReceiveAttrsFired, 3);
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.rerender();
      });
      this.assertText('clicked: 0; foo: 1');
      assert.equal(didReceiveAttrsFired, 3);
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'foo', 2);
      });
      this.assertText('clicked: 0; foo: 2');
      assert.equal(didReceiveAttrsFired, 3);
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.$('#string-action').click();
      });
      this.assertText('clicked: 1; foo: 2');
      assert.equal(didReceiveAttrsFired, 3);
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.$('#function-action').click();
      });
      this.assertText('clicked: 2; foo: 2');
      assert.equal(didReceiveAttrsFired, 3);
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(outer, 'onClick', function () {
          outer.incrementProperty('clicked');
        });
      });
      this.assertText('clicked: 2; foo: 2');
      assert.equal(didReceiveAttrsFired, 3);
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.$('#function-action').click();
      });
      this.assertText('clicked: 3; foo: 2');
      assert.equal(didReceiveAttrsFired, 3);
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.$('#mut-action').click();
      });
      this.assertText('clicked: 4; foo: 2');
      assert.equal(didReceiveAttrsFired, 3);
    };

    return _class2;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/concat-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _metal) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{concat}}',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test it concats static arguments'] = function testItConcatsStaticArguments() {
      this.render("{{concat \"foo\" \" \" \"bar\" \" \" \"baz\"}}");
      this.assertText('foo bar baz');
    };

    _proto['@test it updates for bound arguments'] = function testItUpdatesForBoundArguments() {
      var _this = this;

      this.render("{{concat model.first model.second}}", {
        model: {
          first: 'one',
          second: 'two'
        }
      });
      this.assertText('onetwo');
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertText('onetwo');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'model.first', 'three');
      });
      this.assertText('threetwo');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'model.second', 'four');
      });
      this.assertText('threefour');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'model', {
          first: 'one',
          second: 'two'
        });
      });
      this.assertText('onetwo');
    };

    _proto['@test it can be used as a sub-expression'] = function testItCanBeUsedAsASubExpression() {
      var _this2 = this;

      this.render("{{concat (concat model.first model.second) (concat model.third model.fourth)}}", {
        model: {
          first: 'one',
          second: 'two',
          third: 'three',
          fourth: 'four'
        }
      });
      this.assertText('onetwothreefour');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertText('onetwothreefour');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'model.first', 'five');
      });
      this.assertText('fivetwothreefour');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this2.context, 'model.second', 'six');
        (0, _metal.set)(_this2.context, 'model.third', 'seven');
      });
      this.assertText('fivesixsevenfour');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this2.context, 'model', {
          first: 'one',
          second: 'two',
          third: 'three',
          fourth: 'four'
        });
      });
      this.assertText('onetwothreefour');
    };

    _proto['@test it can be used as input for other helpers'] = function testItCanBeUsedAsInputForOtherHelpers() {
      var _this3 = this;

      this.registerHelper('x-eq', function (_ref) {
        var actual = _ref[0],
            expected = _ref[1];
        return actual === expected;
      });
      this.render("{{#if (x-eq (concat model.first model.second) \"onetwo\")}}Truthy!{{else}}False{{/if}}", {
        model: {
          first: 'one',
          second: 'two'
        }
      });
      this.assertText('Truthy!');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assertText('Truthy!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'model.first', 'three');
      });
      this.assertText('False');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'model', {
          first: 'one',
          second: 'two'
        });
      });
      this.assertText('Truthy!');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/custom-helper-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/glimmer", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _glimmer, _metal) {
  "use strict";

  /* globals EmberDev */
  (0, _internalTestHelpers.moduleFor)('Helpers test: custom helpers',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test it cannot override built-in syntax'] = function testItCannotOverrideBuiltInSyntax() {
      var _this = this;

      this.registerHelper('if', function () {
        return 'Nope';
      });
      expectAssertion(function () {
        _this.render("{{if foo 'LOL'}}", {
          foo: true
        });
      }, /You attempted to overwrite the built-in helper \"if\" which is not allowed. Please rename the helper./);
    };

    _proto['@test it can resolve custom simple helpers with or without dashes'] = function testItCanResolveCustomSimpleHelpersWithOrWithoutDashes() {
      var _this2 = this;

      this.registerHelper('hello', function () {
        return 'hello';
      });
      this.registerHelper('hello-world', function () {
        return 'hello world';
      });
      this.render('{{hello}} | {{hello-world}}');
      this.assertText('hello | hello world');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertText('hello | hello world');
    };

    _proto['@test it does not resolve helpers with a `.` (period)'] = function testItDoesNotResolveHelpersWithAPeriod() {
      var _this3 = this;

      this.registerHelper('hello.world', function () {
        return 'hello world';
      });
      this.render('{{hello.world}}', {
        hello: {
          world: ''
        }
      });
      this.assertText('');
      this.assertStableRerender();
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'hello', {
          world: 'hello world!'
        });
      });
      this.assertText('hello world!');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this3.context, 'hello', {
          world: ''
        });
      });
      this.assertText('');
    };

    _proto['@test it can resolve custom class-based helpers with or without dashes'] = function testItCanResolveCustomClassBasedHelpersWithOrWithoutDashes() {
      var _this4 = this;

      this.registerHelper('hello', {
        compute: function () {
          return 'hello';
        }
      });
      this.registerHelper('hello-world', {
        compute: function () {
          return 'hello world';
        }
      });
      this.render('{{hello}} | {{hello-world}}');
      this.assertText('hello | hello world');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      this.assertText('hello | hello world');
    };

    _proto['@test throws if `this._super` is not called from `init`'] = function testThrowsIfThis_superIsNotCalledFromInit() {
      var _this5 = this;

      this.registerHelper('hello-world', {
        init: function () {}
      });
      expectAssertion(function () {
        _this5.render('{{hello-world}}');
      }, /You must call `this._super\(...arguments\);` when overriding `init` on a framework object. Please update .* to call `this._super\(...arguments\);` from `init`./);
    };

    _proto['@test class-based helper can recompute a new value'] = function testClassBasedHelperCanRecomputeANewValue(assert) {
      var _this6 = this;

      var destroyCount = 0;
      var computeCount = 0;
      var helper;
      this.registerHelper('hello-world', {
        init: function () {
          this._super.apply(this, arguments);

          helper = this;
        },
        compute: function () {
          return ++computeCount;
        },
        destroy: function () {
          destroyCount++;

          this._super();
        }
      });
      this.render('{{hello-world}}');
      this.assertText('1');
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.rerender();
      });
      this.assertText('1');
      (0, _internalTestHelpers.runTask)(function () {
        return helper.recompute();
      });
      this.assertText('2');
      assert.strictEqual(destroyCount, 0, 'destroy is not called on recomputation');
    };

    _proto['@test class-based helper with static arguments can recompute a new value'] = function testClassBasedHelperWithStaticArgumentsCanRecomputeANewValue(assert) {
      var _this7 = this;

      var destroyCount = 0;
      var computeCount = 0;
      var helper;
      this.registerHelper('hello-world', {
        init: function () {
          this._super.apply(this, arguments);

          helper = this;
        },
        compute: function () {
          return ++computeCount;
        },
        destroy: function () {
          destroyCount++;

          this._super();
        }
      });
      this.render('{{hello-world "whut"}}');
      this.assertText('1');
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.rerender();
      });
      this.assertText('1');
      (0, _internalTestHelpers.runTask)(function () {
        return helper.recompute();
      });
      this.assertText('2');
      assert.strictEqual(destroyCount, 0, 'destroy is not called on recomputation');
    } // https://github.com/emberjs/ember.js/issues/14774
    ;

    _proto['@test class-based helper with static arguments can recompute a new value without a runloop'] = function testClassBasedHelperWithStaticArgumentsCanRecomputeANewValueWithoutARunloop(assert) {
      var _this8 = this;

      var destroyCount = 0;
      var computeCount = 0;
      var helper;
      this.registerHelper('hello-world', {
        init: function () {
          this._super.apply(this, arguments);

          helper = this;
        },
        compute: function () {
          return ++computeCount;
        },
        destroy: function () {
          destroyCount++;

          this._super();
        }
      });
      this.render('{{hello-world "whut"}}');
      this.assertText('1');
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.rerender();
      });
      this.assertText('1');
      helper.recompute();
      this.assertText('2');
      assert.strictEqual(destroyCount, 0, 'destroy is not called on recomputation');
    };

    _proto['@test helper params can be returned'] = function testHelperParamsCanBeReturned() {
      this.registerHelper('hello-world', function (values) {
        return values;
      });
      this.render('{{#each (hello-world model) as |item|}}({{item}}){{/each}}', {
        model: ['bob']
      });
      this.assertText('(bob)');
    };

    _proto['@test helper hash can be returned'] = function testHelperHashCanBeReturned() {
      this.registerHelper('hello-world', function (_, hash) {
        return hash.model;
      });
      this.render("{{get (hello-world model=model) 'name'}}", {
        model: {
          name: 'bob'
        }
      });
      this.assertText('bob');
    };

    _proto['@test simple helper is called for param changes'] = function testSimpleHelperIsCalledForParamChanges(assert) {
      var _this9 = this;

      var computeCount = 0;
      this.registerHelper('hello-world', function (_ref) {
        var value = _ref[0];
        computeCount++;
        return value + "-value";
      });
      this.render('{{hello-world model.name}}', {
        model: {
          name: 'bob'
        }
      });
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.rerender();
      });
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this9.context, 'model.name', 'sal');
      });
      this.assertText('sal-value');
      assert.strictEqual(computeCount, 2, 'compute is called exactly 2 times');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this9.context, 'model', {
          name: 'bob'
        });
      });
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 3, 'compute is called exactly 3 times');
    };

    _proto['@test class-based helper compute is called for param changes'] = function testClassBasedHelperComputeIsCalledForParamChanges(assert) {
      var _this10 = this;

      var createCount = 0;
      var computeCount = 0;
      this.registerHelper('hello-world', {
        init: function () {
          this._super.apply(this, arguments);

          createCount++;
        },
        compute: function (_ref2) {
          var value = _ref2[0];
          computeCount++;
          return value + "-value";
        }
      });
      this.render('{{hello-world model.name}}', {
        model: {
          name: 'bob'
        }
      });
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.rerender();
      });
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'model.name', 'sal');
      });
      this.assertText('sal-value');
      assert.strictEqual(computeCount, 2, 'compute is called exactly 2 times');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'model', {
          name: 'bob'
        });
      });
      this.assertText('bob-value');
      assert.strictEqual(computeCount, 3, 'compute is called exactly 3 times');
      assert.strictEqual(createCount, 1, 'helper is only created once');
    };

    _proto['@test simple helper receives params, hash'] = function testSimpleHelperReceivesParamsHash() {
      var _this11 = this;

      this.registerHelper('hello-world', function (_params, _hash) {
        return "params: " + JSON.stringify(_params) + ", hash: " + JSON.stringify(_hash);
      });
      this.render('{{hello-world model.name "rich" first=model.age last="sam"}}', {
        model: {
          name: 'bob',
          age: 42
        }
      });
      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');
      (0, _internalTestHelpers.runTask)(function () {
        return _this11.rerender();
      });
      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'model.name', 'sal');
      });
      this.assertText('params: ["sal","rich"], hash: {"first":42,"last":"sam"}');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'model.age', 28);
      });
      this.assertText('params: ["sal","rich"], hash: {"first":28,"last":"sam"}');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'model', {
          name: 'bob',
          age: 42
        });
      });
      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');
    };

    _proto['@test class-based helper receives params, hash'] = function testClassBasedHelperReceivesParamsHash() {
      var _this12 = this;

      this.registerHelper('hello-world', {
        compute: function (_params, _hash) {
          return "params: " + JSON.stringify(_params) + ", hash: " + JSON.stringify(_hash);
        }
      });
      this.render('{{hello-world model.name "rich" first=model.age last="sam"}}', {
        model: {
          name: 'bob',
          age: 42
        }
      });
      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.rerender();
      });
      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'model.name', 'sal');
      });
      this.assertText('params: ["sal","rich"], hash: {"first":42,"last":"sam"}');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'model.age', 28);
      });
      this.assertText('params: ["sal","rich"], hash: {"first":28,"last":"sam"}');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'model', {
          name: 'bob',
          age: 42
        });
      });
      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');
    };

    _proto['@test class-based helper usable in subexpressions'] = function testClassBasedHelperUsableInSubexpressions() {
      var _this13 = this;

      this.registerHelper('join-words', {
        compute: function (params) {
          return params.join(' ');
        }
      });
      this.render("{{join-words \"Who\"\n                   (join-words \"overcomes\" \"by\")\n                   model.reason\n                   (join-words (join-words \"hath overcome but\" \"half\"))\n                   (join-words \"his\" (join-words \"foe\"))}}", {
        model: {
          reason: 'force'
        }
      });
      this.assertText('Who overcomes by force hath overcome but half his foe');
      (0, _internalTestHelpers.runTask)(function () {
        return _this13.rerender();
      });
      this.assertText('Who overcomes by force hath overcome but half his foe');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'model.reason', 'Nickleback');
      });
      this.assertText('Who overcomes by Nickleback hath overcome but half his foe');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'model', {
          reason: 'force'
        });
      });
      this.assertText('Who overcomes by force hath overcome but half his foe');
    };

    _proto['@test parameterless helper is usable in subexpressions'] = function testParameterlessHelperIsUsableInSubexpressions() {
      var _this14 = this;

      this.registerHelper('should-show', function () {
        return true;
      });
      this.render("{{#if (should-show)}}true{{/if}}");
      this.assertText('true');
      (0, _internalTestHelpers.runTask)(function () {
        return _this14.rerender();
      });
      this.assertText('true');
    };

    _proto['@test parameterless helper is usable in attributes'] = function testParameterlessHelperIsUsableInAttributes() {
      var _this15 = this;

      this.registerHelper('foo-bar', function () {
        return 'baz';
      });
      this.render("<div data-foo-bar=\"{{foo-bar}}\"></div>");
      this.assertHTML('<div data-foo-bar="baz"></div>');
      (0, _internalTestHelpers.runTask)(function () {
        return _this15.rerender();
      });
      this.assertHTML('<div data-foo-bar="baz"></div>');
    };

    _proto['@test simple helper not usable with a block'] = function testSimpleHelperNotUsableWithABlock() {
      var _this16 = this;

      this.registerHelper('some-helper', function () {});
      expectAssertion(function () {
        _this16.render("{{#some-helper}}{{/some-helper}}");
      }, /Helpers may not be used in the block form/);
    };

    _proto['@test class-based helper not usable with a block'] = function testClassBasedHelperNotUsableWithABlock() {
      var _this17 = this;

      this.registerHelper('some-helper', {
        compute: function () {}
      });
      expectAssertion(function () {
        _this17.render("{{#some-helper}}{{/some-helper}}");
      }, /Helpers may not be used in the block form/);
    };

    _proto['@test simple helper not usable within element'] = function testSimpleHelperNotUsableWithinElement() {
      var _this18 = this;

      this.registerHelper('some-helper', function () {});
      this.assert.throws(function () {
        _this18.render("<div {{some-helper}}></div>");
      }, /Compile Error some-helper is not a modifier: Helpers may not be used in the element form/);
    };

    _proto['@test class-based helper not usable within element'] = function testClassBasedHelperNotUsableWithinElement() {
      var _this19 = this;

      this.registerHelper('some-helper', {
        compute: function () {}
      });
      this.assert.throws(function () {
        _this19.render("<div {{some-helper}}></div>");
      }, /Compile Error some-helper is not a modifier: Helpers may not be used in the element form/);
    };

    _proto['@test class-based helper is torn down'] = function testClassBasedHelperIsTornDown(assert) {
      var destroyCalled = 0;
      this.registerHelper('some-helper', {
        destroy: function () {
          destroyCalled++;

          this._super.apply(this, arguments);
        },
        compute: function () {
          return 'must define a compute';
        }
      });
      this.render("{{some-helper}}");
      (0, _internalTestHelpers.runDestroy)(this.component);
      assert.strictEqual(destroyCalled, 1, 'destroy called once');
    };

    _proto['@test class-based helper used in subexpression can recompute'] = function testClassBasedHelperUsedInSubexpressionCanRecompute() {
      var _this20 = this;

      var helper;
      var phrase = 'overcomes by';
      this.registerHelper('dynamic-segment', {
        init: function () {
          this._super.apply(this, arguments);

          helper = this;
        },
        compute: function () {
          return phrase;
        }
      });
      this.registerHelper('join-words', {
        compute: function (params) {
          return params.join(' ');
        }
      });
      this.render("{{join-words \"Who\"\n                   (dynamic-segment)\n                   \"force\"\n                   (join-words (join-words \"hath overcome but\" \"half\"))\n                   (join-words \"his\" (join-words \"foe\"))}}");
      this.assertText('Who overcomes by force hath overcome but half his foe');
      (0, _internalTestHelpers.runTask)(function () {
        return _this20.rerender();
      });
      this.assertText('Who overcomes by force hath overcome but half his foe');
      phrase = 'believes his';
      (0, _internalTestHelpers.runTask)(function () {
        return helper.recompute();
      });
      this.assertText('Who believes his force hath overcome but half his foe');
      phrase = 'overcomes by';
      (0, _internalTestHelpers.runTask)(function () {
        return helper.recompute();
      });
      this.assertText('Who overcomes by force hath overcome but half his foe');
    };

    _proto['@test class-based helper used in subexpression can recompute component'] = function testClassBasedHelperUsedInSubexpressionCanRecomputeComponent() {
      var _this21 = this;

      var helper;
      var phrase = 'overcomes by';
      this.registerHelper('dynamic-segment', {
        init: function () {
          this._super.apply(this, arguments);

          helper = this;
        },
        compute: function () {
          return phrase;
        }
      });
      this.registerHelper('join-words', {
        compute: function (params) {
          return params.join(' ');
        }
      });
      this.registerComponent('some-component', {
        template: '{{first}} {{second}} {{third}} {{fourth}} {{fifth}}'
      });
      this.render("{{some-component first=\"Who\"\n                   second=(dynamic-segment)\n                   third=\"force\"\n                   fourth=(join-words (join-words \"hath overcome but\" \"half\"))\n                   fifth=(join-words \"his\" (join-words \"foe\"))}}");
      this.assertText('Who overcomes by force hath overcome but half his foe');
      (0, _internalTestHelpers.runTask)(function () {
        return _this21.rerender();
      });
      this.assertText('Who overcomes by force hath overcome but half his foe');
      phrase = 'believes his';
      (0, _internalTestHelpers.runTask)(function () {
        return helper.recompute();
      });
      this.assertText('Who believes his force hath overcome but half his foe');
      phrase = 'overcomes by';
      (0, _internalTestHelpers.runTask)(function () {
        return helper.recompute();
      });
      this.assertText('Who overcomes by force hath overcome but half his foe');
    };

    _proto['@test class-based helper used in subexpression is destroyed'] = function testClassBasedHelperUsedInSubexpressionIsDestroyed(assert) {
      var destroyCount = 0;
      this.registerHelper('dynamic-segment', {
        phrase: 'overcomes by',
        init: function () {
          this._super.apply(this, arguments);
        },
        compute: function () {
          return this.phrase;
        },
        destroy: function () {
          destroyCount++;

          this._super.apply(this, arguments);
        }
      });
      this.registerHelper('join-words', {
        compute: function (params) {
          return params.join(' ');
        }
      });
      this.render("{{join-words \"Who\"\n                   (dynamic-segment)\n                   \"force\"\n                   (join-words (join-words \"hath overcome but\" \"half\"))\n                   (join-words \"his\" (join-words \"foe\"))}}");
      (0, _internalTestHelpers.runDestroy)(this.component);
      assert.equal(destroyCount, 1, 'destroy is called after a view is destroyed');
    };

    _proto['@test simple helper can be invoked manually via `owner.factoryFor(...).create().compute()'] = function testSimpleHelperCanBeInvokedManuallyViaOwnerFactoryForCreateCompute(assert) {
      this.registerHelper('some-helper', function () {
        assert.ok(true, 'some-helper helper invoked');
        return 'lolol';
      });
      var instance = this.owner.factoryFor('helper:some-helper').create();
      assert.equal(typeof instance.compute, 'function', 'expected instance.compute to be present');
      assert.equal(instance.compute(), 'lolol', 'can invoke `.compute`');
    };

    _proto['@test class-based helper can be invoked manually via `owner.factoryFor(...).create().compute()'] = function testClassBasedHelperCanBeInvokedManuallyViaOwnerFactoryForCreateCompute(assert) {
      this.registerHelper('some-helper', {
        compute: function () {
          assert.ok(true, 'some-helper helper invoked');
          return 'lolol';
        }
      });
      var instance = this.owner.factoryFor('helper:some-helper').create();
      assert.equal(typeof instance.compute, 'function', 'expected instance.compute to be present');
      assert.equal(instance.compute(), 'lolol', 'can invoke `.compute`');
    };

    _proto['@feature(EMBER_FRAMEWORK_OBJECT_OWNER_ARGUMENT) class-based helper in native ES syntax receives owner'] = function featureEMBER_FRAMEWORK_OBJECT_OWNER_ARGUMENTClassBasedHelperInNativeESSyntaxReceivesOwner(assert) {
      var testContext = this;
      this.add('helper:hello-world',
      /*#__PURE__*/
      function (_Helper) {
        (0, _emberBabel.inheritsLoose)(_class2, _Helper);

        function _class2(owner) {
          var _this22;

          _this22 = _Helper.call(this, owner) || this;
          assert.equal(owner, testContext.owner, 'owner was passed as a constructor argument');
          return _this22;
        }

        var _proto2 = _class2.prototype;

        _proto2.compute = function compute() {
          return 'huzza!';
        };

        return _class2;
      }(_glimmer.Helper));
      this.render('{{hello-world}}');
      this.assertText('huzza!');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));

  if (!EmberDev.runningProdBuild) {
    var HelperMutatingArgsTests =
    /*#__PURE__*/
    function (_RenderingTestCase2) {
      (0, _emberBabel.inheritsLoose)(HelperMutatingArgsTests, _RenderingTestCase2);

      function HelperMutatingArgsTests() {
        return _RenderingTestCase2.apply(this, arguments) || this;
      }

      var _proto3 = HelperMutatingArgsTests.prototype;

      _proto3.buildCompute = function buildCompute() {
        var _this23 = this;

        return function (params, hash) {
          _this23.assert.throws(function () {
            params.push('foo'); // cannot assert error message as it varies by platform
          });

          _this23.assert.throws(function () {
            hash.foo = 'bar'; // cannot assert error message as it varies by platform
          });

          _this23.assert.throws(function () {
            hash.someUnusedHashProperty = 'bar'; // cannot assert error message as it varies by platform
          });
        };
      };

      _proto3['@test cannot mutate params - no positional specified / named specified'] = function testCannotMutateParamsNoPositionalSpecifiedNamedSpecified() {
        this.render('{{test-helper foo=bar}}', {
          bar: 'derp'
        });
      };

      _proto3['@test cannot mutate params - positional specified / no named specified'] = function testCannotMutateParamsPositionalSpecifiedNoNamedSpecified() {
        this.render('{{test-helper bar}}', {
          bar: 'derp'
        });
      };

      _proto3['@test cannot mutate params - positional specified / named specified'] = function testCannotMutateParamsPositionalSpecifiedNamedSpecified() {
        this.render('{{test-helper bar foo=qux}}', {
          bar: 'derp',
          qux: 'baz'
        });
      };

      _proto3['@test cannot mutate params - no positional specified / no named specified'] = function testCannotMutateParamsNoPositionalSpecifiedNoNamedSpecified() {
        this.render('{{test-helper}}', {
          bar: 'derp',
          qux: 'baz'
        });
      };

      return HelperMutatingArgsTests;
    }(_internalTestHelpers.RenderingTestCase);

    (0, _internalTestHelpers.moduleFor)('Helpers test: mutation triggers errors - class based helper',
    /*#__PURE__*/
    function (_HelperMutatingArgsTe) {
      (0, _emberBabel.inheritsLoose)(_class3, _HelperMutatingArgsTe);

      function _class3() {
        var _this24;

        _this24 = _HelperMutatingArgsTe.apply(this, arguments) || this;

        var compute = _this24.buildCompute();

        _this24.registerHelper('test-helper', {
          compute: compute
        });

        return _this24;
      }

      return _class3;
    }(HelperMutatingArgsTests));
    (0, _internalTestHelpers.moduleFor)('Helpers test: mutation triggers errors - simple helper',
    /*#__PURE__*/
    function (_HelperMutatingArgsTe2) {
      (0, _emberBabel.inheritsLoose)(_class4, _HelperMutatingArgsTe2);

      function _class4() {
        var _this25;

        _this25 = _HelperMutatingArgsTe2.apply(this, arguments) || this;

        var compute = _this25.buildCompute();

        _this25.registerHelper('test-helper', compute);

        return _this25;
      }

      return _class4;
    }(HelperMutatingArgsTests));
  }
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/element-action-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/instrumentation", "@ember/-internals/runtime", "@ember/-internals/views", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _instrumentation, _runtime, _views, _helpers) {
  "use strict";

  function _templateObject8() {
    const data = _taggedTemplateLiteralLoose(["\n        <button>Click Me</button>\n        {{yield}}\n      "]);

    _templateObject8 = function () {
      return data;
    };

    return data;
  }

  function _templateObject7() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#middle-component}}\n          {{inner-component action=\"hey\"}}\n        {{/middle-component}}\n      "]);

    _templateObject7 = function () {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    const data = _taggedTemplateLiteralLoose(["\n        <a href=\"#\"\n          {{action \"clicked1\" on=\"click\"}}\n          {{action \"clicked2\" on=\"click\"}}\n        >click me</a>"]);

    _templateObject6 = function () {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    const data = _taggedTemplateLiteralLoose(["\n        <a href=\"#\"\n          {{action \"clicked\" on=\"click\"}}\n          {{action \"doubleClicked\" on=\"doubleClick\"}}\n        >click me</a>"]);

    _templateObject5 = function () {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#target-component as |aTarget|}}\n          <a id=\"edit\" href=\"#\" {{action \"edit\" this target=aTarget}}>click me</a>\n        {{/target-component}}\n        "]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["\n        <a href=\"#\"\n          {{action \"clicked1\" on=\"click\" bubbles=false}}\n          {{action \"clicked2\" on=\"click\" bubbles=false}}\n        >click me</a>"]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n          {{#target-component as |parent|}}\n            {{other-component anotherTarget=parent}}\n          {{/target-component}}\n        "]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#inner-component}}\n          <button {{action \"wat\"}}>Wat me!</button>\n        {{/inner-component}}\n      "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  function getActionAttributes(element) {
    var attributes = element.attributes;
    var actionAttrs = [];

    for (var i = 0; i < attributes.length; i++) {
      var attr = attributes.item(i);

      if (attr.name.indexOf('data-ember-action-') === 0) {
        actionAttrs.push(attr.name);
      }
    }

    return actionAttrs;
  }

  function getActionIds(element) {
    return getActionAttributes(element).map(function (attribute) {
      return attribute.slice('data-ember-action-'.length);
    });
  }

  var isIE11 = !window.ActiveXObject && 'ActiveXObject' in window;

  if (false
  /* EMBER_IMPROVED_INSTRUMENTATION */
  ) {
      (0, _internalTestHelpers.moduleFor)('Helpers test: element action instrumentation',
      /*#__PURE__*/
      function (_RenderingTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

        function _class() {
          return _RenderingTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto.teardown = function teardown() {
          _RenderingTestCase.prototype.teardown.call(this);

          (0, _instrumentation.reset)();
        };

        _proto['@test action should fire interaction event with proper params'] = function testActionShouldFireInteractionEventWithProperParams() {
          var _this = this;

          var subscriberCallCount = 0;
          var subscriberPayload = null;

          var ExampleComponent = _helpers.Component.extend({
            actions: {
              foo: function () {}
            }
          });

          this.registerComponent('example-component', {
            ComponentClass: ExampleComponent,
            template: '<button {{action "foo" "bar"}}>Click me</button>'
          });
          (0, _instrumentation.subscribe)('interaction.ember-action', {
            before: function () {
              subscriberCallCount++;
            },
            after: function (name, time, payload) {
              subscriberPayload = payload;
            }
          });
          this.render('{{example-component}}');
          this.assert.equal(subscriberCallCount, 0, 'subscriber has not been called');
          (0, _internalTestHelpers.runTask)(function () {
            return _this.rerender();
          });
          this.assert.equal(subscriberCallCount, 0, 'subscriber has not been called');
          (0, _internalTestHelpers.runTask)(function () {
            _this.$('button').click();
          });
          this.assert.equal(subscriberCallCount, 1, 'subscriber has been called 1 time');
          this.assert.equal(subscriberPayload.name, 'foo', 'subscriber called with correct name');
          this.assert.equal(subscriberPayload.args[0], 'bar', 'subscriber called with correct args');
        };

        return _class;
      }(_internalTestHelpers.RenderingTestCase));
    }

  (0, _internalTestHelpers.moduleFor)('Helpers test: element action',
  /*#__PURE__*/
  function (_RenderingTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _RenderingTestCase2);

    function _class2() {
      return _RenderingTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test it can call an action on its enclosing component'] = function testItCanCallAnActionOnItsEnclosingComponent() {
      var _this2 = this;

      var fooCallCount = 0;

      var ExampleComponent = _helpers.Component.extend({
        actions: {
          foo: function () {
            fooCallCount++;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action "foo"}}>Click me</button>'
      });
      this.render('{{example-component}}');
      this.assert.equal(fooCallCount, 0, 'foo has not been called');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assert.equal(fooCallCount, 0, 'foo has not been called');
      (0, _internalTestHelpers.runTask)(function () {
        _this2.$('button').click();
      });
      this.assert.equal(fooCallCount, 1, 'foo has been called 1 time');
      (0, _internalTestHelpers.runTask)(function () {
        _this2.$('button').click();
      });
      this.assert.equal(fooCallCount, 2, 'foo has been called 2 times');
    };

    _proto2['@test it can call an action with parameters'] = function testItCanCallAnActionWithParameters() {
      var _this3 = this;

      var fooArgs = [];
      var component;

      var ExampleComponent = _helpers.Component.extend({
        member: 'a',
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        actions: {
          foo: function (thing) {
            fooArgs.push(thing);
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action "foo" member}}>Click me</button>'
      });
      this.render('{{example-component}}');
      this.assert.deepEqual(fooArgs, [], 'foo has not been called');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assert.deepEqual(fooArgs, [], 'foo has not been called');
      (0, _internalTestHelpers.runTask)(function () {
        _this3.$('button').click();
      });
      this.assert.deepEqual(fooArgs, ['a'], 'foo has not been called');
      (0, _internalTestHelpers.runTask)(function () {
        component.set('member', 'b');
      });
      (0, _internalTestHelpers.runTask)(function () {
        _this3.$('button').click();
      });
      this.assert.deepEqual(fooArgs, ['a', 'b'], 'foo has been called with an updated value');
    };

    _proto2['@test it should output a marker attribute with a guid'] = function testItShouldOutputAMarkerAttributeWithAGuid() {
      this.render('<button {{action "show"}}>me the money</button>');
      var button = this.$('button');
      var attributes = getActionAttributes(button[0]);
      this.assert.ok(button.attr('data-ember-action').match(''), 'An empty data-ember-action attribute was added');
      this.assert.ok(attributes[0].match(/data-ember-action-\d+/), 'A data-ember-action-xyz attribute with a guid was added');
    };

    _proto2['@test it should allow alternative events to be handled'] = function testItShouldAllowAlternativeEventsToBeHandled() {
      var _this4 = this;

      var showCalled = false;

      var ExampleComponent = _helpers.Component.extend({
        actions: {
          show: function () {
            showCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<div id="show" {{action "show" on="mouseUp"}}></div>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this4.$('#show').trigger('mouseup');
      });
      this.assert.ok(showCalled, 'show action was called on mouseUp');
    };

    _proto2['@test inside a yield, the target points at the original target'] = function testInsideAYieldTheTargetPointsAtTheOriginalTarget() {
      var _this5 = this;

      var targetWatted = false;
      var innerWatted = false;

      var TargetComponent = _helpers.Component.extend({
        actions: {
          wat: function () {
            targetWatted = true;
          }
        }
      });

      var InnerComponent = _helpers.Component.extend({
        actions: {
          wat: function () {
            innerWatted = true;
          }
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: '{{yield}}'
      });
      this.registerComponent('target-component', {
        ComponentClass: TargetComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject())
      });
      this.render('{{target-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this5.$('button').click();
      });
      this.assert.ok(targetWatted, 'the correct target was watted');
      this.assert.notOk(innerWatted, 'the inner target was not watted');
    };

    _proto2['@test it should allow a target to be specified'] = function testItShouldAllowATargetToBeSpecified() {
      var _this6 = this;

      var targetWatted = false;

      var TargetComponent = _helpers.Component.extend({
        actions: {
          wat: function () {
            targetWatted = true;
          }
        }
      });

      var OtherComponent = _helpers.Component.extend({});

      this.registerComponent('target-component', {
        ComponentClass: TargetComponent,
        template: '{{yield this}}'
      });
      this.registerComponent('other-component', {
        ComponentClass: OtherComponent,
        template: '<a {{action "wat" target=anotherTarget}}>Wat?</a>'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject2()));
      (0, _internalTestHelpers.runTask)(function () {
        _this6.$('a').click();
      });
      this.assert.equal(targetWatted, true, 'the specified target was watted');
    };

    _proto2['@test it should lazily evaluate the target'] = function testItShouldLazilyEvaluateTheTarget() {
      var _this7 = this;

      var firstEdit = 0;
      var secondEdit = 0;
      var component;
      var first = {
        edit: function () {
          firstEdit++;
        }
      };
      var second = {
        edit: function () {
          secondEdit++;
        }
      };

      var ExampleComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        theTarget: first
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a {{action "edit" target=theTarget}}>Edit</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this7.$('a').click();
      });
      this.assert.equal(firstEdit, 1);
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(component, 'theTarget', second);
      });
      (0, _internalTestHelpers.runTask)(function () {
        _this7.$('a').click();
      });
      this.assert.equal(firstEdit, 1);
      this.assert.equal(secondEdit, 1);
    };

    _proto2['@test it should register an event handler'] = function testItShouldRegisterAnEventHandler() {
      var _this8 = this;

      var editHandlerWasCalled = false;
      var shortcutHandlerWasCalled = false;

      var ExampleComponent = _helpers.Component.extend({
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          },
          shortcut: function () {
            shortcutHandlerWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit" allowedKeys="alt"}}>click me</a> <div {{action "shortcut" allowedKeys="any"}}>click me too</div>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this8.$('a[data-ember-action]').trigger('click', {
          altKey: true
        });
      });
      this.assert.equal(editHandlerWasCalled, true, 'the event handler was called');
      (0, _internalTestHelpers.runTask)(function () {
        _this8.$('div[data-ember-action]').trigger('click', {
          ctrlKey: true
        });
      });
      this.assert.equal(shortcutHandlerWasCalled, true, 'the "any" shortcut\'s event handler was called');
    };

    _proto2['@test it handles whitelisted bound modifier keys'] = function testItHandlesWhitelistedBoundModifierKeys() {
      var _this9 = this;

      var editHandlerWasCalled = false;
      var shortcutHandlerWasCalled = false;

      var ExampleComponent = _helpers.Component.extend({
        altKey: 'alt',
        anyKey: 'any',
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          },
          shortcut: function () {
            shortcutHandlerWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit" allowedKeys=altKey}}>click me</a> <div {{action "shortcut" allowedKeys=anyKey}}>click me too</div>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this9.$('a[data-ember-action]').trigger('click', {
          altKey: true
        });
      });
      this.assert.equal(editHandlerWasCalled, true, 'the event handler was called');
      (0, _internalTestHelpers.runTask)(function () {
        _this9.$('div[data-ember-action]').trigger('click', {
          ctrlKey: true
        });
      });
      this.assert.equal(shortcutHandlerWasCalled, true, 'the "any" shortcut\'s event handler was called');
    };

    _proto2['@test it handles whitelisted bound modifier keys with current value'] = function testItHandlesWhitelistedBoundModifierKeysWithCurrentValue() {
      var _this10 = this;

      var editHandlerWasCalled = false;
      var component;

      var ExampleComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        acceptedKeys: 'alt',
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit" allowedKeys=acceptedKeys}}>click me</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this10.$('a[data-ember-action]').trigger('click', {
          altKey: true
        });
      });
      this.assert.equal(editHandlerWasCalled, true, 'the event handler was called');
      editHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(function () {
        component.set('acceptedKeys', '');
      });
      (0, _internalTestHelpers.runTask)(function () {
        _this10.$('div[data-ember-action]').click();
      });
      this.assert.equal(editHandlerWasCalled, false, 'the event handler was not called');
    };

    _proto2['@test should be able to use action more than once for the same event within a view'] = function testShouldBeAbleToUseActionMoreThanOnceForTheSameEventWithinAView() {
      var _this11 = this;

      var editHandlerWasCalled = false;
      var deleteHandlerWasCalled = false;
      var originalHandlerWasCalled = false;
      var component;

      var ExampleComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          },
          delete: function () {
            deleteHandlerWasCalled = true;
          }
        },
        click: function () {
          originalHandlerWasCalled = true;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="edit" href="#" {{action "edit"}}>edit</a><a id="delete" href="#" {{action "delete"}}>delete</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this11.$('#edit').click();
      });
      this.assert.equal(editHandlerWasCalled, true, 'the edit action was called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called (due to bubbling)');
      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(function () {
        _this11.$('#delete').click();
      });
      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, true, 'the delete action was called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called (due to bubbling)');
      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(function () {
        _this11.wrap(component.element).click();
      });
      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called');
    };

    _proto2['@test the event should not bubble if `bubbles=false` is passed'] = function testTheEventShouldNotBubbleIfBubblesFalseIsPassed() {
      var _this12 = this;

      var editHandlerWasCalled = false;
      var deleteHandlerWasCalled = false;
      var originalHandlerWasCalled = false;
      var component;

      var ExampleComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          },
          delete: function () {
            deleteHandlerWasCalled = true;
          }
        },
        click: function () {
          originalHandlerWasCalled = true;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="edit" href="#" {{action "edit" bubbles=false}}>edit</a><a id="delete" href="#" {{action "delete" bubbles=false}}>delete</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this12.$('#edit').click();
      });
      this.assert.equal(editHandlerWasCalled, true, 'the edit action was called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, false, 'the click handler was not called');
      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(function () {
        _this12.$('#delete').click();
      });
      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, true, 'the delete action was called');
      this.assert.equal(originalHandlerWasCalled, false, 'the click handler was not called');
      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(function () {
        _this12.wrap(component.element).click();
      });
      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called');
    };

    _proto2['@test the event should not bubble if `bubbles=false` is passed bound'] = function testTheEventShouldNotBubbleIfBubblesFalseIsPassedBound() {
      var _this13 = this;

      var editHandlerWasCalled = false;
      var deleteHandlerWasCalled = false;
      var originalHandlerWasCalled = false;
      var component;

      var ExampleComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        isFalse: false,
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          },
          delete: function () {
            deleteHandlerWasCalled = true;
          }
        },
        click: function () {
          originalHandlerWasCalled = true;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="edit" href="#" {{action "edit" bubbles=isFalse}}>edit</a><a id="delete" href="#" {{action "delete" bubbles=isFalse}}>delete</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this13.$('#edit').click();
      });
      this.assert.equal(editHandlerWasCalled, true, 'the edit action was called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, false, 'the click handler was not called');
      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(function () {
        _this13.$('#delete').click();
      });
      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, true, 'the delete action was called');
      this.assert.equal(originalHandlerWasCalled, false, 'the click handler was not called');
      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(function () {
        _this13.wrap(component.element).click();
      });
      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called');
    };

    _proto2['@test the bubbling depends on the bound parameter'] = function testTheBubblingDependsOnTheBoundParameter() {
      var _this14 = this;

      var editHandlerWasCalled = false;
      var originalHandlerWasCalled = false;
      var component;

      var ExampleComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        shouldBubble: false,
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          }
        },
        click: function () {
          originalHandlerWasCalled = true;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="edit" href="#" {{action "edit" bubbles=shouldBubble}}>edit</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this14.$('#edit').click();
      });
      this.assert.equal(editHandlerWasCalled, true, 'the edit action was called');
      this.assert.equal(originalHandlerWasCalled, false, 'the click handler was not called');
      editHandlerWasCalled = originalHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(function () {
        component.set('shouldBubble', true);
      });
      (0, _internalTestHelpers.runTask)(function () {
        _this14.$('#edit').click();
      });
      this.assert.equal(editHandlerWasCalled, true, 'the edit action was called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called');
    };

    _proto2['@test multiple actions with bubbles=false for same event are called but prevent bubbling'] = function testMultipleActionsWithBubblesFalseForSameEventAreCalledButPreventBubbling() {
      var _this15 = this;

      var clickAction1WasCalled = false;
      var clickAction2WasCalled = false;
      var eventHandlerWasCalled = false;

      var ExampleComponent = _helpers.Component.extend({
        actions: {
          clicked1: function () {
            clickAction1WasCalled = true;
          },
          clicked2: function () {
            clickAction2WasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject3()),
        click: function () {
          eventHandlerWasCalled = true;
        }
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this15.$('a').trigger('click');
      });
      this.assert.ok(clickAction1WasCalled, 'the first clicked action was called');
      this.assert.ok(clickAction2WasCalled, 'the second clicked action was called');
      this.assert.notOk(eventHandlerWasCalled, 'event did not bubble up');
    };

    _proto2['@test it should work properly in an #each block'] = function testItShouldWorkProperlyInAnEachBlock() {
      var _this16 = this;

      var editHandlerWasCalled = false;

      var ExampleComponent = _helpers.Component.extend({
        items: (0, _runtime.A)([1, 2, 3, 4]),
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '{{#each items as |item|}}<a href="#" {{action "edit"}}>click me</a>{{/each}}'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this16.$('a').click();
      });
      this.assert.equal(editHandlerWasCalled, true, 'the event handler was called');
    };

    _proto2['@test it should work properly in a {{#with foo as |bar|}} block'] = function testItShouldWorkProperlyInAWithFooAsBarBlock() {
      var _this17 = this;

      var editHandlerWasCalled = false;

      var ExampleComponent = _helpers.Component.extend({
        something: {
          ohai: 'there'
        },
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '{{#with something as |somethingElse|}}<a href="#" {{action "edit"}}>click me</a>{{/with}}'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this17.$('a').click();
      });
      this.assert.equal(editHandlerWasCalled, true, 'the event handler was called');
    };

    _proto2['@test it should unregister event handlers when an element action is removed'] = function testItShouldUnregisterEventHandlersWhenAnElementActionIsRemoved(assert) {
      var _this18 = this;

      var ExampleComponent = _helpers.Component.extend({
        actions: {
          edit: function () {}
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '{{#if isActive}}<a href="#" {{action "edit"}}>click me</a>{{/if}}'
      });
      this.render('{{example-component isActive=isActive}}', {
        isActive: true
      });
      assert.equal(this.$('a[data-ember-action]').length, 1, 'The element is rendered');
      var actionId;
      actionId = getActionIds(this.$('a[data-ember-action]')[0])[0];
      assert.ok(_views.ActionManager.registeredActions[actionId], 'An action is registered');
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.rerender();
      });
      assert.equal(this.$('a[data-ember-action]').length, 1, 'The element is still present');
      assert.ok(_views.ActionManager.registeredActions[actionId], 'The action is still registered');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this18.context, 'isActive', false);
      });
      assert.strictEqual(this.$('a[data-ember-action]').length, 0, 'The element is removed');
      assert.ok(!_views.ActionManager.registeredActions[actionId], 'The action is unregistered');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this18.context, 'isActive', true);
      });
      assert.equal(this.$('a[data-ember-action]').length, 1, 'The element is rendered');
      actionId = getActionIds(this.$('a[data-ember-action]')[0])[0];
      assert.ok(_views.ActionManager.registeredActions[actionId], 'A new action is registered');
    };

    _proto2['@test it should capture events from child elements and allow them to trigger the action'] = function testItShouldCaptureEventsFromChildElementsAndAllowThemToTriggerTheAction() {
      var _this19 = this;

      var editHandlerWasCalled = false;

      var ExampleComponent = _helpers.Component.extend({
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<div {{action "edit"}}><button>click me</button></div>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this19.$('button').click();
      });
      this.assert.ok(editHandlerWasCalled, 'event on a child target triggered the action of its parent');
    };

    _proto2['@test it should allow bubbling of events from action helper to original parent event'] = function testItShouldAllowBubblingOfEventsFromActionHelperToOriginalParentEvent() {
      var _this20 = this;

      var editHandlerWasCalled = false;
      var originalHandlerWasCalled = false;

      var ExampleComponent = _helpers.Component.extend({
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          }
        },
        click: function () {
          originalHandlerWasCalled = true;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit"}}>click me</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this20.$('a').click();
      });
      this.assert.ok(editHandlerWasCalled && originalHandlerWasCalled, 'both event handlers were called');
    };

    _proto2['@test it should not bubble an event from action helper to original parent event if `bubbles=false` is passed'] = function testItShouldNotBubbleAnEventFromActionHelperToOriginalParentEventIfBubblesFalseIsPassed() {
      var _this21 = this;

      var editHandlerWasCalled = false;
      var originalHandlerWasCalled = false;

      var ExampleComponent = _helpers.Component.extend({
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          }
        },
        click: function () {
          originalHandlerWasCalled = true;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit" bubbles=false}}>click me</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this21.$('a').click();
      });
      this.assert.ok(editHandlerWasCalled, 'the child event handler was called');
      this.assert.notOk(originalHandlerWasCalled, 'the parent handler was not called');
    };

    _proto2['@test it should allow "send" as the action name (#594)'] = function testItShouldAllowSendAsTheActionName594() {
      var _this22 = this;

      var sendHandlerWasCalled = false;

      var ExampleComponent = _helpers.Component.extend({
        actions: {
          send: function () {
            sendHandlerWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "send"}}>click me</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this22.$('a').click();
      });
      this.assert.ok(sendHandlerWasCalled, 'the event handler was called');
    };

    _proto2['@test it should send the view, event, and current context to the action'] = function testItShouldSendTheViewEventAndCurrentContextToTheAction() {
      var _this23 = this;

      var passedTarget;
      var passedContext;
      var targetThis;

      var TargetComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          targetThis = this;
        },
        actions: {
          edit: function (context) {
            passedTarget = this === targetThis;
            passedContext = context;
          }
        }
      });

      var aContext;

      var ExampleComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          aContext = this;
        }
      });

      this.registerComponent('target-component', {
        ComponentClass: TargetComponent,
        template: '{{yield this}}'
      });
      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject4())
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this23.$('#edit').click();
      });
      this.assert.ok(passedTarget, 'the action is called with the target as this');
      this.assert.strictEqual(passedContext, aContext, 'the parameter is passed along');
    };

    _proto2['@test it should only trigger actions for the event they were registered on'] = function testItShouldOnlyTriggerActionsForTheEventTheyWereRegisteredOn() {
      var _this24 = this;

      var editHandlerWasCalled = false;

      var ExampleComponent = _helpers.Component.extend({
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit"}}>click me</a>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this24.$('a').click();
      });
      this.assert.ok(editHandlerWasCalled, 'the event handler was called on click');
      editHandlerWasCalled = false;
      (0, _internalTestHelpers.runTask)(function () {
        _this24.$('a').trigger('mouseover');
      });
      this.assert.notOk(editHandlerWasCalled, 'the event handler was not called on mouseover');
    };

    _proto2['@test it should allow multiple contexts to be specified'] = function testItShouldAllowMultipleContextsToBeSpecified() {
      var _this25 = this;

      var passedContexts;
      var models = [_runtime.Object.create(), _runtime.Object.create()];

      var ExampleComponent = _helpers.Component.extend({
        modelA: models[0],
        modelB: models[1],
        actions: {
          edit: function () {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            passedContexts = args;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action "edit" modelA modelB}}>click me</button>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this25.$('button').click();
      });
      this.assert.deepEqual(passedContexts, models, 'the action was called with the passed contexts');
    };

    _proto2['@test it should allow multiple contexts to be specified mixed with string args'] = function testItShouldAllowMultipleContextsToBeSpecifiedMixedWithStringArgs() {
      var _this26 = this;

      var passedContexts;

      var model = _runtime.Object.create();

      var ExampleComponent = _helpers.Component.extend({
        model: model,
        actions: {
          edit: function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            passedContexts = args;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action "edit" "herp" model}}>click me</button>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this26.$('button').click();
      });
      this.assert.deepEqual(passedContexts, ['herp', model], 'the action was called with the passed contexts');
    };

    _proto2['@test it should not trigger action with special clicks'] = function testItShouldNotTriggerActionWithSpecialClicks() {
      var _this27 = this;

      var showCalled = false;
      var component;

      var ExampleComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        actions: {
          show: function () {
            showCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action "show" href=true}}>Howdy</button>'
      });
      this.render('{{example-component}}');
      var assert = this.assert;

      var checkClick = function (prop, value, expected) {
        var _this27$wrap$findAll$;

        showCalled = false;

        var event = _this27.wrap(component.element).findAll('button').trigger('click', (_this27$wrap$findAll$ = {}, _this27$wrap$findAll$[prop] = value, _this27$wrap$findAll$))[0];

        if (expected) {
          assert.ok(showCalled, "should call action with " + prop + ":" + value); // IE11 does not allow simulated events to have a valid `defaultPrevented`

          if (!isIE11) {
            assert.ok(event.defaultPrevented, 'should prevent default');
          }
        } else {
          assert.notOk(showCalled, "should not call action with " + prop + ":" + value);
          assert.notOk(event.defaultPrevented, 'should not prevent default');
        }
      };

      checkClick('ctrlKey', true, false);
      checkClick('altKey', true, false);
      checkClick('metaKey', true, false);
      checkClick('shiftKey', true, false);
      checkClick('button', 0, true);
      checkClick('button', 1, false);
      checkClick('button', 2, false);
      checkClick('button', 3, false);
      checkClick('button', 4, false);
    };

    _proto2['@test it can trigger actions for keyboard events'] = function testItCanTriggerActionsForKeyboardEvents() {
      var _this28 = this;

      var showCalled = false;

      var ExampleComponent = _helpers.Component.extend({
        actions: {
          show: function () {
            showCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<input type="text" {{action "show" on="keyUp"}}>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this28.$('input').trigger('keyup', {
          char: 'a',
          which: 65
        });
      });
      this.assert.ok(showCalled, 'the action was called with keyup');
    };

    _proto2['@test a quoteless parameter should allow dynamic lookup of the actionName'] = function testAQuotelessParameterShouldAllowDynamicLookupOfTheActionName() {
      var _this29 = this;

      var lastAction;
      var actionOrder = [];
      var component;

      var ExampleComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        hookMeUp: 'rock',
        actions: {
          rock: function () {
            lastAction = 'rock';
            actionOrder.push('rock');
          },
          paper: function () {
            lastAction = 'paper';
            actionOrder.push('paper');
          },
          scissors: function () {
            lastAction = 'scissors';
            actionOrder.push('scissors');
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="bound-param" {{action hookMeUp}}>Whistle tips go woop woooop</a>'
      });
      this.render('{{example-component}}');
      var test = this;

      var testBoundAction = function (propertyValue) {
        (0, _internalTestHelpers.runTask)(function () {
          component.set('hookMeUp', propertyValue);
        });
        (0, _internalTestHelpers.runTask)(function () {
          _this29.wrap(component.element).findAll('#bound-param').click();
        });
        test.assert.ok(lastAction, propertyValue, "lastAction set to " + propertyValue);
      };

      testBoundAction('rock');
      testBoundAction('paper');
      testBoundAction('scissors');
      this.assert.deepEqual(actionOrder, ['rock', 'paper', 'scissors'], 'action name was looked up properly');
    };

    _proto2['@test a quoteless string parameter should resolve actionName, including path'] = function testAQuotelessStringParameterShouldResolveActionNameIncludingPath() {
      var _this30 = this;

      var lastAction;
      var actionOrder = [];
      var component;

      var ExampleComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        allactions: (0, _runtime.A)([{
          title: 'Rock',
          name: 'rock'
        }, {
          title: 'Paper',
          name: 'paper'
        }, {
          title: 'Scissors',
          name: 'scissors'
        }]),
        actions: {
          rock: function () {
            lastAction = 'rock';
            actionOrder.push('rock');
          },
          paper: function () {
            lastAction = 'paper';
            actionOrder.push('paper');
          },
          scissors: function () {
            lastAction = 'scissors';
            actionOrder.push('scissors');
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '{{#each allactions as |allaction|}}<a id="{{allaction.name}}" {{action allaction.name}}>{{allaction.title}}</a>{{/each}}'
      });
      this.render('{{example-component}}');
      var test = this;

      var testBoundAction = function (propertyValue) {
        (0, _internalTestHelpers.runTask)(function () {
          _this30.wrap(component.element).findAll("#" + propertyValue).click();
        });
        test.assert.ok(lastAction, propertyValue, "lastAction set to " + propertyValue);
      };

      testBoundAction('rock');
      testBoundAction('paper');
      testBoundAction('scissors');
      this.assert.deepEqual(actionOrder, ['rock', 'paper', 'scissors'], 'action name was looked up properly');
    };

    _proto2['@test a quoteless function parameter should be called, including arguments'] = function testAQuotelessFunctionParameterShouldBeCalledIncludingArguments() {
      var _this31 = this;

      var submitCalled = false;
      var incomingArg;
      var arg = 'rough ray';

      var ExampleComponent = _helpers.Component.extend({
        submit: function (actualArg) {
          incomingArg = actualArg;
          submitCalled = true;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: "<a {{action submit '" + arg + "'}}>Hi</a>"
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this31.$('a').click();
      });
      this.assert.ok(submitCalled, 'submit function called');
      this.assert.equal(incomingArg, arg, 'argument passed');
    };

    _proto2['@test a quoteless parameter that does not resolve to a value asserts'] = function testAQuotelessParameterThatDoesNotResolveToAValueAsserts() {
      var _this32 = this;

      var ExampleComponent = _helpers.Component.extend({
        actions: {
          ohNoeNotValid: function () {}
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="oops-bound-param" {{action ohNoeNotValid}}>Hi</a>'
      });
      expectAssertion(function () {
        _this32.render('{{example-component}}');
      }, 'You specified a quoteless path, `ohNoeNotValid`, to the {{action}} helper ' + 'which did not resolve to an action name (a string). ' + 'Perhaps you meant to use a quoted actionName? (e.g. {{action "ohNoeNotValid"}}).');
    };

    _proto2['@test allows multiple actions on a single element'] = function testAllowsMultipleActionsOnASingleElement() {
      var _this33 = this;

      var clickActionWasCalled = false;
      var doubleClickActionWasCalled = false;

      var ExampleComponent = _helpers.Component.extend({
        actions: {
          clicked: function () {
            clickActionWasCalled = true;
          },
          doubleClicked: function () {
            doubleClickActionWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject5())
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this33.$('a').trigger('click');
      });
      this.assert.ok(clickActionWasCalled, 'the clicked action was called');
      (0, _internalTestHelpers.runTask)(function () {
        _this33.$('a').trigger('dblclick');
      });
      this.assert.ok(doubleClickActionWasCalled, 'the doubleClicked action was called');
    };

    _proto2['@test allows multiple actions for same event on a single element'] = function testAllowsMultipleActionsForSameEventOnASingleElement() {
      var _this34 = this;

      var clickAction1WasCalled = false;
      var clickAction2WasCalled = false;

      var ExampleComponent = _helpers.Component.extend({
        actions: {
          clicked1: function () {
            clickAction1WasCalled = true;
          },
          clicked2: function () {
            clickAction2WasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject6())
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this34.$('a').trigger('click');
      });
      this.assert.ok(clickAction1WasCalled, 'the first clicked action was called');
      this.assert.ok(clickAction2WasCalled, 'the second clicked action was called');
    };

    _proto2['@test it should respect preventDefault option if provided'] = function testItShouldRespectPreventDefaultOptionIfProvided() {
      var _this35 = this;

      var ExampleComponent = _helpers.Component.extend({
        actions: {
          show: function () {}
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a {{action "show" preventDefault=false}}>Hi</a>'
      });
      this.render('{{example-component}}');
      var event;
      (0, _internalTestHelpers.runTask)(function () {
        event = _this35.$('a').click()[0];
      });
      this.assert.equal(event.defaultPrevented, false, 'should not preventDefault');
    };

    _proto2['@test it should respect preventDefault option if provided bound'] = function testItShouldRespectPreventDefaultOptionIfProvidedBound() {
      var _this36 = this;

      var component;

      var ExampleComponent = _helpers.Component.extend({
        shouldPreventDefault: false,
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        },
        actions: {
          show: function () {}
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a {{action "show" preventDefault=shouldPreventDefault}}>Hi</a>'
      });
      this.render('{{example-component}}');
      var event;
      (0, _internalTestHelpers.runTask)(function () {
        event = _this36.$('a').trigger(event)[0];
      });
      this.assert.equal(event.defaultPrevented, false, 'should not preventDefault');
      (0, _internalTestHelpers.runTask)(function () {
        component.set('shouldPreventDefault', true);
        event = _this36.$('a').trigger('click')[0];
      }); // IE11 does not allow simulated events to have a valid `defaultPrevented`

      if (!isIE11) {
        this.assert.equal(event.defaultPrevented, true, 'should preventDefault');
      }
    };

    _proto2['@test it should target the proper component when `action` is in yielded block [GH #12409]'] = function testItShouldTargetTheProperComponentWhenActionIsInYieldedBlockGH12409() {
      var _this38 = this;

      var outerActionCalled = false;
      var innerClickCalled = false;

      var OuterComponent = _helpers.Component.extend({
        actions: {
          hey: function () {
            outerActionCalled = true;
          }
        }
      });

      var MiddleComponent = _helpers.Component.extend({});

      var InnerComponent = _helpers.Component.extend({
        click: function () {
          var _this37 = this;

          innerClickCalled = true;
          expectDeprecation(function () {
            _this37.sendAction();
          }, /You called (.*).sendAction\((.*)\) but Component#sendAction is deprecated. Please use closure actions instead./);
        }
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject7())
      });
      this.registerComponent('middle-component', {
        ComponentClass: MiddleComponent,
        template: '{{yield}}'
      });
      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: (0, _internalTestHelpers.strip)(_templateObject8())
      });
      this.render('{{outer-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this38.$('button').click();
      });
      this.assert.ok(outerActionCalled, 'the action fired on the proper target');
      this.assert.ok(innerClickCalled, 'the click was triggered');
    };

    _proto2['@test element action with (mut undefinedThing) works properly'] = function testElementActionWithMutUndefinedThingWorksProperly() {
      var _this39 = this;

      var component;

      var ExampleComponent = _helpers.Component.extend({
        label: undefined,
        init: function () {
          this._super.apply(this, arguments);

          component = this;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action (mut label) "Clicked!"}}>{{if label label "Click me"}}</button>'
      });
      this.render('{{example-component}}');
      this.assertText('Click me');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        _this39.$('button').click();
      });
      this.assertText('Clicked!');
      (0, _internalTestHelpers.runTask)(function () {
        component.set('label', 'Dun clicked');
      });
      this.assertText('Dun clicked');
      (0, _internalTestHelpers.runTask)(function () {
        _this39.$('button').click();
      });
      this.assertText('Clicked!');
      (0, _internalTestHelpers.runTask)(function () {
        component.set('label', undefined);
      });
      this.assertText('Click me');
    };

    _proto2['@test it supports non-registered actions [GH#14888]'] = function testItSupportsNonRegisteredActionsGH14888() {
      this.render("\n      {{#if show}}\n        <button id='ddButton' {{action (mut show) false}}>\n          Show ({{show}})\n        </button>\n      {{/if}}\n    ", {
        show: true
      });
      this.assert.equal(this.$('button').text().trim(), 'Show (true)'); // We need to focus in to simulate an actual click.

      (0, _internalTestHelpers.runTask)(function () {
        document.getElementById('ddButton').focus();
        document.getElementById('ddButton').click();
      });
    };

    _proto2["@test action handler that shifts element attributes doesn't trigger multiple invocations"] = function testActionHandlerThatShiftsElementAttributesDoesnTTriggerMultipleInvocations() {
      var _this40 = this;

      var actionCount = 0;

      var ExampleComponent = _helpers.Component.extend({
        selected: false,
        actions: {
          toggleSelected: function () {
            actionCount++;
            this.toggleProperty('selected');
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button class="{{if selected \'selected\'}}" {{action "toggleSelected"}}>Toggle Selected</button>'
      });
      this.render('{{example-component}}');
      (0, _internalTestHelpers.runTask)(function () {
        _this40.$('button').click();
      });
      this.assert.equal(actionCount, 1, 'Click action only fired once.');
      this.assert.ok(this.$('button').hasClass('selected'), "Element with action handler has properly updated it's conditional class");
      (0, _internalTestHelpers.runTask)(function () {
        _this40.$('button').click();
      });
      this.assert.equal(actionCount, 2, 'Second click action only fired once.');
      this.assert.ok(!this.$('button').hasClass('selected'), "Element with action handler has properly updated it's conditional class");
    };

    return _class2;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/fn-test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/utils", "internal-test-helpers", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _metal, _utils, _internalTestHelpers, _helpers) {
  "use strict";

  if (true
  /* EMBER_GLIMMER_FN_HELPER */
  ) {
      (0, _internalTestHelpers.moduleFor)('Helpers test: {{fn}}',
      /*#__PURE__*/
      function (_RenderingTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

        function _class() {
          return _RenderingTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto.beforeEach = function beforeEach() {
          this.registerHelper('invoke', function (_ref) {
            var fn = _ref[0];
            return fn();
          });
          var testContext = this;
          this.registerComponent('stash', {
            ComponentClass: _helpers.Component.extend({
              init: function () {
                this._super.apply(this, arguments);

                testContext.stashedFn = this.stashedFn;
              }
            })
          });
        };

        _proto['@test updates when arguments change'] = function testUpdatesWhenArgumentsChange() {
          var _this = this;

          this.render("{{invoke (fn this.myFunc this.arg1 this.arg2)}}", {
            myFunc: function (arg1, arg2) {
              return "arg1: " + arg1 + ", arg2: " + arg2;
            },
            arg1: 'foo',
            arg2: 'bar'
          });
          this.assertText('arg1: foo, arg2: bar');
          this.assertStableRerender();
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this.context, 'arg1', 'qux');
          });
          this.assertText('arg1: qux, arg2: bar');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this.context, 'arg2', 'derp');
          });
          this.assertText('arg1: qux, arg2: derp');
          (0, _internalTestHelpers.runTask)(function () {
            (0, _metal.set)(_this.context, 'arg1', 'foo');
            (0, _metal.set)(_this.context, 'arg2', 'bar');
          });
          this.assertText('arg1: foo, arg2: bar');
        };

        _proto['@test updates when the function changes'] = function testUpdatesWhenTheFunctionChanges() {
          var _this2 = this;

          var func1 = function (arg1, arg2) {
            return "arg1: " + arg1 + ", arg2: " + arg2;
          };

          var func2 = function (arg1, arg2) {
            return "arg2: " + arg2 + ", arg1: " + arg1;
          };

          this.render("{{invoke (fn this.myFunc this.arg1 this.arg2)}}", {
            myFunc: func1,
            arg1: 'foo',
            arg2: 'bar'
          });
          this.assertText('arg1: foo, arg2: bar');
          this.assertStableRerender();
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this2.context, 'myFunc', func2);
          });
          this.assertText('arg2: bar, arg1: foo');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this2.context, 'myFunc', func1);
          });
          this.assertText('arg1: foo, arg2: bar');
        };

        _proto['@test a stashed fn result update arguments when invoked'] = function testAStashedFnResultUpdateArgumentsWhenInvoked(assert) {
          var _this3 = this;

          this.render("{{stash stashedFn=(fn this.myFunc this.arg1 this.arg2)}}", {
            myFunc: function (arg1, arg2) {
              return "arg1: " + arg1 + ", arg2: " + arg2;
            },
            arg1: 'foo',
            arg2: 'bar'
          });
          assert.equal(this.stashedFn(), 'arg1: foo, arg2: bar');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this3.context, 'arg1', 'qux');
          });
          assert.equal(this.stashedFn(), 'arg1: qux, arg2: bar');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this3.context, 'arg2', 'derp');
          });
          assert.equal(this.stashedFn(), 'arg1: qux, arg2: derp');
          (0, _internalTestHelpers.runTask)(function () {
            (0, _metal.set)(_this3.context, 'arg1', 'foo');
            (0, _metal.set)(_this3.context, 'arg2', 'bar');
          });
          assert.equal(this.stashedFn(), 'arg1: foo, arg2: bar');
        };

        _proto['@test a stashed fn result invokes the correct function when the bound function changes'] = function testAStashedFnResultInvokesTheCorrectFunctionWhenTheBoundFunctionChanges(assert) {
          var _this4 = this;

          var func1 = function (arg1, arg2) {
            return "arg1: " + arg1 + ", arg2: " + arg2;
          };

          var func2 = function (arg1, arg2) {
            return "arg2: " + arg2 + ", arg1: " + arg1;
          };

          this.render("{{stash stashedFn=(fn this.myFunc this.arg1 this.arg2)}}", {
            myFunc: func1,
            arg1: 'foo',
            arg2: 'bar'
          });
          assert.equal(this.stashedFn(), 'arg1: foo, arg2: bar');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this4.context, 'myFunc', func2);
          });
          assert.equal(this.stashedFn(), 'arg2: bar, arg1: foo');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this4.context, 'myFunc', func1);
          });
          assert.equal(this.stashedFn(), 'arg1: foo, arg2: bar');
        };

        _proto['@test asserts if the first argument is not a function'] = function testAssertsIfTheFirstArgumentIsNotAFunction() {
          var _this5 = this;

          expectAssertion(function () {
            _this5.render("{{invoke (fn this.myFunc this.arg1 this.arg2)}}", {
              myFunc: null,
              arg1: 'foo',
              arg2: 'bar'
            });
          }, /You must pass a function as the `fn` helpers first argument, you passed null/);
        };

        _proto['@test asserts if the provided function accesses `this` without being bound prior to passing to fn'] = function testAssertsIfTheProvidedFunctionAccessesThisWithoutBeingBoundPriorToPassingToFn(assert) {
          var _this6 = this;

          if (!_utils.HAS_NATIVE_PROXY) {
            assert.expect(0);
            return;
          }

          this.render("{{stash stashedFn=(fn this.myFunc this.arg1)}}", {
            myFunc: function (arg1) {
              return "arg1: " + arg1 + ", arg2: " + this.arg2;
            },
            arg1: 'foo',
            arg2: 'bar'
          });
          expectAssertion(function () {
            _this6.stashedFn();
          }, /You accessed `this.arg2` from a function passed to the `fn` helper, but the function itself was not bound to a valid `this` context. Consider updating to usage of `@action`./);
        };

        _proto['@test there is no `this` context within the callback'] = function testThereIsNoThisContextWithinTheCallback(assert) {
          if (true
          /* DEBUG */
          && _utils.HAS_NATIVE_PROXY) {
            assert.expect(0);
            return;
          }

          this.render("{{stash stashedFn=(fn this.myFunc this.arg1)}}", {
            myFunc: function () {
              assert.strictEqual(this, null, 'this is bound to null in production builds');
            }
          });
          this.stashedFn();
        };

        _proto['@test can use `this` if bound prior to passing to fn'] = function testCanUseThisIfBoundPriorToPassingToFn(assert) {
          this.render("{{stash stashedFn=(fn (action this.myFunc) this.arg1)}}", {
            myFunc: function (arg1) {
              return "arg1: " + arg1 + ", arg2: " + this.arg2;
            },
            arg1: 'foo',
            arg2: 'bar'
          });
          assert.equal(this.stashedFn(), 'arg1: foo, arg2: bar');
        };

        _proto['@test partially applies each layer when nested [GH#17959]'] = function testPartiallyAppliesEachLayerWhenNestedGH17959() {
          var _this7 = this;

          this.render("{{invoke (fn (fn (fn this.myFunc this.arg1) this.arg2) this.arg3)}}", {
            myFunc: function (arg1, arg2, arg3) {
              return "arg1: " + arg1 + ", arg2: " + arg2 + ", arg3: " + arg3;
            },
            arg1: 'foo',
            arg2: 'bar',
            arg3: 'qux'
          });
          this.assertText('arg1: foo, arg2: bar, arg3: qux');
          this.assertStableRerender();
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this7.context, 'arg1', 'qux');
          });
          this.assertText('arg1: qux, arg2: bar, arg3: qux');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this7.context, 'arg2', 'derp');
          });
          this.assertText('arg1: qux, arg2: derp, arg3: qux');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this7.context, 'arg3', 'huzzah');
          });
          this.assertText('arg1: qux, arg2: derp, arg3: huzzah');
          (0, _internalTestHelpers.runTask)(function () {
            (0, _metal.set)(_this7.context, 'arg1', 'foo');
            (0, _metal.set)(_this7.context, 'arg2', 'bar');
            (0, _metal.set)(_this7.context, 'arg3', 'qux');
          });
          this.assertText('arg1: foo, arg2: bar, arg3: qux');
        };

        _proto['@test can be used on the result of `mut`'] = function testCanBeUsedOnTheResultOfMut() {
          var _this8 = this;

          this.render("{{this.arg1}}{{stash stashedFn=(fn (mut this.arg1) this.arg2)}}", {
            arg1: 'foo',
            arg2: 'bar'
          });
          this.assertText('foo');
          (0, _internalTestHelpers.runTask)(function () {
            return _this8.stashedFn();
          });
          this.assertText('bar');
        };

        return _class;
      }(_internalTestHelpers.RenderingTestCase));
    }
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/get-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{get}}',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test should be able to get an object value with a static key'] = function testShouldBeAbleToGetAnObjectValueWithAStaticKey() {
      var _this = this;

      this.render("[{{get colors 'apple'}}] [{{if true (get colors 'apple')}}]", {
        colors: {
          apple: 'red'
        }
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'colors.apple', 'green');
      });
      this.assertText('[green] [green]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'colors', {
          apple: 'red'
        });
      });
      this.assertText('[red] [red]');
    };

    _proto['@test should be able to get an object value with nested static key'] = function testShouldBeAbleToGetAnObjectValueWithNestedStaticKey() {
      var _this2 = this;

      this.render("[{{get colors \"apple.gala\"}}] [{{if true (get colors \"apple.gala\")}}]", {
        colors: {
          apple: {
            gala: 'red and yellow'
          }
        }
      });
      this.assertText('[red and yellow] [red and yellow]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertText('[red and yellow] [red and yellow]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'colors.apple.gala', 'yellow and red striped');
      });
      this.assertText('[yellow and red striped] [yellow and red striped]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'colors', {
          apple: {
            gala: 'red and yellow'
          }
        });
      });
      this.assertText('[red and yellow] [red and yellow]');
    };

    _proto['@test should be able to get an object value with a number'] = function testShouldBeAbleToGetAnObjectValueWithANumber() {
      var _this3 = this;

      this.render("[{{get items 1}}][{{get items 2}}][{{get items 3}}]", {
        indexes: [1, 2, 3],
        items: {
          1: 'First',
          2: 'Second',
          3: 'Third'
        }
      });
      this.assertText('[First][Second][Third]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assertText('[First][Second][Third]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'items.1', 'Qux');
      });
      this.assertText('[Qux][Second][Third]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'items', {
          1: 'First',
          2: 'Second',
          3: 'Third'
        });
      });
      this.assertText('[First][Second][Third]');
    };

    _proto['@test should be able to get an array value with a number'] = function testShouldBeAbleToGetAnArrayValueWithANumber() {
      var _this4 = this;

      this.render("[{{get numbers 0}}][{{get numbers 1}}][{{get numbers 2}}]", {
        numbers: [1, 2, 3]
      });
      this.assertText('[1][2][3]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      this.assertText('[1][2][3]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'numbers', [3, 2, 1]);
      });
      this.assertText('[3][2][1]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'numbers', [1, 2, 3]);
      });
      this.assertText('[1][2][3]');
    };

    _proto['@test should be able to get an object value with a path evaluating to a number'] = function testShouldBeAbleToGetAnObjectValueWithAPathEvaluatingToANumber() {
      var _this5 = this;

      this.render("{{#each indexes as |index|}}[{{get items index}}]{{/each}}", {
        indexes: [1, 2, 3],
        items: {
          1: 'First',
          2: 'Second',
          3: 'Third'
        }
      });
      this.assertText('[First][Second][Third]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.rerender();
      });
      this.assertText('[First][Second][Third]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'items.1', 'Qux');
      });
      this.assertText('[Qux][Second][Third]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'items', {
          1: 'First',
          2: 'Second',
          3: 'Third'
        });
      });
      this.assertText('[First][Second][Third]');
    };

    _proto['@test should be able to get an array value with a path evaluating to a number'] = function testShouldBeAbleToGetAnArrayValueWithAPathEvaluatingToANumber() {
      var _this6 = this;

      this.render("{{#each numbers as |num index|}}[{{get numbers index}}]{{/each}}", {
        numbers: [1, 2, 3]
      });
      this.assertText('[1][2][3]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.rerender();
      });
      this.assertText('[1][2][3]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'numbers', [3, 2, 1]);
      });
      this.assertText('[3][2][1]');
    };

    _proto['@test should be able to get an object value with a bound/dynamic key'] = function testShouldBeAbleToGetAnObjectValueWithABoundDynamicKey() {
      var _this7 = this;

      this.render("[{{get colors key}}] [{{if true (get colors key)}}]", {
        colors: {
          apple: 'red',
          banana: 'yellow'
        },
        key: 'apple'
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.rerender();
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'key', 'banana');
      });
      this.assertText('[yellow] [yellow]');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this7.context, 'colors.apple', 'green');
        (0, _metal.set)(_this7.context, 'colors.banana', 'purple');
      });
      this.assertText('[purple] [purple]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'key', 'apple');
      });
      this.assertText('[green] [green]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'colors', {
          apple: 'red'
        });
      });
      this.assertText('[red] [red]');
    };

    _proto['@test should be able to get an object value with nested dynamic key'] = function testShouldBeAbleToGetAnObjectValueWithNestedDynamicKey() {
      var _this8 = this;

      this.render("[{{get colors key}}] [{{if true (get colors key)}}]", {
        colors: {
          apple: {
            gala: 'red and yellow',
            mcintosh: 'red'
          },
          banana: 'yellow'
        },
        key: 'apple.gala'
      });
      this.assertText('[red and yellow] [red and yellow]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.rerender();
      });
      this.assertText('[red and yellow] [red and yellow]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this8.context, 'key', 'apple.mcintosh');
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this8.context, 'key', 'banana');
      });
      this.assertText('[yellow] [yellow]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this8.context, 'key', 'apple.gala');
      });
      this.assertText('[red and yellow] [red and yellow]');
    };

    _proto['@test should be able to get an object value with subexpression returning nested key'] = function testShouldBeAbleToGetAnObjectValueWithSubexpressionReturningNestedKey() {
      var _this9 = this;

      this.render("[{{get colors (concat 'apple' '.' 'gala')}}] [{{if true (get colors (concat 'apple' '.' 'gala'))}}]", {
        colors: {
          apple: {
            gala: 'red and yellow',
            mcintosh: 'red'
          }
        },
        key: 'apple.gala'
      });
      this.assertText('[red and yellow] [red and yellow]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.rerender();
      });
      this.assertText('[red and yellow] [red and yellow]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this9.context, 'colors.apple.gala', 'yellow and red striped');
      });
      this.assertText('[yellow and red striped] [yellow and red striped]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this9.context, 'colors.apple.gala', 'yellow-redish');
      });
      this.assertText('[yellow-redish] [yellow-redish]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this9.context, 'colors', {
          apple: {
            gala: 'red and yellow',
            mcintosh: 'red'
          }
        });
      });
      this.assertText('[red and yellow] [red and yellow]');
    };

    _proto['@test should be able to get an object value with a get helper as the key'] = function testShouldBeAbleToGetAnObjectValueWithAGetHelperAsTheKey() {
      var _this10 = this;

      this.render("[{{get colors (get possibleKeys key)}}] [{{if true (get colors (get possibleKeys key))}}]", {
        colors: {
          apple: 'red',
          banana: 'yellow'
        },
        key: 'key1',
        possibleKeys: {
          key1: 'apple',
          key2: 'banana'
        }
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.rerender();
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'key', 'key2');
      });
      this.assertText('[yellow] [yellow]');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this10.context, 'colors.apple', 'green');
        (0, _metal.set)(_this10.context, 'colors.banana', 'purple');
      });
      this.assertText('[purple] [purple]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'key', 'key1');
      });
      this.assertText('[green] [green]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'colors', {
          apple: 'red',
          banana: 'yellow'
        });
      });
      this.assertText('[red] [red]');
    };

    _proto['@test should be able to get an object value with a get helper value as a bound/dynamic key'] = function testShouldBeAbleToGetAnObjectValueWithAGetHelperValueAsABoundDynamicKey() {
      var _this11 = this;

      this.render("[{{get (get possibleValues objectKey) key}}] [{{if true (get (get possibleValues objectKey) key)}}]", {
        possibleValues: {
          colors1: {
            apple: 'red',
            banana: 'yellow'
          },
          colors2: {
            apple: 'green',
            banana: 'purple'
          }
        },
        objectKey: 'colors1',
        key: 'apple'
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this11.rerender();
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'objectKey', 'colors2');
      });
      this.assertText('[green] [green]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'objectKey', 'colors1');
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'key', 'banana');
      });
      this.assertText('[yellow] [yellow]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'objectKey', 'colors2');
      });
      this.assertText('[purple] [purple]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'objectKey', 'colors1');
      });
      this.assertText('[yellow] [yellow]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'key', 'apple');
      });
    };

    _proto['@test should be able to get an object value with a get helper as the value and a get helper as the key'] = function testShouldBeAbleToGetAnObjectValueWithAGetHelperAsTheValueAndAGetHelperAsTheKey() {
      var _this12 = this;

      this.render("[{{get (get possibleValues objectKey) (get possibleKeys key)}}] [{{if true (get (get possibleValues objectKey) (get possibleKeys key))}}]", {
        possibleValues: {
          colors1: {
            apple: 'red',
            banana: 'yellow'
          },
          colors2: {
            apple: 'green',
            banana: 'purple'
          }
        },
        objectKey: 'colors1',
        possibleKeys: {
          key1: 'apple',
          key2: 'banana'
        },
        key: 'key1'
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.rerender();
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'objectKey', 'colors2');
      });
      this.assertText('[green] [green]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'objectKey', 'colors1');
      });
      this.assertText('[red] [red]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'key', 'key2');
      });
      this.assertText('[yellow] [yellow]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'objectKey', 'colors2');
      });
      this.assertText('[purple] [purple]');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this12.context, 'objectKey', 'colors1');
        (0, _metal.set)(_this12.context, 'key', 'key1');
      });
      this.assertText('[red] [red]');
    };

    _proto['@test the result of a get helper can be yielded'] = function testTheResultOfAGetHelperCanBeYielded() {
      var _this13 = this;

      var fooBarInstance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          fooBarInstance = this;
          this.mcintosh = 'red';
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{yield (get colors mcintosh)}}"
      });
      this.render("{{#foo-bar colors=colors as |value|}}{{value}}{{/foo-bar}}", {
        colors: {
          red: 'banana'
        }
      });
      this.assertText('banana');
      (0, _internalTestHelpers.runTask)(function () {
        return _this13.rerender();
      });
      this.assertText('banana');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(fooBarInstance, 'mcintosh', 'yellow');
        (0, _metal.set)(_this13.context, 'colors', {
          yellow: 'bus'
        });
      });
      this.assertText('bus');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(fooBarInstance, 'mcintosh', 'red');
        (0, _metal.set)(_this13.context, 'colors', {
          red: 'banana'
        });
      });
      this.assertText('banana');
    };

    _proto['@test should handle object values as nulls'] = function testShouldHandleObjectValuesAsNulls() {
      var _this14 = this;

      this.render("[{{get colors 'apple'}}] [{{if true (get colors 'apple')}}]", {
        colors: null
      });
      this.assertText('[] []');
      (0, _internalTestHelpers.runTask)(function () {
        return _this14.rerender();
      });
      this.assertText('[] []');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'colors', {
          apple: 'green',
          banana: 'purple'
        });
      });
      this.assertText('[green] [green]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'colors', null);
      });
      this.assertText('[] []');
    };

    _proto['@test should handle object keys as nulls'] = function testShouldHandleObjectKeysAsNulls() {
      var _this15 = this;

      this.render("[{{get colors key}}] [{{if true (get colors key)}}]", {
        colors: {
          apple: 'red',
          banana: 'yellow'
        },
        key: null
      });
      this.assertText('[] []');
      (0, _internalTestHelpers.runTask)(function () {
        return _this15.rerender();
      });
      this.assertText('[] []');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'key', 'banana');
      });
      this.assertText('[yellow] [yellow]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'key', null);
      });
      this.assertText('[] []');
    };

    _proto['@test should handle object values and keys as nulls'] = function testShouldHandleObjectValuesAndKeysAsNulls() {
      this.render("[{{get colors 'apple'}}] [{{if true (get colors key)}}]", {
        colors: null,
        key: null
      });
      this.assertText('[] []');
    };

    _proto['@test get helper value should be updatable using {{input}} and (mut) - static key'] = function testGetHelperValueShouldBeUpdatableUsingInputAndMutStaticKey(assert) {
      var _this16 = this;

      this.render("{{input type='text' value=(mut (get source 'banana')) id='get-input'}}", {
        source: {
          banana: 'banana'
        }
      });
      assert.strictEqual(this.$('#get-input').val(), 'banana');
      (0, _internalTestHelpers.runTask)(function () {
        return _this16.rerender();
      });
      assert.strictEqual(this.$('#get-input').val(), 'banana');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this16.context, 'source.banana', 'yellow');
      });
      assert.strictEqual(this.$('#get-input').val(), 'yellow');
      (0, _internalTestHelpers.runTask)(function () {
        return _this16.$('#get-input').val('some value').trigger('change');
      });
      assert.strictEqual(this.$('#get-input').val(), 'some value');
      assert.strictEqual((0, _metal.get)(this.context, 'source.banana'), 'some value');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this16.context, 'source', {
          banana: 'banana'
        });
      });
      assert.strictEqual(this.$('#get-input').val(), 'banana');
    };

    _proto['@test get helper value should be updatable using {{input}} and (mut) - dynamic key'] = function testGetHelperValueShouldBeUpdatableUsingInputAndMutDynamicKey(assert) {
      var _this17 = this;

      this.render("{{input type='text' value=(mut (get source key)) id='get-input'}}", {
        source: {
          apple: 'apple',
          banana: 'banana'
        },
        key: 'banana'
      });
      assert.strictEqual(this.$('#get-input').val(), 'banana');
      (0, _internalTestHelpers.runTask)(function () {
        return _this17.rerender();
      });
      assert.strictEqual(this.$('#get-input').val(), 'banana');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this17.context, 'source.banana', 'yellow');
      });
      assert.strictEqual(this.$('#get-input').val(), 'yellow');
      (0, _internalTestHelpers.runTask)(function () {
        return _this17.$('#get-input').val('some value').trigger('change');
      });
      assert.strictEqual(this.$('#get-input').val(), 'some value');
      assert.strictEqual((0, _metal.get)(this.context, 'source.banana'), 'some value');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this17.context, 'key', 'apple');
      });
      assert.strictEqual(this.$('#get-input').val(), 'apple');
      (0, _internalTestHelpers.runTask)(function () {
        return _this17.$('#get-input').val('some other value').trigger('change');
      });
      assert.strictEqual(this.$('#get-input').val(), 'some other value');
      assert.strictEqual((0, _metal.get)(this.context, 'source.apple'), 'some other value');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this17.context, 'key', 'banana');
        (0, _metal.set)(_this17.context, 'source', {
          banana: 'banana'
        });
      });
      assert.strictEqual(this.$('#get-input').val(), 'banana');
    };

    _proto['@test get helper value should be updatable using {{input}} and (mut) - dynamic nested key'] = function testGetHelperValueShouldBeUpdatableUsingInputAndMutDynamicNestedKey(assert) {
      var _this18 = this;

      this.render("{{input type='text' value=(mut (get source key)) id='get-input'}}", {
        source: {
          apple: {
            gala: 'gala',
            mcintosh: 'mcintosh'
          },
          banana: 'banana'
        },
        key: 'apple.mcintosh'
      });
      assert.strictEqual(this.$('#get-input').val(), 'mcintosh');
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.rerender();
      });
      assert.strictEqual(this.$('#get-input').val(), 'mcintosh');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this18.context, 'source.apple.mcintosh', 'red');
      });
      assert.strictEqual(this.$('#get-input').val(), 'red');
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.$('#get-input').val('some value').trigger('change');
      });
      assert.strictEqual(this.$('#get-input').val(), 'some value');
      assert.strictEqual((0, _metal.get)(this.context, 'source.apple.mcintosh'), 'some value');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this18.context, 'key', 'apple.gala');
      });
      assert.strictEqual(this.$('#get-input').val(), 'gala');
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.$('#get-input').val('some other value').trigger('change');
      });
      assert.strictEqual(this.$('#get-input').val(), 'some other value');
      assert.strictEqual((0, _metal.get)(this.context, 'source.apple.gala'), 'some other value');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this18.context, 'key', 'banana');
      });
      assert.strictEqual(this.$('#get-input').val(), 'banana');
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.$('#get-input').val('yet another value').trigger('change');
      });
      assert.strictEqual(this.$('#get-input').val(), 'yet another value');
      assert.strictEqual((0, _metal.get)(this.context, 'source.banana'), 'yet another value');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this18.context, 'key', 'apple.mcintosh');
        (0, _metal.set)(_this18.context, 'source', {
          apple: {
            gala: 'gala',
            mcintosh: 'mcintosh'
          },
          banana: 'banana'
        });
      });
      assert.strictEqual(this.$('#get-input').val(), 'mcintosh');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/hash-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/glimmer/tests/utils/helpers", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _helpers, _metal) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{hash}}',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test returns a hash with the right key-value'] = function testReturnsAHashWithTheRightKeyValue() {
      var _this = this;

      this.render("{{#with (hash name=\"Sergio\") as |person|}}{{person.name}}{{/with}}");
      this.assertText('Sergio');
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertText('Sergio');
    };

    _proto['@test can have more than one key-value'] = function testCanHaveMoreThanOneKeyValue() {
      var _this2 = this;

      this.render("{{#with (hash name=\"Sergio\" lastName=\"Arbeo\") as |person|}}{{person.name}} {{person.lastName}}{{/with}}");
      this.assertText('Sergio Arbeo');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertText('Sergio Arbeo');
    };

    _proto['@test binds values when variables are used'] = function testBindsValuesWhenVariablesAreUsed() {
      var _this3 = this;

      this.render("{{#with (hash name=model.firstName lastName=\"Arbeo\") as |person|}}{{person.name}} {{person.lastName}}{{/with}}", {
        model: {
          firstName: 'Marisa'
        }
      });
      this.assertText('Marisa Arbeo');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assertText('Marisa Arbeo');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'model.firstName', 'Sergio');
      });
      this.assertText('Sergio Arbeo');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'model', {
          firstName: 'Marisa'
        });
      });
      this.assertText('Marisa Arbeo');
    };

    _proto['@test binds multiple values when variables are used'] = function testBindsMultipleValuesWhenVariablesAreUsed() {
      var _this4 = this;

      this.render("{{#with (hash name=model.firstName lastName=model.lastName) as |person|}}{{person.name}} {{person.lastName}}{{/with}}", {
        model: {
          firstName: 'Marisa',
          lastName: 'Arbeo'
        }
      });
      this.assertText('Marisa Arbeo');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      this.assertText('Marisa Arbeo');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'model.firstName', 'Sergio');
      });
      this.assertText('Sergio Arbeo');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'model.lastName', 'Smith');
      });
      this.assertText('Sergio Smith');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'model', {
          firstName: 'Marisa',
          lastName: 'Arbeo'
        });
      });
      this.assertText('Marisa Arbeo');
    };

    _proto['@test hash helpers can be nested'] = function testHashHelpersCanBeNested() {
      var _this5 = this;

      this.render("{{#with (hash person=(hash name=model.firstName)) as |ctx|}}{{ctx.person.name}}{{/with}}", {
        model: {
          firstName: 'Balint'
        }
      });
      this.assertText('Balint');
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.rerender();
      });
      this.assertText('Balint');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'model.firstName', 'Chad');
      });
      this.assertText('Chad');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'model', {
          firstName: 'Balint'
        });
      });
      this.assertText('Balint');
    };

    _proto['@test should yield hash of internal properties'] = function testShouldYieldHashOfInternalProperties() {
      var _this6 = this;

      var fooBarInstance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          fooBarInstance = this;
          this.model = {
            firstName: 'Chad'
          };
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{yield (hash firstName=model.firstName)}}"
      });
      this.render("{{#foo-bar as |values|}}{{values.firstName}}{{/foo-bar}}");
      this.assertText('Chad');
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.rerender();
      });
      this.assertText('Chad');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(fooBarInstance, 'model.firstName', 'Godfrey');
      });
      this.assertText('Godfrey');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(fooBarInstance, 'model', {
          firstName: 'Chad'
        });
      });
      this.assertText('Chad');
    };

    _proto['@test should yield hash of internal and external properties'] = function testShouldYieldHashOfInternalAndExternalProperties() {
      var _this7 = this;

      var fooBarInstance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super();

          fooBarInstance = this;
          this.model = {
            firstName: 'Chad'
          };
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{yield (hash firstName=model.firstName lastName=lastName)}}"
      });
      this.render("{{#foo-bar lastName=model.lastName as |values|}}{{values.firstName}} {{values.lastName}}{{/foo-bar}}", {
        model: {
          lastName: 'Hietala'
        }
      });
      this.assertText('Chad Hietala');
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.rerender();
      });
      this.assertText('Chad Hietala');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(fooBarInstance, 'model.firstName', 'Godfrey');
        (0, _metal.set)(_this7.context, 'model.lastName', 'Chan');
      });
      this.assertText('Godfrey Chan');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(fooBarInstance, 'model', {
          firstName: 'Chad'
        });
        (0, _metal.set)(_this7.context, 'model', {
          lastName: 'Hietala'
        });
      });
      this.assertText('Chad Hietala');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/if-unless-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/glimmer/tests/utils/shared-conditional-tests"], function (_emberBabel, _internalTestHelpers, _sharedConditionalTests) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: inline {{if}}',
  /*#__PURE__*/
  function (_IfUnlessHelperTest) {
    (0, _emberBabel.inheritsLoose)(_class, _IfUnlessHelperTest);

    function _class() {
      return _IfUnlessHelperTest.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.templateFor = function templateFor(_ref) {
      var cond = _ref.cond,
          truthy = _ref.truthy,
          falsy = _ref.falsy;
      return "{{if " + cond + " " + truthy + " " + falsy + "}}";
    };

    _proto['@test it raises when there are more than three arguments'] = function testItRaisesWhenThereAreMoreThanThreeArguments() {
      var _this = this;

      expectAssertion(function () {
        _this.render("{{if condition 'a' 'b' 'c'}}", {
          condition: true
        });
      }, "The inline form of the 'if' helper expects two or three arguments. ('-top-level' @ L1:C0) ");
    };

    _proto['@test it raises when there are less than two arguments'] = function testItRaisesWhenThereAreLessThanTwoArguments() {
      var _this2 = this;

      expectAssertion(function () {
        _this2.render("{{if condition}}", {
          condition: true
        });
      }, "The inline form of the 'if' helper expects two or three arguments. ('-top-level' @ L1:C0) ");
    };

    return _class;
  }(_sharedConditionalTests.IfUnlessHelperTest));
  (0, _internalTestHelpers.moduleFor)('Helpers test: nested {{if}} helpers (returning truthy values)',
  /*#__PURE__*/
  function (_IfUnlessHelperTest2) {
    (0, _emberBabel.inheritsLoose)(_class2, _IfUnlessHelperTest2);

    function _class2() {
      return _IfUnlessHelperTest2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2.templateFor = function templateFor(_ref2) {
      var cond = _ref2.cond,
          truthy = _ref2.truthy,
          falsy = _ref2.falsy;
      return "{{if (if " + cond + " " + cond + " false) " + truthy + " " + falsy + "}}";
    };

    return _class2;
  }(_sharedConditionalTests.IfUnlessHelperTest));
  (0, _internalTestHelpers.moduleFor)('Helpers test: nested {{if}} helpers (returning falsy values)',
  /*#__PURE__*/
  function (_IfUnlessHelperTest3) {
    (0, _emberBabel.inheritsLoose)(_class3, _IfUnlessHelperTest3);

    function _class3() {
      return _IfUnlessHelperTest3.apply(this, arguments) || this;
    }

    var _proto3 = _class3.prototype;

    _proto3.templateFor = function templateFor(_ref3) {
      var cond = _ref3.cond,
          truthy = _ref3.truthy,
          falsy = _ref3.falsy;
      return "{{if (if " + cond + " true " + cond + ") " + truthy + " " + falsy + "}}";
    };

    return _class3;
  }(_sharedConditionalTests.IfUnlessHelperTest));
  (0, _internalTestHelpers.moduleFor)('Helpers test: {{if}} used with another helper',
  /*#__PURE__*/
  function (_IfUnlessHelperTest4) {
    (0, _emberBabel.inheritsLoose)(_class4, _IfUnlessHelperTest4);

    function _class4() {
      return _IfUnlessHelperTest4.apply(this, arguments) || this;
    }

    var _proto4 = _class4.prototype;

    _proto4.wrapperFor = function wrapperFor(templates) {
      return "{{concat " + templates.join(' ') + "}}";
    };

    _proto4.templateFor = function templateFor(_ref4) {
      var cond = _ref4.cond,
          truthy = _ref4.truthy,
          falsy = _ref4.falsy;
      return "(if " + cond + " " + truthy + " " + falsy + ")";
    };

    return _class4;
  }(_sharedConditionalTests.IfUnlessHelperTest));
  (0, _internalTestHelpers.moduleFor)('Helpers test: {{if}} used in attribute position',
  /*#__PURE__*/
  function (_IfUnlessHelperTest5) {
    (0, _emberBabel.inheritsLoose)(_class5, _IfUnlessHelperTest5);

    function _class5() {
      return _IfUnlessHelperTest5.apply(this, arguments) || this;
    }

    var _proto5 = _class5.prototype;

    _proto5.wrapperFor = function wrapperFor(templates) {
      return "<div data-foo=\"" + templates.join('') + "\" />";
    };

    _proto5.templateFor = function templateFor(_ref5) {
      var cond = _ref5.cond,
          truthy = _ref5.truthy,
          falsy = _ref5.falsy;
      return "{{if " + cond + " " + truthy + " " + falsy + "}}";
    };

    _proto5.textValue = function textValue() {
      return this.$('div').attr('data-foo');
    };

    return _class5;
  }(_sharedConditionalTests.IfUnlessHelperTest));
  (0, _internalTestHelpers.moduleFor)('Helpers test: inline {{if}} and {{unless}} without the inverse argument',
  /*#__PURE__*/
  function (_IfUnlessHelperTest6) {
    (0, _emberBabel.inheritsLoose)(_class6, _IfUnlessHelperTest6);

    function _class6() {
      return _IfUnlessHelperTest6.apply(this, arguments) || this;
    }

    var _proto6 = _class6.prototype;

    _proto6.templateFor = function templateFor(_ref6) {
      var cond = _ref6.cond,
          truthy = _ref6.truthy,
          falsy = _ref6.falsy;
      return "{{if " + cond + " " + truthy + "}}{{unless " + cond + " " + falsy + "}}";
    };

    return _class6;
  }(_sharedConditionalTests.IfUnlessHelperTest));
  (0, _internalTestHelpers.moduleFor)('Helpers test: inline {{unless}}',
  /*#__PURE__*/
  function (_IfUnlessHelperTest7) {
    (0, _emberBabel.inheritsLoose)(_class7, _IfUnlessHelperTest7);

    function _class7() {
      return _IfUnlessHelperTest7.apply(this, arguments) || this;
    }

    var _proto7 = _class7.prototype;

    _proto7.templateFor = function templateFor(_ref7) {
      var cond = _ref7.cond,
          truthy = _ref7.truthy,
          falsy = _ref7.falsy;
      return "{{unless " + cond + " " + falsy + " " + truthy + "}}";
    };

    _proto7['@test it raises when there are more than three arguments'] = function testItRaisesWhenThereAreMoreThanThreeArguments() {
      var _this3 = this;

      expectAssertion(function () {
        _this3.render("{{unless condition 'a' 'b' 'c'}}", {
          condition: true
        });
      }, /The inline form of the `unless` helper expects two or three arguments/);
    };

    _proto7['@test it raises when there are less than two arguments'] = function testItRaisesWhenThereAreLessThanTwoArguments() {
      var _this4 = this;

      expectAssertion(function () {
        _this4.render("{{unless condition}}", {
          condition: true
        });
      }, /The inline form of the `unless` helper expects two or three arguments/);
    };

    return _class7;
  }(_sharedConditionalTests.IfUnlessHelperTest));
  (0, _internalTestHelpers.moduleFor)('Helpers test: nested {{unless}} helpers (returning truthy values)',
  /*#__PURE__*/
  function (_IfUnlessHelperTest8) {
    (0, _emberBabel.inheritsLoose)(_class8, _IfUnlessHelperTest8);

    function _class8() {
      return _IfUnlessHelperTest8.apply(this, arguments) || this;
    }

    var _proto8 = _class8.prototype;

    _proto8.templateFor = function templateFor(_ref8) {
      var cond = _ref8.cond,
          truthy = _ref8.truthy,
          falsy = _ref8.falsy;
      return "{{unless (unless " + cond + " false " + cond + ") " + falsy + " " + truthy + "}}";
    };

    return _class8;
  }(_sharedConditionalTests.IfUnlessHelperTest));
  (0, _internalTestHelpers.moduleFor)('Helpers test: nested {{unless}} helpers (returning falsy values)',
  /*#__PURE__*/
  function (_IfUnlessHelperTest9) {
    (0, _emberBabel.inheritsLoose)(_class9, _IfUnlessHelperTest9);

    function _class9() {
      return _IfUnlessHelperTest9.apply(this, arguments) || this;
    }

    var _proto9 = _class9.prototype;

    _proto9.templateFor = function templateFor(_ref9) {
      var cond = _ref9.cond,
          truthy = _ref9.truthy,
          falsy = _ref9.falsy;
      return "{{unless (unless " + cond + " " + cond + " true) " + falsy + " " + truthy + "}}";
    };

    return _class9;
  }(_sharedConditionalTests.IfUnlessHelperTest));
  (0, _internalTestHelpers.moduleFor)('Helpers test: {{unless}} used with another helper',
  /*#__PURE__*/
  function (_IfUnlessHelperTest10) {
    (0, _emberBabel.inheritsLoose)(_class10, _IfUnlessHelperTest10);

    function _class10() {
      return _IfUnlessHelperTest10.apply(this, arguments) || this;
    }

    var _proto10 = _class10.prototype;

    _proto10.wrapperFor = function wrapperFor(templates) {
      return "{{concat " + templates.join(' ') + "}}";
    };

    _proto10.templateFor = function templateFor(_ref10) {
      var cond = _ref10.cond,
          truthy = _ref10.truthy,
          falsy = _ref10.falsy;
      return "(unless " + cond + " " + falsy + " " + truthy + ")";
    };

    return _class10;
  }(_sharedConditionalTests.IfUnlessHelperTest));
  (0, _internalTestHelpers.moduleFor)('Helpers test: {{unless}} used in attribute position',
  /*#__PURE__*/
  function (_IfUnlessHelperTest11) {
    (0, _emberBabel.inheritsLoose)(_class11, _IfUnlessHelperTest11);

    function _class11() {
      return _IfUnlessHelperTest11.apply(this, arguments) || this;
    }

    var _proto11 = _class11.prototype;

    _proto11.wrapperFor = function wrapperFor(templates) {
      return "<div data-foo=\"" + templates.join('') + "\" />";
    };

    _proto11.templateFor = function templateFor(_ref11) {
      var cond = _ref11.cond,
          truthy = _ref11.truthy,
          falsy = _ref11.falsy;
      return "{{unless " + cond + " " + falsy + " " + truthy + "}}";
    };

    _proto11.textValue = function textValue() {
      return this.$('div').attr('data-foo');
    };

    return _class11;
  }(_sharedConditionalTests.IfUnlessHelperTest));
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/loc-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/string"], function (_emberBabel, _internalTestHelpers, _metal, _string) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{loc}}',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      var _this;

      _this = _RenderingTestCase.apply(this, arguments) || this;
      (0, _string._setStrings)({
        'Hello Friend': 'Hallo Freund',
        Hello: 'Hallo, %@'
      });
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _RenderingTestCase.prototype.teardown.call(this);

      (0, _string._setStrings)({});
    };

    _proto['@test it lets the original value through by default'] = function testItLetsTheOriginalValueThroughByDefault() {
      var _this2 = this;

      this.render("{{loc \"Hiya buddy!\"}}");
      this.assertText('Hiya buddy!', 'the unlocalized string is correct');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertText('Hiya buddy!', 'the unlocalized string is correct after rerender');
    };

    _proto['@test it localizes a simple string'] = function testItLocalizesASimpleString() {
      var _this3 = this;

      this.render("{{loc \"Hello Friend\"}}");
      this.assertText('Hallo Freund', 'the localized string is correct');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assertText('Hallo Freund', 'the localized string is correct after rerender');
    };

    _proto['@test it takes passed formats into an account'] = function testItTakesPassedFormatsIntoAnAccount() {
      var _this4 = this;

      this.render("{{loc \"%@, %@\" \"Hello\" \"Mr. Pitkin\"}}");
      this.assertText('Hello, Mr. Pitkin', 'the formatted string is correct');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      this.assertText('Hello, Mr. Pitkin', 'the formatted string is correct after rerender');
    };

    _proto['@test it updates when bound params change'] = function testItUpdatesWhenBoundParamsChange() {
      var _this5 = this;

      this.render("{{loc simple}} - {{loc personal 'Mr. Pitkin'}}", {
        simple: 'Hello Friend',
        personal: 'Hello'
      });
      this.assertText('Hallo Freund - Hallo, Mr. Pitkin', 'the bound value is correct');
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.rerender();
      });
      this.assertText('Hallo Freund - Hallo, Mr. Pitkin', 'the bound value is correct after rerender');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'simple', "G'day mate");
      });
      this.assertText("G'day mate - Hallo, Mr. Pitkin", 'the bound value is correct after update');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'simple', 'Hello Friend');
      });
      this.assertText('Hallo Freund - Hallo, Mr. Pitkin', 'the bound value is correct after reset');
    };

    _proto['@test it updates when nested bound params change'] = function testItUpdatesWhenNestedBoundParamsChange() {
      var _this6 = this;

      this.render("{{loc greetings.simple}} - {{loc greetings.personal 'Mr. Pitkin'}}", {
        greetings: {
          simple: 'Hello Friend',
          personal: 'Hello'
        }
      });
      this.assertText('Hallo Freund - Hallo, Mr. Pitkin', 'the bound value is correct');
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.rerender();
      });
      this.assertText('Hallo Freund - Hallo, Mr. Pitkin', 'the bound value is correct after rerender');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'greetings.simple', "G'day mate");
      });
      this.assertText("G'day mate - Hallo, Mr. Pitkin", 'the bound value is correct after interior mutation');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'greetings', {
          simple: 'Hello Friend',
          personal: 'Hello'
        });
      });
      this.assertText('Hallo Freund - Hallo, Mr. Pitkin', 'the bound value is correct after replacement');
    };

    _proto['@test it can be overriden'] = function testItCanBeOverriden() {
      this.registerHelper('loc', function () {
        return 'Yup';
      });
      this.render("{{loc greeting}}", {
        greeting: 'Hello Friend'
      });
      this.assertText('Yup', 'the localized string is correct');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/log-test", ["ember-babel", "internal-test-helpers"], function (_emberBabel, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{log}}',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      var _this;

      _this = _RenderingTestCase.apply(this, arguments) || this;
      /* eslint-disable no-console */

      _this.originalLog = console.log;
      _this.logCalls = [];

      console.log = function () {
        var _this$logCalls;

        (_this$logCalls = _this.logCalls).push.apply(_this$logCalls, arguments);
        /* eslint-enable no-console */

      };

      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _RenderingTestCase.prototype.teardown.call(this);
      /* eslint-disable no-console */


      console.log = this.originalLog;
      /* eslint-enable no-console */
    };

    _proto.assertLog = function assertLog(values) {
      this.assertText('');
      this.assert.strictEqual(this.logCalls.length, values.length);

      for (var i = 0, len = values.length; i < len; i++) {
        this.assert.strictEqual(this.logCalls[i], values[i]);
      }
    };

    _proto['@test correctly logs primitives'] = function testCorrectlyLogsPrimitives() {
      this.render("{{log \"one\" 1 true}}");
      this.assertLog(['one', 1, true]);
    };

    _proto['@test correctly logs a property'] = function testCorrectlyLogsAProperty() {
      this.render("{{log value}}", {
        value: 'one'
      });
      this.assertLog(['one']);
    };

    _proto['@test correctly logs multiple arguments'] = function testCorrectlyLogsMultipleArguments() {
      this.render("{{log \"my variable:\" value}}", {
        value: 'one'
      });
      this.assertLog(['my variable:', 'one']);
    };

    _proto['@test correctly logs `this`'] = function testCorrectlyLogsThis() {
      this.render("{{log this}}");
      this.assertLog([this.context]);
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/mut-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{mut}}',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test a simple mutable binding using `mut` propagates properly'] = function testASimpleMutableBindingUsingMutPropagatesProperly() {
      var _this = this;

      var bottom;
      this.registerComponent('bottom-mut', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement: function () {
            bottom = this;
          }
        }),
        template: '{{setMe}}'
      });
      this.registerComponent('middle-mut', {
        template: '{{bottom-mut setMe=value}}'
      });
      this.render('{{middle-mut value=(mut val)}}', {
        val: 12
      });
      this.assertText('12', 'the data propagated downwards');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return bottom.attrs.setMe.update(13);
      });
      this.assertText('13', 'the set took effect');
      this.assert.strictEqual((0, _metal.get)(bottom, 'setMe'), 13, "the set took effect on bottom's prop");
      this.assert.strictEqual(bottom.attrs.setMe.value, 13, "the set took effect on bottom's attr");
      this.assert.strictEqual((0, _metal.get)(this.context, 'val'), 13, 'the set propagated back up');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(bottom, 'setMe', 14);
      });
      this.assertText('14', 'the set took effect');
      this.assert.strictEqual((0, _metal.get)(bottom, 'setMe'), 14, "the set took effect on bottom's prop");
      this.assert.strictEqual(bottom.attrs.setMe.value, 14, "the set took effect on bottom's attr");
      this.assert.strictEqual((0, _metal.get)(this.context, 'val'), 14, 'the set propagated back up');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'val', 12);
      });
      this.assertText('12');
    };

    _proto['@test a simple mutable binding using `mut` inserts into the DOM'] = function testASimpleMutableBindingUsingMutInsertsIntoTheDOM() {
      var _this2 = this;

      var bottom, middle;
      this.registerComponent('bottom-mut', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement: function () {
            bottom = this;
          }
        }),
        template: '{{setMe}}'
      });
      this.registerComponent('middle-mut', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement: function () {
            middle = this;
          }
        }),
        template: '{{bottom-mut setMe=(mut value)}}'
      });
      this.render('{{middle-mut value=(mut val)}}', {
        val: 12
      });
      this.assertText('12', 'the data propagated downwards');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return bottom.attrs.setMe.update(13);
      });
      this.assertText('13', 'the set took effect');
      this.assert.strictEqual((0, _metal.get)(bottom, 'setMe'), 13, "the set took effect on bottom's prop");
      this.assert.strictEqual(bottom.attrs.setMe.value, 13, "the set took effect on bottom's attr");
      this.assert.strictEqual((0, _metal.get)(middle, 'value'), 13, "the set propagated to middle's prop");
      this.assert.strictEqual(middle.attrs.value.value, 13, "the set propagated to middle's attr");
      this.assert.strictEqual((0, _metal.get)(this.context, 'val'), 13, 'the set propagated back up');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(bottom, 'setMe', 14);
      });
      this.assertText('14', 'the set took effect');
      this.assert.strictEqual((0, _metal.get)(bottom, 'setMe'), 14, "the set took effect on bottom's prop");
      this.assert.strictEqual(bottom.attrs.setMe.value, 14, "the set took effect on bottom's attr");
      this.assert.strictEqual((0, _metal.get)(middle, 'value'), 14, "the set propagated to middle's prop");
      this.assert.strictEqual(middle.attrs.value.value, 14, "the set propagated to middle's attr");
      this.assert.strictEqual((0, _metal.get)(this.context, 'val'), 14, 'the set propagated back up');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'val', 12);
      });
      this.assertText('12');
    };

    _proto['@test passing a literal results in a assertion'] = function testPassingALiteralResultsInAAssertion() {
      var _this3 = this;

      this.registerComponent('bottom-mut', {
        template: '{{setMe}}'
      });
      expectAssertion(function () {
        _this3.render('{{bottom-mut setMe=(mut "foo bar")}}');
      }, 'You can only pass a path to mut');
    };

    _proto['@test passing the result of a helper invocation results in an assertion'] = function testPassingTheResultOfAHelperInvocationResultsInAnAssertion() {
      var _this4 = this;

      this.registerComponent('bottom-mut', {
        template: '{{setMe}}'
      });
      expectAssertion(function () {
        _this4.render('{{bottom-mut setMe=(mut (concat "foo" " " "bar"))}}');
      }, 'You can only pass a path to mut');
    } // See https://github.com/emberjs/ember.js/commit/807a0cd for an explanation of this test
    ;

    _proto['@test using a string value through middle tier does not trigger assertion (due to the auto-mut transform)'] = function testUsingAStringValueThroughMiddleTierDoesNotTriggerAssertionDueToTheAutoMutTransform() {
      var bottom;
      this.registerComponent('bottom-mut', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement: function () {
            bottom = this;
          }
        }),
        template: '{{stuff}}'
      });
      this.registerComponent('middle-mut', {
        template: '{{bottom-mut stuff=value}}'
      });
      this.render('{{middle-mut value="foo"}}');
      this.assert.equal((0, _metal.get)(bottom, 'stuff'), 'foo', 'the data propagated');
      this.assertText('foo');
      this.assertStableRerender(); // No U-R for this test
    };

    _proto['@test {{readonly}} of a {{mut}} is converted into an immutable binding'] = function testReadonlyOfAMutIsConvertedIntoAnImmutableBinding() {
      var _this5 = this;

      var middle, bottom;
      this.registerComponent('bottom-mut', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement: function () {
            bottom = this;
          }
        }),
        template: '{{setMe}}'
      });
      this.registerComponent('middle-mut', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement: function () {
            middle = this;
          }
        }),
        template: '{{bottom-mut setMe=(readonly value)}}'
      });
      this.render('{{middle-mut value=(mut val)}}', {
        val: 12
      });
      this.assertText('12');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return middle.attrs.value.update(13);
      });
      this.assert.strictEqual((0, _metal.get)(middle, 'value'), 13, "the set took effect on middle's prop");
      this.assert.strictEqual(middle.attrs.value.value, 13, "the set took effect on middle's attr");
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(middle, 'value', 14);
      });
      this.assert.strictEqual((0, _metal.get)(middle, 'value'), 14, "the set took effect on middle's prop");
      this.assert.strictEqual(middle.attrs.value.value, 14, "the set took effect on middle's attr");
      this.assert.strictEqual(bottom.attrs.setMe, 14, 'the mutable binding has been converted to an immutable cell');
      this.assertText('14');
      this.assert.strictEqual((0, _metal.get)(this.context, 'val'), 14, 'the set propagated back up');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'val', 12);
      });
      this.assertText('12');
    };

    _proto['@test mutable bindings work inside of yielded content'] = function testMutableBindingsWorkInsideOfYieldedContent() {
      var _this6 = this;

      this.registerComponent('bottom-mut', {
        template: '{{yield}}'
      });
      this.registerComponent('middle-mut', {
        template: '{{#bottom-mut}}{{model.name}}{{/bottom-mut}}'
      });
      this.render('{{middle-mut model=(mut model)}}', {
        model: {
          name: 'Matthew Beale'
        }
      });
      this.assertText('Matthew Beale');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'model.name', 'Joel Kang');
      });
      this.assertText('Joel Kang');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'model', {
          name: 'Matthew Beale'
        });
      });
      this.assertText('Matthew Beale');
    };

    _proto['@test a simple mutable binding using {{mut}} is available in hooks'] = function testASimpleMutableBindingUsingMutIsAvailableInHooks() {
      var _this7 = this;

      var bottom;
      var willRender = [];
      var didInsert = [];
      this.registerComponent('bottom-mut', {
        ComponentClass: _helpers.Component.extend({
          willRender: function () {
            willRender.push((0, _metal.get)(this, 'setMe'));
          },
          didInsertElement: function () {
            didInsert.push((0, _metal.get)(this, 'setMe'));
            bottom = this;
          }
        }),
        template: '{{setMe}}'
      });
      this.registerComponent('middle-mut', {
        template: '{{bottom-mut setMe=(mut value)}}'
      });
      this.render('{{middle-mut value=(mut val)}}', {
        val: 12
      });
      this.assert.deepEqual(willRender, [12], 'willReceive is [12]');
      this.assert.deepEqual(didInsert, [12], 'didInsert is [12]');
      this.assertText('12');
      this.assertStableRerender();
      this.assert.deepEqual(willRender, [12], 'willReceive is [12]');
      this.assert.deepEqual(didInsert, [12], 'didInsert is [12]');
      this.assert.strictEqual((0, _metal.get)(bottom, 'setMe'), 12, 'the data propagated');
      (0, _internalTestHelpers.runTask)(function () {
        return bottom.attrs.setMe.update(13);
      });
      this.assert.strictEqual((0, _metal.get)(bottom, 'setMe'), 13, "the set took effect on bottom's prop");
      this.assert.strictEqual(bottom.attrs.setMe.value, 13, "the set took effect on bottom's attr");
      this.assert.strictEqual((0, _metal.get)(this.context, 'val'), 13, 'the set propagated back up');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(bottom, 'setMe', 14);
      });
      this.assert.strictEqual((0, _metal.get)(bottom, 'setMe'), 14, "the set took effect on bottom's prop");
      this.assert.strictEqual(bottom.attrs.setMe.value, 14, "the set took effect on bottom's attr");
      this.assert.strictEqual((0, _metal.get)(this.context, 'val'), 14, 'the set propagated back up');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'val', 12);
      });
      this.assertText('12');
    };

    _proto['@test a mutable binding with a backing computed property and attribute present in the root of the component is updated when the upstream property invalidates #11023'] = function testAMutableBindingWithABackingComputedPropertyAndAttributePresentInTheRootOfTheComponentIsUpdatedWhenTheUpstreamPropertyInvalidates11023() {
      var bottom, middle;
      this.registerComponent('bottom-mut', {
        ComponentClass: _helpers.Component.extend({
          thingy: null,
          didInsertElement: function () {
            bottom = this;
          }
        }),
        template: '{{thingy}}'
      });
      this.registerComponent('middle-mut', {
        ComponentClass: _helpers.Component.extend({
          baseValue: 12,
          val: (0, _metal.computed)('baseValue', function () {
            return this.get('baseValue');
          }),
          didInsertElement: function () {
            middle = this;
          }
        }),
        template: '{{bottom-mut thingy=(mut val)}}'
      });
      this.render('{{middle-mut}}');
      this.assert.strictEqual((0, _metal.get)(bottom, 'thingy'), 12, 'data propagated');
      this.assertText('12');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(middle, 'baseValue', 13);
      });
      this.assert.strictEqual((0, _metal.get)(middle, 'val'), 13, 'the set took effect');
      this.assert.strictEqual(bottom.attrs.thingy.value, 13, "the set propagated down to bottom's attrs");
      this.assert.strictEqual((0, _metal.get)(bottom, 'thingy'), 13, "the set propagated down to bottom's prop");
      this.assertText('13');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(middle, 'baseValue', 12);
      });
      this.assertText('12');
    };

    _proto['@test automatic mutable bindings exposes a mut cell in attrs'] = function testAutomaticMutableBindingsExposesAMutCellInAttrs() {
      var inner;
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement: function () {
            inner = this;
          }
        }),
        template: '{{foo}}'
      });
      this.registerComponent('x-outer', {
        template: '{{x-inner foo=bar}}'
      });
      this.render('{{x-outer bar=baz}}', {
        baz: 'foo'
      });
      this.assertText('foo');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return inner.attrs.foo.update('bar');
      });
      this.assert.equal(inner.attrs.foo.value, 'bar');
      this.assert.equal((0, _metal.get)(inner, 'foo'), 'bar');
      this.assertText('bar');
      (0, _internalTestHelpers.runTask)(function () {
        return inner.attrs.foo.update('foo');
      });
      this.assertText('foo');
    };

    _proto['@test automatic mutable bindings tolerate undefined non-stream inputs and attempts to set them'] = function testAutomaticMutableBindingsTolerateUndefinedNonStreamInputsAndAttemptsToSetThem() {
      var inner;
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement: function () {
            inner = this;
          }
        }),
        template: '{{model}}'
      });
      this.registerComponent('x-outer', {
        template: '{{x-inner model=nonexistent}}'
      });
      this.render('{{x-outer}}');
      this.assertText('');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return inner.attrs.model.update(42);
      });
      this.assert.equal(inner.attrs.model.value, 42);
      this.assert.equal((0, _metal.get)(inner, 'model'), 42);
      this.assertText('42');
      (0, _internalTestHelpers.runTask)(function () {
        return inner.attrs.model.update(undefined);
      });
      this.assertText('');
    };

    _proto['@test automatic mutable bindings tolerate constant non-stream inputs and attempts to set them'] = function testAutomaticMutableBindingsTolerateConstantNonStreamInputsAndAttemptsToSetThem() {
      var inner;
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement: function () {
            inner = this;
          }
        }),
        template: 'hello{{model}}'
      });
      this.registerComponent('x-outer', {
        template: '{{x-inner model=x}}'
      });
      this.render('{{x-outer x="foo"}}');
      this.assertText('hellofoo');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return inner.attrs.model.update(42);
      });
      this.assert.equal(inner.attrs.model.value, 42);
      this.assert.equal((0, _metal.get)(inner, 'model'), 42);
      this.assertText('hello42');
      (0, _internalTestHelpers.runTask)(function () {
        return inner.attrs.model.update('foo');
      });
      this.assertText('hellofoo');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
  (0, _internalTestHelpers.moduleFor)('Mutable Bindings used in Computed Properties that are bound as attributeBindings',
  /*#__PURE__*/
  function (_RenderingTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _RenderingTestCase2);

    function _class2() {
      return _RenderingTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test an attribute binding of a computed property of a 2-way bound attr recomputes when the attr changes'] = function testAnAttributeBindingOfAComputedPropertyOfA2WayBoundAttrRecomputesWhenTheAttrChanges() {
      var _this8 = this;

      var input, output;
      this.registerComponent('x-input', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement: function () {
            input = this;
          }
        })
      });
      this.registerComponent('x-output', {
        ComponentClass: _helpers.Component.extend({
          attributeBindings: ['style'],
          didInsertElement: function () {
            output = this;
          },
          style: (0, _metal.computed)('height', function () {
            var height = this.get('height');
            return (0, _helpers.htmlSafe)("height: " + height + "px;");
          }),
          height: 20
        }),
        template: '{{height}}'
      });
      this.render('{{x-output height=height}}{{x-input height=(mut height)}}', {
        height: 60
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 60px;')
        },
        content: '60'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return input.attrs.height.update(35);
      });
      this.assert.strictEqual((0, _metal.get)(output, 'height'), 35, 'the set took effect');
      this.assert.strictEqual((0, _metal.get)(this.context, 'height'), 35, 'the set propagated back up');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 35px;')
        },
        content: '35'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(input, 'height', 36);
      });
      this.assert.strictEqual((0, _metal.get)(output, 'height'), 36, 'the set took effect');
      this.assert.strictEqual((0, _metal.get)(this.context, 'height'), 36, 'the set propagated back up');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 36px;')
        },
        content: '36'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this8.context, 'height', 60);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 60px;')
        },
        content: '60'
      });
      this.assert.strictEqual((0, _metal.get)(input, 'height'), 60);
    };

    _proto2['@test an attribute binding of a computed property with a setter of a 2-way bound attr recomputes when the attr changes'] = function testAnAttributeBindingOfAComputedPropertyWithASetterOfA2WayBoundAttrRecomputesWhenTheAttrChanges() {
      var _this9 = this;

      var input, output;
      this.registerComponent('x-input', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement: function () {
            input = this;
          }
        })
      });
      this.registerComponent('x-output', {
        ComponentClass: _helpers.Component.extend({
          attributeBindings: ['style'],
          didInsertElement: function () {
            output = this;
          },
          style: (0, _metal.computed)('height', 'width', function () {
            var height = this.get('height');
            var width = this.get('width');
            return (0, _helpers.htmlSafe)("height: " + height + "px; width: " + width + "px;");
          }),
          height: 20,
          width: (0, _metal.computed)('height', {
            get: function () {
              return this.get('height') * 2;
            },
            set: function (keyName, width) {
              this.set('height', width / 2);
              return width;
            }
          })
        }),
        template: '{{width}}x{{height}}'
      });
      this.render('{{x-output width=width}}{{x-input width=(mut width)}}', {
        width: 70
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 35px; width: 70px;')
        },
        content: '70x35'
      });
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(input, 'width', 80);
      });
      this.assert.strictEqual((0, _metal.get)(output, 'width'), 80, 'the set took effect');
      this.assert.strictEqual((0, _metal.get)(this.context, 'width'), 80, 'the set propagated back up');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 40px; width: 80px;')
        },
        content: '80x40'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return input.attrs.width.update(90);
      });
      this.assert.strictEqual((0, _metal.get)(output, 'width'), 90, 'the set took effect');
      this.assert.strictEqual((0, _metal.get)(this.context, 'width'), 90, 'the set propagated back up');
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 45px; width: 90px;')
        },
        content: '90x45'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this9.context, 'width', 70);
      });
      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          style: (0, _internalTestHelpers.styles)('height: 35px; width: 70px;')
        },
        content: '70x35'
      });
      this.assert.strictEqual((0, _metal.get)(input, 'width'), 70);
    };

    return _class2;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/partial-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/runtime"], function (_emberBabel, _internalTestHelpers, _metal, _runtime) {
  "use strict";

  function _templateObject14() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#outer-component name=name as |outer|}}\n        {{partial 'some-partial'}}\n      {{/outer-component}}"]);

    _templateObject14 = function () {
      return data;
    };

    return data;
  }

  function _templateObject13() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#outer.inner as |inner|}}\n        inner.name: {{inner.name}}\n      {{/outer.inner}}\n    "]);

    _templateObject13 = function () {
      return data;
    };

    return data;
  }

  function _templateObject12() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with item.thing as |t|}}\n        {{partial t}}\n      {{else}}\n        Nothing!\n      {{/with}}"]);

    _templateObject12 = function () {
      return data;
    };

    return data;
  }

  function _templateObject11() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#each model.items as |template i|}}\n        {{model.type}}: {{partial template}}\n      {{/each}}"]);

    _templateObject11 = function () {
      return data;
    };

    return data;
  }

  function _templateObject10() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with 'Sophie' as |person1|}}\n        Hi {{person1}} (aged {{age}}). {{partial 'person2-partial'}}\n      {{/with}}"]);

    _templateObject10 = function () {
      return data;
    };

    return data;
  }

  function _templateObject9() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with 'Sarah' as |person4|}}\n        Hi {{person1}} (aged {{age}}), {{person2}}, {{person3}} and {{person4}}.\n      {{/with}}\n    "]);

    _templateObject9 = function () {
      return data;
    };

    return data;
  }

  function _templateObject8() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with 'Alex' as |person3|}}\n        Hi {{person1}} (aged {{age}}), {{person2}} and {{person3}}. {{partial 'person4-partial'}}\n      {{/with}}\n    "]);

    _templateObject8 = function () {
      return data;
    };

    return data;
  }

  function _templateObject7() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with 'Ben' as |person2|}}\n        Hi {{person1}} (aged {{age}}) and {{person2}}. {{partial 'person3-partial'}}\n      {{/with}}\n    "]);

    _templateObject7 = function () {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#each names as |name i|}}\n        {{i}}: {{partial 'outer-partial'}}\n      {{/each}}"]);

    _templateObject6 = function () {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    const data = _taggedTemplateLiteralLoose(["\n      [outer: {{name}}] {{partial 'inner-partial'}}\n    "]);

    _templateObject5 = function () {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#each items as |item|}}\n        {{item}}: {{partial 'show-item'}} |\n      {{/each}}"]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#each items as |item|}}\n        {{item.id}}: {{partial 'show-item'}} |\n      {{/each}}"]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with model as |item|}}\n        {{item.name}}: {{partial 'show-id'}}\n      {{/with}}"]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#each model.items as |item|}}\n        {{item}}: {{partial 'show-item'}} |\n      {{/each}}"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{partial}}',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test should render other templates registered with the container'] = function testShouldRenderOtherTemplatesRegisteredWithTheContainer() {
      this.registerPartial('_subTemplateFromContainer', 'sub-template');
      this.render("This {{partial \"subTemplateFromContainer\"}} is pretty great.");
      this.assertStableRerender();
      this.assertText('This sub-template is pretty great.');
    };

    _proto['@test should render other slash-separated templates registered with the container'] = function testShouldRenderOtherSlashSeparatedTemplatesRegisteredWithTheContainer() {
      this.registerPartial('child/_subTemplateFromContainer', 'sub-template');
      this.render("This {{partial \"child/subTemplateFromContainer\"}} is pretty great.");
      this.assertStableRerender();
      this.assertText('This sub-template is pretty great.');
    };

    _proto['@test should use the current context'] = function testShouldUseTheCurrentContext() {
      var _this = this;

      this.registerPartial('_person_name', '{{model.firstName}} {{model.lastName}}');
      this.render('Who is {{partial "person_name"}}?', {
        model: {
          firstName: 'Kris',
          lastName: 'Selden'
        }
      });
      this.assertStableRerender();
      this.assertText('Who is Kris Selden?');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'model.firstName', 'Kelly');
      });
      this.assertText('Who is Kelly Selden?');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'model', {
          firstName: 'Kris',
          lastName: 'Selden'
        });
      });
      this.assertText('Who is Kris Selden?');
    };

    _proto['@test Quoteless parameters passed to {{partial}} perform a bound property lookup of the partial name'] = function testQuotelessParametersPassedToPartialPerformABoundPropertyLookupOfThePartialName() {
      var _this2 = this;

      this.registerPartial('_subTemplate', 'sub-template');
      this.registerPartial('_otherTemplate', 'other-template');
      this.render('This {{partial templates.partialName}} is pretty {{partial nonexistent}}great.', {
        templates: {
          partialName: 'subTemplate'
        }
      });
      this.assertStableRerender();
      this.assertText('This sub-template is pretty great.');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'templates.partialName', 'otherTemplate');
      });
      this.assertText('This other-template is pretty great.');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'templates.partialName', null);
      });
      this.assertText('This  is pretty great.');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'templates', {
          partialName: 'subTemplate'
        });
      });
      this.assertText('This sub-template is pretty great.');
    };

    _proto['@test partial using data from {{#each}}'] = function testPartialUsingDataFromEach() {
      var _this3 = this;

      this.registerPartial('show-item', '{{item}}');
      this.render((0, _internalTestHelpers.strip)(_templateObject()), {
        model: {
          items: (0, _runtime.A)(['apple', 'orange', 'banana'])
        }
      });
      this.assertStableRerender();
      this.assertText('apple: apple |orange: orange |banana: banana |');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.context.model.items.pushObject('strawberry');
      });
      this.assertText('apple: apple |orange: orange |banana: banana |strawberry: strawberry |');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'model', {
          items: (0, _runtime.A)(['apple', 'orange', 'banana'])
        });
      });
      this.assertText('apple: apple |orange: orange |banana: banana |');
    };

    _proto['@test partial using `{{get` on data from {{#with}}'] = function testPartialUsingGetOnDataFromWith() {
      var _this4 = this;

      this.registerPartial('show-id', '{{get item "id"}}');
      this.render((0, _internalTestHelpers.strip)(_templateObject2()), {
        model: {
          id: 1,
          name: 'foo'
        }
      });
      this.assertStableRerender();
      this.assertText('foo: 1');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'model.id', 2);
      });
      this.assertText('foo: 2');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'model.name', 'bar');
      });
      this.assertText('bar: 2');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'model', {
          id: 1,
          name: 'foo'
        });
      });
      this.assertText('foo: 1');
    };

    _proto['@test partial using `{{get` on data from {{#each}}'] = function testPartialUsingGetOnDataFromEach() {
      var _this5 = this;

      this.registerPartial('show-item', '{{get item "id"}}');
      this.render((0, _internalTestHelpers.strip)(_templateObject3()), {
        items: (0, _runtime.A)([{
          id: 1
        }, {
          id: 2
        }, {
          id: 3
        }])
      });
      this.assertStableRerender();
      this.assertText('1: 1 |2: 2 |3: 3 |');
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.context.items.pushObject({
          id: 4
        });
      });
      this.assertText('1: 1 |2: 2 |3: 3 |4: 4 |');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'items', (0, _runtime.A)([{
          id: 1
        }, {
          id: 2
        }, {
          id: 3
        }]));
      });
      this.assertText('1: 1 |2: 2 |3: 3 |');
    };

    _proto['@test partial using conditional on data from {{#each}}'] = function testPartialUsingConditionalOnDataFromEach() {
      var _this6 = this;

      this.registerPartial('show-item', '{{#if item}}{{item}}{{/if}}');
      this.render((0, _internalTestHelpers.strip)(_templateObject4()), {
        items: (0, _runtime.A)(['apple', null, 'orange', 'banana'])
      });
      this.assertStableRerender();
      this.assertText('apple: apple |:  |orange: orange |banana: banana |');
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.context.items.pushObject('strawberry');
      });
      this.assertText('apple: apple |:  |orange: orange |banana: banana |strawberry: strawberry |');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'items', (0, _runtime.A)(['apple', null, 'orange', 'banana']));
      });
      this.assertText('apple: apple |:  |orange: orange |banana: banana |');
    };

    _proto['@test nested partials using data from {{#each}}'] = function testNestedPartialsUsingDataFromEach() {
      var _this7 = this;

      this.registerPartial('_outer-partial', (0, _internalTestHelpers.strip)(_templateObject5()));
      this.registerPartial('inner-partial', '[inner: {{name}}]');
      this.render((0, _internalTestHelpers.strip)(_templateObject6()), {
        names: (0, _runtime.A)(['Alex', 'Ben'])
      });
      this.assertStableRerender();
      this.assertText('0: [outer: Alex] [inner: Alex]1: [outer: Ben] [inner: Ben]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.context.names.pushObject('Sophie');
      });
      this.assertText('0: [outer: Alex] [inner: Alex]1: [outer: Ben] [inner: Ben]2: [outer: Sophie] [inner: Sophie]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'names', (0, _runtime.A)(['Alex', 'Ben']));
      });
      this.assertText('0: [outer: Alex] [inner: Alex]1: [outer: Ben] [inner: Ben]');
    };

    _proto['@test nested partials within nested `{{#with}}` blocks'] = function testNestedPartialsWithinNestedWithBlocks() {
      var _this8 = this;

      this.registerPartial('_person2-partial', (0, _internalTestHelpers.strip)(_templateObject7()));
      this.registerPartial('_person3-partial', (0, _internalTestHelpers.strip)(_templateObject8()));
      this.registerPartial('_person4-partial', (0, _internalTestHelpers.strip)(_templateObject9()));
      this.render((0, _internalTestHelpers.strip)(_templateObject10()), {
        age: 0
      });
      this.assertStableRerender();
      this.assertText('Hi Sophie (aged 0). Hi Sophie (aged 0) and Ben. Hi Sophie (aged 0), Ben and Alex. Hi Sophie (aged 0), Ben, Alex and Sarah.');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this8.context, 'age', 1);
      });
      this.assertText('Hi Sophie (aged 1). Hi Sophie (aged 1) and Ben. Hi Sophie (aged 1), Ben and Alex. Hi Sophie (aged 1), Ben, Alex and Sarah.');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this8.context, 'age', 0);
      });
      this.assertText('Hi Sophie (aged 0). Hi Sophie (aged 0) and Ben. Hi Sophie (aged 0), Ben and Alex. Hi Sophie (aged 0), Ben, Alex and Sarah.');
    };

    _proto['@test dynamic partials in {{#each}}'] = function testDynamicPartialsInEach() {
      var _this9 = this;

      this.registerPartial('_odd', 'ODD{{i}}');
      this.registerPartial('_even', 'EVEN{{i}}');
      this.render((0, _internalTestHelpers.strip)(_templateObject11()), {
        model: {
          items: ['even', 'odd', 'even', 'odd'],
          type: 'number'
        }
      });
      this.assertStableRerender();
      this.assertText('number: EVEN0number: ODD1number: EVEN2number: ODD3');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this9.context, 'model.type', 'integer');
      });
      this.assertText('integer: EVEN0integer: ODD1integer: EVEN2integer: ODD3');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this9.context, 'model', {
          items: ['even', 'odd', 'even', 'odd'],
          type: 'number'
        });
      });
      this.assertText('number: EVEN0number: ODD1number: EVEN2number: ODD3');
    };

    _proto['@test dynamic partials in {{#with}}'] = function testDynamicPartialsInWith() {
      var _this10 = this;

      this.registerPartial('_thing', '{{t}}');
      this.render((0, _internalTestHelpers.strip)(_templateObject12()), {
        item: {
          thing: false
        }
      });
      this.assertStableRerender();
      this.assertText('Nothing!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'item.thing', 'thing');
      });
      this.assertText('thing');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'item', {
          thing: false
        });
      });
      this.assertText('Nothing!');
    };

    _proto['@test partials which contain contextual components'] = function testPartialsWhichContainContextualComponents() {
      var _this11 = this;

      this.registerComponent('outer-component', {
        template: '{{yield (hash inner=(component "inner-component" name=name))}}'
      });
      this.registerComponent('inner-component', {
        template: '{{yield (hash name=name)}}'
      });
      this.registerPartial('_some-partial', (0, _internalTestHelpers.strip)(_templateObject13()));
      this.render((0, _internalTestHelpers.strip)(_templateObject14()), {
        name: 'Sophie'
      });
      this.assertStableRerender();
      this.assertText('inner.name: Sophie');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'name', 'Ben');
      });
      this.assertText('inner.name: Ben');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'name', 'Sophie');
      });
      this.assertText('inner.name: Sophie');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/readonly-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{readonly}}',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test {{readonly}} of a path should work'] = function testReadonlyOfAPathShouldWork() {
      var component;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement: function () {
            component = this;
          }
        }),
        template: '{{value}}'
      });
      this.render('{{foo-bar value=(readonly val)}}', {
        val: 12
      });
      this.assertText('12');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(component, 'value', 13);
      });
      this.assert.notOk(component.attrs.value.update);
      this.assertText('13', 'local property is updated');
      this.assert.equal((0, _metal.get)(this.context, 'val'), 12, 'upstream attribute is not updated'); // No U-R
    };

    _proto['@test passing an action to {{readonly}} avoids mutable cell wrapping'] = function testPassingAnActionToReadonlyAvoidsMutableCellWrapping(assert) {
      assert.expect(4);
      var outer, inner;
      this.registerComponent('x-inner', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            inner = this;
          }
        })
      });
      this.registerComponent('x-outer', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            outer = this;
          }
        }),
        template: '{{x-inner onClick=(readonly onClick)}}'
      });
      this.render('{{x-outer onClick=(action doIt)}}', {
        doIt: function () {
          assert.ok(true, 'action was called');
        }
      });
      assert.equal(typeof outer.attrs.onClick, 'function', 'function itself is present in outer component attrs');
      outer.attrs.onClick();
      assert.equal(typeof inner.attrs.onClick, 'function', 'function itself is present in inner component attrs');
      inner.attrs.onClick();
    };

    _proto['@test updating a {{readonly}} property from above works'] = function testUpdatingAReadonlyPropertyFromAboveWorks(assert) {
      var _this = this;

      var component;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            component = this;
          }
        }),
        template: '{{value}}'
      });
      this.render('{{foo-bar value=(readonly thing)}}', {
        thing: 'initial'
      });
      this.assertText('initial');
      this.assertStableRerender();
      assert.strictEqual(component.attrs.value, 'initial', 'no mutable cell');
      assert.strictEqual((0, _metal.get)(component, 'value'), 'initial', 'no mutable cell');
      assert.strictEqual(this.context.thing, 'initial');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'thing', 'updated!');
      });
      this.assertText('updated!');
      assert.strictEqual(component.attrs.value, 'updated!', 'passed down value was set in attrs');
      assert.strictEqual((0, _metal.get)(component, 'value'), 'updated!', 'passed down value was set');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'thing', 'initial');
      });
      this.assertText('initial');
    };

    _proto['@test updating a nested path of a {{readonly}}'] = function testUpdatingANestedPathOfAReadonly(assert) {
      var component;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement: function () {
            component = this;
          }
        }),
        template: '{{value.prop}}'
      });
      this.render('{{foo-bar value=(readonly thing)}}', {
        thing: {
          prop: 'initial'
        }
      });
      this.assertText('initial');
      this.assertStableRerender();
      assert.notOk(component.attrs.value.update, 'no update available');
      assert.deepEqual((0, _metal.get)(component, 'value'), {
        prop: 'initial'
      });
      assert.deepEqual(this.context.thing, {
        prop: 'initial'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(component, 'value.prop', 'updated!');
      });
      this.assertText('updated!', 'nested path is updated');
      assert.deepEqual((0, _metal.get)(component, 'value'), {
        prop: 'updated!'
      });
      assert.deepEqual(this.context.thing, {
        prop: 'updated!'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(component, 'value.prop', 'initial');
      });
      this.assertText('initial');
    };

    _proto['@test {{readonly}} of a string renders correctly'] = function testReadonlyOfAStringRendersCorrectly() {
      var component;
      this.registerComponent('foo-bar', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement: function () {
            component = this;
          }
        }),
        template: '{{value}}'
      });
      this.render('{{foo-bar value=(readonly "12")}}');
      this.assertText('12');
      this.assertStableRerender();
      this.assert.notOk(component.attrs.value.update);
      this.assert.strictEqual((0, _metal.get)(component, 'value'), '12');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(component, 'value', '13');
      });
      this.assertText('13', 'local property is updated');
      this.assert.strictEqual((0, _metal.get)(component, 'value'), '13');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(component, 'value', '12');
      });
      this.assertText('12');
    };

    _proto['@test {{mut}} of a {{readonly}} mutates only the middle and bottom tiers'] = function testMutOfAReadonlyMutatesOnlyTheMiddleAndBottomTiers() {
      var _this2 = this;

      var middle, bottom;
      this.registerComponent('x-bottom', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement: function () {
            bottom = this;
          }
        }),
        template: '{{bar}}'
      });
      this.registerComponent('x-middle', {
        ComponentClass: _helpers.Component.extend({
          didInsertElement: function () {
            middle = this;
          }
        }),
        template: '{{foo}} {{x-bottom bar=(mut foo)}}'
      });
      this.render('{{x-middle foo=(readonly val)}}', {
        val: 12
      });
      this.assertText('12 12');
      this.assertStableRerender();
      this.assert.equal((0, _metal.get)(bottom, 'bar'), 12, "bottom's local bar received the value");
      this.assert.equal((0, _metal.get)(middle, 'foo'), 12, "middle's local foo received the value"); // updating the mut-cell directly

      (0, _internalTestHelpers.runTask)(function () {
        return bottom.attrs.bar.update(13);
      });
      this.assert.equal((0, _metal.get)(bottom, 'bar'), 13, "bottom's local bar was updated after set of bottom's bar");
      this.assert.equal((0, _metal.get)(middle, 'foo'), 13, "middle's local foo was updated after set of bottom's bar");
      this.assertText('13 13');
      this.assert.equal((0, _metal.get)(this.context, 'val'), 12, 'But context val is not updated');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(bottom, 'bar', 14);
      });
      this.assert.equal((0, _metal.get)(bottom, 'bar'), 14, "bottom's local bar was updated after set of bottom's bar");
      this.assert.equal((0, _metal.get)(middle, 'foo'), 14, "middle's local foo was updated after set of bottom's bar");
      this.assertText('14 14');
      this.assert.equal((0, _metal.get)(this.context, 'val'), 12, 'But context val is not updated');
      this.assert.notOk(middle.attrs.foo.update, "middle's foo attr is not a mutable cell");
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(middle, 'foo', 15);
      });
      this.assertText('15 15');
      this.assert.equal((0, _metal.get)(middle, 'foo'), 15, "set of middle's foo took effect");
      this.assert.equal((0, _metal.get)(bottom, 'bar'), 15, "bottom's local bar was updated after set of middle's foo");
      this.assert.equal((0, _metal.get)(this.context, 'val'), 12, 'Context val remains unchanged');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'val', 10);
      });
      this.assertText('10 10');
      this.assert.equal((0, _metal.get)(bottom, 'bar'), 10, "bottom's local bar was updated after set of context's val");
      this.assert.equal((0, _metal.get)(middle, 'foo'), 10, "middle's local foo was updated after set of context's val"); // setting as a normal property

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(bottom, 'bar', undefined);
      });
      this.assertText(' ');
      this.assert.equal((0, _metal.get)(bottom, 'bar'), undefined, "bottom's local bar was updated to a falsy value");
      this.assert.equal((0, _metal.get)(middle, 'foo'), undefined, "middle's local foo was updated to a falsy value");
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'val', 12);
      });
      this.assertText('12 12', 'bottom and middle were both reset');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/tracked-test", ["ember-babel", "@ember/-internals/runtime", "@ember/-internals/metal", "internal-test-helpers", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _runtime, _metal, _internalTestHelpers, _helpers) {
  "use strict";

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["\n            <button {{action this.addNumber}}>\n              {{join this.numbers}}\n            </button>\n          "]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n            <button onclick={{action this.updatePerson}}>\n              {{hello-world this.full}}\n            </button>\n          "]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n            <button onclick={{action this.updateName}}>\n              {{hello-world this.name}}\n            </button>\n          "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  if (false
  /* EMBER_METAL_TRACKED_PROPERTIES */
  ) {
      (0, _internalTestHelpers.moduleFor)('Helper Tracked Properties',
      /*#__PURE__*/
      function (_RenderingTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

        function _class() {
          return _RenderingTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto['@test tracked properties rerender when updated'] = function testTrackedPropertiesRerenderWhenUpdated(assert) {
          var _this = this;

          var computeCount = 0;

          var PersonComponent = _helpers.Component.extend({
            name: (0, _metal.tracked)({
              value: 'bob'
            }),
            updateName: function () {
              this.name = 'sal';
            }
          });

          this.registerComponent('person', {
            ComponentClass: PersonComponent,
            template: (0, _internalTestHelpers.strip)(_templateObject())
          });
          this.registerHelper('hello-world', function (_ref) {
            var value = _ref[0];
            computeCount++;
            return value + "-value";
          });
          this.render('<Person/>');
          this.assertText('bob-value');
          assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
          (0, _internalTestHelpers.runTask)(function () {
            return _this.rerender();
          });
          this.assertText('bob-value');
          assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
          (0, _internalTestHelpers.runTask)(function () {
            return _this.$('button').click();
          });
          this.assertText('sal-value');
          assert.strictEqual(computeCount, 2, 'compute is called exactly 2 times');
        };

        _proto['@test nested tracked properties rerender when updated'] = function testNestedTrackedPropertiesRerenderWhenUpdated(assert) {
          var _this2 = this;

          var computeCount = 0;

          var Person = _runtime.Object.extend({
            name: (0, _metal.tracked)({
              value: 'bob'
            })
          });

          this.registerHelper('hello-world', function (_ref2) {
            var value = _ref2[0];
            computeCount++;
            return value + "-value";
          });
          this.render('{{hello-world model.name}}', {
            model: Person.create()
          });
          this.assertText('bob-value');
          assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
          (0, _internalTestHelpers.runTask)(function () {
            return _this2.rerender();
          });
          this.assertText('bob-value');
          assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
          (0, _internalTestHelpers.runTask)(function () {
            return _this2.context.model.name = 'sal';
          });
          this.assertText('sal-value');
          assert.strictEqual(computeCount, 2, 'compute is called exactly 2 times');
        };

        _proto['@test getters update when dependent properties are invalidated'] = function testGettersUpdateWhenDependentPropertiesAreInvalidated(assert) {
          var _this3 = this;

          var computeCount = 0;

          var PersonComponent = _helpers.Component.extend({
            first: (0, _metal.tracked)({
              value: 'Rob'
            }),
            last: (0, _metal.tracked)({
              value: 'Jackson'
            }),
            full: (0, _metal.nativeDescDecorator)({
              get: function () {
                return this.first + " " + this.last;
              }
            }),
            updatePerson: function () {
              this.first = 'Kris';
              this.last = 'Selden';
            }
          });

          this.registerComponent('person', {
            ComponentClass: PersonComponent,
            template: (0, _internalTestHelpers.strip)(_templateObject2())
          });
          this.registerHelper('hello-world', function (_ref3) {
            var value = _ref3[0];
            computeCount++;
            return value;
          });
          this.render('<Person/>');
          this.assertText('Rob Jackson');
          assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
          (0, _internalTestHelpers.runTask)(function () {
            return _this3.rerender();
          });
          this.assertText('Rob Jackson');
          assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
          (0, _internalTestHelpers.runTask)(function () {
            return _this3.$('button').click();
          });
          this.assertText('Kris Selden');
          assert.strictEqual(computeCount, 2, 'compute is called exactly 2 times');
        };

        _proto['@test array properties rerender when updated'] = function testArrayPropertiesRerenderWhenUpdated() {
          var _this4 = this;

          var NumListComponent = _helpers.Component.extend({
            numbers: (0, _metal.tracked)({
              initializer: function () {
                return (0, _runtime.A)([1, 2, 3]);
              }
            }),
            addNumber: function () {
              this.numbers.pushObject(4);
            }
          });

          this.registerComponent('num-list', {
            ComponentClass: NumListComponent,
            template: (0, _internalTestHelpers.strip)(_templateObject3())
          });
          this.registerHelper('join', function (_ref4) {
            var value = _ref4[0];
            return value.join(', ');
          });
          this.render('<NumList />');
          this.assertText('1, 2, 3');
          (0, _internalTestHelpers.runTask)(function () {
            return _this4.$('button').click();
          });
          this.assertText('1, 2, 3, 4');
        };

        _proto['@test nested getters update when dependent properties are invalidated'] = function testNestedGettersUpdateWhenDependentPropertiesAreInvalidated(assert) {
          var _this5 = this;

          var computeCount = 0;

          var Person = _runtime.Object.extend({
            first: (0, _metal.tracked)({
              value: 'Rob'
            }),
            last: (0, _metal.tracked)({
              value: 'Jackson'
            }),
            full: (0, _metal.nativeDescDecorator)({
              get: function () {
                return this.first + " " + this.last;
              }
            })
          });

          this.registerHelper('hello-world', function (_ref5) {
            var value = _ref5[0];
            computeCount++;
            return value;
          });
          this.render('{{hello-world model.full}}', {
            model: Person.create()
          });
          this.assertText('Rob Jackson');
          assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
          (0, _internalTestHelpers.runTask)(function () {
            return _this5.rerender();
          });
          this.assertText('Rob Jackson');
          assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');
          (0, _internalTestHelpers.runTask)(function () {
            _this5.context.model.first = 'Kris';
            _this5.context.model.last = 'Selden';
          });
          this.assertText('Kris Selden');
          assert.strictEqual(computeCount, 2, 'compute is called exactly 2 times');
        };

        return _class;
      }(_internalTestHelpers.RenderingTestCase));
    }
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/unbound-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/runtime", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _runtime, _helpers) {
  "use strict";

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#if (unbound model.foo)}}\n        {{#if model.bar}}true{{/if}}\n        {{#unless model.bar}}false{{/unless}}\n      {{/if}}\n      {{#unless (unbound model.notfoo)}}\n        {{#if model.bar}}true{{/if}}\n        {{#unless model.bar}}false{{/unless}}\n      {{/unless}}"]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n      {{unbound (surround model.prefix model.value \"bar\")}} {{surround model.prefix model.value \"bar\"}} {{unbound (surround \"bar\" model.value model.suffix)}} {{surround \"bar\" model.value model.suffix}}"]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        <li>\n          <a href=\"unsafe:javascript:bob-is-cool\">Bob</a>\n        </li>\n        <li>\n          <a href=\"unsafe:vbscript:james-is-cool\">James</a>\n        </li>\n        <li>\n          <a href=\"unsafe:javascript:richard-is-cool\">Richard</a>\n        </li>\n      </ul>\n    "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{unbound}}',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test should be able to output a property without binding'] = function testShouldBeAbleToOutputAPropertyWithoutBinding() {
      var _this = this;

      this.render("<div id=\"first\">{{unbound content.anUnboundString}}</div>", {
        content: {
          anUnboundString: 'No spans here, son.'
        }
      });
      this.assertText('No spans here, son.');
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertText('No spans here, son.');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'content.anUnboundString', 'HEY');
      });
      this.assertText('No spans here, son.');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'content', {
          anUnboundString: 'No spans here, son.'
        });
      });
      this.assertText('No spans here, son.');
    };

    _proto['@test should be able to use unbound helper in #each helper'] = function testShouldBeAbleToUseUnboundHelperInEachHelper() {
      var _this2 = this;

      this.render("<ul>{{#each items as |item|}}<li>{{unbound item}}</li>{{/each}}</ul>", {
        items: (0, _runtime.A)(['a', 'b', 'c', 1, 2, 3])
      });
      this.assertText('abc123');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertText('abc123');
    };

    _proto['@test should be able to use unbound helper in #each helper (with objects)'] = function testShouldBeAbleToUseUnboundHelperInEachHelperWithObjects() {
      var _this3 = this;

      this.render("<ul>{{#each items as |item|}}<li>{{unbound item.wham}}</li>{{/each}}</ul>", {
        items: (0, _runtime.A)([{
          wham: 'bam'
        }, {
          wham: 1
        }])
      });
      this.assertText('bam1');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assertText('bam1');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.context.items.setEach('wham', 'HEY');
      });
      this.assertText('bam1');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'items', (0, _runtime.A)([{
          wham: 'bam'
        }, {
          wham: 1
        }]));
      });
      this.assertText('bam1');
    };

    _proto['@test it should assert unbound cannot be called with multiple arguments'] = function testItShouldAssertUnboundCannotBeCalledWithMultipleArguments() {
      var _this4 = this;

      var willThrow = function () {
        _this4.render("{{unbound foo bar}}", {
          foo: 'BORK',
          bar: 'BLOOP'
        });
      };

      expectAssertion(willThrow, /unbound helper cannot be called with multiple params or hash params/);
    };

    _proto['@test should render on attributes'] = function testShouldRenderOnAttributes() {
      var _this5 = this;

      this.render("<a href=\"{{unbound model.foo}}\"></a>", {
        model: {
          foo: 'BORK'
        }
      });
      this.assertHTML('<a href="BORK"></a>');
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.rerender();
      });
      this.assertHTML('<a href="BORK"></a>');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'model.foo', 'OOF');
      });
      this.assertHTML('<a href="BORK"></a>');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'model', {
          foo: 'BORK'
        });
      });
      this.assertHTML('<a href="BORK"></a>');
    };

    _proto['@test should property escape unsafe hrefs'] = function testShouldPropertyEscapeUnsafeHrefs() {
      var _this6 = this;

      var unsafeUrls = (0, _runtime.A)([{
        name: 'Bob',
        url: 'javascript:bob-is-cool'
      }, {
        name: 'James',
        url: 'vbscript:james-is-cool'
      }, {
        name: 'Richard',
        url: 'javascript:richard-is-cool'
      }]);
      this.render("<ul>{{#each people as |person|}}<li><a href=\"{{unbound person.url}}\">{{person.name}}</a></li>{{/each}}</ul>", {
        people: unsafeUrls
      });
      var escapedHtml = (0, _internalTestHelpers.strip)(_templateObject());
      this.assertHTML(escapedHtml);
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.rerender();
      });
      this.assertHTML(escapedHtml);
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.context.people.setEach('url', 'http://google.com');
      });
      this.assertHTML(escapedHtml);
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'people', unsafeUrls);
      });
      this.assertHTML(escapedHtml);
    };

    _proto['@skip helper form updates on parent re-render'] = function skipHelperFormUpdatesOnParentReRender() {
      var _this7 = this;

      this.render("{{unbound foo}}", {
        foo: 'BORK'
      });
      this.assertText('BORK');
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.rerender();
      });
      this.assertText('BORK');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'foo', 'OOF');
      });
      this.assertText('BORK');
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.rerender();
      });
      this.assertText('OOF');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'foo', '');
      });
      this.assertText('OOF');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'foo', 'BORK');
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.rerender();
      });
      this.assertText('BORK');
    } // semantics here is not guaranteed
    ;

    _proto['@test sexpr form does not update no matter what'] = function testSexprFormDoesNotUpdateNoMatterWhat() {
      var _this8 = this;

      this.registerHelper('capitalize', function (args) {
        return args[0].toUpperCase();
      });
      this.render("{{capitalize (unbound foo)}}", {
        foo: 'bork'
      });
      this.assertText('BORK');
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.rerender();
      });
      this.assertText('BORK');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this8.context, 'foo', 'oof');

        _this8.rerender();
      });
      this.assertText('BORK');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this8.context, 'foo', 'blip');
      });
      this.assertText('BORK');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this8.context, 'foo', 'bork');

        _this8.rerender();
      });
      this.assertText('BORK');
    };

    _proto['@test sexpr in helper form does not update on parent re-render'] = function testSexprInHelperFormDoesNotUpdateOnParentReRender() {
      var _this9 = this;

      this.registerHelper('capitalize', function (params) {
        return params[0].toUpperCase();
      });
      this.registerHelper('doublize', function (params) {
        return params[0] + " " + params[0];
      });
      this.render("{{capitalize (unbound (doublize foo))}}", {
        foo: 'bork'
      });
      this.assertText('BORK BORK');
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.rerender();
      });
      this.assertText('BORK BORK');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this9.context, 'foo', 'oof');

        _this9.rerender();
      });
      this.assertText('BORK BORK');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this9.context, 'foo', 'blip');
      });
      this.assertText('BORK BORK');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this9.context, 'foo', 'bork');

        _this9.rerender();
      });
      this.assertText('BORK BORK');
    };

    _proto['@test should be able to render an unbound helper invocation'] = function testShouldBeAbleToRenderAnUnboundHelperInvocation() {
      var _this10 = this;

      this.registerHelper('repeat', function (_ref, _ref2) {
        var value = _ref[0];
        var count = _ref2.count;
        var a = [];

        while (a.length < count) {
          a.push(value);
        }

        return a.join('');
      });
      this.render("{{unbound (repeat foo count=bar)}} {{repeat foo count=bar}} {{unbound (repeat foo count=2)}} {{repeat foo count=4}}", {
        foo: 'X',
        bar: 5
      });
      this.assertText('XXXXX XXXXX XX XXXX');
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.rerender();
      });
      this.assertText('XXXXX XXXXX XX XXXX');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'bar', 1);
      });
      this.assertText('XXXXX X XX XXXX');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'bar', 5);
      });
      this.assertText('XXXXX XXXXX XX XXXX');
    };

    _proto['@test should be able to render an bound helper invocation mixed with static values'] = function testShouldBeAbleToRenderAnBoundHelperInvocationMixedWithStaticValues() {
      var _this11 = this;

      this.registerHelper('surround', function (_ref3) {
        var prefix = _ref3[0],
            value = _ref3[1],
            suffix = _ref3[2];
        return prefix + "-" + value + "-" + suffix;
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject2()), {
        model: {
          prefix: 'before',
          value: 'core',
          suffix: 'after'
        }
      });
      this.assertText('before-core-bar before-core-bar bar-core-after bar-core-after');
      (0, _internalTestHelpers.runTask)(function () {
        return _this11.rerender();
      });
      this.assertText('before-core-bar before-core-bar bar-core-after bar-core-after');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.setProperties)(_this11.context.model, {
          prefix: 'beforeChanged',
          value: 'coreChanged',
          suffix: 'afterChanged'
        });
      });
      this.assertText('before-core-bar beforeChanged-coreChanged-bar bar-core-after bar-coreChanged-afterChanged');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this11.context, 'model', {
          prefix: 'before',
          value: 'core',
          suffix: 'after'
        });
      });
      this.assertText('before-core-bar before-core-bar bar-core-after bar-core-after');
    };

    _proto['@test should be able to render unbound forms of multi-arg helpers'] = function testShouldBeAbleToRenderUnboundFormsOfMultiArgHelpers() {
      var _this12 = this;

      this.registerHelper('fauxconcat', function (params) {
        return params.join('');
      });
      this.render("{{fauxconcat model.foo model.bar model.bing}} {{unbound (fauxconcat model.foo model.bar model.bing)}}", {
        model: {
          foo: 'a',
          bar: 'b',
          bing: 'c'
        }
      });
      this.assertText('abc abc');
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.rerender();
      });
      this.assertText('abc abc');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'model.bar', 'X');
      });
      this.assertText('aXc abc');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'model', {
          foo: 'a',
          bar: 'b',
          bing: 'c'
        });
      });
      this.assertText('abc abc');
    };

    _proto['@test should be able to render an unbound helper invocation for helpers with dependent keys'] =
    /*#__PURE__*/
    function () {
      var _testShouldBeAbleToRenderAnUnboundHelperInvocationForHelpersWithDependentKeys = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var _this13;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _this13 = this;
              this.registerHelper('capitalizeName', {
                destroy: function () {
                  this.removeObserver('value.firstName', this, this.recompute);

                  this._super.apply(this, arguments);
                },
                compute: function (_ref4) {
                  var value = _ref4[0];

                  if (this.get('value')) {
                    this.removeObserver('value.firstName', this, this.recompute);
                  }

                  this.set('value', value);
                  this.addObserver('value.firstName', this, this.recompute);
                  return value ? (0, _metal.get)(value, 'firstName').toUpperCase() : '';
                }
              });
              this.registerHelper('concatNames', {
                destroy: function () {
                  this.teardown();

                  this._super.apply(this, arguments);
                },
                teardown: function () {
                  this.removeObserver('value.firstName', this, this.recompute);
                  this.removeObserver('value.lastName', this, this.recompute);
                },
                compute: function (_ref5) {
                  var value = _ref5[0];

                  if (this.get('value')) {
                    this.teardown();
                  }

                  this.set('value', value);
                  this.addObserver('value.firstName', this, this.recompute);
                  this.addObserver('value.lastName', this, this.recompute);
                  return (value ? (0, _metal.get)(value, 'firstName') : '') + (value ? (0, _metal.get)(value, 'lastName') : '');
                }
              });
              this.render("{{capitalizeName person}} {{unbound (capitalizeName person)}} {{concatNames person}} {{unbound (concatNames person)}}", {
                person: {
                  firstName: 'shooby',
                  lastName: 'taylor'
                }
              });
              this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');
              (0, _internalTestHelpers.runTask)(function () {
                return _this13.rerender();
              });
              _context.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');
              (0, _internalTestHelpers.runTask)(function () {
                return (0, _metal.set)(_this13.context, 'person.firstName', 'sally');
              });
              _context.next = 12;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 12:
              this.assertText('SALLY SHOOBY sallytaylor shoobytaylor');
              (0, _internalTestHelpers.runTask)(function () {
                return (0, _metal.set)(_this13.context, 'person', {
                  firstName: 'shooby',
                  lastName: 'taylor'
                });
              });
              _context.next = 16;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 16:
              this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');

            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testShouldBeAbleToRenderAnUnboundHelperInvocationForHelpersWithDependentKeys() {
        return _testShouldBeAbleToRenderAnUnboundHelperInvocationForHelpersWithDependentKeys.apply(this, arguments);
      }

      return testShouldBeAbleToRenderAnUnboundHelperInvocationForHelpersWithDependentKeys;
    }();

    _proto['@test should be able to render an unbound helper invocation in #each helper'] = function testShouldBeAbleToRenderAnUnboundHelperInvocationInEachHelper() {
      var _this14 = this;

      this.registerHelper('capitalize', function (params) {
        return params[0].toUpperCase();
      });
      this.render("{{#each people as |person|}}{{capitalize person.firstName}} {{unbound (capitalize person.firstName)}}{{/each}}", {
        people: (0, _runtime.A)([{
          firstName: 'shooby',
          lastName: 'taylor'
        }, {
          firstName: 'cindy',
          lastName: 'taylor'
        }])
      });
      this.assertText('SHOOBY SHOOBYCINDY CINDY');
      (0, _internalTestHelpers.runTask)(function () {
        return _this14.rerender();
      });
      this.assertText('SHOOBY SHOOBYCINDY CINDY');
      (0, _internalTestHelpers.runTask)(function () {
        return _this14.context.people.setEach('firstName', 'chad');
      });
      this.assertText('CHAD SHOOBYCHAD CINDY');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this14.context, 'people', (0, _runtime.A)([{
          firstName: 'shooby',
          lastName: 'taylor'
        }, {
          firstName: 'cindy',
          lastName: 'taylor'
        }]));
      });
      this.assertText('SHOOBY SHOOBYCINDY CINDY');
    };

    _proto['@test should be able to render an unbound helper invocation with bound hash options'] =
    /*#__PURE__*/
    function () {
      var _testShouldBeAbleToRenderAnUnboundHelperInvocationWithBoundHashOptions = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var _this15;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _this15 = this;
              this.registerHelper('capitalizeName', {
                destroy: function () {
                  this.removeObserver('value.firstName', this, this.recompute);

                  this._super.apply(this, arguments);
                },
                compute: function (_ref6) {
                  var value = _ref6[0];

                  if (this.get('value')) {
                    this.removeObserver('value.firstName', this, this.recompute);
                  }

                  this.set('value', value);
                  this.addObserver('value.firstName', this, this.recompute);
                  return value ? (0, _metal.get)(value, 'firstName').toUpperCase() : '';
                }
              });
              this.registerHelper('concatNames', {
                destroy: function () {
                  this.teardown();

                  this._super.apply(this, arguments);
                },
                teardown: function () {
                  this.removeObserver('value.firstName', this, this.recompute);
                  this.removeObserver('value.lastName', this, this.recompute);
                },
                compute: function (_ref7) {
                  var value = _ref7[0];

                  if (this.get('value')) {
                    this.teardown();
                  }

                  this.set('value', value);
                  this.addObserver('value.firstName', this, this.recompute);
                  this.addObserver('value.lastName', this, this.recompute);
                  return (value ? (0, _metal.get)(value, 'firstName') : '') + (value ? (0, _metal.get)(value, 'lastName') : '');
                }
              });
              this.render("{{capitalizeName person}} {{unbound (capitalizeName person)}} {{concatNames person}} {{unbound (concatNames person)}}", {
                person: {
                  firstName: 'shooby',
                  lastName: 'taylor'
                }
              });
              _context2.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');
              (0, _internalTestHelpers.runTask)(function () {
                return _this15.rerender();
              });
              _context2.next = 10;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 10:
              this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');
              (0, _internalTestHelpers.runTask)(function () {
                return (0, _metal.set)(_this15.context, 'person.firstName', 'sally');
              });
              _context2.next = 14;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 14:
              this.assertText('SALLY SHOOBY sallytaylor shoobytaylor');
              (0, _internalTestHelpers.runTask)(function () {
                return (0, _metal.set)(_this15.context, 'person', {
                  firstName: 'shooby',
                  lastName: 'taylor'
                });
              });
              this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');

            case 17:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testShouldBeAbleToRenderAnUnboundHelperInvocationWithBoundHashOptions() {
        return _testShouldBeAbleToRenderAnUnboundHelperInvocationWithBoundHashOptions.apply(this, arguments);
      }

      return testShouldBeAbleToRenderAnUnboundHelperInvocationWithBoundHashOptions;
    }();

    _proto['@test should be able to render bound form of a helper inside unbound form of same helper'] = function testShouldBeAbleToRenderBoundFormOfAHelperInsideUnboundFormOfSameHelper() {
      var _this16 = this;

      this.render((0, _internalTestHelpers.strip)(_templateObject3()), {
        model: {
          foo: true,
          notfoo: false,
          bar: true
        }
      });
      this.assertText('truetrue');
      (0, _internalTestHelpers.runTask)(function () {
        return _this16.rerender();
      });
      this.assertText('truetrue');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this16.context, 'model.bar', false);
      });
      this.assertText('falsefalse');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this16.context, 'model', {
          foo: true,
          notfoo: false,
          bar: true
        });
      });
      this.assertText('truetrue');
    };

    _proto['@test yielding unbound does not update'] = function testYieldingUnboundDoesNotUpdate() {
      var _this17 = this;

      var fooBarInstance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          fooBarInstance = this;
        },
        model: {
          foo: 'bork'
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{yield (unbound model.foo)}}"
      });
      this.render("{{#foo-bar as |value|}}{{value}}{{/foo-bar}}");
      this.assertText('bork');
      (0, _internalTestHelpers.runTask)(function () {
        return _this17.rerender();
      });
      this.assertText('bork');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(fooBarInstance, 'model.foo', 'oof');
      });
      this.assertText('bork');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(fooBarInstance, 'model', {
          foo: 'bork'
        });
      });
      this.assertText('bork');
    };

    _proto['@test yielding unbound hash does not update'] = function testYieldingUnboundHashDoesNotUpdate() {
      var _this18 = this;

      var fooBarInstance;

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          fooBarInstance = this;
        },
        model: {
          foo: 'bork'
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: "{{yield (unbound (hash foo=model.foo))}}"
      });
      this.render("{{#foo-bar as |value|}}{{value.foo}}{{/foo-bar}}");
      this.assertText('bork');
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.rerender();
      });
      this.assertText('bork');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(fooBarInstance, 'model.foo', 'oof');
      });
      this.assertText('bork');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(fooBarInstance, 'model', {
          foo: 'bork'
        });
      });
      this.assertText('bork');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/helpers/yield-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Helpers test: {{yield}} helper',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test can yield to block'] = function testCanYieldToBlock() {
      var _this = this;

      this.registerComponent('yield-comp', {
        template: '[In layout:] {{yield}}'
      });
      this.render('{{#yield-comp}}[In Block:] {{object.title}}{{/yield-comp}}', {
        object: {
          title: 'Seattle'
        }
      });
      this.assertText('[In layout:] [In Block:] Seattle');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'object.title', 'Vancouver');
      });
      this.assertText('[In layout:] [In Block:] Vancouver');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'object', {
          title: 'Seattle'
        });
      });
      this.assertText('[In layout:] [In Block:] Seattle');
    };

    _proto['@test templates should yield to block inside a nested component'] = function testTemplatesShouldYieldToBlockInsideANestedComponent() {
      var _this2 = this;

      this.registerComponent('outer-comp', {
        template: '<div>[In layout:] {{yield}}</div>'
      });
      this.registerComponent('inner-comp', {
        template: '{{#outer-comp}}[In Block:] {{object.title}}{{/outer-comp}}'
      });
      this.render('{{inner-comp object=object}}', {
        object: {
          title: 'Seattle'
        }
      });
      this.assertText('[In layout:] [In Block:] Seattle');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'object.title', 'Vancouver');
      });
      this.assertText('[In layout:] [In Block:] Vancouver');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'object', {
          title: 'Seattle'
        });
      });
      this.assertText('[In layout:] [In Block:] Seattle');
    };

    _proto['@test templates should yield to block, when the yield is embedded in a each helper'] = function testTemplatesShouldYieldToBlockWhenTheYieldIsEmbeddedInAEachHelper() {
      var _this3 = this;

      var list = [1, 2, 3];
      this.registerComponent('outer-comp', {
        template: '{{#each list as |item|}}{{yield}}{{/each}}'
      });
      this.render('{{#outer-comp list=list}}Hello{{/outer-comp}}', {
        list: list
      });
      this.assertText('HelloHelloHello');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'list', [4, 5]);
      });
      this.assertText('HelloHello');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'list', list);
      });
      this.assertText('HelloHelloHello');
    };

    _proto['@test templates should yield to block, when the yield is embedded in a if helper'] = function testTemplatesShouldYieldToBlockWhenTheYieldIsEmbeddedInAIfHelper() {
      var _this4 = this;

      this.registerComponent('outer-comp', {
        template: '{{#if boolean}}{{yield}}{{/if}}'
      });
      this.render('{{#outer-comp boolean=boolean}}Hello{{/outer-comp}}', {
        boolean: true
      });
      this.assertText('Hello');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'boolean', false);
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'boolean', true);
      });
      this.assertText('Hello');
    };

    _proto['@test simple curlies inside of a yielded clock should work when the yield is nested inside of another view'] = function testSimpleCurliesInsideOfAYieldedClockShouldWorkWhenTheYieldIsNestedInsideOfAnotherView() {
      var _this5 = this;

      this.registerComponent('kiwi-comp', {
        template: '{{#if falsy}}{{else}}{{yield}}{{/if}}'
      });
      this.render('{{#kiwi-comp}}{{text}}{{/kiwi-comp}}', {
        text: 'ohai'
      });
      this.assertText('ohai');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'text', 'portland');
      });
      this.assertText('portland');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'text', 'ohai');
      });
      this.assertText('ohai');
    };

    _proto['@test nested simple curlies inside of a yielded block should work when the yield is nested inside of another view'] = function testNestedSimpleCurliesInsideOfAYieldedBlockShouldWorkWhenTheYieldIsNestedInsideOfAnotherView() {
      var _this6 = this;

      this.registerComponent('parent-comp', {
        template: '{{#if falsy}}{{else}}{{yield}}{{/if}}'
      });
      this.registerComponent('child-comp', {
        template: '{{#if falsy}}{{else}}{{text}}{{/if}}'
      });
      this.render('{{#parent-comp}}{{child-comp text=text}}{{/parent-comp}}', {
        text: 'ohai'
      });
      this.assertText('ohai');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'text', 'portland');
      });
      this.assertText('portland');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'text', 'ohai');
      });
      this.assertText('ohai');
    };

    _proto['@test yielding to a non-existent block is not an error'] = function testYieldingToANonExistentBlockIsNotAnError() {
      var _this7 = this;

      this.registerComponent('yielding-comp', {
        template: 'Hello:{{yield}}'
      });
      this.registerComponent('outer-comp', {
        template: '{{yielding-comp}} {{title}}'
      });
      this.render('{{outer-comp title=title}}', {
        title: 'Mr. Selden'
      });
      this.assertText('Hello: Mr. Selden');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'title', 'Mr. Chag');
      });
      this.assertText('Hello: Mr. Chag');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'title', 'Mr. Selden');
      });
      this.assertText('Hello: Mr. Selden');
    };

    _proto['@test yield uses the original context'] = function testYieldUsesTheOriginalContext() {
      var _this8 = this;

      var KiwiCompComponent = _helpers.Component.extend({
        boundText: 'Inner'
      });

      this.registerComponent('kiwi-comp', {
        ComponentClass: KiwiCompComponent,
        template: '<p>{{boundText}}</p><p>{{yield}}</p>'
      });
      this.render('{{#kiwi-comp}}{{boundText}}{{/kiwi-comp}}', {
        boundText: 'Original'
      });
      this.assertText('InnerOriginal');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this8.context, 'boundText', 'Otherworld');
      });
      this.assertText('InnerOtherworld');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this8.context, 'boundText', 'Original');
      });
      this.assertText('InnerOriginal');
    };

    _proto["@test outer block param doesn't mask inner component property"] = function testOuterBlockParamDoesnTMaskInnerComponentProperty() {
      var _this9 = this;

      var KiwiCompComponent = _helpers.Component.extend({
        boundText: 'Inner'
      });

      this.registerComponent('kiwi-comp', {
        ComponentClass: KiwiCompComponent,
        template: '<p>{{boundText}}</p><p>{{yield}}</p>'
      });
      this.render('{{#with boundText as |item|}}{{#kiwi-comp}}{{item}}{{/kiwi-comp}}{{/with}}', {
        boundText: 'Outer'
      });
      this.assertText('InnerOuter');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this9.context, 'boundText', 'Otherworld');
      });
      this.assertText('InnerOtherworld');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this9.context, 'boundText', 'Outer');
      });
      this.assertText('InnerOuter');
    };

    _proto["@test inner block param doesn't mask yield property"] = function testInnerBlockParamDoesnTMaskYieldProperty() {
      var _this10 = this;

      var KiwiCompComponent = _helpers.Component.extend({
        boundText: 'Inner'
      });

      this.registerComponent('kiwi-comp', {
        ComponentClass: KiwiCompComponent,
        template: '{{#with boundText as |item|}}<p>{{item}}</p><p>{{yield}}</p>{{/with}}'
      });
      this.render('{{#kiwi-comp}}{{item}}{{/kiwi-comp}}', {
        item: 'Outer'
      });
      this.assertText('InnerOuter');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'item', 'Otherworld');
      });
      this.assertText('InnerOtherworld');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this10.context, 'item', 'Outer');
      });
      this.assertText('InnerOuter');
    };

    _proto['@test can bind a block param to a component and use it in yield'] = function testCanBindABlockParamToAComponentAndUseItInYield() {
      var _this11 = this;

      this.registerComponent('kiwi-comp', {
        template: '<p>{{content}}</p><p>{{yield}}</p>'
      });
      this.render('{{#with boundText as |item|}}{{#kiwi-comp content=item}}{{item}}{{/kiwi-comp}}{{/with}}', {
        boundText: 'Outer'
      });
      this.assertText('OuterOuter');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'boundText', 'Update');
      });
      this.assertText('UpdateUpdate');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'boundText', 'Outer');
      });
      this.assertText('OuterOuter');
    } // INUR not need with no data update
    ;

    _proto['@test yield should not introduce a view'] = function testYieldShouldNotIntroduceAView(assert) {
      var ParentCompComponent = _helpers.Component.extend({
        isParentComponent: true
      });

      var ChildCompComponent = _helpers.Component.extend({
        didReceiveAttrs: function () {
          this._super();

          var parentView = this.get('parentView');
          assert.ok(parentView.get('isParentComponent'));
        }
      });

      this.registerComponent('parent-comp', {
        ComponentClass: ParentCompComponent,
        template: '{{yield}}'
      });
      this.registerComponent('child-comp', {
        ComponentClass: ChildCompComponent
      });
      this.render('{{#parent-comp}}{{child-comp}}{{/parent-comp}}');
    };

    _proto['@test yield with nested components (#3220)'] = function testYieldWithNestedComponents3220() {
      var _this12 = this;

      this.registerComponent('inner-component', {
        template: '{{yield}}'
      });
      this.registerComponent('outer-component', {
        template: '{{#inner-component}}<span>{{yield}}</span>{{/inner-component}}'
      });
      this.render('{{#outer-component}}Hello {{boundText}}{{/outer-component}}', {
        boundText: 'world'
      });
      this.assertText('Hello world');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'boundText', 'update');
      });
      this.assertText('Hello update');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'boundText', 'world');
      });
      this.assertText('Hello world');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/input-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _metal) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Input element tests',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.runAttributeTest = function runAttributeTest(attributeName, values) {
      var _this = this;

      var template = "<input " + attributeName + "={{value}}>";
      this.render(template, {
        value: values[0]
      });
      this.assertAttributeHasValue(attributeName, values[0], attributeName + " is set on initial render");
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertAttributeHasValue(attributeName, values[0], attributeName + " is set on noop rerender");
      this.setComponentValue(values[1]);
      this.assertAttributeHasValue(attributeName, values[1], attributeName + " is set on rerender");
      this.setComponentValue(values[0]);
      this.assertAttributeHasValue(attributeName, values[0], attributeName + " can be set back to the initial value");
    };

    _proto.runPropertyTest = function runPropertyTest(propertyName, values) {
      var _this2 = this;

      var attributeName = propertyName;
      var template = "<input " + attributeName + "={{value}}>";
      this.render(template, {
        value: values[0]
      });
      this.assertPropertyHasValue(propertyName, values[0], propertyName + " is set on initial render");
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertPropertyHasValue(propertyName, values[0], propertyName + " is set on noop rerender");
      this.setComponentValue(values[1]);
      this.assertPropertyHasValue(propertyName, values[1], propertyName + " is set on rerender");
      this.setComponentValue(values[0]);
      this.assertPropertyHasValue(propertyName, values[0], propertyName + " can be set back to the initial value");
    };

    _proto.runFalsyValueProperty = function runFalsyValueProperty(values) {
      var _this3 = this;

      var value = 'value';
      var template = "<input value={{value}}>";
      this.render(template, {
        value: values[0]
      });
      this.assertPropertyHasValue(value, '', value + " is set on initial render");
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assertPropertyHasValue(value, '', value + " is set on noop rerender");
      this.setComponentValue(values[1]);
      this.assertPropertyHasValue(value, values[1], value + " is set on rerender");
      this.setComponentValue(values[0]);
      this.assertPropertyHasValue(value, '', value + " can be set back to the initial value");
    };

    _proto['@test input disabled attribute'] = function testInputDisabledAttribute() {
      var _this4 = this;

      var model = {
        model: {
          value: false
        }
      };
      this.render("<input disabled={{model.value}}>", model);
      this.assert.equal(this.$inputElement().prop('disabled'), false);
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      this.assert.equal(this.$inputElement().prop('disabled'), false);
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.context.set('model.value', true);
      });
      this.assert.equal(this.$inputElement().prop('disabled'), true);
      this.assertHTML('<input disabled="">'); // Note the DOM output is <input disabled>

      (0, _internalTestHelpers.runTask)(function () {
        return _this4.context.set('model.value', 'wat');
      });
      this.assert.equal(this.$inputElement().prop('disabled'), true);
      this.assertHTML('<input disabled="">'); // Note the DOM output is <input disabled>

      (0, _internalTestHelpers.runTask)(function () {
        return _this4.context.set('model', {
          value: false
        });
      });
      this.assert.equal(this.$inputElement().prop('disabled'), false);
      this.assertHTML('<input>');
    };

    _proto['@test input value attribute'] = function testInputValueAttribute() {
      this.runPropertyTest('value', ['foo', 'bar']);
    };

    _proto['@test input placeholder attribute'] = function testInputPlaceholderAttribute() {
      this.runAttributeTest('placeholder', ['foo', 'bar']);
    };

    _proto['@test input name attribute'] = function testInputNameAttribute() {
      this.runAttributeTest('name', ['nam', 'name']);
    };

    _proto['@test input maxlength attribute'] = function testInputMaxlengthAttribute() {
      this.runAttributeTest('maxlength', [2, 3]);
    };

    _proto['@test input size attribute'] = function testInputSizeAttribute() {
      this.runAttributeTest('size', [2, 3]);
    };

    _proto['@test input tabindex attribute'] = function testInputTabindexAttribute() {
      this.runAttributeTest('tabindex', [2, 3]);
    };

    _proto['@test null input value'] = function testNullInputValue() {
      this.runFalsyValueProperty([null, 'hello']);
    };

    _proto['@test undefined input value'] = function testUndefinedInputValue() {
      this.runFalsyValueProperty([undefined, 'hello']);
    };

    _proto['@test undefined `toString` method as input value'] = function testUndefinedToStringMethodAsInputValue() {
      this.runFalsyValueProperty([Object.create(null), 'hello']);
    };

    _proto['@test cursor position is not lost when updating content'] = function testCursorPositionIsNotLostWhenUpdatingContent() {
      var template = "<input value={{value}}>";
      this.render(template, {
        value: 'hola'
      });
      this.setDOMValue('hello');
      this.setSelectionRange(1, 3);
      this.setComponentValue('hello');
      this.assertSelectionRange(1, 3); // Note: We should eventually get around to testing reseting, however
      // browsers handle `selectionStart` and `selectionEnd` differently
      // when are synthetically testing movement of the cursor.
    };

    _proto['@test input can be updated multiple times'] = function testInputCanBeUpdatedMultipleTimes() {
      var template = "<input value={{value}}>";
      this.render(template, {
        value: 'hola'
      });
      this.assertValue('hola', 'Value is initialised');
      this.setComponentValue('');
      this.assertValue('', 'Value is set in the DOM');
      this.setDOMValue('hola');
      this.setComponentValue('hola');
      this.assertValue('hola', 'Value is updated the first time');
      this.setComponentValue('');
      this.assertValue('', 'Value is updated the second time');
    };

    _proto['@test DOM is SSOT if value is set'] = function testDOMIsSSOTIfValueIsSet() {
      var template = "<input value={{value}}>";
      this.render(template, {
        value: 'hola'
      });
      this.assertValue('hola', 'Value is initialised');
      this.setComponentValue('hello');
      this.assertValue('hello', 'Value is initialised');
      this.setDOMValue('hola');
      this.assertValue('hola', 'DOM is used');
      this.setComponentValue('bye');
      this.assertValue('bye', 'Value is used'); // Simulates setting the input to the same value as it already is which won't cause a rerender

      this.setDOMValue('hola');
      this.assertValue('hola', 'DOM is used');
      this.setComponentValue('hola');
      this.assertValue('hola', 'Value is used');
    } // private helpers and assertions
    ;

    _proto.setDOMValue = function setDOMValue(value) {
      this.inputElement().value = value;
    };

    _proto.setComponentValue = function setComponentValue(value) {
      var _this5 = this;

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'value', value);
      });
    };

    _proto.setSelectionRange = function setSelectionRange(start, end) {
      this.inputElement().selectionStart = start;
      this.inputElement().selectionEnd = end;
    };

    _proto.inputElement = function inputElement() {
      return this.$inputElement()[0];
    };

    _proto.$inputElement = function $inputElement() {
      return this.$('input');
    };

    _proto.assertValue = function assertValue(value, message) {
      this.assertPropertyHasValue('value', value, message);
    };

    _proto.assertAttributeHasValue = function assertAttributeHasValue(attribute, value, message) {
      this.assert.equal(this.$inputElement().attr(attribute), value, attribute + " " + message);
    };

    _proto.assertPropertyHasValue = function assertPropertyHasValue(property, value, message) {
      this.assert.equal(this.$inputElement().prop(property), value, property + " " + message);
    };

    _proto.assertSelectionRange = function assertSelectionRange(start, end) {
      this.assert.equal(this.inputElement().selectionStart, start);
      this.assert.equal(this.inputElement().selectionEnd, end);
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/modifiers/on-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/browser-environment", "@ember/-internals/container", "@ember/-internals/utils"], function (_emberBabel, _internalTestHelpers, _browserEnvironment, _container, _utils) {
  "use strict";

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["template-compiler:main"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  var isIE11 = !window.ActiveXObject && 'ActiveXObject' in window;

  if (true
  /* EMBER_GLIMMER_ON_MODIFIER */
  ) {
      (0, _internalTestHelpers.moduleFor)('{{on}} Modifier',
      /*#__PURE__*/
      function (_RenderingTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

        function _class() {
          return _RenderingTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto.beforeEach = function beforeEach() {
          // might error if getOnManagerInstance fails
          this.startingCounters = this.getOnManagerInstance().counters;
        };

        _proto.getOnManagerInstance = function getOnManagerInstance() {
          // leveraging private APIs, this can be deleted if these APIs change
          // but it has been useful to verify some internal details
          var templateCompiler = this.owner.lookup((0, _container.privatize)(_templateObject()));
          return templateCompiler.resolver.resolver.builtInModifiers.on.manager;
        };

        _proto.assertCounts = function assertCounts(expected) {
          var _this$getOnManagerIns = this.getOnManagerInstance(),
              counters = _this$getOnManagerIns.counters;

          this.assert.deepEqual(counters, {
            adds: expected.adds + this.startingCounters.adds,
            removes: expected.removes + this.startingCounters.removes
          }, "counters have incremented by " + JSON.stringify(expected));
        };

        _proto['@test SUPPORTS_EVENT_OPTIONS is correct (private API usage)'] = function testSUPPORTS_EVENT_OPTIONSIsCorrectPrivateAPIUsage(assert) {
          var manager = this.getOnManagerInstance();
          var SUPPORTS_EVENT_OPTIONS = manager.SUPPORTS_EVENT_OPTIONS;

          if (_browserEnvironment.isChrome || _browserEnvironment.isFirefox) {
            assert.strictEqual(SUPPORTS_EVENT_OPTIONS, true, 'is true in chrome and firefox');
          } else if (isIE11) {
            assert.strictEqual(SUPPORTS_EVENT_OPTIONS, false, 'is false in IE11');
          } else {
            assert.expect(0);
          }
        };

        _proto['@test it adds an event listener'] = function testItAddsAnEventListener(assert) {
          var _this = this;

          var count = 0;
          this.render('<button {{on "click" this.callback}}>Click Me</button>', {
            callback: function () {
              count++;
            }
          });
          assert.equal(count, 0, 'not called on initial render');
          this.assertStableRerender();
          this.assertCounts({
            adds: 1,
            removes: 0
          });
          assert.equal(count, 0, 'not called on a rerender');
          (0, _internalTestHelpers.runTask)(function () {
            return _this.$('button').click();
          });
          assert.equal(count, 1, 'has been called 1 time');
          (0, _internalTestHelpers.runTask)(function () {
            return _this.$('button').click();
          });
          assert.equal(count, 2, 'has been called 2 times');
          this.assertCounts({
            adds: 1,
            removes: 0
          });
        };

        _proto['@test passes the event to the listener'] = function testPassesTheEventToTheListener(assert) {
          var _this2 = this;

          var event;
          this.render('<button {{on "click" this.callback}}>Click Me</button>', {
            callback: function (evt) {
              event = evt;
            }
          });
          (0, _internalTestHelpers.runTask)(function () {
            return _this2.$('button').click();
          });
          assert.strictEqual(event.target, this.element.querySelector('button'), 'has a valid event with a target');
          this.assertCounts({
            adds: 1,
            removes: 0
          });
        };

        _proto['@test the listener callback is bound'] = function testTheListenerCallbackIsBound(assert) {
          var _this3 = this;

          var first = 0;
          var second = 0;

          var firstCallback = function () {
            return first++;
          };

          var secondCallback = function () {
            return second++;
          };

          this.render('<button {{on "click" this.callback}}>Click Me</button>', {
            callback: firstCallback
          });
          assert.equal(first, 0, 'precond - first not called on initial render');
          assert.equal(second, 0, 'precond - second not called on initial render');
          (0, _internalTestHelpers.runTask)(function () {
            return _this3.$('button').click();
          });
          assert.equal(first, 1, 'first has been called 1 time');
          assert.equal(second, 0, 'second not called on initial render');
          (0, _internalTestHelpers.runTask)(function () {
            return _this3.context.set('callback', secondCallback);
          });
          (0, _internalTestHelpers.runTask)(function () {
            return _this3.$('button').click();
          });
          assert.equal(first, 1, 'first has been called 1 time');
          assert.equal(second, 1, 'second has been called 1 times');
          this.assertCounts({
            adds: 2,
            removes: 1
          });
        };

        _proto['@test setting once named argument ensures the callback is only called once'] = function testSettingOnceNamedArgumentEnsuresTheCallbackIsOnlyCalledOnce(assert) {
          var _this4 = this;

          var count = 0;
          this.render('<button {{on "click" this.callback once=true}}>Click Me</button>', {
            callback: function () {
              count++;
            }
          });
          assert.equal(count, 0, 'not called on initial render');
          this.assertStableRerender();
          assert.equal(count, 0, 'not called on a rerender');
          (0, _internalTestHelpers.runTask)(function () {
            return _this4.$('button').click();
          });
          assert.equal(count, 1, 'has been called 1 time');
          (0, _internalTestHelpers.runTask)(function () {
            return _this4.$('button').click();
          });
          assert.equal(count, 1, 'has been called 1 times');

          if (isIE11) {
            this.assertCounts({
              adds: 1,
              removes: 1
            });
          } else {
            this.assertCounts({
              adds: 1,
              removes: 0
            });
          }
        };

        _proto['@test changing from `once=false` to `once=true` ensures the callback can only be called once'] = function testChangingFromOnceFalseToOnceTrueEnsuresTheCallbackCanOnlyBeCalledOnce(assert) {
          var _this5 = this;

          var count = 0;
          this.render('<button {{on "click" this.callback once=once}}>Click Me</button>', {
            callback: function () {
              count++;
            },
            once: false
          });
          (0, _internalTestHelpers.runTask)(function () {
            return _this5.$('button').click();
          });
          assert.equal(count, 1, 'has been called 1 time');
          (0, _internalTestHelpers.runTask)(function () {
            return _this5.$('button').click();
          });
          assert.equal(count, 2, 'has been called 2 times');
          (0, _internalTestHelpers.runTask)(function () {
            return _this5.context.set('once', true);
          });
          (0, _internalTestHelpers.runTask)(function () {
            return _this5.$('button').click();
          });
          assert.equal(count, 3, 'has been called 3 time');
          (0, _internalTestHelpers.runTask)(function () {
            return _this5.$('button').click();
          });
          assert.equal(count, 3, 'is not called again');

          if (isIE11) {
            this.assertCounts({
              adds: 2,
              removes: 2
            });
          } else {
            this.assertCounts({
              adds: 2,
              removes: 1
            });
          }
        };

        _proto['@test setting passive named argument prevents calling preventDefault'] = function testSettingPassiveNamedArgumentPreventsCallingPreventDefault() {
          var _this6 = this;

          var matcher = /You marked this listener as 'passive', meaning that you must not call 'event.preventDefault\(\)'/;
          this.render('<button {{on "click" this.callback passive=true}}>Click Me</button>', {
            callback: function (event) {
              expectAssertion(function () {
                event.preventDefault();
              }, matcher);
            }
          });
          (0, _internalTestHelpers.runTask)(function () {
            return _this6.$('button').click();
          });
        };

        _proto['@test by default bubbling is used (capture: false)'] = function testByDefaultBubblingIsUsedCaptureFalse(assert) {
          var _this7 = this;

          this.render("\n            <div class=\"outer\" {{on 'click' this.handleOuterClick}}>\n              <div class=\"inner\" {{on 'click' this.handleInnerClick}}></div>\n            </div>\n          ", {
            handleOuterClick: function () {
              assert.step('outer clicked');
            },
            handleInnerClick: function () {
              assert.step('inner clicked');
            }
          });
          (0, _internalTestHelpers.runTask)(function () {
            return _this7.$('.inner').click();
          });
          assert.verifySteps(['inner clicked', 'outer clicked'], 'uses capture: false by default');
        };

        _proto['@test specifying capture named argument uses capture semantics'] = function testSpecifyingCaptureNamedArgumentUsesCaptureSemantics(assert) {
          var _this8 = this;

          this.render("\n            <div class=\"outer\" {{on 'click' this.handleOuterClick capture=true}}>\n              <div class=\"inner\" {{on 'click' this.handleInnerClick}}></div>\n            </div>\n          ", {
            handleOuterClick: function () {
              assert.step('outer clicked');
            },
            handleInnerClick: function () {
              assert.step('inner clicked');
            }
          });
          (0, _internalTestHelpers.runTask)(function () {
            return _this8.$('.inner').click();
          });
          assert.verifySteps(['outer clicked', 'inner clicked'], 'capture works');
        };

        _proto['@test can use capture and once together'] = function testCanUseCaptureAndOnceTogether(assert) {
          var _this9 = this;

          this.render("\n            <div class=\"outer\" {{on 'click' this.handleOuterClick once=true capture=true}}>\n              <div class=\"inner\" {{on 'click' this.handleInnerClick}}></div>\n            </div>\n          ", {
            handleOuterClick: function () {
              assert.step('outer clicked');
            },
            handleInnerClick: function () {
              assert.step('inner clicked');
            }
          });
          (0, _internalTestHelpers.runTask)(function () {
            return _this9.$('.inner').click();
          });
          assert.verifySteps(['outer clicked', 'inner clicked'], 'capture works');
          (0, _internalTestHelpers.runTask)(function () {
            return _this9.$('.inner').click();
          });
          assert.verifySteps(['inner clicked'], 'once works');
        };

        _proto['@test unrelated updates to `this` context does not result in removing + re-adding'] = function testUnrelatedUpdatesToThisContextDoesNotResultInRemovingReAdding(assert) {
          var _this10 = this;

          var called = false;
          this.render('<button {{on "click" this.callback}}>Click Me</button>', {
            callback: function () {
              called = true;
            },
            otherThing: 0
          });
          this.assertCounts({
            adds: 1,
            removes: 0
          });
          (0, _internalTestHelpers.runTask)(function () {
            return _this10.$('button').click();
          });
          assert.equal(called, 1, 'callback is being invoked');
          (0, _internalTestHelpers.runTask)(function () {
            return _this10.context.set('otherThing', 1);
          });
          this.assertCounts({
            adds: 1,
            removes: 0
          });
        };

        _proto['@test asserts when eventName is missing'] = function testAssertsWhenEventNameIsMissing() {
          var _this11 = this;

          expectAssertion(function () {
            _this11.render("<button {{on undefined this.callback}}>Click Me</button>", {
              callback: function () {}
            });
          }, /You must pass a valid DOM event name as the first argument to the `on` modifier/);
        };

        _proto['@test asserts when eventName is a bound undefined value'] = function testAssertsWhenEventNameIsABoundUndefinedValue() {
          var _this12 = this;

          expectAssertion(function () {
            _this12.render("<button {{on this.someUndefinedThing this.callback}}>Click Me</button>", {
              callback: function () {}
            });
          }, /You must pass a valid DOM event name as the first argument to the `on` modifier/);
        };

        _proto['@test asserts when eventName is a function'] = function testAssertsWhenEventNameIsAFunction() {
          var _this13 = this;

          expectAssertion(function () {
            _this13.render("<button {{on this.callback}}>Click Me</button>", {
              callback: function () {}
            });
          }, /You must pass a valid DOM event name as the first argument to the `on` modifier/);
        };

        _proto['@test asserts when callback is missing'] = function testAssertsWhenCallbackIsMissing() {
          var _this14 = this;

          expectAssertion(function () {
            _this14.render("<button {{on 'click'}}>Click Me</button>");
          }, /You must pass a function as the second argument to the `on` modifier/);
        };

        _proto['@test asserts when callback is undefined'] = function testAssertsWhenCallbackIsUndefined() {
          var _this15 = this;

          expectAssertion(function () {
            _this15.render("<button {{on 'click' this.foo}}>Click Me</button>");
          }, /You must pass a function as the second argument to the `on` modifier/);
        };

        _proto['@test asserts when callback is null'] = function testAssertsWhenCallbackIsNull() {
          var _this16 = this;

          expectAssertion(function () {
            _this16.render("<button {{on 'click' this.foo}}>Click Me</button>", {
              foo: null
            });
          }, /You must pass a function as the second argument to the `on` modifier/);
        };

        _proto['@test asserts if the provided callback accesses `this` without being bound prior to passing to on'] = function testAssertsIfTheProvidedCallbackAccessesThisWithoutBeingBoundPriorToPassingToOn(assert) {
          var _this18 = this;

          this.render("<button {{on 'click' this.myFunc}}>Click Me</button>", {
            myFunc: function () {
              var _this17 = this;

              if (_utils.HAS_NATIVE_PROXY) {
                expectAssertion(function () {
                  _this17.arg1;
                }, /You accessed `this.arg1` from a function passed to the `on` modifier, but the function itself was not bound to a valid `this` context. Consider updating to usage of `@action`./);
              } else {
                // IE11
                assert.strictEqual(this, null, 'this is null on browsers without native proxy support');
              }
            },
            arg1: 'foo'
          });
          (0, _internalTestHelpers.runTask)(function () {
            return _this18.$('button').click();
          });
        };

        _proto['@test asserts if more than 2 positional parameters are provided'] = function testAssertsIfMoreThan2PositionalParametersAreProvided() {
          var _this19 = this;

          expectAssertion(function () {
            _this19.render("<button {{on 'click' this.callback this.someArg}}>Click Me</button>", {
              callback: function () {},
              someArg: 'foo'
            });
          }, /You can only pass two positional arguments \(event name and callback\) to the `on` modifier, but you provided 3. Consider using the `fn` helper to provide additional arguments to the `on` callback./);
        };

        _proto['@test it removes the modifier when the element is removed'] = function testItRemovesTheModifierWhenTheElementIsRemoved(assert) {
          var _this20 = this;

          var count = 0;
          this.render('{{#if this.showButton}}<button {{on "click" this.callback}}>Click Me</button>{{/if}}', {
            callback: function () {
              count++;
            },
            showButton: true
          });
          this.assertCounts({
            adds: 1,
            removes: 0
          });
          (0, _internalTestHelpers.runTask)(function () {
            return _this20.$('button').click();
          });
          assert.equal(count, 1, 'has been called 1 time');
          (0, _internalTestHelpers.runTask)(function () {
            return _this20.context.set('showButton', false);
          });
          this.assertCounts({
            adds: 1,
            removes: 1
          });
        };

        return _class;
      }(_internalTestHelpers.RenderingTestCase));
    }
});
enifed("@ember/-internals/glimmer/tests/integration/mount-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/owner", "@ember/-internals/glimmer/tests/utils/helpers", "@ember/controller", "@ember/-internals/metal", "@ember/engine"], function (_emberBabel, _internalTestHelpers, _owner, _helpers, _controller, _metal, _engine) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('{{mount}} single param assertion',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test it asserts that only a single param is passed'] = function testItAssertsThatOnlyASingleParamIsPassed() {
      var _this = this;

      expectAssertion(function () {
        _this.render('{{mount "chat" "foo"}}');
      }, /You can only pass a single positional argument to the {{mount}} helper, e.g. {{mount "chat-engine"}}./i);
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
  (0, _internalTestHelpers.moduleFor)('{{mount}} assertions',
  /*#__PURE__*/
  function (_RenderingTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _RenderingTestCase2);

    function _class2() {
      return _RenderingTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test it asserts when an invalid engine name is provided'] = function testItAssertsWhenAnInvalidEngineNameIsProvided() {
      var _this2 = this;

      expectAssertion(function () {
        _this2.render('{{mount engineName}}', {
          engineName: {}
        });
      }, /Invalid engine name '\[object Object\]' specified, engine name must be either a string, null or undefined./i);
    };

    _proto2['@test it asserts that the specified engine is registered'] = function testItAssertsThatTheSpecifiedEngineIsRegistered() {
      var _this3 = this;

      expectAssertion(function () {
        _this3.render('{{mount "chat"}}');
      }, /You used `{{mount 'chat'}}`, but the engine 'chat' can not be found./i);
    };

    return _class2;
  }(_internalTestHelpers.RenderingTestCase));
  (0, _internalTestHelpers.moduleFor)('{{mount}} test',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class3, _ApplicationTestCase);

    function _class3() {
      var _this4;

      _this4 = _ApplicationTestCase.apply(this, arguments) || this;
      var engineRegistrations = _this4.engineRegistrations = {};

      _this4.add('engine:chat', _engine.default.extend({
        router: null,
        init: function () {
          var _this5 = this;

          this._super.apply(this, arguments);

          Object.keys(engineRegistrations).forEach(function (fullName) {
            _this5.register(fullName, engineRegistrations[fullName]);
          });
        }
      }));

      _this4.addTemplate('index', '{{mount "chat"}}');

      return _this4;
    }

    var _proto3 = _class3.prototype;

    _proto3['@test it boots an engine, instantiates its application controller, and renders its application template'] = function testItBootsAnEngineInstantiatesItsApplicationControllerAndRendersItsApplicationTemplate(assert) {
      var _this6 = this;

      this.engineRegistrations['template:application'] = (0, _helpers.compile)('<h2>Chat here, {{username}}</h2>', {
        moduleName: 'my-app/templates/application.hbs'
      });
      var controller;
      this.engineRegistrations['controller:application'] = _controller.default.extend({
        username: 'dgeb',
        init: function () {
          this._super();

          controller = this;
        }
      });
      return this.visit('/').then(function () {
        assert.ok(controller, "engine's application controller has been instantiated");
        var engineInstance = (0, _owner.getOwner)(controller);
        assert.strictEqual((0, _engine.getEngineParent)(engineInstance), _this6.applicationInstance, 'engine instance has the application instance as its parent');

        _this6.assertInnerHTML('<h2>Chat here, dgeb</h2>');

        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(controller, 'username', 'chancancode');
        });

        _this6.assertInnerHTML('<h2>Chat here, chancancode</h2>');

        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(controller, 'username', 'dgeb');
        });

        _this6.assertInnerHTML('<h2>Chat here, dgeb</h2>');
      });
    };

    _proto3['@test it emits a useful backtracking re-render assertion message'] =
    /*#__PURE__*/
    function () {
      var _testItEmitsAUsefulBacktrackingReRenderAssertionMessage = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var _this7, expectedBacktrackingMessage;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _this7 = this;
              this.router.map(function () {
                this.route('route-with-mount');
              });
              this.addTemplate('index', '');
              this.addTemplate('route-with-mount', '{{mount "chat"}}');
              this.engineRegistrations['template:application'] = (0, _helpers.compile)('hi {{person.name}} [{{component-with-backtracking-set person=person}}]', {
                moduleName: 'my-app/templates/application.hbs'
              });
              this.engineRegistrations['controller:application'] = _controller.default.extend({
                person: {
                  name: 'Alex'
                }
              });
              this.engineRegistrations['template:components/component-with-backtracking-set'] = (0, _helpers.compile)('[component {{person.name}}]', {
                moduleName: 'my-app/templates/components/component-with-backtracking-set.hbs'
              });
              this.engineRegistrations['component:component-with-backtracking-set'] = _helpers.Component.extend({
                init: function () {
                  this._super.apply(this, arguments);

                  this.set('person.name', 'Ben');
                }
              });
              expectedBacktrackingMessage = /modified "person\.name" twice on \[object Object\] in a single render\. It was rendered in "template:my-app\/templates\/route-with-mount.hbs" \(in "engine:chat"\) and modified in "component:component-with-backtracking-set" \(in "engine:chat"\)/;
              _context.next = 11;
              return this.visit('/');

            case 11:
              assert.throwsAssertion(function () {
                return (0, _internalTestHelpers.runTask)(function () {
                  return _this7.visit('/route-with-mount');
                });
              }, expectedBacktrackingMessage);
              _context.next = 14;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 14:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testItEmitsAUsefulBacktrackingReRenderAssertionMessage(_x) {
        return _testItEmitsAUsefulBacktrackingReRenderAssertionMessage.apply(this, arguments);
      }

      return testItEmitsAUsefulBacktrackingReRenderAssertionMessage;
    }();

    _proto3['@test it renders with a bound engine name'] = function testItRendersWithABoundEngineName() {
      var _this8 = this;

      this.router.map(function () {
        this.route('bound-engine-name');
      });
      var controller;
      this.add('controller:bound-engine-name', _controller.default.extend({
        engineName: null,
        init: function () {
          this._super();

          controller = this;
        }
      }));
      this.addTemplate('bound-engine-name', '{{mount engineName}}');
      this.add('engine:foo', _engine.default.extend({
        router: null,
        init: function () {
          this._super.apply(this, arguments);

          this.register('template:application', (0, _helpers.compile)('<h2>Foo Engine</h2>', {
            moduleName: 'my-app/templates/application.hbs'
          }));
        }
      }));
      this.add('engine:bar', _engine.default.extend({
        router: null,
        init: function () {
          this._super.apply(this, arguments);

          this.register('template:application', (0, _helpers.compile)('<h2>Bar Engine</h2>', {
            moduleName: 'my-app/templates/application.hbs'
          }));
        }
      }));
      return this.visit('/bound-engine-name').then(function () {
        _this8.assertInnerHTML('<!---->');

        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(controller, 'engineName', 'foo');
        });

        _this8.assertInnerHTML('<h2>Foo Engine</h2>');

        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(controller, 'engineName', undefined);
        });

        _this8.assertInnerHTML('<!---->');

        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(controller, 'engineName', 'foo');
        });

        _this8.assertInnerHTML('<h2>Foo Engine</h2>');

        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(controller, 'engineName', 'bar');
        });

        _this8.assertInnerHTML('<h2>Bar Engine</h2>');

        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(controller, 'engineName', 'foo');
        });

        _this8.assertInnerHTML('<h2>Foo Engine</h2>');

        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(controller, 'engineName', null);
        });

        _this8.assertInnerHTML('<!---->');
      });
    };

    _proto3['@test it declares the event dispatcher as a singleton'] = function testItDeclaresTheEventDispatcherAsASingleton() {
      var _this9 = this;

      this.router.map(function () {
        this.route('engine-event-dispatcher-singleton');
      });
      var controller;
      var component;
      this.add('controller:engine-event-dispatcher-singleton', _controller.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          controller = this;
        }
      }));
      this.addTemplate('engine-event-dispatcher-singleton', '{{mount "foo"}}');
      this.add('engine:foo', _engine.default.extend({
        router: null,
        init: function () {
          this._super.apply(this, arguments);

          this.register('template:application', (0, _helpers.compile)('<h2>Foo Engine: {{tagless-component}}</h2>', {
            moduleName: 'my-app/templates/application.hbs'
          }));
          this.register('component:tagless-component', _helpers.Component.extend({
            tagName: '',
            init: function () {
              this._super.apply(this, arguments);

              component = this;
            }
          }));
          this.register('template:components/tagless-component', (0, _helpers.compile)('Tagless Component', {
            moduleName: 'my-app/templates/components/tagless-component.hbs'
          }));
        }
      }));
      return this.visit('/engine-event-dispatcher-singleton').then(function () {
        _this9.assertInnerHTML('<h2>Foo Engine: Tagless Component</h2>');

        var controllerOwnerEventDispatcher = (0, _owner.getOwner)(controller).lookup('event_dispatcher:main');
        var taglessComponentOwnerEventDispatcher = (0, _owner.getOwner)(component).lookup('event_dispatcher:main');

        _this9.assert.strictEqual(controllerOwnerEventDispatcher, taglessComponentOwnerEventDispatcher);
      });
    };

    return _class3;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('{{mount}} params tests',
  /*#__PURE__*/
  function (_ApplicationTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class4, _ApplicationTestCase2);

    function _class4() {
      var _this10;

      _this10 = _ApplicationTestCase2.apply(this, arguments) || this;

      _this10.add('engine:paramEngine', _engine.default.extend({
        router: null,
        init: function () {
          this._super.apply(this, arguments);

          this.register('template:application', (0, _helpers.compile)('<h2>Param Engine: {{model.foo}}</h2>', {
            moduleName: 'my-app/templates/application.hbs'
          }));
        }
      }));

      return _this10;
    }

    var _proto4 = _class4.prototype;

    _proto4['@test it renders with static parameters'] = function testItRendersWithStaticParameters() {
      var _this11 = this;

      this.router.map(function () {
        this.route('engine-params-static');
      });
      this.addTemplate('engine-params-static', '{{mount "paramEngine" model=(hash foo="bar")}}');
      return this.visit('/engine-params-static').then(function () {
        _this11.assertInnerHTML('<h2>Param Engine: bar</h2>');
      });
    };

    _proto4['@test it renders with bound parameters'] = function testItRendersWithBoundParameters() {
      var _this12 = this;

      this.router.map(function () {
        this.route('engine-params-bound');
      });
      var controller;
      this.add('controller:engine-params-bound', _controller.default.extend({
        boundParamValue: null,
        init: function () {
          this._super();

          controller = this;
        }
      }));
      this.addTemplate('engine-params-bound', '{{mount "paramEngine" model=(hash foo=boundParamValue)}}');
      return this.visit('/engine-params-bound').then(function () {
        _this12.assertInnerHTML('<h2>Param Engine: </h2>');

        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(controller, 'boundParamValue', 'bar');
        });

        _this12.assertInnerHTML('<h2>Param Engine: bar</h2>');

        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(controller, 'boundParamValue', undefined);
        });

        _this12.assertInnerHTML('<h2>Param Engine: </h2>');

        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(controller, 'boundParamValue', 'bar');
        });

        _this12.assertInnerHTML('<h2>Param Engine: bar</h2>');

        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(controller, 'boundParamValue', 'baz');
        });

        _this12.assertInnerHTML('<h2>Param Engine: baz</h2>');

        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(controller, 'boundParamValue', 'bar');
        });

        _this12.assertInnerHTML('<h2>Param Engine: bar</h2>');

        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(controller, 'boundParamValue', null);
        });

        _this12.assertInnerHTML('<h2>Param Engine: </h2>');
      });
    };

    _proto4['@test it renders contextual components passed as parameter values'] = function testItRendersContextualComponentsPassedAsParameterValues() {
      var _this13 = this;

      this.router.map(function () {
        this.route('engine-params-contextual-component');
      });
      this.addComponent('foo-component', {
        template: "foo-component rendered! - {{app-bar-component}}"
      });
      this.addComponent('app-bar-component', {
        ComponentClass: _helpers.Component.extend({
          tagName: ''
        }),
        template: 'rendered app-bar-component from the app'
      });
      this.add('engine:componentParamEngine', _engine.default.extend({
        router: null,
        init: function () {
          this._super.apply(this, arguments);

          this.register('template:application', (0, _helpers.compile)('{{model.foo}}', {
            moduleName: 'my-app/templates/application.hbs'
          }));
        }
      }));
      this.addTemplate('engine-params-contextual-component', '{{mount "componentParamEngine" model=(hash foo=(component "foo-component"))}}');
      return this.visit('/engine-params-contextual-component').then(function () {
        _this13.assertComponentElement(_this13.firstChild, {
          content: 'foo-component rendered! - rendered app-bar-component from the app'
        });
      });
    };

    return _class4;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/outlet-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _metal) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('outlet view',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      var _this;

      _this = _RenderingTestCase.apply(this, arguments) || this;

      var CoreOutlet = _this.owner.factoryFor('view:-outlet');

      _this.component = CoreOutlet.create();
      return _this;
    }

    var _proto = _class.prototype;

    _proto['@test should not error when initial rendered template is undefined'] = function testShouldNotErrorWhenInitialRenderedTemplateIsUndefined() {
      var _this2 = this;

      var outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: undefined,
          template: undefined
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.component.setOutletState(outletState);
      });
      (0, _internalTestHelpers.runAppend)(this.component);
      this.assertText('');
    };

    _proto['@test should render the outlet when set after DOM insertion'] = function testShouldRenderTheOutletWhenSetAfterDOMInsertion() {
      var _this3 = this;

      var outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: undefined,
          template: undefined
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.component.setOutletState(outletState);
      });
      (0, _internalTestHelpers.runAppend)(this.component);
      this.assertText('');
      this.registerTemplate('application', 'HI{{outlet}}');
      outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: {},
          template: this.owner.lookup('template:application')
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.component.setOutletState(outletState);
      });
      this.assertText('HI');
      this.assertStableRerender();
      this.registerTemplate('index', '<p>BYE</p>');
      outletState.outlets.main = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'index',
          controller: {},
          template: this.owner.lookup('template:index')
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.component.setOutletState(outletState);
      });
      this.assertText('HIBYE');
    };

    _proto['@test should render the outlet when set before DOM insertion'] = function testShouldRenderTheOutletWhenSetBeforeDOMInsertion() {
      var _this4 = this;

      this.registerTemplate('application', 'HI{{outlet}}');
      var outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: {},
          template: this.owner.lookup('template:application')
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.component.setOutletState(outletState);
      });
      (0, _internalTestHelpers.runAppend)(this.component);
      this.assertText('HI');
      this.assertStableRerender();
      this.registerTemplate('index', '<p>BYE</p>');
      outletState.outlets.main = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'index',
          controller: {},
          template: this.owner.lookup('template:index')
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.component.setOutletState(outletState);
      });
      this.assertText('HIBYE');
    };

    _proto['@test should support an optional name'] = function testShouldSupportAnOptionalName() {
      var _this5 = this;

      this.registerTemplate('application', '<h1>HI</h1>{{outlet "special"}}');
      var outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: {},
          template: this.owner.lookup('template:application')
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.component.setOutletState(outletState);
      });
      (0, _internalTestHelpers.runAppend)(this.component);
      this.assertText('HI');
      this.assertStableRerender();
      this.registerTemplate('special', '<p>BYE</p>');
      outletState.outlets.special = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'special',
          controller: {},
          template: this.owner.lookup('template:special')
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.component.setOutletState(outletState);
      });
      this.assertText('HIBYE');
    };

    _proto['@test does not default outlet name when positional argument is present'] = function testDoesNotDefaultOutletNameWhenPositionalArgumentIsPresent() {
      var _this6 = this;

      this.registerTemplate('application', '<h1>HI</h1>{{outlet someUndefinedThing}}');
      var outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: {},
          template: this.owner.lookup('template:application')
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.component.setOutletState(outletState);
      });
      (0, _internalTestHelpers.runAppend)(this.component);
      this.assertText('HI');
      this.assertStableRerender();
      this.registerTemplate('special', '<p>BYE</p>');
      outletState.outlets.main = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'special',
          controller: {},
          template: this.owner.lookup('template:special')
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.component.setOutletState(outletState);
      });
      this.assertText('HI');
    };

    _proto['@test should support bound outlet name'] = function testShouldSupportBoundOutletName() {
      var _this7 = this;

      var controller = {
        outletName: 'foo'
      };
      this.registerTemplate('application', '<h1>HI</h1>{{outlet outletName}}');
      var outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: controller,
          template: this.owner.lookup('template:application')
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.component.setOutletState(outletState);
      });
      (0, _internalTestHelpers.runAppend)(this.component);
      this.assertText('HI');
      this.assertStableRerender();
      this.registerTemplate('foo', '<p>FOO</p>');
      outletState.outlets.foo = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'foo',
          controller: {},
          template: this.owner.lookup('template:foo')
        },
        outlets: Object.create(null)
      };
      this.registerTemplate('bar', '<p>BAR</p>');
      outletState.outlets.bar = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'bar',
          controller: {},
          template: this.owner.lookup('template:bar')
        },
        outlets: Object.create(null)
      };
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.component.setOutletState(outletState);
      });
      this.assertText('HIFOO');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(controller, 'outletName', 'bar');
      });
      this.assertText('HIBAR');
    };

    _proto['@test outletState can pass through user code (liquid-fire initimate API) '] = function testOutletStateCanPassThroughUserCodeLiquidFireInitimateAPI() {
      var _this8 = this;

      this.registerTemplate('outer', 'A{{#-with-dynamic-vars outletState=(identity (-get-dynamic-var "outletState"))}}B{{outlet}}D{{/-with-dynamic-vars}}E');
      this.registerTemplate('inner', 'C'); // This looks like it doesn't do anything, but its presence
      // guarantees that the outletState gets converted from a reference
      // to a value and then back to a reference. That is what we're
      // testing here.

      this.registerHelper('identity', function (_ref) {
        var a = _ref[0];
        return a;
      });
      var outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'outer',
          controller: {},
          template: this.owner.lookup('template:outer')
        },
        outlets: {
          main: {
            render: {
              owner: this.owner,
              into: undefined,
              outlet: 'main',
              name: 'inner',
              controller: {},
              template: this.owner.lookup('template:inner')
            },
            outlets: Object.create(null)
          }
        }
      };
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.component.setOutletState(outletState);
      });
      (0, _internalTestHelpers.runAppend)(this.component);
      this.assertText('ABCDE');
      this.assertStableRerender();
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/refinements-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _metal) {
  "use strict";

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with var as |foo|}}\n        {{foo}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |outlet|}}\n        {{outlet}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |mount|}}\n        {{mount}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |component|}}\n        {{component}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |input|}}\n        {{input}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |-with-dynamic-vars|}}\n        {{-with-dynamic-vars}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |-in-element|}}\n        {{-in-element}}\n      {{/with}}"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('syntax refinements',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test block params should not be refined'] = function testBlockParamsShouldNotBeRefined() {
      var _this = this;

      this.registerHelper('foo', function () {
        return 'bar helper';
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject()), {
        var: 'var'
      });
      this.assertText('var---var---var---var---var---var---var');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'var', 'RARRR!!!');
      });
      this.assertText('RARRR!!!---RARRR!!!---RARRR!!!---RARRR!!!---RARRR!!!---RARRR!!!---RARRR!!!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'var', 'var');
      });
      this.assertText('var---var---var---var---var---var---var');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/render-settled-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/glimmer", "@ember/runloop", "rsvp"], function (_emberBabel, _internalTestHelpers, _glimmer, _runloop, _rsvp) {
  "use strict";

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["{{foo}}"]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["{{foo}}"]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["{{foo}}"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('renderSettled',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test resolves when no rendering is happening'] = function testResolvesWhenNoRenderingIsHappening(assert) {
      return (0, _glimmer.renderSettled)().then(function () {
        assert.ok(true, 'resolved even without rendering');
      });
    };

    _proto['@test resolves renderers exist but no runloops are triggered'] = function testResolvesRenderersExistButNoRunloopsAreTriggered(assert) {
      this.render((0, _internalTestHelpers.strip)(_templateObject()), {
        foo: 'bar'
      });
      return (0, _glimmer.renderSettled)().then(function () {
        assert.ok(true, 'resolved even without runloops');
      });
    };

    _proto['@test does not create extraneous promises'] = function testDoesNotCreateExtraneousPromises(assert) {
      var first = (0, _glimmer.renderSettled)();
      var second = (0, _glimmer.renderSettled)();
      assert.strictEqual(first, second);
      return (0, _rsvp.all)([first, second]);
    };

    _proto['@test resolves when rendering has completed (after property update)'] = function testResolvesWhenRenderingHasCompletedAfterPropertyUpdate() {
      var _this = this;

      this.render((0, _internalTestHelpers.strip)(_templateObject2()), {
        foo: 'bar'
      });
      this.assertText('bar');
      this.component.set('foo', 'baz');
      this.assertText('bar');
      return (0, _glimmer.renderSettled)().then(function () {
        _this.assertText('baz');
      });
    };

    _proto['@test resolves in run loop when renderer has settled'] = function testResolvesInRunLoopWhenRendererHasSettled(assert) {
      var _this2 = this;

      assert.expect(3);
      this.render((0, _internalTestHelpers.strip)(_templateObject3()), {
        foo: 'bar'
      });
      this.assertText('bar');
      var promise;
      return (0, _runloop.run)(function () {
        (0, _runloop.schedule)('actions', null, function () {
          _this2.component.set('foo', 'set in actions');

          promise = (0, _glimmer.renderSettled)().then(function () {
            _this2.assertText('set in afterRender');
          });
          (0, _runloop.schedule)('afterRender', null, function () {
            _this2.component.set('foo', 'set in afterRender');
          });
        }); // still not updated here

        _this2.assertText('bar');

        return promise;
      });
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/svg-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _metal) {
  "use strict";

  function _templateObject14() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        <svg class=\"blue tall\"></svg>\n      </div>\n    "]);

    _templateObject14 = function () {
      return data;
    };

    return data;
  }

  function _templateObject13() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        <svg class=\"yellow tall\"></svg>\n      </div>\n    "]);

    _templateObject13 = function () {
      return data;
    };

    return data;
  }

  function _templateObject12() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        <svg class=\"blue tall\"></svg>\n      </div>\n    "]);

    _templateObject12 = function () {
      return data;
    };

    return data;
  }

  function _templateObject11() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        <svg class=\"blue tall\"></svg>\n      </div>\n    "]);

    _templateObject11 = function () {
      return data;
    };

    return data;
  }

  function _templateObject10() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        <svg viewBox=\"0 0 ", "\"></svg>\n      </div>\n    "]);

    _templateObject10 = function () {
      return data;
    };

    return data;
  }

  function _templateObject9() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        <svg viewBox=\"0 0 200 200\"></svg>\n      </div>\n    "]);

    _templateObject9 = function () {
      return data;
    };

    return data;
  }

  function _templateObject8() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        <svg viewBox=\"0 0 ", "\"></svg>\n      </div>\n    "]);

    _templateObject8 = function () {
      return data;
    };

    return data;
  }

  function _templateObject7() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        <svg viewBox=\"0 0 ", "\"></svg>\n      </div>\n    "]);

    _templateObject7 = function () {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        <svg viewBox=\"", "\"></svg>\n      </div>\n    "]);

    _templateObject6 = function () {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        <svg viewBox=\"", "\"></svg>\n      </div>\n    "]);

    _templateObject5 = function () {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        <svg viewBox=\"", "\"></svg>\n      </div>\n    "]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        <svg viewBox=\"", "\"></svg>\n      </div>\n    "]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        <svg viewBox=\"", "\"></svg>\n      </div>\n    "]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      <div>\n        <svg viewBox=\"", "\"></svg>\n      </div>\n    "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('SVG element tests',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test unquoted viewBox property is output'] = function testUnquotedViewBoxPropertyIsOutput(assert) {
      var _this = this;

      var viewBoxString = '0 0 100 100';
      this.render('<div><svg viewBox={{model.viewBoxString}}></svg></div>', {
        model: {
          viewBoxString: viewBoxString
        }
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject(), viewBoxString));
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject2(), viewBoxString));
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'model.viewBoxString', null);
      });
      assert.equal(this.firstChild.getAttribute('svg'), null);
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'model', {
          viewBoxString: viewBoxString
        });
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject3(), viewBoxString));
    };

    _proto['@test quoted viewBox property is output'] = function testQuotedViewBoxPropertyIsOutput(assert) {
      var _this2 = this;

      var viewBoxString = '0 0 100 100';
      this.render('<div><svg viewBox="{{model.viewBoxString}}"></svg></div>', {
        model: {
          viewBoxString: viewBoxString
        }
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject4(), viewBoxString));
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject5(), viewBoxString));
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'model.viewBoxString', null);
      });
      assert.equal(this.firstChild.getAttribute('svg'), null);
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'model', {
          viewBoxString: viewBoxString
        });
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject6(), viewBoxString));
    };

    _proto['@test quoted viewBox property is concat'] = function testQuotedViewBoxPropertyIsConcat() {
      var _this3 = this;

      var viewBoxString = '100 100';
      this.render('<div><svg viewBox="0 0 {{model.viewBoxString}}"></svg></div>', {
        model: {
          viewBoxString: viewBoxString
        }
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject7(), viewBoxString));
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject8(), viewBoxString));
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'model.viewBoxString', '200 200');
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject9()));
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'model', {
          viewBoxString: viewBoxString
        });
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject10(), viewBoxString));
    };

    _proto['@test class is output'] = function testClassIsOutput() {
      var _this4 = this;

      this.render("<div><svg class='{{model.color}} tall'></svg></div>", {
        model: {
          color: 'blue'
        }
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject11()));
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject12()));
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'model.color', 'yellow');
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject13()));
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'model', {
          color: 'blue'
        });
      });
      this.assertInnerHTML((0, _internalTestHelpers.strip)(_templateObject14()));
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/syntax/each-in-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/runtime", "@ember/-internals/utils", "@ember/-internals/glimmer/tests/utils/shared-conditional-tests"], function (_emberBabel, _internalTestHelpers, _metal, _runtime, _utils, _sharedConditionalTests) {
  "use strict";

  function _templateObject14() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        <li>three: qux</li>\n      </ul>\n    "]);

    _templateObject14 = function () {
      return data;
    };

    return data;
  }

  function _templateObject13() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        <li>one: foo</li>\n        <li>two: bar</li>\n      </ul>\n    "]);

    _templateObject13 = function () {
      return data;
    };

    return data;
  }

  function _templateObject12() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        {{#each-in map key=\"@identity\" as |key value|}}\n          <li>{{key.name}}: {{value}}</li>\n        {{/each-in}}\n      </ul>"]);

    _templateObject12 = function () {
      return data;
    };

    return data;
  }

  function _templateObject11() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        <li>Smartphones: 8203</li>\n        <li>JavaScript Frameworks: Infinity</li>\n      </ul>\n    "]);

    _templateObject11 = function () {
      return data;
    };

    return data;
  }

  function _templateObject10() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        <li>Smartphones: 100</li>\n        <li>Tablets: 20</li>\n      </ul>\n    "]);

    _templateObject10 = function () {
      return data;
    };

    return data;
  }

  function _templateObject9() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        <li>Smartphones: 100</li>\n        <li>JavaScript Frameworks: Infinity</li>\n        <li>Tweets: 443115</li>\n      </ul>\n    "]);

    _templateObject9 = function () {
      return data;
    };

    return data;
  }

  function _templateObject8() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        <li>Smartphones: 8203</li>\n        <li>JavaScript Frameworks: Infinity</li>\n      </ul>\n    "]);

    _templateObject8 = function () {
      return data;
    };

    return data;
  }

  function _templateObject7() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        {{#each-in categories as |category count|}}\n          <li>{{category}}: {{count}}</li>\n        {{/each-in}}\n      </ul>\n    "]);

    _templateObject7 = function () {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#each-in arr as |key value|}}\n        [{{key}}:{{value}}]\n      {{/each-in}}"]);

    _templateObject6 = function () {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#each-in arr as |key value|}}\n        [{{key}}:{{value}}]\n      {{/each-in}}"]);

    _templateObject5 = function () {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        <li>Smartphones: 8203</li>\n        <li>JavaScript Frameworks: Infinity</li>\n      </ul>\n    "]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        <li>Emberinios: 123456</li>\n      </ul>\n    "]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        <li>Smartphones: 8203</li>\n        <li>JavaScript Frameworks: Infinity</li>\n      </ul>\n    "]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      <ul>\n        {{#each-in categories as |category count|}}\n          <li>{{category}}: {{count}}</li>\n        {{/each-in}}\n      </ul>\n    "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  function EmptyFunction() {}

  function NonEmptyFunction() {}

  NonEmptyFunction.foo = 'bar';

  var EmptyConstructor = function EmptyConstructor() {};

  var NonEmptyConstructor = function NonEmptyConstructor() {};

  NonEmptyConstructor.foo = 'bar';

  var TogglingEachInTest =
  /*#__PURE__*/
  function (_TogglingSyntaxCondit) {
    (0, _emberBabel.inheritsLoose)(TogglingEachInTest, _TogglingSyntaxCondit);

    function TogglingEachInTest() {
      return _TogglingSyntaxCondit.apply(this, arguments) || this;
    }

    var _proto = TogglingEachInTest.prototype;

    _proto.templateFor = function templateFor(_ref) {
      var cond = _ref.cond,
          truthy = _ref.truthy,
          falsy = _ref.falsy;
      return "{{#each-in " + cond + " as |key|}}" + truthy + "{{else}}" + falsy + "{{/each-in}}";
    };

    return TogglingEachInTest;
  }(_sharedConditionalTests.TogglingSyntaxConditionalsTest);

  var BasicEachInTest =
  /*#__PURE__*/
  function (_TogglingEachInTest) {
    (0, _emberBabel.inheritsLoose)(BasicEachInTest, _TogglingEachInTest);

    function BasicEachInTest() {
      return _TogglingEachInTest.apply(this, arguments) || this;
    }

    return BasicEachInTest;
  }(TogglingEachInTest);

  var BasicSyntaxTest =
  /*#__PURE__*/
  function (_BasicEachInTest) {
    (0, _emberBabel.inheritsLoose)(BasicSyntaxTest, _BasicEachInTest);

    function BasicSyntaxTest() {
      return _BasicEachInTest.apply(this, arguments) || this;
    }

    (0, _emberBabel.createClass)(BasicSyntaxTest, [{
      key: "truthyValue",
      get: function () {
        return {
          'Not Empty': 1
        };
      }
    }, {
      key: "falsyValue",
      get: function () {
        return {};
      }
    }]);
    return BasicSyntaxTest;
  }(BasicEachInTest);

  var EachInProxyTest =
  /*#__PURE__*/
  function (_TogglingEachInTest2) {
    (0, _emberBabel.inheritsLoose)(EachInProxyTest, _TogglingEachInTest2);

    function EachInProxyTest() {
      return _TogglingEachInTest2.apply(this, arguments) || this;
    }

    return EachInProxyTest;
  }(TogglingEachInTest);

  (0, _internalTestHelpers.applyMixins)(BasicEachInTest, new _sharedConditionalTests.TruthyGenerator([{
    foo: 1
  }, _runtime.Object.create({
    'Not Empty': 1
  }), [1], NonEmptyFunction, NonEmptyConstructor]), new _sharedConditionalTests.FalsyGenerator([null, undefined, false, '', 0, [], EmptyFunction, EmptyConstructor, {}, Object.create(null), Object.create({}), Object.create({
    'Not Empty': 1
  }), _runtime.Object.create()]));
  (0, _internalTestHelpers.applyMixins)(EachInProxyTest, new _sharedConditionalTests.TruthyGenerator([_runtime.ObjectProxy.create({
    content: {
      'Not empty': 1
    }
  })]), new _sharedConditionalTests.FalsyGenerator([_runtime.ObjectProxy.create(), _runtime.ObjectProxy.create({
    content: null
  }), _runtime.ObjectProxy.create({
    content: {}
  }), _runtime.ObjectProxy.create({
    content: Object.create(null)
  }), _runtime.ObjectProxy.create({
    content: Object.create({})
  }), _runtime.ObjectProxy.create({
    content: Object.create({
      'Not Empty': 1
    })
  }), _runtime.ObjectProxy.create({
    content: _runtime.Object.create()
  })])); // Truthy/Falsy tests

  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each-in}} with `ObjectProxy`',
  /*#__PURE__*/
  function (_EachInProxyTest) {
    (0, _emberBabel.inheritsLoose)(_class, _EachInProxyTest);

    function _class() {
      return _EachInProxyTest.apply(this, arguments) || this;
    }

    (0, _emberBabel.createClass)(_class, [{
      key: "truthyValue",
      get: function () {
        return _runtime.ObjectProxy.create({
          content: {
            'Not Empty': 1
          }
        });
      }
    }, {
      key: "falsyValue",
      get: function () {
        return _runtime.ObjectProxy.create({
          content: null
        });
      }
    }]);
    return _class;
  }(EachInProxyTest));
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each-in}}', BasicSyntaxTest); // Rendering tests

  var AbstractEachInTest =
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(AbstractEachInTest, _RenderingTestCase);

    function AbstractEachInTest() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto2 = AbstractEachInTest.prototype;

    _proto2.createHash = function createHash()
    /* hash */
    {
      throw new Error('Not implemented: `createHash`');
    };

    _proto2.makeHash = function makeHash(obj) {
      var _this$createHash = this.createHash(obj),
          hash = _this$createHash.hash,
          delegate = _this$createHash.delegate;

      this.hash = hash;
      this.delegate = delegate;
      return hash;
    };

    _proto2.replaceHash = function replaceHash(hash) {
      var _this = this;

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'hash', _this.createHash(hash).hash);
      });
    };

    _proto2.clear = function clear() {
      var _this2 = this;

      return (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'hash', _this2.createHash({}).hash);
      });
    };

    _proto2.setProp = function setProp(key, value) {
      var _this3 = this;

      return (0, _internalTestHelpers.runTask)(function () {
        return _this3.delegate.setProp(_this3.context, key, value);
      });
    };

    _proto2.updateNestedValue = function updateNestedValue(key, innerKey, value) {
      var _this4 = this;

      return (0, _internalTestHelpers.runTask)(function () {
        return _this4.delegate.updateNestedValue(_this4.context, key, innerKey, value);
      });
    };

    _proto2.render = function render(template) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.hash !== undefined) {
        context.hash = this.hash;
      }

      if (this.type !== undefined) {
        context.type = this.type;
      }

      context.secretKey = 'asd';
      return _RenderingTestCase.prototype.render.call(this, template, context);
    };

    return AbstractEachInTest;
  }(_internalTestHelpers.RenderingTestCase);

  var EachInTest =
  /*#__PURE__*/
  function (_AbstractEachInTest) {
    (0, _emberBabel.inheritsLoose)(EachInTest, _AbstractEachInTest);

    function EachInTest() {
      return _AbstractEachInTest.apply(this, arguments) || this;
    }

    var _proto3 = EachInTest.prototype;

    _proto3["@test it repeats the given block for each item in the hash"] = function () {
      this.makeHash({
        Smartphones: 8203,
        'JavaScript Frameworks': Infinity
      });
      this.render("<ul>{{#each-in hash as |category count|}}<li>{{category}}: {{count}}</li>{{else}}Empty!{{/each-in}}</ul>");
      this.assertText('Smartphones: 8203JavaScript Frameworks: Infinity');
      this.assertStableRerender();

      if (this.allowsSetProp) {
        // Not al backing data structures allow kvo tracking. Maps and Iterables don't
        this.setProp('Tweets', 100);
        this.assertText('Smartphones: 8203JavaScript Frameworks: InfinityTweets: 100');
      }

      this.clear();
      this.assertText('Empty!');
    };

    _proto3["@test it can render sub-paths of each item"] = function (assert) {
      var _this5 = this;

      this.makeHash({
        Smartphones: {
          reports: {
            unitsSold: 8203
          }
        },
        'JavaScript Frameworks': {
          reports: {
            unitsSold: Infinity
          }
        }
      });
      this.render("<ul>{{#each-in hash as |category data|}}<li>{{category}}: {{data.reports.unitsSold}}</li>{{else}}Empty!{{/each-in}}</ul>");
      this.assertText('Smartphones: 8203JavaScript Frameworks: Infinity');
      this.assertStableRerender();

      if (this.allowsSetProp) {
        this.setProp('Tweets', {
          reports: {
            unitsSold: 100
          }
        });
        this.assertText('Smartphones: 8203JavaScript Frameworks: InfinityTweets: 100');
      }

      (0, _internalTestHelpers.runTask)(function () {
        return _this5.updateNestedValue('Smartphones', 'reports.unitsSold', 8204);
      });
      assert.ok(this.textValue().indexOf('Smartphones: 8204') > -1);
      this.clear();
      this.assertText('Empty!');
    };

    _proto3["@test it can render duplicate items"] = function () {
      this.makeHash({
        Smartphones: 8203,
        Tablets: 8203,
        'JavaScript Frameworks': Infinity,
        Bugs: Infinity
      });
      this.render("<ul>{{#each-in hash key='@identity' as |category count|}}<li>{{category}}: {{count}}</li>{{/each-in}}</ul>");
      this.assertText('Smartphones: 8203Tablets: 8203JavaScript Frameworks: InfinityBugs: Infinity');
      this.assertStableRerender();

      if (this.allowsSetProp) {
        this.setProp('Smartphones', 100);
        this.setProp('Tweets', 443115);
        this.assertText('Smartphones: 100Tablets: 8203JavaScript Frameworks: InfinityBugs: InfinityTweets: 443115');
      }

      this.clear();
      this.assertText('');
    };

    _proto3["@test it repeats the given block when the hash is dynamic"] = function () {
      var _this$createHash2 = this.createHash({
        Smartphones: 8203,
        'JavaScript Frameworks': Infinity
      }),
          categories = _this$createHash2.hash;

      var _this$createHash3 = this.createHash({
        Emberinios: 533462,
        Tweets: 7323
      }),
          otherCategories = _this$createHash3.hash;

      var context = {
        hashes: {
          categories: categories,
          otherCategories: otherCategories,
          type: 'categories'
        }
      };
      this.render("<ul>{{#each-in (get hashes hashes.type) as |category count|}}<li>{{category}}: {{count}}</li>{{else}}Empty!{{/each-in}}</ul>", context);
      this.assertText('Smartphones: 8203JavaScript Frameworks: Infinity');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(context, 'hashes.type', 'otherCategories');
      });
      this.assertText('Emberinios: 533462Tweets: 7323');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(context, 'hashes.type', 'categories');
      });
      this.assertText('Smartphones: 8203JavaScript Frameworks: Infinity');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(context, 'hashes.type', 'nonExistent');
      });
      this.clear();
      this.assertText('Empty!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(context, 'hashes.type', 'categories');
      });
      this.assertText('Smartphones: 8203JavaScript Frameworks: Infinity');
    };

    _proto3['@test keying off of `undefined` does not render'] = function testKeyingOffOfUndefinedDoesNotRender() {
      this.makeHash({});
      this.render("{{#each-in hash as |key value|}}{{key}}: {{value.baz}}{{else}}Empty!{{/each-in}}");
      this.assertText('Empty!');
      this.assertStableRerender();
      this.replaceHash({
        bar: {
          baz: 'Here!'
        }
      });
      this.assertText('bar: Here!');
      this.clear();
      this.assertText('Empty!');
    };

    _proto3["@test it can render items with a key of empty string"] = function () {
      this.makeHash({
        '': 'empty-string',
        a: 'a'
      });
      this.render("<ul>{{#each-in hash as |key value|}}<li>{{key}}: {{value}}</li>{{else}}Empty!{{/each-in}}</ul>");
      this.assertText(': empty-stringa: a');
      this.assertStableRerender();
      this.clear();
      this.assertText('Empty!');
    };

    return EachInTest;
  }(AbstractEachInTest);

  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each-in}} with POJOs',
  /*#__PURE__*/
  function (_EachInTest) {
    (0, _emberBabel.inheritsLoose)(_class2, _EachInTest);

    function _class2() {
      var _this6;

      _this6 = _EachInTest.apply(this, arguments) || this;
      _this6.allowsSetProp = true;
      return _this6;
    }

    var _proto4 = _class2.prototype;

    _proto4.createHash = function createHash(pojo) {
      return {
        hash: pojo,
        delegate: {
          setProp: function (context, key, value) {
            (0, _metal.set)(context.hash, key, value);
          },
          updateNestedValue: function (context, key, innerKey, value) {
            var target = context.hash[key];
            (0, _metal.set)(target, innerKey, value);
          }
        }
      };
    };

    _proto4["@test it only iterates over an object's own properties"] = function () {
      var protoCategories = {
        Smartphones: 8203,
        'JavaScript Frameworks': Infinity
      };
      var categories = Object.create(protoCategories);
      categories['Televisions'] = 183;
      categories['Alarm Clocks'] = 999;
      this.render("<ul>{{#each-in categories as |category count|}}<li>{{category}}: {{count}}</li>{{else}}Empty!{{/each-in}}</ul>", {
        categories: categories
      });
      this.assertText('Televisions: 183Alarm Clocks: 999');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(protoCategories, 'Robots', 666);
        (0, _metal.set)(categories, 'Tweets', 443115);
      });
      this.assertText('Televisions: 183Alarm Clocks: 999Tweets: 443115');
      categories = Object.create(protoCategories);
      categories['Televisions'] = 183;
      categories['Alarm Clocks'] = 999;
    };

    _proto4["@test it does not observe direct property mutations (not going through set) on the object"] = function () {
      var _this7 = this;

      this.render((0, _internalTestHelpers.strip)(_templateObject()), {
        categories: {
          Smartphones: 8203,
          'JavaScript Frameworks': Infinity
        }
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject2()));
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        var categories = (0, _metal.get)(_this7.context, 'categories');
        delete categories.Smartphones;
      });
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        var categories = (0, _metal.get)(_this7.context, 'categories');
        categories['Emberinios'] = 123456;
      });
      this.assertInvariants();
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this7.context, 'categories', {
          Emberinios: 123456
        });
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject3()));
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this7.context, 'categories', {
          Smartphones: 8203,
          'JavaScript Frameworks': Infinity
        });
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject4()));
    };

    _proto4['@test it skips holes in sparse arrays'] = function testItSkipsHolesInSparseArrays() {
      var arr = [];
      arr[5] = 'foo';
      arr[6] = 'bar';
      this.render((0, _internalTestHelpers.strip)(_templateObject5()), {
        arr: arr
      });
      this.assertText('[5:foo][6:bar]');
      this.assertStableRerender();
    };

    _proto4['@test it iterate over array with `in` instead of walking over elements'] = function testItIterateOverArrayWithInInsteadOfWalkingOverElements() {
      var _this8 = this;

      var arr = [1, 2, 3];
      arr.foo = 'bar';
      this.render((0, _internalTestHelpers.strip)(_templateObject6()), {
        arr: arr
      });
      this.assertText('[0:1][1:2][2:3][foo:bar]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.rerender();
      });
      this.assertText('[0:1][1:2][2:3][foo:bar]');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(arr, 'zomg', 'lol');
      });
      this.assertText('[0:1][1:2][2:3][foo:bar][zomg:lol]');
      arr = [1, 2, 3];
      arr.foo = 'bar';
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this8.context, 'arr', arr);
      });
      this.assertText('[0:1][1:2][2:3][foo:bar]');
    };

    return _class2;
  }(EachInTest));
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each-in}} with EmberObjects',
  /*#__PURE__*/
  function (_EachInTest2) {
    (0, _emberBabel.inheritsLoose)(_class3, _EachInTest2);

    function _class3() {
      var _this9;

      _this9 = _EachInTest2.apply(this, arguments) || this;
      _this9.allowsSetProp = true;
      return _this9;
    }

    var _proto5 = _class3.prototype;

    _proto5.createHash = function createHash(pojo) {
      var hash = _runtime.Object.create(pojo);

      return {
        hash: hash,
        delegate: {
          setProp: function (context, key, value) {
            (0, _metal.set)(context, "hash." + key, value);
          },
          updateNestedValue: function (context, key, innerKey, value) {
            var target = (0, _metal.get)(context.hash, key);
            (0, _metal.set)(target, innerKey, value);
          }
        }
      };
    };

    return _class3;
  }(EachInTest));
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each-in}} with object proxies',
  /*#__PURE__*/
  function (_EachInTest3) {
    (0, _emberBabel.inheritsLoose)(_class4, _EachInTest3);

    function _class4() {
      var _this10;

      _this10 = _EachInTest3.apply(this, arguments) || this;
      _this10.allowsSetProp = true;
      return _this10;
    }

    var _proto6 = _class4.prototype;

    _proto6.createHash = function createHash(pojo) {
      var hash = _runtime.ObjectProxy.create({
        content: pojo
      });

      return {
        hash: hash,
        delegate: {
          setProp: function (context, key, value) {
            (0, _metal.set)(context, "hash." + key, value);
          },
          updateNestedValue: function (context, key, innerKey, value) {
            var target = (0, _metal.get)(context.hash, key);
            (0, _metal.set)(target, innerKey, value);
          }
        }
      };
    };

    _proto6['@test it iterates over the content, not the proxy'] = function testItIteratesOverTheContentNotTheProxy() {
      var _this11 = this;

      var content = {
        Smartphones: 8203,
        'JavaScript Frameworks': Infinity
      };

      var proxy = _runtime.ObjectProxy.create({
        content: content,
        foo: 'bar'
      });

      this.render((0, _internalTestHelpers.strip)(_templateObject7()), {
        categories: proxy
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject8()));
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(proxy, 'content.Smartphones', 100);
        (0, _metal.set)(proxy, 'content.Tweets', 443115);
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject9()));
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(proxy, 'content', {
          Smartphones: 100,
          Tablets: 20
        });
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject10()));
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'categories', _runtime.ObjectProxy.create({
          content: {
            Smartphones: 8203,
            'JavaScript Frameworks': Infinity
          }
        }));
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject11()));
    };

    return _class4;
  }(EachInTest));
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each-in}} with ES6 Maps',
  /*#__PURE__*/
  function (_EachInTest4) {
    (0, _emberBabel.inheritsLoose)(_class5, _EachInTest4);

    function _class5() {
      return _EachInTest4.apply(this, arguments) || this;
    }

    var _proto7 = _class5.prototype;

    _proto7.createHash = function createHash(pojo) {
      var map = new Map();
      Object.keys(pojo).forEach(function (key) {
        map.set(key, pojo[key]);
      });
      return {
        hash: map,
        delegate: {
          updateNestedValue: function (context, key, innerKey, value) {
            var target = context.hash.get(key);
            (0, _metal.set)(target, innerKey, value);
          }
        }
      };
    };

    _proto7["@test it supports having objects as keys on ES6 Maps"] = function () {
      var _this12 = this;

      var map = new Map();
      map.set({
        name: 'one'
      }, 'foo');
      map.set({
        name: 'two'
      }, 'bar');
      this.render((0, _internalTestHelpers.strip)(_templateObject12()), {
        map: map
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject13()));
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        var map = new Map();
        map.set({
          name: 'three'
        }, 'qux');
        (0, _metal.set)(_this12.context, 'map', map);
      });
      this.assertHTML((0, _internalTestHelpers.strip)(_templateObject14()));
    };

    return _class5;
  }(EachInTest));

  if (_utils.HAS_NATIVE_SYMBOL) {
    (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each-in}} with custom iterables',
    /*#__PURE__*/
    function (_EachInTest5) {
      (0, _emberBabel.inheritsLoose)(_class6, _EachInTest5);

      function _class6() {
        return _EachInTest5.apply(this, arguments) || this;
      }

      var _proto8 = _class6.prototype;

      _proto8.createHash = function createHash(pojo) {
        var _iterable;

        var ary = Object.keys(pojo).reduce(function (accum, key) {
          return accum.concat([[key, pojo[key]]]);
        }, []);
        var iterable = (_iterable = {}, _iterable[Symbol.iterator] = function () {
          return makeIterator(ary);
        }, _iterable);
        return {
          hash: iterable,
          delegate: {
            updateNestedValue: function (context, key, innerKey, value) {
              var ary = Array.from(context.hash);
              var target = ary.find(function (_ref2) {
                var k = _ref2[0];
                return k === key;
              })[1];
              (0, _metal.set)(target, innerKey, value);
            }
          }
        };
      };

      return _class6;
    }(EachInTest));
  } // Utils


  function makeIterator(ary) {
    var index = 0;
    return {
      next: function () {
        return index < ary.length ? {
          value: ary[index++],
          done: false
        } : {
          done: true
        };
      }
    };
  }
});
enifed("@ember/-internals/glimmer/tests/integration/syntax/each-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/runtime", "@ember/-internals/utils", "@ember/-internals/glimmer/tests/utils/helpers", "@ember/-internals/glimmer/tests/utils/shared-conditional-tests"], function (_emberBabel, _internalTestHelpers, _metal, _runtime, _utils, _helpers, _sharedConditionalTests) {
  "use strict";

  function _templateObject8() {
    const data = _taggedTemplateLiteralLoose(["\n          <h1>Think Pieces\u2122</h1>\n\n          <ul id=\"posts\">\n            <li>Rails is omakase</li>\n            <li>Ember is omakase</li>\n          </ul>\n        "]);

    _templateObject8 = function () {
      return data;
    };

    return data;
  }

  function _templateObject7() {
    const data = _taggedTemplateLiteralLoose(["\n          <h1>Essays</h1>\n\n          <ul id=\"posts\">\n            <li>Rails is omakase</li>\n            <li>Ember is omakase</li>\n          </ul>\n        "]);

    _templateObject7 = function () {
      return data;
    };

    return data;
  }

  function _templateObject6() {
    const data = _taggedTemplateLiteralLoose(["\n        <h1>Blog Posts</h1>\n\n        <ul id=\"posts\">\n          <li>Rails is omakase</li>\n          <li>Ember is omakase</li>\n        </ul>\n      "]);

    _templateObject6 = function () {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    const data = _taggedTemplateLiteralLoose(["\n        <h1>{{page.title}}</h1>\n\n        <ul id=\"posts\">\n          {{#each model as |post|}}\n            <li>{{post.title}}</li>\n          {{/each}}\n        </ul>\n      "]);

    _templateObject5 = function () {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#each list as |value key|}}\n        [{{key}}:{{value}}]\n      {{/each}}"]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#each foo.bar.baz as |thing|}}\n        {{thing}}\n      {{/each}}"]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#each content as |value|}}\n        {{value}}-\n        {{#each options as |option|}}\n          {{option.value}}:{{option.label}}\n        {{/each}}\n      {{/each}}\n      "]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#each list as |item|}}\n        <li>Prev</li>\n        {{foo-bar item=item}}\n        <li>Next</li>\n      {{/each}}\n    "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  var ArrayDelegate =
  /*#__PURE__*/
  function () {
    function ArrayDelegate(content, target) {
      this._array = content;
      this._target = target || this;
    } // The following methods are APIs used by the tests


    var _proto = ArrayDelegate.prototype;

    _proto.toArray = function toArray() {
      return this._array.slice();
    };

    _proto.objectAt = function objectAt(idx) {
      return this._array[idx];
    };

    _proto.clear = function clear() {
      this._array.length = 0;
      this.arrayContentDidChange();
    };

    _proto.replace = function replace(idx, del, ins) {
      var _this$_array;

      (_this$_array = this._array).splice.apply(_this$_array, [idx, del].concat(ins));

      this.arrayContentDidChange();
    };

    _proto.unshiftObject = function unshiftObject(obj) {
      this._array.unshift(obj);

      this.arrayContentDidChange();
    };

    _proto.unshiftObjects = function unshiftObjects(arr) {
      var _this$_array2;

      (_this$_array2 = this._array).unshift.apply(_this$_array2, arr);

      this.arrayContentDidChange();
    };

    _proto.pushObject = function pushObject(obj) {
      this._array.push(obj);

      this.arrayContentDidChange();
    };

    _proto.pushObjects = function pushObjects(arr) {
      var _this$_array3;

      (_this$_array3 = this._array).push.apply(_this$_array3, arr);

      this.arrayContentDidChange();
    };

    _proto.shiftObject = function shiftObject() {
      var obj = this._array.shift();

      this.arrayContentDidChange();
      return obj;
    };

    _proto.popObject = function popObject() {
      var obj = this._array.pop();

      this.arrayContentDidChange();
      return obj;
    };

    _proto.insertAt = function insertAt(idx, obj) {
      this._array.splice(idx, 0, obj);

      this.arrayContentDidChange();
    };

    _proto.removeAt = function removeAt(idx) {
      var len = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      this._array.splice(idx, len);

      this.arrayContentDidChange();
    };

    _proto.arrayContentDidChange = function arrayContentDidChange() {
      (0, _metal.notifyPropertyChange)(this._target, '[]');
      (0, _metal.notifyPropertyChange)(this._target, 'length');
    };

    _proto.toString = function toString() {
      return "#<" + (this.constructor.name || 'UnknownArrayDelegate') + ">";
    };

    _proto.toJSON = function toJSON() {
      return this.toString();
    };

    return ArrayDelegate;
  }();

  var makeSet = function () {
    // IE11 does not support `new Set(items);`
    var set = new Set([1, 2, 3]);

    if (set.size === 3) {
      return function (items) {
        return new Set(items);
      };
    } else {
      return function (items) {
        var s = new Set();
        items.forEach(function (value) {
          return s.add(value);
        });
        return s;
      };
    }
  }();

  var SetDelegate =
  /*#__PURE__*/
  function (_ArrayDelegate) {
    (0, _emberBabel.inheritsLoose)(SetDelegate, _ArrayDelegate);

    function SetDelegate(set) {
      var _this;

      var array = [];
      set.forEach(function (value) {
        return array.push(value);
      });
      _this = _ArrayDelegate.call(this, array, set) || this;
      _this._set = set;
      return _this;
    }

    var _proto2 = SetDelegate.prototype;

    _proto2.arrayContentDidChange = function arrayContentDidChange() {
      var _this2 = this;

      this._set.clear();

      this._array.forEach(function (value) {
        return _this2._set.add(value);
      });

      _ArrayDelegate.prototype.arrayContentDidChange.call(this);
    };

    return SetDelegate;
  }(ArrayDelegate);

  var ForEachable =
  /*#__PURE__*/
  function (_ArrayDelegate2) {
    (0, _emberBabel.inheritsLoose)(ForEachable, _ArrayDelegate2);

    function ForEachable() {
      return _ArrayDelegate2.apply(this, arguments) || this;
    }

    var _proto3 = ForEachable.prototype;

    _proto3.forEach = function forEach(callback) {
      this._array.forEach(callback);
    };

    (0, _emberBabel.createClass)(ForEachable, [{
      key: "length",
      get: function () {
        return this._array.length;
      }
    }]);
    return ForEachable;
  }(ArrayDelegate);

  var ArrayIterable;

  if (_utils.HAS_NATIVE_SYMBOL) {
    ArrayIterable =
    /*#__PURE__*/
    function (_ArrayDelegate3) {
      (0, _emberBabel.inheritsLoose)(ArrayIterable, _ArrayDelegate3);

      function ArrayIterable() {
        return _ArrayDelegate3.apply(this, arguments) || this;
      }

      var _proto4 = ArrayIterable.prototype;

      _proto4[Symbol.iterator] = function () {
        return this._array[Symbol.iterator]();
      };

      return ArrayIterable;
    }(ArrayDelegate);
  }

  var TogglingEachTest =
  /*#__PURE__*/
  function (_TogglingSyntaxCondit) {
    (0, _emberBabel.inheritsLoose)(TogglingEachTest, _TogglingSyntaxCondit);

    function TogglingEachTest() {
      return _TogglingSyntaxCondit.apply(this, arguments) || this;
    }

    (0, _emberBabel.createClass)(TogglingEachTest, [{
      key: "truthyValue",
      get: function () {
        return ['non-empty'];
      }
    }, {
      key: "falsyValue",
      get: function () {
        return [];
      }
    }]);
    return TogglingEachTest;
  }(_sharedConditionalTests.TogglingSyntaxConditionalsTest);

  var BasicEachTest =
  /*#__PURE__*/
  function (_TogglingEachTest) {
    (0, _emberBabel.inheritsLoose)(BasicEachTest, _TogglingEachTest);

    function BasicEachTest() {
      return _TogglingEachTest.apply(this, arguments) || this;
    }

    return BasicEachTest;
  }(TogglingEachTest);

  var TRUTHY_CASES = [['hello'], (0, _runtime.A)(['hello']), makeSet(['hello']), new ForEachable(['hello']), _runtime.ArrayProxy.create({
    content: ['hello']
  }), _runtime.ArrayProxy.create({
    content: (0, _runtime.A)(['hello'])
  })];
  var FALSY_CASES = [null, undefined, false, '', 0, [], (0, _runtime.A)([]), makeSet([]), new ForEachable([]), _runtime.ArrayProxy.create({
    content: []
  }), _runtime.ArrayProxy.create({
    content: (0, _runtime.A)([])
  })];

  if (_utils.HAS_NATIVE_SYMBOL) {
    TRUTHY_CASES.push(new ArrayIterable(['hello']));
    FALSY_CASES.push(new ArrayIterable([]));
  }

  (0, _internalTestHelpers.applyMixins)(BasicEachTest, new _sharedConditionalTests.TruthyGenerator(TRUTHY_CASES), new _sharedConditionalTests.FalsyGenerator(FALSY_CASES), _sharedConditionalTests.ArrayTestCases);
  (0, _internalTestHelpers.moduleFor)('Syntax test: toggling {{#each}}',
  /*#__PURE__*/
  function (_BasicEachTest) {
    (0, _emberBabel.inheritsLoose)(_class, _BasicEachTest);

    function _class() {
      return _BasicEachTest.apply(this, arguments) || this;
    }

    var _proto5 = _class.prototype;

    _proto5.templateFor = function templateFor(_ref) {
      var cond = _ref.cond,
          truthy = _ref.truthy,
          falsy = _ref.falsy;
      return "{{#each " + cond + "}}" + truthy + "{{else}}" + falsy + "{{/each}}";
    };

    return _class;
  }(BasicEachTest));
  (0, _internalTestHelpers.moduleFor)('Syntax test: toggling {{#each as}}',
  /*#__PURE__*/
  function (_BasicEachTest2) {
    (0, _emberBabel.inheritsLoose)(_class2, _BasicEachTest2);

    function _class2() {
      return _BasicEachTest2.apply(this, arguments) || this;
    }

    var _proto6 = _class2.prototype;

    _proto6.templateFor = function templateFor(_ref2) {
      var cond = _ref2.cond,
          truthy = _ref2.truthy,
          falsy = _ref2.falsy;
      return "{{#each " + cond + " as |test|}}" + truthy + "{{else}}" + falsy + "{{/each}}";
    };

    return _class2;
  }(BasicEachTest));

  var EachEdgeCasesTest =
  /*#__PURE__*/
  function (_TogglingEachTest2) {
    (0, _emberBabel.inheritsLoose)(EachEdgeCasesTest, _TogglingEachTest2);

    function EachEdgeCasesTest() {
      return _TogglingEachTest2.apply(this, arguments) || this;
    }

    return EachEdgeCasesTest;
  }(TogglingEachTest);

  (0, _internalTestHelpers.applyMixins)(EachEdgeCasesTest, new _sharedConditionalTests.FalsyGenerator([true, 'hello', 1, Object, function () {}, {}, {
    foo: 'bar'
  }, Object.create(null), Object.create({}), Object.create({
    foo: 'bar'
  })]));
  (0, _internalTestHelpers.moduleFor)('Syntax test: toggling {{#each}}',
  /*#__PURE__*/
  function (_EachEdgeCasesTest) {
    (0, _emberBabel.inheritsLoose)(_class3, _EachEdgeCasesTest);

    function _class3() {
      return _EachEdgeCasesTest.apply(this, arguments) || this;
    }

    var _proto7 = _class3.prototype;

    _proto7.templateFor = function templateFor(_ref3) {
      var cond = _ref3.cond,
          truthy = _ref3.truthy,
          falsy = _ref3.falsy;
      return "{{#each " + cond + "}}" + truthy + "{{else}}" + falsy + "{{/each}}";
    };

    return _class3;
  }(EachEdgeCasesTest));
  (0, _internalTestHelpers.moduleFor)('Syntax test: toggling {{#each as}}',
  /*#__PURE__*/
  function (_EachEdgeCasesTest2) {
    (0, _emberBabel.inheritsLoose)(_class4, _EachEdgeCasesTest2);

    function _class4() {
      return _EachEdgeCasesTest2.apply(this, arguments) || this;
    }

    var _proto8 = _class4.prototype;

    _proto8.templateFor = function templateFor(_ref4) {
      var cond = _ref4.cond,
          truthy = _ref4.truthy,
          falsy = _ref4.falsy;
      return "{{#each " + cond + " as |test|}}" + truthy + "{{else}}" + falsy + "{{/each}}";
    };

    return _class4;
  }(EachEdgeCasesTest));

  var AbstractEachTest =
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(AbstractEachTest, _RenderingTestCase);

    function AbstractEachTest() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto9 = AbstractEachTest.prototype;
    /* abstract */

    _proto9.createList = function createList()
    /* items */
    {
      throw new Error('Not implemented: `createList`');
    };

    _proto9.makeList = function makeList(items) {
      var _this$createList = this.createList(items),
          list = _this$createList.list,
          delegate = _this$createList.delegate;

      this.list = list;
      this.delegate = delegate;
    };

    _proto9.replaceList = function replaceList(list) {
      var _this3 = this;

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'list', _this3.createList(list).list);
      });
    };

    _proto9.forEach = function forEach(callback) {
      return this.delegate.toArray().forEach(callback);
    };

    _proto9.objectAt = function objectAt(idx) {
      return this.delegate.objectAt(idx);
    };

    _proto9.clear = function clear() {
      return this.delegate.clear();
    };

    _proto9.replace = function replace(idx, del, ins) {
      return this.delegate.replace(idx, del, ins);
    };

    _proto9.unshiftObject = function unshiftObject(obj) {
      return this.delegate.unshiftObject(obj);
    };

    _proto9.unshiftObjects = function unshiftObjects(arr) {
      return this.delegate.unshiftObjects(arr);
    };

    _proto9.pushObject = function pushObject(obj) {
      return this.delegate.pushObject(obj);
    };

    _proto9.pushObjects = function pushObjects(arr) {
      return this.delegate.pushObjects(arr);
    };

    _proto9.shiftObject = function shiftObject() {
      return this.delegate.shiftObject();
    };

    _proto9.popObject = function popObject() {
      return this.delegate.popObject();
    };

    _proto9.insertAt = function insertAt(idx, obj) {
      return this.delegate.insertAt(idx, obj);
    };

    _proto9.removeAt = function removeAt(idx, len) {
      return this.delegate.removeAt(idx, len);
    };

    _proto9.render = function render(template) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.list !== undefined) {
        context.list = this.list;
      }

      return _RenderingTestCase.prototype.render.call(this, template, context);
    };

    return AbstractEachTest;
  }(_internalTestHelpers.RenderingTestCase);

  var EachTest =
  /*#__PURE__*/
  function (_AbstractEachTest) {
    (0, _emberBabel.inheritsLoose)(EachTest, _AbstractEachTest);

    function EachTest() {
      return _AbstractEachTest.apply(this, arguments) || this;
    }

    var _proto10 = EachTest.prototype;
    /* single each */

    _proto10['@test it repeats the given block for each item in the array'] = function testItRepeatsTheGivenBlockForEachItemInTheArray() {
      var _this4 = this;

      this.makeList([{
        text: 'hello'
      }]);
      this.render("{{#each list as |item|}}{{item.text}}{{else}}Empty{{/each}}");
      this.assertText('hello');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      this.assertText('hello');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.objectAt(0), 'text', 'Hello');
      });
      this.assertText('Hello');
      (0, _internalTestHelpers.runTask)(function () {
        _this4.pushObject({
          text: ' '
        });

        _this4.pushObject({
          text: 'World'
        });
      });
      this.assertText('Hello World');
      (0, _internalTestHelpers.runTask)(function () {
        _this4.pushObject({
          text: 'Earth'
        });

        _this4.removeAt(1);

        _this4.insertAt(1, {
          text: 'Globe'
        });
      });
      this.assertText('HelloGlobeWorldEarth');
      (0, _internalTestHelpers.runTask)(function () {
        _this4.pushObject({
          text: 'Planet'
        });

        _this4.removeAt(1);

        _this4.insertAt(1, {
          text: ' '
        });

        _this4.pushObject({
          text: ' '
        });

        _this4.pushObject({
          text: 'Earth'
        });

        _this4.removeAt(3);
      });
      this.assertText('Hello WorldPlanet Earth');
      (0, _internalTestHelpers.runTask)(function () {
        _this4.pushObject({
          text: 'Globe'
        });

        _this4.removeAt(1);

        _this4.insertAt(1, {
          text: ' '
        });

        _this4.pushObject({
          text: ' '
        });

        _this4.pushObject({
          text: 'World'
        });

        _this4.removeAt(2);
      });
      this.assertText('Hello Planet EarthGlobe World');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.replace(2, 4, [{
          text: 'my'
        }]);
      });
      this.assertText('Hello my World');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.clear();
      });
      this.assertText('Empty');
      this.replaceList([{
        text: 'hello'
      }]);
      this.assertText('hello');
    };

    _proto10['@test it receives the index as the second parameter'] = function testItReceivesTheIndexAsTheSecondParameter() {
      var _this5 = this;

      this.makeList([{
        text: 'hello'
      }, {
        text: 'world'
      }]);
      this.render("{{#each list as |item index|}}[{{index}}. {{item.text}}]{{/each}}");
      this.assertText('[0. hello][1. world]');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.insertAt(1, {
          text: 'my'
        });
      });
      this.assertText('[0. hello][1. my][2. world]');
      this.replaceList([{
        text: 'hello'
      }, {
        text: 'world'
      }]);
      this.assertText('[0. hello][1. world]');
    };

    _proto10['@test it accepts a string key'] = function testItAcceptsAStringKey() {
      var _this6 = this;

      this.makeList([{
        text: 'hello'
      }, {
        text: 'world'
      }]);
      this.render("{{#each list key='text' as |item|}}{{item.text}}{{/each}}");
      this.assertText('helloworld');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.pushObject({
          text: 'again'
        });
      });
      this.assertText('helloworldagain');
      this.replaceList([{
        text: 'hello'
      }, {
        text: 'world'
      }]);
      this.assertText('helloworld');
    };

    _proto10['@test it accepts a numeric key'] = function testItAcceptsANumericKey() {
      var _this7 = this;

      this.makeList([{
        id: 1
      }, {
        id: 2
      }]);
      this.render("{{#each list key='id' as |item|}}{{item.id}}{{/each}}");
      this.assertText('12');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.pushObject({
          id: 3
        });
      });
      this.assertText('123');
      this.replaceList([{
        id: 1
      }, {
        id: 2
      }]);
      this.assertText('12');
    };

    _proto10['@test it can specify @index as the key'] = function testItCanSpecifyIndexAsTheKey() {
      var _this8 = this;

      this.makeList([{
        id: 1
      }, {
        id: 2
      }]);
      this.render("{{#each list key='@index' as |item|}}{{item.id}}{{/each}}");
      this.assertText('12');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.pushObject({
          id: 3
        });
      });
      this.assertText('123');
      this.replaceList([{
        id: 1
      }, {
        id: 2
      }]);
      this.assertText('12');
    };

    _proto10['@test it can specify @identity as the key for arrays of primitives'] = function testItCanSpecifyIdentityAsTheKeyForArraysOfPrimitives() {
      var _this9 = this;

      this.makeList([1, 2]);
      this.render("{{#each list key='@identity' as |item|}}{{item}}{{/each}}");
      this.assertText('12');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.pushObject(3);
      });
      this.assertText('123');
      this.replaceList([1, 2]);
      this.assertText('12');
    };

    _proto10['@test it can specify @identity as the key for mixed arrays of objects and primitives'] = function testItCanSpecifyIdentityAsTheKeyForMixedArraysOfObjectsAndPrimitives() {
      var _this10 = this;

      this.makeList([1, {
        id: 2
      }, 3]);
      this.render("{{#each list key='@identity' as |item|}}{{if item.id item.id item}}{{/each}}");
      this.assertText('123');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.insertAt(2, {
          id: 4
        });
      });
      this.assertText('1243');
      this.replaceList([1, {
        id: 2
      }, 3]);
      this.assertText('123');
    };

    _proto10['@test it can render duplicate primitive items'] = function testItCanRenderDuplicatePrimitiveItems() {
      var _this11 = this;

      this.makeList(['a', 'a', 'a']);
      this.render("{{#each list as |item|}}{{item}}{{/each}}");
      this.assertText('aaa');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this11.pushObject('a');
      });
      this.assertText('aaaa');
      (0, _internalTestHelpers.runTask)(function () {
        return _this11.pushObject('a');
      });
      this.assertText('aaaaa');
      this.replaceList(['a', 'a', 'a']);
      this.assertText('aaa');
    };

    _proto10["@test updating and setting within #each"] = function () {
      var _this12 = this;

      this.makeList([{
        value: 1
      }, {
        value: 2
      }, {
        value: 3
      }]);

      var FooBarComponent = _helpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.isEven = true;
          this.tagName = 'li';
        },
        _isEven: function () {
          this.set('isEven', this.get('item.value') % 2 === 0);
        },
        didUpdate: function () {
          this._isEven();
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{#if isEven}}{{item.value}}{{/if}}'
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject()));
      this.assertText('Prev1NextPrev2NextPrev3Next');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.objectAt(0), 'value', 3);
      });
      this.assertText('PrevNextPrev2NextPrev3Next');
      this.replaceList([{
        value: 1
      }, {
        value: 2
      }, {
        value: 3
      }]);
      this.assertText('Prev1NextPrev2NextPrev3Next');
    };

    _proto10['@test it can render duplicate objects'] = function testItCanRenderDuplicateObjects() {
      var _this13 = this;

      var duplicateItem = {
        text: 'foo'
      };
      this.makeList([duplicateItem, duplicateItem, {
        text: 'bar'
      }, {
        text: 'baz'
      }]);
      this.render("{{#each list as |item|}}{{item.text}}{{/each}}");
      this.assertText('foofoobarbaz');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this13.pushObject(duplicateItem);
      });
      this.assertText('foofoobarbazfoo');
      (0, _internalTestHelpers.runTask)(function () {
        return _this13.pushObject(duplicateItem);
      });
      this.assertText('foofoobarbazfoofoo');
      this.replaceList([duplicateItem, duplicateItem, {
        text: 'bar'
      }, {
        text: 'baz'
      }]);
      this.assertText('foofoobarbaz');
    };

    _proto10["@test it maintains DOM stability when condition changes between objects with the same keys"] = function () {
      var _this14 = this;

      this.makeList([{
        text: 'Hello'
      }, {
        text: ' '
      }, {
        text: 'world'
      }]);
      this.render("{{#each list key=\"text\" as |item|}}{{item.text}}{{/each}}");
      this.assertText('Hello world');
      this.takeSnapshot();
      (0, _internalTestHelpers.runTask)(function () {
        _this14.popObject();

        _this14.popObject();

        _this14.pushObject({
          text: ' '
        });

        _this14.pushObject({
          text: 'world'
        });
      });
      this.assertText('Hello world');
      this.assertInvariants();
      this.replaceList([{
        text: 'Hello'
      }, {
        text: ' '
      }, {
        text: 'world'
      }]);
      this.assertText('Hello world');
      this.assertInvariants();
    };

    _proto10["@test it maintains DOM stability for stable keys when list is updated"] = function () {
      var _this15 = this;

      this.makeList([{
        text: 'Hello'
      }, {
        text: ' '
      }, {
        text: 'world'
      }]);
      this.render("{{#each list key=\"text\" as |item|}}{{item.text}}{{/each}}");
      this.assertText('Hello world');
      this.assertStableRerender();
      var oldSnapshot = this.takeSnapshot();
      (0, _internalTestHelpers.runTask)(function () {
        _this15.unshiftObject({
          text: ', '
        });

        _this15.unshiftObject({
          text: 'Hi'
        });

        _this15.pushObject({
          text: '!'
        });

        _this15.pushObject({
          text: 'earth'
        });
      });
      this.assertText('Hi, Hello world!earth');
      this.assertPartialInvariants(2, 5);
      this.replaceList([{
        text: 'Hello'
      }, {
        text: ' '
      }, {
        text: 'world'
      }]);
      this.assertText('Hello world');
      this.assertInvariants(oldSnapshot, this.takeSnapshot());
    };

    _proto10["@test it renders all items with duplicate key values"] = function () {
      var _this16 = this;

      this.makeList([{
        text: 'Hello'
      }, {
        text: 'Hello'
      }, {
        text: 'Hello'
      }]);
      this.render("{{#each list key=\"text\" as |item|}}{{item.text}}{{/each}}");
      this.assertText('HelloHelloHello');
      (0, _internalTestHelpers.runTask)(function () {
        _this16.forEach(function (hash) {
          return (0, _metal.set)(hash, 'text', 'Goodbye');
        });
      });
      this.assertText('GoodbyeGoodbyeGoodbye');
      this.replaceList([{
        text: 'Hello'
      }, {
        text: 'Hello'
      }, {
        text: 'Hello'
      }]);
      this.assertText('HelloHelloHello');
    };

    _proto10['@test context is not changed to the inner scope inside an {{#each as}} block'] = function testContextIsNotChangedToTheInnerScopeInsideAnEachAsBlock() {
      var _this17 = this;

      this.makeList([{
        name: 'Chad'
      }, {
        name: 'Zack'
      }, {
        name: 'Asa'
      }]);
      this.render("{{name}}-{{#each list as |person|}}{{name}}{{/each}}-{{name}}", {
        name: 'Joel'
      });
      this.assertText('Joel-JoelJoelJoel-Joel');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this17.shiftObject();
      });
      this.assertText('Joel-JoelJoel-Joel');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this17.context, 'name', 'Godfrey');
      });
      this.assertText('Godfrey-GodfreyGodfrey-Godfrey');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this17.context, 'name', 'Joel');
      });
      this.replaceList([{
        name: 'Chad'
      }, {
        name: 'Zack'
      }, {
        name: 'Asa'
      }]);
      this.assertText('Joel-JoelJoelJoel-Joel');
    };

    _proto10['@test can access the item and the original scope'] = function testCanAccessTheItemAndTheOriginalScope() {
      var _this18 = this;

      this.makeList([{
        name: 'Tom Dale'
      }, {
        name: 'Yehuda Katz'
      }, {
        name: 'Godfrey Chan'
      }]);
      this.render("{{#each list key=\"name\" as |person|}}[{{title}}: {{person.name}}]{{/each}}", {
        title: 'Seor Engineer'
      });
      this.assertText('[Seor Engineer: Tom Dale][Seor Engineer: Yehuda Katz][Seor Engineer: Godfrey Chan]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.rerender();
      });
      this.assertText('[Seor Engineer: Tom Dale][Seor Engineer: Yehuda Katz][Seor Engineer: Godfrey Chan]');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this18.objectAt(1), 'name', 'Stefan Penner');

        _this18.removeAt(0);

        _this18.pushObject({
          name: 'Tom Dale'
        });

        _this18.insertAt(1, {
          name: 'Chad Hietala'
        });

        (0, _metal.set)(_this18.context, 'title', 'Principal Engineer');
      });
      this.assertText('[Principal Engineer: Stefan Penner][Principal Engineer: Chad Hietala][Principal Engineer: Godfrey Chan][Principal Engineer: Tom Dale]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this18.context, 'title', 'Seor Engineer');
      });
      this.replaceList([{
        name: 'Tom Dale'
      }, {
        name: 'Yehuda Katz'
      }, {
        name: 'Godfrey Chan'
      }]);
      this.assertText('[Seor Engineer: Tom Dale][Seor Engineer: Yehuda Katz][Seor Engineer: Godfrey Chan]');
    };

    _proto10['@test the scoped variable is not available outside the {{#each}} block.'] = function testTheScopedVariableIsNotAvailableOutsideTheEachBlock() {
      var _this19 = this;

      this.makeList(['Yehuda']);
      this.render("{{name}}-{{#each list as |name|}}{{name}}{{/each}}-{{name}}", {
        name: 'Stef'
      });
      this.assertText('Stef-Yehuda-Stef');
      (0, _internalTestHelpers.runTask)(function () {
        return _this19.rerender();
      });
      this.assertText('Stef-Yehuda-Stef');
      (0, _internalTestHelpers.runTask)(function () {
        return _this19.pushObjects([' ', 'Katz']);
      });
      this.assertText('Stef-Yehuda Katz-Stef');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this19.context, 'name', 'Tom');
      });
      this.assertText('Tom-Yehuda Katz-Tom');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this19.context, 'name', 'Stef');
      });
      this.replaceList(['Yehuda']);
      this.assertText('Stef-Yehuda-Stef');
    };

    _proto10['@test inverse template is displayed with context'] = function testInverseTemplateIsDisplayedWithContext() {
      var _this20 = this;

      this.makeList([]);
      this.render("{{#each list as |thing|}}Has Thing{{else}}No Thing {{otherThing}}{{/each}}", {
        otherThing: 'bar'
      });
      this.assertText('No Thing bar');
      (0, _internalTestHelpers.runTask)(function () {
        return _this20.rerender();
      });
      this.assertText('No Thing bar');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this20.context, 'otherThing', 'biz');
      });
      this.assertText('No Thing biz');
      (0, _internalTestHelpers.runTask)(function () {
        return _this20.pushObject('non-empty');
      });
      this.assertText('Has Thing');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this20.context, 'otherThing', 'baz');
      });
      this.assertText('Has Thing');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this20.context, 'otherThing', 'bar');
      });
      this.replaceList([]);
      this.assertText('No Thing bar');
    };

    _proto10['@test content that are not initially present updates correctly GH#13983'] = function testContentThatAreNotInitiallyPresentUpdatesCorrectlyGH13983() {
      var _this21 = this; // The root cause of this bug is that Glimmer did not call `didInitializeChildren`
      // on the inserted `TryOpcode`, causing that `TryOpcode` to have an uninitialized
      // tag. Currently the only way to observe this the "JUMP-IF-NOT-MODIFIED", i.e. by
      // wrapping it in an component.


      this.registerComponent('x-wrapper', {
        template: '{{yield}}'
      });
      this.makeList([]);
      this.render("{{#x-wrapper}}{{#each list as |obj|}}[{{obj.text}}]{{/each}}{{/x-wrapper}}");
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return _this21.rerender();
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return _this21.pushObject({
          text: 'foo'
        });
      });
      this.assertText('[foo]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this21.objectAt(0), 'text', 'FOO');
      });
      this.assertText('[FOO]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this21.pushObject({
          text: 'bar'
        });
      });
      this.assertText('[FOO][bar]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this21.objectAt(1), 'text', 'BAR');
      });
      this.assertText('[FOO][BAR]');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this21.objectAt(1), 'text', 'baz');
      });
      this.assertText('[FOO][baz]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this21.replace(1, 1, [{
          text: 'BAZ'
        }]);
      });
      this.assertText('[FOO][BAZ]');
      this.replaceList([]);
      this.assertText('');
    };

    _proto10['@test empty trusted content clears properly [GH#16314]'] = function testEmptyTrustedContentClearsProperlyGH16314() {
      var _this22 = this;

      this.makeList(['hello']);
      this.render("before {{#each list as |value|}}{{{value}}}{{/each}} after");
      this.assertText('before hello after');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return _this22.pushObjects([null, ' world']);
      });
      this.assertText('before hello world after');
      (0, _internalTestHelpers.runTask)(function () {
        return _this22.replace(1, 2, [undefined, ' world!']);
      });
      this.assertText('before hello world! after');
      (0, _internalTestHelpers.runTask)(function () {
        return _this22.replace(1, 2, [(0, _helpers.htmlSafe)(''), ' world!!']);
      });
      this.assertText('before hello world!! after');
      this.replaceList(['hello']);
      this.assertText('before hello after');
    }
    /* multi each */
    ;

    _proto10['@test re-using the same variable with different {{#each}} blocks does not override each other'] = function testReUsingTheSameVariableWithDifferentEachBlocksDoesNotOverrideEachOther() {
      var _this23 = this;

      var admins = this.createList([{
        name: 'Tom Dale'
      }]);
      var users = this.createList([{
        name: 'Yehuda Katz'
      }]);
      this.render("Admin: {{#each admins key=\"name\" as |person|}}[{{person.name}}]{{/each}} User: {{#each users key=\"name\" as |person|}}[{{person.name}}]{{/each}}", {
        admins: admins.list,
        users: users.list
      });
      this.assertText('Admin: [Tom Dale] User: [Yehuda Katz]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this23.rerender();
      });
      this.assertText('Admin: [Tom Dale] User: [Yehuda Katz]');
      (0, _internalTestHelpers.runTask)(function () {
        admins.delegate.pushObject({
          name: 'Godfrey Chan'
        });
        (0, _metal.set)(users.delegate.objectAt(0), 'name', 'Stefan Penner');
      });
      this.assertText('Admin: [Tom Dale][Godfrey Chan] User: [Stefan Penner]');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this23.context, 'admins', _this23.createList([{
          name: 'Tom Dale'
        }]).list);
        (0, _metal.set)(_this23.context, 'users', _this23.createList([{
          name: 'Yehuda Katz'
        }]).list);
      });
      this.assertText('Admin: [Tom Dale] User: [Yehuda Katz]');
    };

    _proto10["@test an outer {{#each}}'s scoped variable does not clobber an inner {{#each}}'s property if they share the same name - Issue #1315"] = function () {
      var _this24 = this;

      var content = this.createList(['X', 'Y']);
      var options = this.createList([{
        label: 'One',
        value: 1
      }, {
        label: 'Two',
        value: 2
      }]);
      this.render((0, _internalTestHelpers.strip)(_templateObject2()), {
        content: content.list,
        options: options.list
      });
      this.assertText('X-1:One2:TwoY-1:One2:Two');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        content.delegate.pushObject('Z');
        (0, _metal.set)(options.delegate.objectAt(0), 'value', 0);
      });
      this.assertText('X-0:One2:TwoY-0:One2:TwoZ-0:One2:Two');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this24.context, 'content', _this24.createList(['X', 'Y']).list);
        (0, _metal.set)(_this24.context, 'options', _this24.createList([{
          label: 'One',
          value: 1
        }, {
          label: 'Two',
          value: 2
        }]).list);
      });
      this.assertText('X-1:One2:TwoY-1:One2:Two');
    };

    _proto10['@test the scoped variable is not available outside the {{#each}} block'] = function testTheScopedVariableIsNotAvailableOutsideTheEachBlock() {
      var _this25 = this;

      var first = this.createList(['Limbo']);
      var fifth = this.createList(['Wrath']);
      var ninth = this.createList(['Treachery']);
      this.render("{{ring}}-{{#each first as |ring|}}{{ring}}-{{#each fifth as |ring|}}{{ring}}-{{#each ninth as |ring|}}{{ring}}-{{/each}}{{ring}}-{{/each}}{{ring}}-{{/each}}{{ring}}", {
        ring: 'Greed',
        first: first.list,
        fifth: fifth.list,
        ninth: ninth.list
      });
      this.assertText('Greed-Limbo-Wrath-Treachery-Wrath-Limbo-Greed');
      (0, _internalTestHelpers.runTask)(function () {
        return _this25.rerender();
      });
      this.assertText('Greed-Limbo-Wrath-Treachery-Wrath-Limbo-Greed');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this25.context, 'ring', 'O');
        fifth.delegate.insertAt(0, 'D');
      });
      this.assertText('O-Limbo-D-Treachery-D-Wrath-Treachery-Wrath-Limbo-O');
      (0, _internalTestHelpers.runTask)(function () {
        first.delegate.pushObject('I');
        ninth.delegate.replace(0, 1, ['K']);
      });
      this.assertText('O-Limbo-D-K-D-Wrath-K-Wrath-Limbo-I-D-K-D-Wrath-K-Wrath-I-O');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this25.context, 'ring', 'Greed');
        (0, _metal.set)(_this25.context, 'first', _this25.createList(['Limbo']).list);
        (0, _metal.set)(_this25.context, 'fifth', _this25.createList(['Wrath']).list);
        (0, _metal.set)(_this25.context, 'ninth', _this25.createList(['Treachery']).list);
      });
      this.assertText('Greed-Limbo-Wrath-Treachery-Wrath-Limbo-Greed');
    };

    _proto10['@test it should support {{#each name as |foo|}}, then {{#each foo as |bar|}}'] = function testItShouldSupportEachNameAsFooThenEachFooAsBar() {
      var _this26 = this;

      var inner = this.createList(['caterpillar']);
      var outer = this.createList([inner.list]);
      this.render("{{#each name key=\"@index\" as |foo|}}{{#each foo as |bar|}}{{bar}}{{/each}}{{/each}}", {
        name: outer.list
      });
      this.assertText('caterpillar');
      (0, _internalTestHelpers.runTask)(function () {
        return _this26.rerender();
      });
      this.assertText('caterpillar');
      (0, _internalTestHelpers.runTask)(function () {
        inner.delegate.replace(0, 1, ['lady']);
        outer.delegate.pushObject(_this26.createList(['bird']).list);
      });
      this.assertText('ladybird');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this26.context, 'name', _this26.createList([_this26.createList(['caterpillar']).list]).list);
      });
      this.assertText('caterpillar');
    };

    return EachTest;
  }(AbstractEachTest);

  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with native arrays',
  /*#__PURE__*/
  function (_EachTest) {
    (0, _emberBabel.inheritsLoose)(_class5, _EachTest);

    function _class5() {
      return _EachTest.apply(this, arguments) || this;
    }

    var _proto11 = _class5.prototype;

    _proto11.createList = function createList(items) {
      return {
        list: items,
        delegate: new ArrayDelegate(items, items)
      };
    };

    return _class5;
  }(EachTest));
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with emberA-wrapped arrays',
  /*#__PURE__*/
  function (_EachTest2) {
    (0, _emberBabel.inheritsLoose)(_class6, _EachTest2);

    function _class6() {
      return _EachTest2.apply(this, arguments) || this;
    }

    var _proto12 = _class6.prototype;

    _proto12.createList = function createList(items) {
      var wrapped = (0, _runtime.A)(items);
      return {
        list: wrapped,
        delegate: wrapped
      };
    };

    return _class6;
  }(EachTest));
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with native Set',
  /*#__PURE__*/
  function (_EachTest3) {
    (0, _emberBabel.inheritsLoose)(_class7, _EachTest3);

    function _class7() {
      return _EachTest3.apply(this, arguments) || this;
    }

    var _proto13 = _class7.prototype;

    _proto13.createList = function createList(items) {
      var set = makeSet(items);
      return {
        list: set,
        delegate: new SetDelegate(set)
      };
    };

    _proto13['@test it can render duplicate primitive items'] = function testItCanRenderDuplicatePrimitiveItems(assert) {
      assert.ok(true, 'not supported by Set');
    };

    _proto13['@test it can render duplicate objects'] = function testItCanRenderDuplicateObjects(assert) {
      assert.ok(true, 'not supported by Set');
    };

    return _class7;
  }(EachTest));
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with array-like objects implementing forEach',
  /*#__PURE__*/
  function (_EachTest4) {
    (0, _emberBabel.inheritsLoose)(_class8, _EachTest4);

    function _class8() {
      return _EachTest4.apply(this, arguments) || this;
    }

    var _proto14 = _class8.prototype;

    _proto14.createList = function createList(items) {
      var forEachable = new ForEachable(items);
      return {
        list: forEachable,
        delegate: forEachable
      };
    };

    return _class8;
  }(EachTest));

  if (_utils.HAS_NATIVE_SYMBOL) {
    (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with array-like objects implementing Symbol.iterator',
    /*#__PURE__*/
    function (_EachTest5) {
      (0, _emberBabel.inheritsLoose)(_class9, _EachTest5);

      function _class9() {
        return _EachTest5.apply(this, arguments) || this;
      }

      var _proto15 = _class9.prototype;

      _proto15.createList = function createList(items) {
        var iterable = new ArrayIterable(items);
        return {
          list: iterable,
          delegate: iterable
        };
      };

      return _class9;
    }(EachTest));
  }

  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with array proxies, modifying itself',
  /*#__PURE__*/
  function (_EachTest6) {
    (0, _emberBabel.inheritsLoose)(_class10, _EachTest6);

    function _class10() {
      return _EachTest6.apply(this, arguments) || this;
    }

    var _proto16 = _class10.prototype;

    _proto16.createList = function createList(items) {
      var proxty = _runtime.ArrayProxy.create({
        content: (0, _runtime.A)(items)
      });

      return {
        list: proxty,
        delegate: proxty
      };
    };

    return _class10;
  }(EachTest));
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with array proxies, replacing its content',
  /*#__PURE__*/
  function (_EachTest7) {
    (0, _emberBabel.inheritsLoose)(_class11, _EachTest7);

    function _class11() {
      return _EachTest7.apply(this, arguments) || this;
    }

    var _proto17 = _class11.prototype;

    _proto17.createList = function createList(items) {
      var wrapped = (0, _runtime.A)(items);
      return {
        list: wrapped,
        delegate: _runtime.ArrayProxy.create({
          content: wrapped
        })
      };
    };

    return _class11;
  }(EachTest));
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each as}} undefined path',
  /*#__PURE__*/
  function (_RenderingTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class12, _RenderingTestCase2);

    function _class12() {
      return _RenderingTestCase2.apply(this, arguments) || this;
    }

    var _proto18 = _class12.prototype;

    _proto18['@test keying off of `undefined` does not render'] = function testKeyingOffOfUndefinedDoesNotRender() {
      var _this27 = this;

      this.render((0, _internalTestHelpers.strip)(_templateObject3()), {
        foo: {}
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return _this27.rerender();
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this27.context, 'foo', {
          bar: {
            baz: ['Here!']
          }
        });
      });
      this.assertText('Here!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this27.context, 'foo', {});
      });
      this.assertText('');
    };

    return _class12;
  }(_internalTestHelpers.RenderingTestCase));
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each}} with sparse arrays',
  /*#__PURE__*/
  function (_RenderingTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class13, _RenderingTestCase3);

    function _class13() {
      return _RenderingTestCase3.apply(this, arguments) || this;
    }

    var _proto19 = _class13.prototype;

    _proto19['@test it should itterate over holes'] = function testItShouldItterateOverHoles() {
      var _this28 = this;

      var sparseArray = [];
      sparseArray[3] = 'foo';
      sparseArray[4] = 'bar';
      this.render((0, _internalTestHelpers.strip)(_templateObject4()), {
        list: (0, _runtime.A)(sparseArray)
      });
      this.assertText('[0:][1:][2:][3:foo][4:bar]');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        var list = (0, _metal.get)(_this28.context, 'list');
        list.pushObject('baz');
      });
      this.assertText('[0:][1:][2:][3:foo][4:bar][5:baz]');
    };

    return _class13;
  }(_internalTestHelpers.RenderingTestCase));
  /* globals MutationObserver: false */

  if (typeof MutationObserver === 'function') {
    (0, _internalTestHelpers.moduleFor)('Syntax test: {{#each as}} DOM mutation test',
    /*#__PURE__*/
    function (_RenderingTestCase4) {
      (0, _emberBabel.inheritsLoose)(_class14, _RenderingTestCase4);

      function _class14() {
        var _this29;

        _this29 = _RenderingTestCase4.apply(this, arguments) || this;
        _this29.observer = null;
        return _this29;
      }

      var _proto20 = _class14.prototype;

      _proto20.observe = function observe(element) {
        var observer = this.observer = new MutationObserver(function () {});
        observer.observe(element, {
          childList: true,
          characterData: true
        });
      };

      _proto20.teardown = function teardown() {
        if (this.observer) {
          this.observer.disconnect();
        }

        _RenderingTestCase4.prototype.teardown.call(this);
      };

      _proto20.assertNoMutation = function assertNoMutation() {
        this.assert.deepEqual(this.observer.takeRecords(), [], 'Expected no mutations');
      };

      _proto20.expectMutations = function expectMutations() {
        this.assert.ok(this.observer.takeRecords().length > 0, 'Expected some mutations');
      };

      _proto20['@test {{#each}} should not mutate a subtree when the array has not changed [GH #14332]'] = function testEachShouldNotMutateASubtreeWhenTheArrayHasNotChangedGH14332() {
        var _this30 = this;

        var page = {
          title: 'Blog Posts'
        };
        var model = [{
          title: 'Rails is omakase'
        }, {
          title: 'Ember is omakase'
        }];
        this.render((0, _internalTestHelpers.strip)(_templateObject5()), {
          page: page,
          model: model
        });
        this.assertHTML((0, _internalTestHelpers.strip)(_templateObject6()));
        this.observe(this.$('#posts')[0]); // MutationObserver is async

        return _runtime.RSVP.Promise.resolve(function () {
          _this30.assertStableRerender();
        }).then(function () {
          _this30.assertNoMutation();

          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this30.context, 'page', {
              title: 'Essays'
            });
          });

          _this30.assertHTML((0, _internalTestHelpers.strip)(_templateObject7()));
        }).then(function () {
          _this30.assertNoMutation();

          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this30.context.page, 'title', 'Think Pieces');
          });

          _this30.assertHTML((0, _internalTestHelpers.strip)(_templateObject8()));
        }).then(function () {
          // The last set is localized to the `page` object, so we do not expect Glimmer
          // to re-iterate the list
          _this30.assertNoMutation();
        });
      };

      return _class14;
    }(_internalTestHelpers.RenderingTestCase));
  }
});
enifed("@ember/-internals/glimmer/tests/integration/syntax/experimental-syntax-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/glimmer"], function (_emberBabel, _internalTestHelpers, _glimmer) {
  "use strict";

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#-let obj as |bar|}}\n        {{bar}}\n      {{/-let}}\n    "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('registerMacros',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      var _this;

      var originalMacros = _glimmer._experimentalMacros.slice();

      (0, _glimmer._registerMacros)(function (blocks) {
        blocks.add('-let', function (params, hash, _default, inverse, builder) {
          builder.compileParams(params);
          builder.invokeStaticBlock(_default, params.length);
        });
      });
      _this = _RenderingTestCase.apply(this, arguments) || this;
      _this.originalMacros = originalMacros;
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _glimmer._experimentalMacros.length = 0;
      this.originalMacros.forEach(function (macro) {
        return _glimmer._experimentalMacros.push(macro);
      });

      _RenderingTestCase.prototype.teardown.call(this);
    };

    _proto['@test allows registering custom syntax via private API'] = function testAllowsRegisteringCustomSyntaxViaPrivateAPI() {
      this.render((0, _internalTestHelpers.strip)(_templateObject()), {
        obj: 'hello world!'
      });
      this.assertText('hello world!');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/syntax/if-unless-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers", "@ember/-internals/glimmer/tests/utils/shared-conditional-tests"], function (_emberBabel, _internalTestHelpers, _runtime, _metal, _helpers, _sharedConditionalTests) {
  "use strict";

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#if foo.bar.baz}}\n        Here!\n      {{else}}\n        Nothing Here!\n      {{/if}}"]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#if cond}}\n        {{#each numbers as |number|}}\n          {{foo-bar number=number}}\n        {{/each}}\n      {{else}}\n        Nothing Here!\n      {{/if}}"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#if}} with inverse',
  /*#__PURE__*/
  function (_IfUnlessWithSyntaxTe) {
    (0, _emberBabel.inheritsLoose)(_class, _IfUnlessWithSyntaxTe);

    function _class() {
      return _IfUnlessWithSyntaxTe.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.templateFor = function templateFor(_ref) {
      var cond = _ref.cond,
          truthy = _ref.truthy,
          falsy = _ref.falsy;
      return "{{#if " + cond + "}}" + truthy + "{{else}}" + falsy + "{{/if}}";
    };

    return _class;
  }(_sharedConditionalTests.IfUnlessWithSyntaxTest));
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#unless}} with inverse',
  /*#__PURE__*/
  function (_IfUnlessWithSyntaxTe2) {
    (0, _emberBabel.inheritsLoose)(_class2, _IfUnlessWithSyntaxTe2);

    function _class2() {
      return _IfUnlessWithSyntaxTe2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2.templateFor = function templateFor(_ref2) {
      var cond = _ref2.cond,
          truthy = _ref2.truthy,
          falsy = _ref2.falsy;
      return "{{#unless " + cond + "}}" + falsy + "{{else}}" + truthy + "{{/unless}}";
    };

    return _class2;
  }(_sharedConditionalTests.IfUnlessWithSyntaxTest));
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#if}} and {{#unless}} without inverse',
  /*#__PURE__*/
  function (_IfUnlessWithSyntaxTe3) {
    (0, _emberBabel.inheritsLoose)(_class3, _IfUnlessWithSyntaxTe3);

    function _class3() {
      return _IfUnlessWithSyntaxTe3.apply(this, arguments) || this;
    }

    var _proto3 = _class3.prototype;

    _proto3.templateFor = function templateFor(_ref3) {
      var cond = _ref3.cond,
          truthy = _ref3.truthy,
          falsy = _ref3.falsy;
      return "{{#if " + cond + "}}" + truthy + "{{/if}}{{#unless " + cond + "}}" + falsy + "{{/unless}}";
    };

    return _class3;
  }(_sharedConditionalTests.IfUnlessWithSyntaxTest));
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#if}}',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class4, _RenderingTestCase);

    function _class4() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto4 = _class4.prototype;

    _proto4['@test using `if` with an `{{each}}` destroys components when transitioning to and from inverse (GH #12267)'] = function testUsingIfWithAnEachDestroysComponentsWhenTransitioningToAndFromInverseGH12267(assert) {
      var _this = this;

      var destroyedChildrenCount = 0;
      this.registerComponent('foo-bar', {
        template: '{{number}}',
        ComponentClass: _helpers.Component.extend({
          willDestroy: function () {
            this._super();

            destroyedChildrenCount++;
          }
        })
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject()), {
        cond: true,
        numbers: (0, _runtime.A)([1, 2, 3])
      });
      this.assertText('123');
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertText('123');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'cond', false);
      });
      this.assertText('Nothing Here!');
      assert.equal(destroyedChildrenCount, 3, 'the children were properly destroyed');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'cond', true);
      });
      this.assertText('123');
    };

    _proto4['@test looking up `undefined` property defaults to false'] = function testLookingUpUndefinedPropertyDefaultsToFalse() {
      var _this2 = this;

      this.render((0, _internalTestHelpers.strip)(_templateObject2()), {
        foo: {}
      });
      this.assertText('Nothing Here!');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertText('Nothing Here!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'foo', {
          bar: {
            baz: true
          }
        });
      });
      this.assertText('Here!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'foo', {});
      });
      this.assertText('Nothing Here!');
    };

    return _class4;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/syntax/in-element-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/glimmer", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _glimmer, _metal) {
  "use strict";

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#if showModal}}\n        {{#-in-element someElement}}\n          {{modal-display text=text}}\n        {{/-in-element}}\n      {{/if}}\n    "]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#-in-element someElement}}\n        {{text}}\n      {{/-in-element}}\n    "]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["{{#in-element el}}{{/in-element}}"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('{{-in-element}}',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test using {{#in-element whatever}} asserts'] = function testUsingInElementWhateverAsserts() {
      var _this = this; // the in-element keyword is not yet public API this test should be removed
      // once https://github.com/emberjs/rfcs/pull/287 lands and is enabled


      var el = document.createElement('div');
      expectAssertion(function () {
        _this.render((0, _internalTestHelpers.strip)(_templateObject()), {
          el: el
        });
      }, /The {{in-element}} helper cannot be used. \('-top-level' @ L1:C0\)/);
    };

    _proto['@test allows rendering into an external element'] = function testAllowsRenderingIntoAnExternalElement() {
      var _this2 = this;

      var someElement = document.createElement('div');
      this.render((0, _internalTestHelpers.strip)(_templateObject2()), {
        someElement: someElement,
        text: 'Whoop!'
      });
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      (0, _internalTestHelpers.equalTokens)(someElement, 'Whoop!');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'text', 'Huzzah!!');
      });
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      (0, _internalTestHelpers.equalTokens)(someElement, 'Huzzah!!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'text', 'Whoop!');
      });
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      (0, _internalTestHelpers.equalTokens)(someElement, 'Whoop!');
    };

    _proto['@test components are cleaned up properly'] = function testComponentsAreCleanedUpProperly(assert) {
      var _this3 = this;

      var hooks = [];
      var someElement = document.createElement('div');
      this.registerComponent('modal-display', {
        ComponentClass: _glimmer.Component.extend({
          didInsertElement: function () {
            hooks.push('didInsertElement');
          },
          willDestroyElement: function () {
            hooks.push('willDestroyElement');
          }
        }),
        template: "{{text}}"
      });
      this.render((0, _internalTestHelpers.strip)(_templateObject3()), {
        someElement: someElement,
        text: 'Whoop!',
        showModal: false
      });
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      (0, _internalTestHelpers.equalTokens)(someElement, '');
      this.assertStableRerender();
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'showModal', true);
      });
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      this.assertComponentElement(someElement.firstChild, {
        content: 'Whoop!'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'text', 'Huzzah!');
      });
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      this.assertComponentElement(someElement.firstChild, {
        content: 'Huzzah!'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'text', 'Whoop!');
      });
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      this.assertComponentElement(someElement.firstChild, {
        content: 'Whoop!'
      });
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'showModal', false);
      });
      (0, _internalTestHelpers.equalTokens)(this.element, '<!---->');
      (0, _internalTestHelpers.equalTokens)(someElement, '');
      assert.deepEqual(hooks, ['didInsertElement', 'willDestroyElement']);
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/syntax/let-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/runtime"], function (_emberBabel, _internalTestHelpers, _metal, _runtime) {
  "use strict";

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n        {{name}}\n        {{#let committer1.name as |name|}}\n          [{{name}}\n          {{#let committer2.name as |name|}}\n            [{{name}}]\n          {{/let}}\n          {{name}}]\n        {{/let}}\n        {{name}}\n        {{#let committer2.name as |name|}}\n          [{{name}}\n          {{#let committer1.name as |name|}}\n            [{{name}}]\n          {{/let}}\n          {{name}}]\n        {{/let}}\n        {{name}}\n      "]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#let foo.bar.baz as |thing|}}\n          value: \"{{thing}}\"\n        {{/let}}"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#let as}}',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.templateFor = function templateFor(_ref) {
      var cond = _ref.cond,
          truthy = _ref.truthy,
          falsy = _ref.falsy;
      return "{{#let " + cond + " as |test|}}" + truthy + "{{else}}" + falsy + "{{/let}}";
    };

    _proto['@test it renders the block if `undefined` is passed as an argument'] = function testItRendersTheBlockIfUndefinedIsPassedAsAnArgument() {
      var _this = this;

      this.render((0, _internalTestHelpers.strip)(_templateObject()), {
        foo: {}
      });
      this.assertText('value: ""');
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertText('value: ""');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'foo', {
          bar: {
            baz: 'Here!'
          }
        });
      });
      this.assertText('value: "Here!"');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'foo', {});
      });
      this.assertText('value: ""');
    };

    _proto['@test it renders the block if arguments are falsey'] = function testItRendersTheBlockIfArgumentsAreFalsey() {
      var _this2 = this;

      this.render("{{#let cond1 cond2 as |cond|}}value: \"{{cond1}}\"{{/let}}", {
        cond1: false
      });
      this.assertText('value: "false"');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertText('value: "false"');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'cond1', '');
      });
      this.assertText('value: ""');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'cond1', 0);
      });
      this.assertText('value: "0"');
    };

    _proto['@test it yields multiple arguments in order'] = function testItYieldsMultipleArgumentsInOrder() {
      var _this3 = this;

      this.render("{{#let foo bar baz.name as |a b c|}}{{a}} {{b}} {{c}}{{/let}}", {
        foo: 'Seor Engineer',
        bar: '',
        baz: {
          name: 'Dale'
        }
      });
      this.assertText('Seor Engineer  Dale');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'bar', 'Tom');
      });
      this.assertText('Seor Engineer Tom Dale');
    };

    _proto['@test can access alias and original scope'] = function testCanAccessAliasAndOriginalScope() {
      var _this4 = this;

      this.render("{{#let person as |tom|}}{{title}}: {{tom.name}}{{/let}}", {
        title: 'Seor Engineer',
        person: {
          name: 'Tom Dale'
        }
      });
      this.assertText('Seor Engineer: Tom Dale');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      this.assertText('Seor Engineer: Tom Dale');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this4.context, 'person.name', 'Yehuda Katz');
        (0, _metal.set)(_this4.context, 'title', 'Principal Engineer');
      });
      this.assertText('Principal Engineer: Yehuda Katz');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this4.context, 'person', {
          name: 'Tom Dale'
        });
        (0, _metal.set)(_this4.context, 'title', 'Seor Engineer');
      });
      this.assertText('Seor Engineer: Tom Dale');
    };

    _proto['@test the scoped variable is not available outside the {{#let}} block.'] = function testTheScopedVariableIsNotAvailableOutsideTheLetBlock() {
      var _this5 = this;

      this.render("{{name}}-{{#let other as |name|}}{{name}}{{/let}}-{{name}}", {
        name: 'Stef',
        other: 'Yehuda'
      });
      this.assertText('Stef-Yehuda-Stef');
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.rerender();
      });
      this.assertText('Stef-Yehuda-Stef');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'other', 'Chad');
      });
      this.assertText('Stef-Chad-Stef');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'name', 'Tom');
      });
      this.assertText('Tom-Chad-Tom');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this5.context, 'name', 'Stef');
        (0, _metal.set)(_this5.context, 'other', 'Yehuda');
      });
      this.assertText('Stef-Yehuda-Stef');
    };

    _proto['@test can access alias of a proxy'] = function testCanAccessAliasOfAProxy() {
      var _this6 = this;

      this.render("{{#let proxy as |person|}}{{person.name}}{{/let}}", {
        proxy: _runtime.ObjectProxy.create({
          content: {
            name: 'Tom Dale'
          }
        })
      });
      this.assertText('Tom Dale');
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.rerender();
      });
      this.assertText('Tom Dale');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'proxy.name', 'Yehuda Katz');
      });
      this.assertText('Yehuda Katz');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'proxy.content', {
          name: 'Godfrey Chan'
        });
      });
      this.assertText('Godfrey Chan');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'proxy.content.name', 'Stefan Penner');
      });
      this.assertText('Stefan Penner');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'proxy.content', null);
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'proxy', _runtime.ObjectProxy.create({
          content: {
            name: 'Tom Dale'
          }
        }));
      });
      this.assertText('Tom Dale');
    };

    _proto['@test can access alias of an array'] = function testCanAccessAliasOfAnArray() {
      var _this7 = this;

      this.render("{{#let arrayThing as |words|}}{{#each words as |word|}}{{word}}{{/each}}{{/let}}", {
        arrayThing: (0, _runtime.A)(['Hello', ' ', 'world'])
      });
      this.assertText('Hello world');
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.rerender();
      });
      this.assertText('Hello world');
      (0, _internalTestHelpers.runTask)(function () {
        var array = (0, _metal.get)(_this7.context, 'arrayThing');
        array.replace(0, 1, ['Goodbye']);
        (0, _runtime.removeAt)(array, 1);
        array.insertAt(1, ', ');
        array.pushObject('!');
      });
      this.assertText('Goodbye, world!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'arrayThing', ['Hello', ' ', 'world']);
      });
      this.assertText('Hello world');
    };

    _proto['@test `attrs` can be used as a block param [GH#14678]'] = function testAttrsCanBeUsedAsABlockParamGH14678() {
      var _this8 = this;

      this.render('{{#let hash as |attrs|}}[{{hash.foo}}-{{attrs.foo}}]{{/let}}', {
        hash: {
          foo: 'foo'
        }
      });
      this.assertText('[foo-foo]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.rerender();
      });
      this.assertText('[foo-foo]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.context.set('hash.foo', 'FOO');
      });
      this.assertText('[FOO-FOO]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.context.set('hash.foo', 'foo');
      });
      this.assertText('[foo-foo]');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
  (0, _internalTestHelpers.moduleFor)('Syntax test: Multiple {{#let as}} helpers',
  /*#__PURE__*/
  function (_RenderingTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _RenderingTestCase2);

    function _class2() {
      return _RenderingTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test re-using the same variable with different {{#let}} blocks does not override each other'] = function testReUsingTheSameVariableWithDifferentLetBlocksDoesNotOverrideEachOther() {
      var _this9 = this;

      this.render("Admin: {{#let admin as |person|}}{{person.name}}{{/let}} User: {{#let user as |person|}}{{person.name}}{{/let}}", {
        admin: {
          name: 'Tom Dale'
        },
        user: {
          name: 'Yehuda Katz'
        }
      });
      this.assertText('Admin: Tom Dale User: Yehuda Katz');
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.rerender();
      });
      this.assertText('Admin: Tom Dale User: Yehuda Katz');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this9.context, 'admin.name', 'Godfrey Chan');
        (0, _metal.set)(_this9.context, 'user.name', 'Stefan Penner');
      });
      this.assertText('Admin: Godfrey Chan User: Stefan Penner');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this9.context, 'admin', {
          name: 'Tom Dale'
        });
        (0, _metal.set)(_this9.context, 'user', {
          name: 'Yehuda Katz'
        });
      });
      this.assertText('Admin: Tom Dale User: Yehuda Katz');
    };

    _proto2['@test the scoped variable is not available outside the {{#let}} block'] = function testTheScopedVariableIsNotAvailableOutsideTheLetBlock() {
      var _this10 = this;

      this.render("{{ring}}-{{#let first as |ring|}}{{ring}}-{{#let fifth as |ring|}}{{ring}}-{{#let ninth as |ring|}}{{ring}}-{{/let}}{{ring}}-{{/let}}{{ring}}-{{/let}}{{ring}}", {
        ring: 'Greed',
        first: 'Limbo',
        fifth: 'Wrath',
        ninth: 'Treachery'
      });
      this.assertText('Greed-Limbo-Wrath-Treachery-Wrath-Limbo-Greed');
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.rerender();
      });
      this.assertText('Greed-Limbo-Wrath-Treachery-Wrath-Limbo-Greed');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this10.context, 'ring', 'O');
        (0, _metal.set)(_this10.context, 'fifth', 'D');
      });
      this.assertText('O-Limbo-D-Treachery-D-Limbo-O');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this10.context, 'first', 'I');
        (0, _metal.set)(_this10.context, 'ninth', 'K');
      });
      this.assertText('O-I-D-K-D-I-O');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this10.context, 'ring', 'Greed');
        (0, _metal.set)(_this10.context, 'first', 'Limbo');
        (0, _metal.set)(_this10.context, 'fifth', 'Wrath');
        (0, _metal.set)(_this10.context, 'ninth', 'Treachery');
      });
      this.assertText('Greed-Limbo-Wrath-Treachery-Wrath-Limbo-Greed');
    };

    _proto2['@test it should support {{#let name as |foo|}}, then {{#let foo as |bar|}}'] = function testItShouldSupportLetNameAsFooThenLetFooAsBar() {
      var _this11 = this;

      this.render("{{#let name as |foo|}}{{#let foo as |bar|}}{{bar}}{{/let}}{{/let}}", {
        name: 'caterpillar'
      });
      this.assertText('caterpillar');
      (0, _internalTestHelpers.runTask)(function () {
        return _this11.rerender();
      });
      this.assertText('caterpillar');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'name', 'butterfly');
      });
      this.assertText('butterfly');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'name', 'caterpillar');
      });
      this.assertText('caterpillar');
    };

    _proto2['@test updating the context should update the alias'] = function testUpdatingTheContextShouldUpdateTheAlias() {
      var _this12 = this;

      this.render("{{#let this as |person|}}{{person.name}}{{/let}}", {
        name: 'Los Pivots'
      });
      this.assertText('Los Pivots');
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.rerender();
      });
      this.assertText('Los Pivots');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'name', "l'Pivots");
      });
      this.assertText("l'Pivots");
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'name', 'Los Pivots');
      });
      this.assertText('Los Pivots');
    };

    _proto2['@test nested {{#let}} blocks should have access to root context'] = function testNestedLetBlocksShouldHaveAccessToRootContext() {
      var _this13 = this;

      this.render((0, _internalTestHelpers.strip)(_templateObject2()), {
        name: 'ebryn',
        committer1: {
          name: 'trek'
        },
        committer2: {
          name: 'machty'
        }
      });
      this.assertText('ebryn[trek[machty]trek]ebryn[machty[trek]machty]ebryn');
      (0, _internalTestHelpers.runTask)(function () {
        return _this13.rerender();
      });
      this.assertText('ebryn[trek[machty]trek]ebryn[machty[trek]machty]ebryn');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'name', 'chancancode');
      });
      this.assertText('chancancode[trek[machty]trek]chancancode[machty[trek]machty]chancancode');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'committer1', {
          name: 'krisselden'
        });
      });
      this.assertText('chancancode[krisselden[machty]krisselden]chancancode[machty[krisselden]machty]chancancode');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this13.context, 'committer1.name', 'wycats');
        (0, _metal.set)(_this13.context, 'committer2', {
          name: 'rwjblue'
        });
      });
      this.assertText('chancancode[wycats[rwjblue]wycats]chancancode[rwjblue[wycats]rwjblue]chancancode');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this13.context, 'name', 'ebryn');
        (0, _metal.set)(_this13.context, 'committer1', {
          name: 'trek'
        });
        (0, _metal.set)(_this13.context, 'committer2', {
          name: 'machty'
        });
      });
      this.assertText('ebryn[trek[machty]trek]ebryn[machty[trek]machty]ebryn');
    };

    return _class2;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/syntax/with-dynamic-var-test", ["ember-babel", "internal-test-helpers"], function (_emberBabel, _internalTestHelpers) {
  "use strict";

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#-with-dynamic-vars outletState=\"bar\"}}\n        {{-get-dynamic-var 'outletState'}}\n      {{/-with-dynamic-vars}}\n    "]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n        {{#-with-dynamic-vars foo=\"bar\"}}\n          {{-get-dynamic-var 'foo'}}\n        {{/-with-dynamic-vars}}\n      "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('{{-with-dynamic-var}}',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test does not allow setting values other than outletState'] = function testDoesNotAllowSettingValuesOtherThanOutletState() {
      var _this = this;

      expectAssertion(function () {
        _this.render((0, _internalTestHelpers.strip)(_templateObject()));
      }, /Using `-with-dynamic-scope` is only supported for `outletState` \(you used `foo`\)./);
    };

    _proto['@test allows setting/getting outletState'] = function testAllowsSettingGettingOutletState() {
      // this is simply asserting that we can write and read outletState
      // the actual value being used here is not what is used in real life
      // feel free to change the value being set and asserted as needed
      this.render((0, _internalTestHelpers.strip)(_templateObject2()));
      this.assertText('bar');
    };

    _proto['@test does not allow setting values other than outletState'] = function testDoesNotAllowSettingValuesOtherThanOutletState() {
      var _this2 = this;

      expectAssertion(function () {
        _this2.render("{{-get-dynamic-var 'foo'}}");
      }, /Using `-get-dynamic-scope` is only supported for `outletState` \(you used `foo`\)./);
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/integration/syntax/with-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/runtime", "@ember/-internals/glimmer/tests/utils/shared-conditional-tests"], function (_emberBabel, _internalTestHelpers, _metal, _runtime, _sharedConditionalTests) {
  "use strict";

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["\n      {{name}}\n      {{#with committer1.name as |name|}}\n        [{{name}}\n        {{#with committer2.name as |name|}}\n          [{{name}}]\n        {{/with}}\n        {{name}}]\n      {{/with}}\n      {{name}}\n      {{#with committer2.name as |name|}}\n        [{{name}}\n        {{#with committer1.name as |name|}}\n          [{{name}}]\n        {{/with}}\n        {{name}}]\n      {{/with}}\n      {{name}}\n    "]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n      {{#with foo.bar.baz as |thing|}}\n        {{thing}}\n      {{/with}}"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#with}}',
  /*#__PURE__*/
  function (_IfUnlessWithSyntaxTe) {
    (0, _emberBabel.inheritsLoose)(_class, _IfUnlessWithSyntaxTe);

    function _class() {
      return _IfUnlessWithSyntaxTe.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.templateFor = function templateFor(_ref) {
      var cond = _ref.cond,
          truthy = _ref.truthy,
          falsy = _ref.falsy;
      return "{{#with " + cond + "}}" + truthy + "{{else}}" + falsy + "{{/with}}";
    };

    return _class;
  }(_sharedConditionalTests.IfUnlessWithSyntaxTest));
  (0, _internalTestHelpers.moduleFor)('Syntax test: {{#with as}}',
  /*#__PURE__*/
  function (_IfUnlessWithSyntaxTe2) {
    (0, _emberBabel.inheritsLoose)(_class2, _IfUnlessWithSyntaxTe2);

    function _class2() {
      return _IfUnlessWithSyntaxTe2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2.templateFor = function templateFor(_ref2) {
      var cond = _ref2.cond,
          truthy = _ref2.truthy,
          falsy = _ref2.falsy;
      return "{{#with " + cond + " as |test|}}" + truthy + "{{else}}" + falsy + "{{/with}}";
    };

    _proto2['@test keying off of `undefined` does not render'] = function testKeyingOffOfUndefinedDoesNotRender() {
      var _this = this;

      this.render((0, _internalTestHelpers.strip)(_templateObject()), {
        foo: {}
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return _this.rerender();
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'foo', {
          bar: {
            baz: 'Here!'
          }
        });
      });
      this.assertText('Here!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'foo', {});
      });
      this.assertText('');
    };

    _proto2['@test it renders and hides the given block based on the conditional'] = function testItRendersAndHidesTheGivenBlockBasedOnTheConditional() {
      var _this2 = this;

      this.render("{{#with cond1 as |cond|}}{{cond.greeting}}{{else}}False{{/with}}", {
        cond1: {
          greeting: 'Hello'
        }
      });
      this.assertText('Hello');
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.rerender();
      });
      this.assertText('Hello');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'cond1.greeting', 'Hello world');
      });
      this.assertText('Hello world');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'cond1', false);
      });
      this.assertText('False');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'cond1', {
          greeting: 'Hello'
        });
      });
      this.assertText('Hello');
    };

    _proto2['@test can access alias and original scope'] = function testCanAccessAliasAndOriginalScope() {
      var _this3 = this;

      this.render("{{#with person as |tom|}}{{title}}: {{tom.name}}{{/with}}", {
        title: 'Seor Engineer',
        person: {
          name: 'Tom Dale'
        }
      });
      this.assertText('Seor Engineer: Tom Dale');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.rerender();
      });
      this.assertText('Seor Engineer: Tom Dale');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this3.context, 'person.name', 'Yehuda Katz');
        (0, _metal.set)(_this3.context, 'title', 'Principal Engineer');
      });
      this.assertText('Principal Engineer: Yehuda Katz');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this3.context, 'person', {
          name: 'Tom Dale'
        });
        (0, _metal.set)(_this3.context, 'title', 'Seor Engineer');
      });
      this.assertText('Seor Engineer: Tom Dale');
    };

    _proto2['@test the scoped variable is not available outside the {{#with}} block.'] = function testTheScopedVariableIsNotAvailableOutsideTheWithBlock() {
      var _this4 = this;

      this.render("{{name}}-{{#with other as |name|}}{{name}}{{/with}}-{{name}}", {
        name: 'Stef',
        other: 'Yehuda'
      });
      this.assertText('Stef-Yehuda-Stef');
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.rerender();
      });
      this.assertText('Stef-Yehuda-Stef');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'other', 'Chad');
      });
      this.assertText('Stef-Chad-Stef');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this4.context, 'name', 'Tom');
      });
      this.assertText('Tom-Chad-Tom');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this4.context, 'name', 'Stef');
        (0, _metal.set)(_this4.context, 'other', 'Yehuda');
      });
      this.assertText('Stef-Yehuda-Stef');
    };

    _proto2['@test inverse template is displayed with context'] = function testInverseTemplateIsDisplayedWithContext() {
      var _this5 = this;

      this.render("{{#with falsyThing as |thing|}}Has Thing{{else}}No Thing {{otherThing}}{{/with}}", {
        falsyThing: null,
        otherThing: 'bar'
      });
      this.assertText('No Thing bar');
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.rerender();
      });
      this.assertText('No Thing bar');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'otherThing', 'biz');
      });
      this.assertText('No Thing biz');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'falsyThing', true);
      });
      this.assertText('Has Thing');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this5.context, 'otherThing', 'baz');
      });
      this.assertText('Has Thing');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this5.context, 'otherThing', 'bar');
        (0, _metal.set)(_this5.context, 'falsyThing', null);
      });
      this.assertText('No Thing bar');
    };

    _proto2['@test can access alias of a proxy'] = function testCanAccessAliasOfAProxy() {
      var _this6 = this;

      this.render("{{#with proxy as |person|}}{{person.name}}{{/with}}", {
        proxy: _runtime.ObjectProxy.create({
          content: {
            name: 'Tom Dale'
          }
        })
      });
      this.assertText('Tom Dale');
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.rerender();
      });
      this.assertText('Tom Dale');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'proxy.name', 'Yehuda Katz');
      });
      this.assertText('Yehuda Katz');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'proxy.content', {
          name: 'Godfrey Chan'
        });
      });
      this.assertText('Godfrey Chan');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'proxy.content.name', 'Stefan Penner');
      });
      this.assertText('Stefan Penner');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'proxy.content', null);
      });
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this6.context, 'proxy', _runtime.ObjectProxy.create({
          content: {
            name: 'Tom Dale'
          }
        }));
      });
      this.assertText('Tom Dale');
    };

    _proto2['@test can access alias of an array'] = function testCanAccessAliasOfAnArray() {
      var _this7 = this;

      this.render("{{#with arrayThing as |words|}}{{#each words as |word|}}{{word}}{{/each}}{{/with}}", {
        arrayThing: (0, _runtime.A)(['Hello', ' ', 'world'])
      });
      this.assertText('Hello world');
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.rerender();
      });
      this.assertText('Hello world');
      (0, _internalTestHelpers.runTask)(function () {
        var array = (0, _metal.get)(_this7.context, 'arrayThing');
        array.replace(0, 1, ['Goodbye']);
        (0, _runtime.removeAt)(array, 1);
        array.insertAt(1, ', ');
        array.pushObject('!');
      });
      this.assertText('Goodbye, world!');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'arrayThing', ['Hello', ' ', 'world']);
      });
      this.assertText('Hello world');
    };

    _proto2['@test `attrs` can be used as a block param [GH#14678]'] = function testAttrsCanBeUsedAsABlockParamGH14678() {
      var _this8 = this;

      this.render('{{#with hash as |attrs|}}[{{hash.foo}}-{{attrs.foo}}]{{/with}}', {
        hash: {
          foo: 'foo'
        }
      });
      this.assertText('[foo-foo]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.rerender();
      });
      this.assertText('[foo-foo]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.context.set('hash.foo', 'FOO');
      });
      this.assertText('[FOO-FOO]');
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.context.set('hash.foo', 'foo');
      });
      this.assertText('[foo-foo]');
    };

    return _class2;
  }(_sharedConditionalTests.IfUnlessWithSyntaxTest));
  (0, _internalTestHelpers.moduleFor)('Syntax test: Multiple {{#with as}} helpers',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class3, _RenderingTestCase);

    function _class3() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto3 = _class3.prototype;

    _proto3['@test re-using the same variable with different {{#with}} blocks does not override each other'] = function testReUsingTheSameVariableWithDifferentWithBlocksDoesNotOverrideEachOther() {
      var _this9 = this;

      this.render("Admin: {{#with admin as |person|}}{{person.name}}{{/with}} User: {{#with user as |person|}}{{person.name}}{{/with}}", {
        admin: {
          name: 'Tom Dale'
        },
        user: {
          name: 'Yehuda Katz'
        }
      });
      this.assertText('Admin: Tom Dale User: Yehuda Katz');
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.rerender();
      });
      this.assertText('Admin: Tom Dale User: Yehuda Katz');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this9.context, 'admin.name', 'Godfrey Chan');
        (0, _metal.set)(_this9.context, 'user.name', 'Stefan Penner');
      });
      this.assertText('Admin: Godfrey Chan User: Stefan Penner');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this9.context, 'admin', {
          name: 'Tom Dale'
        });
        (0, _metal.set)(_this9.context, 'user', {
          name: 'Yehuda Katz'
        });
      });
      this.assertText('Admin: Tom Dale User: Yehuda Katz');
    };

    _proto3['@test the scoped variable is not available outside the {{#with}} block'] = function testTheScopedVariableIsNotAvailableOutsideTheWithBlock() {
      var _this10 = this;

      this.render("{{ring}}-{{#with first as |ring|}}{{ring}}-{{#with fifth as |ring|}}{{ring}}-{{#with ninth as |ring|}}{{ring}}-{{/with}}{{ring}}-{{/with}}{{ring}}-{{/with}}{{ring}}", {
        ring: 'Greed',
        first: 'Limbo',
        fifth: 'Wrath',
        ninth: 'Treachery'
      });
      this.assertText('Greed-Limbo-Wrath-Treachery-Wrath-Limbo-Greed');
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.rerender();
      });
      this.assertText('Greed-Limbo-Wrath-Treachery-Wrath-Limbo-Greed');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this10.context, 'ring', 'O');
        (0, _metal.set)(_this10.context, 'fifth', 'D');
      });
      this.assertText('O-Limbo-D-Treachery-D-Limbo-O');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this10.context, 'first', 'I');
        (0, _metal.set)(_this10.context, 'ninth', 'K');
      });
      this.assertText('O-I-D-K-D-I-O');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this10.context, 'ring', 'Greed');
        (0, _metal.set)(_this10.context, 'first', 'Limbo');
        (0, _metal.set)(_this10.context, 'fifth', 'Wrath');
        (0, _metal.set)(_this10.context, 'ninth', 'Treachery');
      });
      this.assertText('Greed-Limbo-Wrath-Treachery-Wrath-Limbo-Greed');
    };

    _proto3['@test it should support {{#with name as |foo|}}, then {{#with foo as |bar|}}'] = function testItShouldSupportWithNameAsFooThenWithFooAsBar() {
      var _this11 = this;

      this.render("{{#with name as |foo|}}{{#with foo as |bar|}}{{bar}}{{/with}}{{/with}}", {
        name: 'caterpillar'
      });
      this.assertText('caterpillar');
      (0, _internalTestHelpers.runTask)(function () {
        return _this11.rerender();
      });
      this.assertText('caterpillar');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'name', 'butterfly');
      });
      this.assertText('butterfly');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this11.context, 'name', 'caterpillar');
      });
      this.assertText('caterpillar');
    };

    _proto3['@test updating the context should update the alias'] = function testUpdatingTheContextShouldUpdateTheAlias() {
      var _this12 = this;

      this.render("{{#with this as |person|}}{{person.name}}{{/with}}", {
        name: 'Los Pivots'
      });
      this.assertText('Los Pivots');
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.rerender();
      });
      this.assertText('Los Pivots');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'name', "l'Pivots");
      });
      this.assertText("l'Pivots");
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this12.context, 'name', 'Los Pivots');
      });
      this.assertText('Los Pivots');
    };

    _proto3['@test nested {{#with}} blocks should have access to root context'] = function testNestedWithBlocksShouldHaveAccessToRootContext() {
      var _this13 = this;

      this.render((0, _internalTestHelpers.strip)(_templateObject2()), {
        name: 'ebryn',
        committer1: {
          name: 'trek'
        },
        committer2: {
          name: 'machty'
        }
      });
      this.assertText('ebryn[trek[machty]trek]ebryn[machty[trek]machty]ebryn');
      (0, _internalTestHelpers.runTask)(function () {
        return _this13.rerender();
      });
      this.assertText('ebryn[trek[machty]trek]ebryn[machty[trek]machty]ebryn');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'name', 'chancancode');
      });
      this.assertText('chancancode[trek[machty]trek]chancancode[machty[trek]machty]chancancode');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'committer1', {
          name: 'krisselden'
        });
      });
      this.assertText('chancancode[krisselden[machty]krisselden]chancancode[machty[krisselden]machty]chancancode');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this13.context, 'committer1.name', 'wycats');
        (0, _metal.set)(_this13.context, 'committer2', {
          name: 'rwjblue'
        });
      });
      this.assertText('chancancode[wycats[rwjblue]wycats]chancancode[rwjblue[wycats]rwjblue]chancancode');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this13.context, 'name', 'ebryn');
        (0, _metal.set)(_this13.context, 'committer1', {
          name: 'trek'
        });
        (0, _metal.set)(_this13.context, 'committer2', {
          name: 'machty'
        });
      });
      this.assertText('ebryn[trek[machty]trek]ebryn[machty[trek]machty]ebryn');
    };

    return _class3;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/unit/outlet-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/glimmer", "@ember/runloop"], function (_emberBabel, _internalTestHelpers, _glimmer, _runloop) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Glimmer OutletView',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test render in the render queue'] = function testRenderInTheRenderQueue(assert) {
      var didAppendOutletView = 0;
      var expectedOutlet = '#foo.bar';
      var renderer = {
        appendOutletView: function (view, target) {
          didAppendOutletView++;
          assert.equal(view, outletView);
          assert.equal(target, expectedOutlet);
        }
      };
      var outletView = new _glimmer.OutletView({}, renderer);
      (0, _runloop.run)(function () {
        assert.equal(didAppendOutletView, 0, 'appendOutletView should not yet have been called (before appendTo)');
        outletView.appendTo(expectedOutlet);
        assert.equal(didAppendOutletView, 0, 'appendOutletView should not yet have been called (sync after appendTo)');
        (0, _runloop.schedule)('actions', function () {
          return assert.equal(didAppendOutletView, 0, 'appendOutletView should not yet have been called (in actions)');
        });
        (0, _runloop.schedule)('render', function () {
          return assert.equal(didAppendOutletView, 1, 'appendOutletView should be invoked in render');
        });
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/glimmer/tests/unit/runtime-resolver-cache-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _metal, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-glimmer runtime resolver cache',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test a helper definition is only generated once'] = function testAHelperDefinitionIsOnlyGeneratedOnce(assert) {
      var _this = this;

      this.registerHelper('foo-bar', function () {
        return 'foo-bar helper!';
      });
      this.registerHelper('baz-qux', function () {
        return 'baz-qux helper!';
      }); // assert precondition

      var state = this.getCacheCounters();
      assert.deepEqual(state, {
        templateCacheHits: 0,
        templateCacheMisses: 0,
        componentDefinitionCount: 0,
        helperDefinitionCount: 0
      }, 'precondition');
      this.render("\n          {{~#if cond~}}\n            {{foo-bar}}\n          {{~else~}}\n            {{baz-qux}}\n          {{~/if}}", {
        cond: true
      });
      this.assertText('foo-bar helper!');
      state = this.expectCacheChanges({
        helperDefinitionCount: 1
      }, state, 'calculate foo-bar helper only'); // show component-two for the first time

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'cond', false);
      });
      this.assertText('baz-qux helper!');
      state = this.expectCacheChanges({
        helperDefinitionCount: 1
      }, state, 'calculate baz-qux helper, misses cache'); // show foo-bar again

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'cond', true);
      });
      this.assertText('foo-bar helper!');
      state = this.expectCacheChanges({}, state, 'toggle back to foo-bar cache hit'); // show baz-qux again

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this.context, 'cond', false);
      });
      this.assertText('baz-qux helper!');
      state = this.expectCacheChanges({}, state, 'toggle back to baz-qux cache hit');
    };

    _proto['@test a component definition is only generated once'] = function testAComponentDefinitionIsOnlyGeneratedOnce(assert) {
      var _this2 = this; // static layout


      this.registerComponent('component-one', {
        template: 'One'
      });
      this.registerComponent('component-two', {
        ComponentClass: _helpers.Component.extend(),
        template: 'Two'
      }); // assert precondition

      var state = this.getCacheCounters();
      assert.deepEqual(state, {
        templateCacheHits: 0,
        templateCacheMisses: 0,
        componentDefinitionCount: 0,
        helperDefinitionCount: 0
      }, 'precondition'); // show component-one for the first time

      this.render("{{component componentName}}", {
        componentName: 'component-one'
      });
      this.assertText('One');
      state = this.expectCacheChanges({
        componentDefinitionCount: 1
      }, state, 'test case component and component-one no change'); // show component-two for the first time

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'componentName', 'component-two');
      });
      this.assertText('Two');
      state = this.expectCacheChanges({
        componentDefinitionCount: 1
      }, state, 'component-two first render'); // show component-one again

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'componentName', 'component-one');
      });
      this.assertText('One');
      state = this.expectCacheChanges({}, state, 'toggle back to component-one no change'); // show component-two again

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this2.context, 'componentName', 'component-two');
      });
      this.assertText('Two');
      state = this.expectCacheChanges({}, state, 'toggle back to component-two no change');
    };

    _proto['@test each template is only compiled once'] = function testEachTemplateIsOnlyCompiledOnce(assert) {
      var _this3 = this; // static layout


      this.registerComponent('component-one', {
        template: 'One'
      }); // test directly import template factory onto late bound layout

      var Two = _helpers.Component.extend({
        layout: this.compile('Two')
      });

      this.registerComponent('component-two', {
        ComponentClass: Two
      }); // inject layout onto component, share layout with component-one

      this.registerComponent('root-component', {
        ComponentClass: _helpers.Component
      });
      this.owner.inject('component:root-component', 'layout', 'template:components/component-one'); // template instance shared between to template managers

      var rootFactory = this.owner.factoryFor('component:root-component'); // assert precondition

      var state = this.getCacheCounters();
      assert.deepEqual(state, {
        templateCacheHits: 0,
        templateCacheMisses: 0,
        componentDefinitionCount: 0,
        helperDefinitionCount: 0
      }, 'precondition'); // show component-one for the first time

      this.render("\n    {{~#if cond~}}\n      {{component-one}}\n    {{~else~}}\n      {{component-two}}\n    {{~/if}}", {
        cond: true
      });
      this.assertText('One');
      state = this.expectCacheChanges({
        componentDefinitionCount: 1
      }, state, 'test case component and component-one no change'); // show component-two for the first time

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'cond', false);
      });
      this.assertText('Two');
      state = this.expectCacheChanges({
        templateCacheMisses: 1,
        componentDefinitionCount: 1
      }, state, 'component-two first render misses template cache'); // show component-one again

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'cond', true);
      });
      this.assertText('One');
      state = this.expectCacheChanges({}, state, 'toggle back to component-one no change'); // show component-two again

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this3.context, 'cond', false);
      });
      this.assertText('Two');
      state = this.expectCacheChanges({
        templateCacheHits: 1
      }, state, 'toggle back to component-two hits template cache'); // render new root append

      var root = rootFactory.create();

      try {
        (0, _internalTestHelpers.runAppend)(root);
        this.assertText('TwoOne'); // roots have different capabilities so this will hit

        state = this.expectCacheChanges({}, state, 'append root with component-one no change'); // render new root append

        var root2 = rootFactory.create();

        try {
          (0, _internalTestHelpers.runAppend)(root2);
          this.assertText('TwoOneOne');
          state = this.expectCacheChanges({}, state, 'append another root no change');
        } finally {
          (0, _internalTestHelpers.runDestroy)(root2);
        }
      } finally {
        (0, _internalTestHelpers.runDestroy)(root);
      }
    };

    _proto.getCacheCounters = function getCacheCounters() {
      var _this$runtimeResolver = this.runtimeResolver,
          templateCacheHits = _this$runtimeResolver.templateCacheHits,
          templateCacheMisses = _this$runtimeResolver.templateCacheMisses,
          componentDefinitionCount = _this$runtimeResolver.componentDefinitionCount,
          helperDefinitionCount = _this$runtimeResolver.helperDefinitionCount;
      return {
        templateCacheHits: templateCacheHits,
        templateCacheMisses: templateCacheMisses,
        componentDefinitionCount: componentDefinitionCount,
        helperDefinitionCount: helperDefinitionCount
      };
    };

    _proto.expectCacheChanges = function expectCacheChanges(expected, lastState, message) {
      var state = this.getCacheCounters();
      var actual = diff(state, lastState);
      this.assert.deepEqual(actual, expected, message);
      return state;
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));

  function diff(state, lastState) {
    var res = {};
    Object.keys(state).forEach(function (key) {
      var delta = state[key] - lastState[key];

      if (delta !== 0) {
        res[key] = state[key] - lastState[key];
      }
    });
    return res;
  }
});
enifed("@ember/-internals/glimmer/tests/unit/template-factory-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/glimmer", "ember-template-compiler", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _glimmer, _emberTemplateCompiler, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Template factory test',
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RenderingTestCase);

    function _class() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test the template factory returned from precompile is the same as compile'] = function testTheTemplateFactoryReturnedFromPrecompileIsTheSameAsCompile(assert) {
      var owner = this.owner;
      var runtimeResolver = this.runtimeResolver;
      var templateStr = 'Hello {{name}}';
      var options = {
        moduleName: 'my-app/templates/some-module.hbs'
      };
      var spec = (0, _emberTemplateCompiler.precompile)(templateStr, options);
      var body = "exports.default = template(" + spec + ");";
      var module = new Function('exports', 'template', body);
      var exports = {};
      module(exports, _glimmer.template);
      var Precompiled = exports['default'];
      var Compiled = (0, _emberTemplateCompiler.compile)(templateStr, options);
      assert.equal(typeof Precompiled.create, 'function', 'precompiled is a factory');
      assert.ok(Precompiled.id, 'precompiled has id');
      assert.equal(typeof Compiled.create, 'function', 'compiled is a factory');
      assert.ok(Compiled.id, 'compiled has id');
      assert.equal(runtimeResolver.templateCacheMisses, 0, 'misses 0');
      assert.equal(runtimeResolver.templateCacheHits, 0, 'hits 0');
      var precompiled = runtimeResolver.createTemplate(Precompiled, owner);
      assert.equal(runtimeResolver.templateCacheMisses, 1, 'misses 1');
      assert.equal(runtimeResolver.templateCacheHits, 0, 'hits 0');
      var compiled = runtimeResolver.createTemplate(Compiled, owner);
      assert.equal(runtimeResolver.templateCacheMisses, 2, 'misses 2');
      assert.equal(runtimeResolver.templateCacheHits, 0, 'hits 0');
      assert.ok(typeof precompiled.spec !== 'string', 'Spec has been parsed');
      assert.ok(typeof compiled.spec !== 'string', 'Spec has been parsed');
      this.registerComponent('x-precompiled', {
        ComponentClass: _helpers.Component.extend({
          layout: Precompiled
        })
      });
      this.registerComponent('x-compiled', {
        ComponentClass: _helpers.Component.extend({
          layout: Compiled
        })
      });
      this.render('{{x-precompiled name="precompiled"}} {{x-compiled name="compiled"}}');
      assert.equal(runtimeResolver.templateCacheMisses, 2, 'misses 2');
      assert.equal(runtimeResolver.templateCacheHits, 2, 'hits 2');
      this.assertText('Hello precompiled Hello compiled');
    };

    return _class;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("@ember/-internals/glimmer/tests/unit/utils/debug-stack-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/glimmer"], function (_emberBabel, _internalTestHelpers, _glimmer) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Glimmer DebugStack',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test pushing and popping'] = function testPushingAndPopping(assert) {
      if (true
      /* DEBUG */
      ) {
          var stack = new _glimmer.DebugStack();
          assert.equal(stack.peek(), undefined);
          stack.push('template:application');
          assert.equal(stack.peek(), '"template:application"');
          stack.push('component:top-level-component');
          assert.equal(stack.peek(), '"component:top-level-component"');
          stack.pushEngine('engine:my-engine');
          stack.push('component:component-in-engine');
          assert.equal(stack.peek(), '"component:component-in-engine" (in "engine:my-engine")');
          stack.pop();
          stack.pop();
          var item = stack.pop();
          assert.equal(item, 'component:top-level-component');
          assert.equal(stack.peek(), '"template:application"');
        } else {
        assert.expect(0);
      }
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/glimmer/tests/utils/glimmerish-component", ["exports", "@ember/-internals/glimmer", "@ember/-internals/owner"], function (_exports, _glimmer, _owner) {
  "use strict";

  _exports.default = void 0;

  var GlimmerishComponentManager =
  /*#__PURE__*/
  function () {
    function GlimmerishComponentManager(owner) {
      this.capabilities = (0, _glimmer.capabilities)('3.4', {
        updateHook: false
      });
      this.owner = owner;
    }

    var _proto = GlimmerishComponentManager.prototype;

    _proto.createComponent = function createComponent(Factory, args) {
      return new Factory(this.owner, args.named);
    };

    _proto.getContext = function getContext(component) {
      return component;
    };

    return GlimmerishComponentManager;
  }();

  var GlimmerishComponent = function GlimmerishComponent(owner, args) {
    (0, _owner.setOwner)(this, owner);
    this.args = args;
  };

  (0, _glimmer.setComponentManager)(function () {
    return new GlimmerishComponentManager();
  }, GlimmerishComponent);
  var _default = GlimmerishComponent;
  _exports.default = _default;
});
enifed("@ember/-internals/glimmer/tests/utils/helpers", ["exports", "ember-template-compiler", "@ember/-internals/glimmer"], function (_exports, _emberTemplateCompiler, _glimmer) {
  "use strict";

  Object.defineProperty(_exports, "compile", {
    enumerable: true,
    get: function () {
      return _emberTemplateCompiler.compile;
    }
  });
  Object.defineProperty(_exports, "precompile", {
    enumerable: true,
    get: function () {
      return _emberTemplateCompiler.precompile;
    }
  });
  Object.defineProperty(_exports, "INVOKE", {
    enumerable: true,
    get: function () {
      return _glimmer.INVOKE;
    }
  });
  Object.defineProperty(_exports, "Helper", {
    enumerable: true,
    get: function () {
      return _glimmer.Helper;
    }
  });
  Object.defineProperty(_exports, "helper", {
    enumerable: true,
    get: function () {
      return _glimmer.helper;
    }
  });
  Object.defineProperty(_exports, "Component", {
    enumerable: true,
    get: function () {
      return _glimmer.Component;
    }
  });
  Object.defineProperty(_exports, "LinkComponent", {
    enumerable: true,
    get: function () {
      return _glimmer.LinkComponent;
    }
  });
  Object.defineProperty(_exports, "InteractiveRenderer", {
    enumerable: true,
    get: function () {
      return _glimmer.InteractiveRenderer;
    }
  });
  Object.defineProperty(_exports, "InertRenderer", {
    enumerable: true,
    get: function () {
      return _glimmer.InertRenderer;
    }
  });
  Object.defineProperty(_exports, "htmlSafe", {
    enumerable: true,
    get: function () {
      return _glimmer.htmlSafe;
    }
  });
  Object.defineProperty(_exports, "SafeString", {
    enumerable: true,
    get: function () {
      return _glimmer.SafeString;
    }
  });
  Object.defineProperty(_exports, "DOMChanges", {
    enumerable: true,
    get: function () {
      return _glimmer.DOMChanges;
    }
  });
  Object.defineProperty(_exports, "isHTMLSafe", {
    enumerable: true,
    get: function () {
      return _glimmer.isHTMLSafe;
    }
  });
});
enifed("@ember/-internals/glimmer/tests/utils/shared-conditional-tests", ["exports", "ember-babel", "internal-test-helpers", "@ember/polyfills", "@ember/-internals/metal", "@ember/-internals/runtime", "@ember/-internals/glimmer/tests/utils/helpers"], function (_exports, _emberBabel, _internalTestHelpers, _polyfills, _metal, _runtime, _helpers) {
  "use strict";

  _exports.IfUnlessWithSyntaxTest = _exports.TogglingSyntaxConditionalsTest = _exports.IfUnlessHelperTest = _exports.TogglingHelperConditionalsTest = _exports.TogglingConditionalsTest = _exports.ArrayTestCases = _exports.ObjectTestCases = _exports.BasicConditionalsTest = _exports.StableFalsyGenerator = _exports.StableTruthyGenerator = _exports.FalsyGenerator = _exports.TruthyGenerator = void 0;

  var _ObjectTestCases, _ArrayTestCases;
  /* eslint-disable no-new-wrappers */


  var AbstractConditionalsTest =
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(AbstractConditionalsTest, _RenderingTestCase);

    function AbstractConditionalsTest() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto = AbstractConditionalsTest.prototype;

    _proto.wrapperFor = function wrapperFor(templates) {
      return templates.join('');
    };

    _proto.wrappedTemplateFor = function wrappedTemplateFor(options) {
      return this.wrapperFor([this.templateFor(options)]);
    }
    /* abstract */
    ;

    _proto.templateFor = function templateFor()
    /* { cond, truthy, falsy } */
    {
      // e.g. `{{#if ${cond}}}${truthy}{{else}}${falsy}{{/if}}`
      throw new Error('Not implemented: `templateFor`');
    }
    /* abstract */
    ;

    _proto.renderValues = function renderValues()
    /* ...values */
    {
      throw new Error('Not implemented: `renderValues`');
    };

    (0, _emberBabel.createClass)(AbstractConditionalsTest, [{
      key: "truthyValue",
      get: function () {
        return true;
      }
    }, {
      key: "falsyValue",
      get: function () {
        return false;
      }
    }]);
    return AbstractConditionalsTest;
  }(_internalTestHelpers.RenderingTestCase);

  var AbstractGenerator =
  /*#__PURE__*/
  function () {
    function AbstractGenerator(cases) {
      this.cases = cases;
    }
    /* abstract */


    var _proto2 = AbstractGenerator.prototype;

    _proto2.generate = function generate()
    /* value, idx */
    {
      throw new Error('Not implemented: `generate`');
    };

    return AbstractGenerator;
  }();
  /*
    The test cases in this file generally follow the following pattern:
  
    1. Render with [ truthy, ...(other truthy variations), falsy, ...(other falsy variations) ]
    2. No-op rerender
    3. Make all of them falsy (through interior mutation)
    4. Make all of them truthy (through interior mutation, sometimes with some slight variations)
    5. Reset them to their original values (through replacement)
  */


  var TruthyGenerator =
  /*#__PURE__*/
  function (_AbstractGenerator) {
    (0, _emberBabel.inheritsLoose)(TruthyGenerator, _AbstractGenerator);

    function TruthyGenerator() {
      return _AbstractGenerator.apply(this, arguments) || this;
    }

    var _proto3 = TruthyGenerator.prototype;

    _proto3.generate = function generate(value, idx) {
      var _ref;

      return _ref = {}, _ref["@test it should consider " + JSON.stringify(value) + " truthy [" + idx + "]"] = function () {
        var _this = this;

        this.renderValues(value);
        this.assertText('T1');
        (0, _internalTestHelpers.runTask)(function () {
          return _this.rerender();
        });
        this.assertText('T1');
        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(_this.context, 'cond1', _this.falsyValue);
        });
        this.assertText('F1');
        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(_this.context, 'cond1', value);
        });
        this.assertText('T1');
      }, _ref;
    };

    return TruthyGenerator;
  }(AbstractGenerator);

  _exports.TruthyGenerator = TruthyGenerator;

  var FalsyGenerator =
  /*#__PURE__*/
  function (_AbstractGenerator2) {
    (0, _emberBabel.inheritsLoose)(FalsyGenerator, _AbstractGenerator2);

    function FalsyGenerator() {
      return _AbstractGenerator2.apply(this, arguments) || this;
    }

    var _proto4 = FalsyGenerator.prototype;

    _proto4.generate = function generate(value, idx) {
      var _ref2;

      return _ref2 = {}, _ref2["@test it should consider " + JSON.stringify(value) + " falsy [" + idx + "]"] = function () {
        var _this2 = this;

        this.renderValues(value);
        this.assertText('F1');
        (0, _internalTestHelpers.runTask)(function () {
          return _this2.rerender();
        });
        this.assertText('F1');
        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(_this2.context, 'cond1', _this2.truthyValue);
        });
        this.assertText('T1');
        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(_this2.context, 'cond1', value);
        });
        this.assertText('F1');
      }, _ref2;
    };

    return FalsyGenerator;
  }(AbstractGenerator);

  _exports.FalsyGenerator = FalsyGenerator;

  var StableTruthyGenerator =
  /*#__PURE__*/
  function (_TruthyGenerator) {
    (0, _emberBabel.inheritsLoose)(StableTruthyGenerator, _TruthyGenerator);

    function StableTruthyGenerator() {
      return _TruthyGenerator.apply(this, arguments) || this;
    }

    var _proto5 = StableTruthyGenerator.prototype;

    _proto5.generate = function generate(value, idx) {
      var _assign;

      return (0, _polyfills.assign)(_TruthyGenerator.prototype.generate.call(this, value, idx), (_assign = {}, _assign["@test it maintains DOM stability when condition changes from " + value + " to another truthy value and back [" + idx + "]"] = function () {
        var _this3 = this;

        this.renderValues(value);
        this.assertText('T1');
        this.takeSnapshot();
        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(_this3.context, 'cond1', _this3.truthyValue);
        });
        this.assertText('T1');
        this.assertInvariants();
        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(_this3.context, 'cond1', value);
        });
        this.assertText('T1');
        this.assertInvariants();
      }, _assign));
    };

    return StableTruthyGenerator;
  }(TruthyGenerator);

  _exports.StableTruthyGenerator = StableTruthyGenerator;

  var StableFalsyGenerator =
  /*#__PURE__*/
  function (_FalsyGenerator) {
    (0, _emberBabel.inheritsLoose)(StableFalsyGenerator, _FalsyGenerator);

    function StableFalsyGenerator() {
      return _FalsyGenerator.apply(this, arguments) || this;
    }

    var _proto6 = StableFalsyGenerator.prototype;

    _proto6.generate = function generate(value, idx) {
      var _assign2;

      return (0, _polyfills.assign)(_FalsyGenerator.prototype.generate.call(this, value), (_assign2 = {}, _assign2["@test it maintains DOM stability when condition changes from " + value + " to another falsy value and back [" + idx + "]"] = function () {
        var _this4 = this;

        this.renderValues(value);
        this.assertText('F1');
        this.takeSnapshot();
        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(_this4.context, 'cond1', _this4.falsyValue);
        });
        this.assertText('F1');
        this.assertInvariants();
        (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(_this4.context, 'cond1', value);
        });
        this.assertText('F1');
        this.assertInvariants();
      }, _assign2));
    };

    return StableFalsyGenerator;
  }(FalsyGenerator);

  _exports.StableFalsyGenerator = StableFalsyGenerator;

  var ObjectProxyGenerator =
  /*#__PURE__*/
  function (_AbstractGenerator3) {
    (0, _emberBabel.inheritsLoose)(ObjectProxyGenerator, _AbstractGenerator3);

    function ObjectProxyGenerator() {
      return _AbstractGenerator3.apply(this, arguments) || this;
    }

    var _proto7 = ObjectProxyGenerator.prototype;

    _proto7.generate = function generate(value, idx) {
      // This is inconsistent with our usual to-bool policy, but the current proxy implementation
      // simply uses !!content to determine truthiness
      if (value) {
        var _ref3;

        return _ref3 = {}, _ref3["@test it should consider an object proxy with `" + JSON.stringify(value) + "` truthy [" + idx + "]"] = function () {
          var _this5 = this;

          this.renderValues(_runtime.ObjectProxy.create({
            content: value
          }));
          this.assertText('T1');
          (0, _internalTestHelpers.runTask)(function () {
            return _this5.rerender();
          });
          this.assertText('T1');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this5.context, 'cond1.content', _this5.falsyValue);
          });
          this.assertText('F1');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this5.context, 'cond1', _runtime.ObjectProxy.create({
              content: value
            }));
          });
          this.assertText('T1');
        }, _ref3;
      } else {
        var _ref4;

        return _ref4 = {}, _ref4["@test it should consider an object proxy with `" + JSON.stringify(value) + "` falsy [" + idx + "]"] = function () {
          var _this6 = this;

          this.renderValues(_runtime.ObjectProxy.create({
            content: value
          }));
          this.assertText('F1');
          (0, _internalTestHelpers.runTask)(function () {
            return _this6.rerender();
          });
          this.assertText('F1');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this6.context, 'cond1.content', _this6.truthyValue);
          });
          this.assertText('T1');
          (0, _internalTestHelpers.runTask)(function () {
            return (0, _metal.set)(_this6.context, 'cond1', _runtime.ObjectProxy.create({
              content: value
            }));
          });
          this.assertText('F1');
        }, _ref4;
      }
    };

    return ObjectProxyGenerator;
  }(AbstractGenerator); // Testing behaviors shared across all conditionals, i.e. {{#if}}, {{#unless}},
  // {{#with}}, {{#each}}, {{#each-in}}, (if) and (unless)


  var BasicConditionalsTest =
  /*#__PURE__*/
  function (_AbstractConditionals) {
    (0, _emberBabel.inheritsLoose)(BasicConditionalsTest, _AbstractConditionals);

    function BasicConditionalsTest() {
      return _AbstractConditionals.apply(this, arguments) || this;
    }

    var _proto8 = BasicConditionalsTest.prototype;

    _proto8['@test it renders the corresponding block based on the conditional'] = function testItRendersTheCorrespondingBlockBasedOnTheConditional() {
      var _this7 = this;

      this.renderValues(this.truthyValue, this.falsyValue);
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.rerender();
      });
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this7.context, 'cond1', _this7.falsyValue);
      });
      this.assertText('F1F2');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this7.context, 'cond1', _this7.truthyValue);
        (0, _metal.set)(_this7.context, 'cond2', _this7.truthyValue);
      });
      this.assertText('T1T2');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this7.context, 'cond1', _this7.truthyValue);
        (0, _metal.set)(_this7.context, 'cond2', _this7.falsyValue);
      });
      this.assertText('T1F2');
    };

    return BasicConditionalsTest;
  }(AbstractConditionalsTest); // Testing behaviors related to ember objects, object proxies, etc


  _exports.BasicConditionalsTest = BasicConditionalsTest;
  var ObjectTestCases = (_ObjectTestCases = {}, _ObjectTestCases['@test it considers object proxies without content falsy'] = function () {
    var _this8 = this;

    this.renderValues(_runtime.ObjectProxy.create({
      content: {}
    }), _runtime.ObjectProxy.create({
      content: _runtime.Object.create()
    }), _runtime.ObjectProxy.create({
      content: null
    }));
    this.assertText('T1T2F3');
    (0, _internalTestHelpers.runTask)(function () {
      return _this8.rerender();
    });
    this.assertText('T1T2F3');
    (0, _internalTestHelpers.runTask)(function () {
      (0, _metal.set)(_this8.context, 'cond1.content', null);
      (0, _metal.set)(_this8.context, 'cond2.content', null);
    });
    this.assertText('F1F2F3');
    (0, _internalTestHelpers.runTask)(function () {
      (0, _metal.set)(_this8.context, 'cond1.content', _runtime.Object.create());
      (0, _metal.set)(_this8.context, 'cond2.content', {});
      (0, _metal.set)(_this8.context, 'cond3.content', {
        foo: 'bar'
      });
    });
    this.assertText('T1T2T3');
    (0, _internalTestHelpers.runTask)(function () {
      (0, _metal.set)(_this8.context, 'cond1', _runtime.ObjectProxy.create({
        content: {}
      }));
      (0, _metal.set)(_this8.context, 'cond2', _runtime.ObjectProxy.create({
        content: _runtime.Object.create()
      }));
      (0, _metal.set)(_this8.context, 'cond3', _runtime.ObjectProxy.create({
        content: null
      }));
    });
    this.assertText('T1T2F3');
  }, _ObjectTestCases); // Testing behaviors related to arrays and array proxies

  _exports.ObjectTestCases = ObjectTestCases;
  var ArrayTestCases = (_ArrayTestCases = {}, _ArrayTestCases['@test it considers empty arrays falsy'] = function () {
    var _this9 = this;

    this.renderValues((0, _runtime.A)(['hello']), (0, _runtime.A)());
    this.assertText('T1F2');
    (0, _internalTestHelpers.runTask)(function () {
      return _this9.rerender();
    });
    this.assertText('T1F2');
    (0, _internalTestHelpers.runTask)(function () {
      return (0, _runtime.removeAt)((0, _metal.get)(_this9.context, 'cond1'), 0);
    });
    this.assertText('F1F2');
    (0, _internalTestHelpers.runTask)(function () {
      (0, _metal.get)(_this9.context, 'cond1').pushObject('hello');
      (0, _metal.get)(_this9.context, 'cond2').pushObjects([1]);
    });
    this.assertText('T1T2');
    (0, _internalTestHelpers.runTask)(function () {
      (0, _metal.set)(_this9.context, 'cond1', (0, _runtime.A)(['hello']));
      (0, _metal.set)(_this9.context, 'cond2', (0, _runtime.A)());
    });
    this.assertText('T1F2');
  }, _ArrayTestCases['@test it considers array proxies without content falsy'] = function () {
    var _this10 = this;

    this.renderValues(_runtime.ArrayProxy.create({
      content: (0, _runtime.A)(['hello'])
    }), _runtime.ArrayProxy.create({
      content: null
    }));
    this.assertText('T1F2');
    (0, _internalTestHelpers.runTask)(function () {
      return _this10.rerender();
    });
    this.assertText('T1F2');
    (0, _internalTestHelpers.runTask)(function () {
      (0, _metal.set)(_this10.context, 'cond1.content', null);
      (0, _metal.set)(_this10.context, 'cond2.content', null);
    });
    this.assertText('F1F2');
    (0, _internalTestHelpers.runTask)(function () {
      (0, _metal.set)(_this10.context, 'cond1.content', (0, _runtime.A)(['hello']));
      (0, _metal.set)(_this10.context, 'cond2.content', (0, _runtime.A)([1]));
    });
    this.assertText('T1T2');
    (0, _internalTestHelpers.runTask)(function () {
      (0, _metal.set)(_this10.context, 'cond1', _runtime.ArrayProxy.create({
        content: (0, _runtime.A)(['hello'])
      }));
      (0, _metal.set)(_this10.context, 'cond2', _runtime.ArrayProxy.create({
        content: null
      }));
    });
    this.assertText('T1F2');
  }, _ArrayTestCases['@test it considers array proxies with empty arrays falsy'] = function () {
    var _this11 = this;

    this.renderValues(_runtime.ArrayProxy.create({
      content: (0, _runtime.A)(['hello'])
    }), _runtime.ArrayProxy.create({
      content: (0, _runtime.A)()
    }));
    this.assertText('T1F2');
    (0, _internalTestHelpers.runTask)(function () {
      return _this11.rerender();
    });
    this.assertText('T1F2');
    (0, _internalTestHelpers.runTask)(function () {
      return (0, _runtime.removeAt)((0, _metal.get)(_this11.context, 'cond1.content'), 0);
    });
    this.assertText('F1F2');
    (0, _internalTestHelpers.runTask)(function () {
      (0, _metal.get)(_this11.context, 'cond1.content').pushObject('hello');
      (0, _metal.get)(_this11.context, 'cond2.content').pushObjects([1]);
    });
    this.assertText('T1T2');
    (0, _internalTestHelpers.runTask)(function () {
      (0, _metal.set)(_this11.context, 'cond1', _runtime.ArrayProxy.create({
        content: (0, _runtime.A)(['hello'])
      }));
      (0, _metal.set)(_this11.context, 'cond2', _runtime.ArrayProxy.create({
        content: (0, _runtime.A)()
      }));
    });
    this.assertText('T1F2');
  }, _ArrayTestCases);
  _exports.ArrayTestCases = ArrayTestCases;
  var IfUnlessWithTestCases = [new StableTruthyGenerator([true, ' ', 'hello', 'false', 'null', 'undefined', 1, ['hello'], (0, _runtime.A)(['hello']), {}, {
    foo: 'bar'
  }, _runtime.Object.create(), _runtime.Object.create({
    foo: 'bar'
  }), _runtime.ObjectProxy.create({
    content: true
  }), Object, function () {}, new String('hello'), new String(''), new Boolean(true), new Boolean(false), new Date()]), new StableFalsyGenerator([false, null, undefined, '', 0, [], (0, _runtime.A)(), _runtime.ObjectProxy.create({
    content: undefined
  })]), new ObjectProxyGenerator([true, ' ', 'hello', 'false', 'null', 'undefined', 1, ['hello'], (0, _runtime.A)(['hello']), _runtime.ArrayProxy.create({
    content: ['hello']
  }), _runtime.ArrayProxy.create({
    content: []
  }), {}, {
    foo: 'bar'
  }, _runtime.Object.create(), _runtime.Object.create({
    foo: 'bar'
  }), _runtime.ObjectProxy.create({
    content: true
  }), _runtime.ObjectProxy.create({
    content: undefined
  }), new String('hello'), new String(''), new Boolean(true), new Boolean(false), new Date(), false, null, undefined, '', 0, [], (0, _runtime.A)()]), ObjectTestCases, ArrayTestCases]; // Testing behaviors shared across the "toggling" conditionals, i.e. {{#if}},
  // {{#unless}}, {{#with}}, {{#each}}, {{#each-in}}, (if) and (unless)

  var TogglingConditionalsTest =
  /*#__PURE__*/
  function (_BasicConditionalsTes) {
    (0, _emberBabel.inheritsLoose)(TogglingConditionalsTest, _BasicConditionalsTes);

    function TogglingConditionalsTest() {
      return _BasicConditionalsTes.apply(this, arguments) || this;
    }

    return TogglingConditionalsTest;
  }(BasicConditionalsTest); // Testing behaviors shared across the (if) and (unless) helpers


  _exports.TogglingConditionalsTest = TogglingConditionalsTest;

  var TogglingHelperConditionalsTest =
  /*#__PURE__*/
  function (_TogglingConditionals) {
    (0, _emberBabel.inheritsLoose)(TogglingHelperConditionalsTest, _TogglingConditionals);

    function TogglingHelperConditionalsTest() {
      return _TogglingConditionals.apply(this, arguments) || this;
    }

    var _proto9 = TogglingHelperConditionalsTest.prototype;

    _proto9.renderValues = function renderValues() {
      var templates = [];
      var context = {};

      for (var i = 1; i <= arguments.length; i++) {
        templates.push(this.templateFor({
          cond: "cond" + i,
          truthy: "t" + i,
          falsy: "f" + i
        }));
        context["t" + i] = "T" + i;
        context["f" + i] = "F" + i;
        context["cond" + i] = i - 1 < 0 || arguments.length <= i - 1 ? undefined : arguments[i - 1];
      }

      var wrappedTemplate = this.wrapperFor(templates);
      this.render(wrappedTemplate, context);
    };

    _proto9['@test it has access to the outer scope from both templates'] = function testItHasAccessToTheOuterScopeFromBothTemplates() {
      var _this12 = this;

      var template = this.wrapperFor([this.templateFor({
        cond: 'cond1',
        truthy: 'truthy',
        falsy: 'falsy'
      }), this.templateFor({
        cond: 'cond2',
        truthy: 'truthy',
        falsy: 'falsy'
      })]);
      this.render(template, {
        cond1: this.truthyValue,
        cond2: this.falsyValue,
        truthy: 'YES',
        falsy: 'NO'
      });
      this.assertText('YESNO');
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.rerender();
      });
      this.assertText('YESNO');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this12.context, 'truthy', 'YASS');
        (0, _metal.set)(_this12.context, 'falsy', 'NOPE');
      });
      this.assertText('YASSNOPE');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this12.context, 'cond1', _this12.falsyValue);
        (0, _metal.set)(_this12.context, 'cond2', _this12.truthyValue);
      });
      this.assertText('NOPEYASS');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this12.context, 'truthy', 'YES');
        (0, _metal.set)(_this12.context, 'falsy', 'NO');
        (0, _metal.set)(_this12.context, 'cond1', _this12.truthyValue);
        (0, _metal.set)(_this12.context, 'cond2', _this12.falsyValue);
      });
      this.assertText('YESNO');
    };

    _proto9['@test it does not update when the unbound helper is used'] = function testItDoesNotUpdateWhenTheUnboundHelperIsUsed() {
      var _this13 = this;

      var template = this.wrapperFor([this.templateFor({
        cond: '(unbound cond1)',
        truthy: '"T1"',
        falsy: '"F1"'
      }), this.templateFor({
        cond: '(unbound cond2)',
        truthy: '"T2"',
        falsy: '"F2"'
      })]);
      this.render(template, {
        cond1: this.truthyValue,
        cond2: this.falsyValue
      });
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(function () {
        return _this13.rerender();
      });
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this13.context, 'cond1', _this13.falsyValue);
      });
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this13.context, 'cond1', _this13.truthyValue);
        (0, _metal.set)(_this13.context, 'cond2', _this13.truthyValue);
      });
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this13.context, 'cond1', _this13.truthyValue);
        (0, _metal.set)(_this13.context, 'cond2', _this13.falsyValue);
      });
      this.assertText('T1F2');
    };

    _proto9['@test evaluation should be lazy'] = function testEvaluationShouldBeLazy(assert) {
      var _this14 = this;

      var truthyEvaluated;
      var falsyEvaluated;

      var withoutEvaluatingTruthy = function (callback) {
        truthyEvaluated = false;
        callback();
        assert.ok(!truthyEvaluated, 'x-truthy is not evaluated');
      };

      var withoutEvaluatingFalsy = function (callback) {
        falsyEvaluated = false;
        callback();
        assert.ok(!falsyEvaluated, 'x-falsy is not evaluated');
      };

      this.registerHelper('x-truthy', {
        compute: function () {
          truthyEvaluated = true;
          return 'T';
        }
      });
      this.registerHelper('x-falsy', {
        compute: function () {
          falsyEvaluated = true;
          return 'F';
        }
      });
      var template = this.wrappedTemplateFor({
        cond: 'cond',
        truthy: '(x-truthy)',
        falsy: '(x-falsy)'
      });
      withoutEvaluatingFalsy(function () {
        return _this14.render(template, {
          cond: _this14.truthyValue
        });
      });
      this.assertText('T');
      withoutEvaluatingFalsy(function () {
        return (0, _internalTestHelpers.runTask)(function () {
          return _this14.rerender();
        });
      });
      this.assertText('T');
      withoutEvaluatingTruthy(function () {
        return (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(_this14.context, 'cond', _this14.falsyValue);
        });
      });
      this.assertText('F');
      withoutEvaluatingTruthy(function () {
        return (0, _internalTestHelpers.runTask)(function () {
          return _this14.rerender();
        });
      });
      this.assertText('F');
      withoutEvaluatingFalsy(function () {
        return (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(_this14.context, 'cond', _this14.truthyValue);
        });
      });
      this.assertText('T');
    };

    return TogglingHelperConditionalsTest;
  }(TogglingConditionalsTest);

  _exports.TogglingHelperConditionalsTest = TogglingHelperConditionalsTest;

  var IfUnlessHelperTest =
  /*#__PURE__*/
  function (_TogglingHelperCondit) {
    (0, _emberBabel.inheritsLoose)(IfUnlessHelperTest, _TogglingHelperCondit);

    function IfUnlessHelperTest() {
      return _TogglingHelperCondit.apply(this, arguments) || this;
    }

    return IfUnlessHelperTest;
  }(TogglingHelperConditionalsTest);

  _exports.IfUnlessHelperTest = IfUnlessHelperTest;

  _internalTestHelpers.applyMixins.apply(void 0, [IfUnlessHelperTest].concat(IfUnlessWithTestCases)); // Testing behaviors shared across the "toggling" syntatical constructs,
  // i.e. {{#if}}, {{#unless}}, {{#with}}, {{#each}} and {{#each-in}}


  var TogglingSyntaxConditionalsTest =
  /*#__PURE__*/
  function (_TogglingConditionals2) {
    (0, _emberBabel.inheritsLoose)(TogglingSyntaxConditionalsTest, _TogglingConditionals2);

    function TogglingSyntaxConditionalsTest() {
      return _TogglingConditionals2.apply(this, arguments) || this;
    }

    var _proto10 = TogglingSyntaxConditionalsTest.prototype;

    _proto10.renderValues = function renderValues() {
      var templates = [];
      var context = {};

      for (var i = 1; i <= arguments.length; i++) {
        templates.push(this.templateFor({
          cond: "cond" + i,
          truthy: "{{t}}" + i,
          falsy: "{{f}}" + i
        }));
        context["cond" + i] = i - 1 < 0 || arguments.length <= i - 1 ? undefined : arguments[i - 1];
      }

      var wrappedTemplate = this.wrapperFor(templates);
      this.render(wrappedTemplate, (0, _polyfills.assign)({
        t: 'T',
        f: 'F'
      }, context));
    };

    _proto10['@test it does not update when the unbound helper is used'] = function testItDoesNotUpdateWhenTheUnboundHelperIsUsed() {
      var _this15 = this;

      var template = "" + this.templateFor({
        cond: '(unbound cond1)',
        truthy: 'T1',
        falsy: 'F1'
      }) + this.templateFor({
        cond: '(unbound cond2)',
        truthy: 'T2',
        falsy: 'F2'
      });
      this.render(template, {
        cond1: this.truthyValue,
        cond2: this.falsyValue
      });
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(function () {
        return _this15.rerender();
      });
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this15.context, 'cond1', _this15.falsyValue);
      });
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this15.context, 'cond1', _this15.truthyValue);
        (0, _metal.set)(_this15.context, 'cond2', _this15.truthyValue);
      });
      this.assertText('T1F2');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this15.context, 'cond1', _this15.truthyValue);
        (0, _metal.set)(_this15.context, 'cond2', _this15.falsyValue);
      });
      this.assertText('T1F2');
    };

    _proto10['@test it has access to the outer scope from both templates'] = function testItHasAccessToTheOuterScopeFromBothTemplates() {
      var _this16 = this;

      var template = this.wrapperFor([this.templateFor({
        cond: 'cond1',
        truthy: '{{truthy}}',
        falsy: '{{falsy}}'
      }), this.templateFor({
        cond: 'cond2',
        truthy: '{{truthy}}',
        falsy: '{{falsy}}'
      })]);
      this.render(template, {
        cond1: this.truthyValue,
        cond2: this.falsyValue,
        truthy: 'YES',
        falsy: 'NO'
      });
      this.assertText('YESNO');
      (0, _internalTestHelpers.runTask)(function () {
        return _this16.rerender();
      });
      this.assertText('YESNO');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this16.context, 'truthy', 'YASS');
        (0, _metal.set)(_this16.context, 'falsy', 'NOPE');
      });
      this.assertText('YASSNOPE');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this16.context, 'cond1', _this16.falsyValue);
        (0, _metal.set)(_this16.context, 'cond2', _this16.truthyValue);
      });
      this.assertText('NOPEYASS');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this16.context, 'truthy', 'YES');
        (0, _metal.set)(_this16.context, 'falsy', 'NO');
        (0, _metal.set)(_this16.context, 'cond1', _this16.truthyValue);
        (0, _metal.set)(_this16.context, 'cond2', _this16.falsyValue);
      });
      this.assertText('YESNO');
    };

    _proto10['@test it updates correctly when enclosing another conditional'] = function testItUpdatesCorrectlyWhenEnclosingAnotherConditional() {
      var _this17 = this; // This tests whether the outer conditional tracks its bounds correctly as its inner bounds changes


      var inner = this.templateFor({
        cond: 'inner',
        truthy: 'T-inner',
        falsy: 'F-inner'
      });
      var template = this.wrappedTemplateFor({
        cond: 'outer',
        truthy: inner,
        falsy: 'F-outer'
      });
      this.render(template, {
        outer: this.truthyValue,
        inner: this.truthyValue
      });
      this.assertText('T-inner');
      (0, _internalTestHelpers.runTask)(function () {
        return _this17.rerender();
      });
      this.assertText('T-inner'); // Changes the inner bounds

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this17.context, 'inner', _this17.falsyValue);
      });
      this.assertText('F-inner'); // Now rerender the outer conditional, which require first clearing its bounds

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this17.context, 'outer', _this17.falsyValue);
      });
      this.assertText('F-outer');
    };

    _proto10['@test it updates correctly when enclosing #each'] = function testItUpdatesCorrectlyWhenEnclosingEach() {
      var _this18 = this; // This tests whether the outer conditional tracks its bounds correctly as its inner bounds changes


      var template = this.wrappedTemplateFor({
        cond: 'outer',
        truthy: '{{#each inner as |text|}}{{text}}{{/each}}',
        falsy: 'F-outer'
      });
      this.render(template, {
        outer: this.truthyValue,
        inner: ['inner', '-', 'before']
      });
      this.assertText('inner-before');
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.rerender();
      });
      this.assertText('inner-before'); // Changes the inner bounds

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this18.context, 'inner', ['inner-after']);
      });
      this.assertText('inner-after'); // Now rerender the outer conditional, which require first clearing its bounds

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this18.context, 'outer', _this18.falsyValue);
      });
      this.assertText('F-outer'); // Reset

      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this18.context, 'inner', ['inner-again']);
        (0, _metal.set)(_this18.context, 'outer', _this18.truthyValue);
      });
      this.assertText('inner-again'); // Now clear the inner bounds

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this18.context, 'inner', []);
      });
      this.assertText(''); // Now rerender the outer conditional, which require first clearing its bounds

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this18.context, 'outer', _this18.falsyValue);
      });
      this.assertText('F-outer');
    };

    _proto10['@test it updates correctly when enclosing triple-curlies'] = function testItUpdatesCorrectlyWhenEnclosingTripleCurlies() {
      var _this19 = this; // This tests whether the outer conditional tracks its bounds correctly as its inner bounds changes


      var template = this.wrappedTemplateFor({
        cond: 'outer',
        truthy: '{{{inner}}}',
        falsy: 'F-outer'
      });
      this.render(template, {
        outer: this.truthyValue,
        inner: '<b>inner</b>-<b>before</b>'
      });
      this.assertText('inner-before');
      (0, _internalTestHelpers.runTask)(function () {
        return _this19.rerender();
      });
      this.assertText('inner-before'); // Changes the inner bounds

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this19.context, 'inner', '<p>inner-after</p>');
      });
      this.assertText('inner-after'); // Now rerender the outer conditional, which require first clearing its bounds

      (0, _internalTestHelpers.runTask)(function () {
        return (0, _metal.set)(_this19.context, 'outer', _this19.falsyValue);
      });
      this.assertText('F-outer');
    };

    _proto10['@test child conditional should not render children if parent conditional becomes false'] = function testChildConditionalShouldNotRenderChildrenIfParentConditionalBecomesFalse(assert) {
      var _this20 = this;

      var childCreated = false;
      this.registerComponent('foo-bar', {
        template: 'foo-bar',
        ComponentClass: _helpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            childCreated = true;
          }
        })
      });
      var innerTemplate = this.templateFor({
        cond: 'cond2',
        truthy: '{{foo-bar}}',
        falsy: ''
      });
      var wrappedTemplate = this.wrappedTemplateFor({
        cond: 'cond1',
        truthy: innerTemplate,
        falsy: ''
      });
      this.render(wrappedTemplate, {
        cond1: this.truthyValue,
        cond2: this.falsyValue
      });
      assert.ok(!childCreated);
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        return _this20.rerender();
      });
      assert.ok(!childCreated);
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this20.context, 'cond2', _this20.truthyValue);
        (0, _metal.set)(_this20.context, 'cond1', _this20.falsyValue);
      });
      assert.ok(!childCreated);
      this.assertText('');
      (0, _internalTestHelpers.runTask)(function () {
        (0, _metal.set)(_this20.context, 'cond2', _this20.falsyValue);
        (0, _metal.set)(_this20.context, 'cond1', _this20.truthyValue);
      });
      assert.ok(!childCreated);
      this.assertText('');
    };

    _proto10['@test evaluation should be lazy'] = function testEvaluationShouldBeLazy(assert) {
      var _this21 = this;

      var truthyEvaluated;
      var falsyEvaluated;

      var withoutEvaluatingTruthy = function (callback) {
        truthyEvaluated = false;
        callback();
        assert.ok(!truthyEvaluated, 'x-truthy is not evaluated');
      };

      var withoutEvaluatingFalsy = function (callback) {
        falsyEvaluated = false;
        callback();
        assert.ok(!falsyEvaluated, 'x-falsy is not evaluated');
      };

      this.registerHelper('x-truthy', {
        compute: function () {
          truthyEvaluated = true;
          return 'T';
        }
      });
      this.registerHelper('x-falsy', {
        compute: function () {
          falsyEvaluated = true;
          return 'F';
        }
      });
      var template = this.wrappedTemplateFor({
        cond: 'cond',
        truthy: '{{x-truthy}}',
        falsy: '{{x-falsy}}'
      });
      withoutEvaluatingFalsy(function () {
        return _this21.render(template, {
          cond: _this21.truthyValue
        });
      });
      this.assertText('T');
      withoutEvaluatingFalsy(function () {
        return (0, _internalTestHelpers.runTask)(function () {
          return _this21.rerender();
        });
      });
      this.assertText('T');
      withoutEvaluatingTruthy(function () {
        return (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(_this21.context, 'cond', _this21.falsyValue);
        });
      });
      this.assertText('F');
      withoutEvaluatingTruthy(function () {
        return (0, _internalTestHelpers.runTask)(function () {
          return _this21.rerender();
        });
      });
      this.assertText('F');
      withoutEvaluatingFalsy(function () {
        return (0, _internalTestHelpers.runTask)(function () {
          return (0, _metal.set)(_this21.context, 'cond', _this21.truthyValue);
        });
      });
      this.assertText('T');
    };

    return TogglingSyntaxConditionalsTest;
  }(TogglingConditionalsTest);

  _exports.TogglingSyntaxConditionalsTest = TogglingSyntaxConditionalsTest;

  var IfUnlessWithSyntaxTest =
  /*#__PURE__*/
  function (_TogglingSyntaxCondit) {
    (0, _emberBabel.inheritsLoose)(IfUnlessWithSyntaxTest, _TogglingSyntaxCondit);

    function IfUnlessWithSyntaxTest() {
      return _TogglingSyntaxCondit.apply(this, arguments) || this;
    }

    return IfUnlessWithSyntaxTest;
  }(TogglingSyntaxConditionalsTest);

  _exports.IfUnlessWithSyntaxTest = IfUnlessWithSyntaxTest;

  _internalTestHelpers.applyMixins.apply(void 0, [IfUnlessWithSyntaxTest].concat(IfUnlessWithTestCases));
});
enifed("@ember/-internals/glimmer/tests/utils/string-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/glimmer/tests/utils/helpers"], function (_emberBabel, _internalTestHelpers, _helpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('SafeString',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test htmlSafe should return an instance of SafeString'] = function testHtmlSafeShouldReturnAnInstanceOfSafeString() {
      var safeString = (0, _helpers.htmlSafe)('you need to be more <b>bold</b>');
      this.assert.ok(safeString instanceof _helpers.SafeString, 'should be a SafeString');
    };

    _proto['@test htmlSafe should return an empty string for null'] = function testHtmlSafeShouldReturnAnEmptyStringForNull() {
      var safeString = (0, _helpers.htmlSafe)(null);
      this.assert.equal(safeString instanceof _helpers.SafeString, true, 'should be a SafeString');
      this.assert.equal(safeString.toString(), '', 'should return an empty string');
    };

    _proto['@test htmlSafe should return an instance of SafeString'] = function testHtmlSafeShouldReturnAnInstanceOfSafeString() {
      var safeString = (0, _helpers.htmlSafe)();
      this.assert.equal(safeString instanceof _helpers.SafeString, true, 'should be a SafeString');
      this.assert.equal(safeString.toString(), '', 'should return an empty string');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('SafeString isHTMLSafe',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test isHTMLSafe should detect SafeString'] = function testIsHTMLSafeShouldDetectSafeString() {
      var safeString = (0, _helpers.htmlSafe)('<em>Emphasize</em> the important things.');
      this.assert.ok((0, _helpers.isHTMLSafe)(safeString));
    };

    _proto2['@test isHTMLSafe should not detect SafeString on primatives'] = function testIsHTMLSafeShouldNotDetectSafeStringOnPrimatives() {
      this.assert.notOk((0, _helpers.isHTMLSafe)('Hello World'));
      this.assert.notOk((0, _helpers.isHTMLSafe)({}));
      this.assert.notOk((0, _helpers.isHTMLSafe)([]));
      this.assert.notOk((0, _helpers.isHTMLSafe)(10));
      this.assert.notOk((0, _helpers.isHTMLSafe)(null));
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/meta/tests/listeners_test", ["ember-babel", "internal-test-helpers", "@ember/-internals/meta"], function (_emberBabel, _internalTestHelpers, _meta) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.meta listeners',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test basics'] = function testBasics(assert) {
      var t = {};
      var m = (0, _meta.meta)({});
      m.addToListeners('hello', t, 'm', 0);
      var matching = m.matchingListeners('hello');
      assert.equal(matching.length, 3);
      assert.equal(matching[0], t);
      m.removeFromListeners('hello', t, 'm');
      matching = m.matchingListeners('hello');
      assert.equal(matching, undefined);
    };

    _proto['@test inheritance'] = function testInheritance(assert) {
      var target = {};
      var parent = {};
      var parentMeta = (0, _meta.meta)(parent);
      parentMeta.addToListeners('hello', target, 'm', 0);
      var child = Object.create(parent);
      var m = (0, _meta.meta)(child);
      var matching = m.matchingListeners('hello');
      assert.equal(matching.length, 3);
      assert.equal(matching[0], target);
      assert.equal(matching[1], 'm');
      assert.equal(matching[2], 0);
      m.removeFromListeners('hello', target, 'm');
      matching = m.matchingListeners('hello');
      assert.equal(matching, undefined);
      matching = parentMeta.matchingListeners('hello');
      assert.equal(matching.length, 3);
    };

    _proto['@test deduplication'] = function testDeduplication(assert) {
      var t = {};
      var m = (0, _meta.meta)({});
      m.addToListeners('hello', t, 'm', 0);
      m.addToListeners('hello', t, 'm', 0);
      var matching = m.matchingListeners('hello');
      assert.equal(matching.length, 3);
      assert.equal(matching[0], t);
    };

    _proto['@test parent caching'] = function testParentCaching(assert) {
      if (true
      /* DEBUG */
      ) {
          _meta.counters.flattenedListenersCalls = 0;
          _meta.counters.parentListenersUsed = 0;
        }

      var Class = function Class() {};

      var classMeta = (0, _meta.meta)(Class.prototype);
      classMeta.addToListeners('hello', null, 'm', 0);
      var instance = new Class();
      var m = (0, _meta.meta)(instance);
      var matching = m.matchingListeners('hello');
      assert.equal(matching.length, 3);

      if (true
      /* DEBUG */
      ) {
          assert.equal(_meta.counters.flattenedListenersCalls, 2);
          assert.equal(_meta.counters.parentListenersUsed, 1);
        }

      matching = m.matchingListeners('hello');
      assert.equal(matching.length, 3);

      if (true
      /* DEBUG */
      ) {
          assert.equal(_meta.counters.flattenedListenersCalls, 3);
          assert.equal(_meta.counters.parentListenersUsed, 1);
        }
    };

    _proto['@test parent cache invalidation'] = function testParentCacheInvalidation(assert) {
      if (true
      /* DEBUG */
      ) {
          _meta.counters.flattenedListenersCalls = 0;
          _meta.counters.parentListenersUsed = 0;
          _meta.counters.listenersInherited = 0;
        }

      var Class = function Class() {};

      var classMeta = (0, _meta.meta)(Class.prototype);
      classMeta.addToListeners('hello', null, 'm', 0);
      var instance = new Class();
      var m = (0, _meta.meta)(instance);
      var matching = m.matchingListeners('hello');
      assert.equal(matching.length, 3);

      if (true
      /* DEBUG */
      ) {
          assert.equal(_meta.counters.flattenedListenersCalls, 2);
          assert.equal(_meta.counters.parentListenersUsed, 1);
          assert.equal(_meta.counters.listenersInherited, 0);
        }

      m.addToListeners('hello', null, 'm2');
      matching = m.matchingListeners('hello');
      assert.equal(matching.length, 6);

      if (true
      /* DEBUG */
      ) {
          assert.equal(_meta.counters.flattenedListenersCalls, 4);
          assert.equal(_meta.counters.parentListenersUsed, 1);
          assert.equal(_meta.counters.listenersInherited, 1);
        }
    };

    _proto['@test reopen after flatten'] = function testReopenAfterFlatten(assert) {
      if (!true
      /* DEBUG */
      ) {
          assert.expect(0);
          return;
        } // Ensure counter is zeroed


      _meta.counters.reopensAfterFlatten = 0;

      var Class1 = function Class1() {};

      var class1Meta = (0, _meta.meta)(Class1.prototype);
      class1Meta.addToListeners('hello', null, 'm', 0);
      var instance1 = new Class1();
      var m1 = (0, _meta.meta)(instance1);

      var Class2 = function Class2() {};

      var class2Meta = (0, _meta.meta)(Class2.prototype);
      class2Meta.addToListeners('hello', null, 'm', 0);
      var instance2 = new Class2();
      var m2 = (0, _meta.meta)(instance2);
      m1.matchingListeners('hello');
      m2.matchingListeners('hello');
      assert.equal(_meta.counters.reopensAfterFlatten, 0, 'no reopen calls yet');
      m1.addToListeners('world', null, 'm', 0);
      m2.addToListeners('world', null, 'm', 0);
      m1.matchingListeners('world');
      m2.matchingListeners('world');
      assert.equal(_meta.counters.reopensAfterFlatten, 1, 'reopen calls after invalidating parent cache');
      m1.addToListeners('world', null, 'm', 0);
      m2.addToListeners('world', null, 'm', 0);
      m1.matchingListeners('world');
      m2.matchingListeners('world');
      assert.equal(_meta.counters.reopensAfterFlatten, 1, 'no reopen calls after mutating leaf nodes');
      class1Meta.removeFromListeners('hello', null, 'm');
      class2Meta.removeFromListeners('hello', null, 'm');
      m1.matchingListeners('hello');
      m2.matchingListeners('hello');
      assert.equal(_meta.counters.reopensAfterFlatten, 2, 'one reopen call after mutating parents');
      class1Meta.addToListeners('hello', null, 'm', 0);
      m1.matchingListeners('hello');
      class2Meta.addToListeners('hello', null, 'm', 0);
      m2.matchingListeners('hello');
      assert.equal(_meta.counters.reopensAfterFlatten, 3, 'one reopen call after mutating parents and flattening out of order');
    };

    _proto['@test removed listeners are removed from the underlying structure GH#1112213'] = function testRemovedListenersAreRemovedFromTheUnderlyingStructureGH1112213(assert) {
      // this is using private API to confirm the underlying data structure is properly maintained
      // and should be changed to match the data structure as needed
      var Class1 = function Class1() {};

      var class1Meta = (0, _meta.meta)(Class1.prototype);
      class1Meta.addToListeners('hello', null, 'm', 0);
      var instance1 = new Class1();
      var m1 = (0, _meta.meta)(instance1);

      function listenerFunc() {}

      m1.removeFromListeners('hello', null, 'm', 0);
      m1.addToListeners('stringListener', null, 'm', 0);
      m1.addToListeners('functionListener', null, listenerFunc, 0);
      m1.removeFromListeners('functionListener', null, listenerFunc, 0);
      m1.removeFromListeners('stringListener', null, 'm', 0);
      assert.equal(m1.flattenedListeners().length, 1, 'instance listeners correctly removed, inherited listeners remain');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/meta/tests/meta_test", ["ember-babel", "internal-test-helpers", "@ember/-internals/meta"], function (_emberBabel, _internalTestHelpers, _meta) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.meta',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test should return the same hash for an object'] = function testShouldReturnTheSameHashForAnObject(assert) {
      var obj = {};
      (0, _meta.meta)(obj).foo = 'bar';
      assert.equal((0, _meta.meta)(obj).foo, 'bar', 'returns same hash with multiple calls to Ember.meta()');
    };

    _proto['@test meta is not enumerable'] = function testMetaIsNotEnumerable(assert) {
      var proto, obj, props, prop;
      proto = {
        foo: 'bar'
      };
      (0, _meta.meta)(proto);
      obj = Object.create(proto);
      (0, _meta.meta)(obj);
      obj.bar = 'baz';
      props = [];

      for (prop in obj) {
        props.push(prop);
      }

      assert.deepEqual(props.sort(), ['bar', 'foo']);

      if (typeof JSON !== 'undefined' && 'stringify' in JSON) {
        try {
          JSON.stringify(obj);
        } catch (e) {
          assert.ok(false, 'meta should not fail JSON.stringify');
        }
      }
    };

    _proto['@test meta.writeWatching issues useful error after destroy'] = function testMetaWriteWatchingIssuesUsefulErrorAfterDestroy() {
      var target = {
        toString: function () {
          return '<special-sauce:123>';
        }
      };
      var targetMeta = (0, _meta.meta)(target);
      targetMeta.destroy();
      expectAssertion(function () {
        targetMeta.writeWatching('hello', 1);
      }, 'Cannot update watchers for `hello` on `<special-sauce:123>` after it has been destroyed.');
    };

    _proto['@test meta.writableTag issues useful error after destroy'] = function testMetaWritableTagIssuesUsefulErrorAfterDestroy() {
      var target = {
        toString: function () {
          return '<special-sauce:123>';
        }
      };
      var targetMeta = (0, _meta.meta)(target);
      targetMeta.destroy();
      expectAssertion(function () {
        targetMeta.writableTag(function () {});
      }, 'Cannot create a new tag for `<special-sauce:123>` after it has been destroyed.');
    };

    _proto['@test meta.writableChainWatchers issues useful error after destroy'] = function testMetaWritableChainWatchersIssuesUsefulErrorAfterDestroy() {
      var target = {
        toString: function () {
          return '<special-sauce:123>';
        }
      };
      var targetMeta = (0, _meta.meta)(target);
      targetMeta.destroy();
      expectAssertion(function () {
        targetMeta.writableChainWatchers(function () {});
      }, 'Cannot create a new chain watcher for `<special-sauce:123>` after it has been destroyed.');
    };

    _proto['@test meta.writableChains issues useful error after destroy'] = function testMetaWritableChainsIssuesUsefulErrorAfterDestroy() {
      var target = {
        toString: function () {
          return '<special-sauce:123>';
        }
      };
      var targetMeta = (0, _meta.meta)(target);
      targetMeta.destroy();
      expectAssertion(function () {
        targetMeta.writableChains(function () {});
      }, 'Cannot create a new chains for `<special-sauce:123>` after it has been destroyed.');
    };

    _proto['@test meta.writeValues issues useful error after destroy'] = function testMetaWriteValuesIssuesUsefulErrorAfterDestroy() {
      var target = {
        toString: function () {
          return '<special-sauce:123>';
        }
      };
      var targetMeta = (0, _meta.meta)(target);
      targetMeta.destroy();
      expectAssertion(function () {
        targetMeta.writeValues('derp', 'ohai');
      }, 'Cannot set the value of `derp` on `<special-sauce:123>` after it has been destroyed.');
    };

    _proto['@test meta.writeDeps issues useful error after destroy'] = function testMetaWriteDepsIssuesUsefulErrorAfterDestroy() {
      var target = {
        toString: function () {
          return '<special-sauce:123>';
        }
      };
      var targetMeta = (0, _meta.meta)(target);
      targetMeta.destroy();
      expectAssertion(function () {
        targetMeta.writeDeps('derp', 'ohai', 1);
      }, 'Cannot modify dependent keys for `ohai` on `<special-sauce:123>` after it has been destroyed.');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/accessors/get_path_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  var obj;
  (0, _internalTestHelpers.moduleFor)('get with path',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      obj = {
        foo: {
          bar: {
            baz: {
              biff: 'BIFF'
            }
          }
        },
        foothis: {
          bar: {
            baz: {
              biff: 'BIFF'
            }
          }
        },
        falseValue: false,
        emptyString: '',
        Wuz: {
          nar: 'foo'
        },
        nullValue: null
      };
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      obj = undefined;
    } // ..........................................................
    // LOCAL PATHS
    //
    ;

    _proto['@test [obj, foo] -> obj.foo'] = function testObjFooObjFoo(assert) {
      assert.deepEqual((0, _metal.get)(obj, 'foo'), obj.foo);
    };

    _proto['@test [obj, foo.bar] -> obj.foo.bar'] = function testObjFooBarObjFooBar(assert) {
      assert.deepEqual((0, _metal.get)(obj, 'foo.bar'), obj.foo.bar);
    };

    _proto['@test [obj, foothis.bar] -> obj.foothis.bar'] = function testObjFoothisBarObjFoothisBar(assert) {
      assert.deepEqual((0, _metal.get)(obj, 'foothis.bar'), obj.foothis.bar);
    };

    _proto['@test [obj, falseValue.notDefined] -> (undefined)'] = function testObjFalseValueNotDefinedUndefined(assert) {
      assert.strictEqual((0, _metal.get)(obj, 'falseValue.notDefined'), undefined);
    };

    _proto['@test [obj, emptyString.length] -> 0'] = function testObjEmptyStringLength0(assert) {
      assert.strictEqual((0, _metal.get)(obj, 'emptyString.length'), 0);
    };

    _proto['@test [obj, nullValue.notDefined] -> (undefined)'] = function testObjNullValueNotDefinedUndefined(assert) {
      assert.strictEqual((0, _metal.get)(obj, 'nullValue.notDefined'), undefined);
    } // ..........................................................
    // GLOBAL PATHS TREATED LOCAL WITH GET
    //
    ;

    _proto['@test [obj, Wuz] -> obj.Wuz'] = function testObjWuzObjWuz(assert) {
      assert.deepEqual((0, _metal.get)(obj, 'Wuz'), obj.Wuz);
    };

    _proto['@test [obj, Wuz.nar] -> obj.Wuz.nar'] = function testObjWuzNarObjWuzNar(assert) {
      assert.deepEqual((0, _metal.get)(obj, 'Wuz.nar'), obj.Wuz.nar);
    };

    _proto['@test [obj, Foo] -> (undefined)'] = function testObjFooUndefined(assert) {
      assert.strictEqual((0, _metal.get)(obj, 'Foo'), undefined);
    };

    _proto['@test [obj, Foo.bar] -> (undefined)'] = function testObjFooBarUndefined(assert) {
      assert.strictEqual((0, _metal.get)(obj, 'Foo.bar'), undefined);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/accessors/get_properties_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('getProperties',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test can retrieve a hash of properties from an object via an argument list or array of property names'] = function testCanRetrieveAHashOfPropertiesFromAnObjectViaAnArgumentListOrArrayOfPropertyNames(assert) {
      var obj = {
        firstName: 'Steve',
        lastName: 'Jobs',
        companyName: 'Apple, Inc.'
      };
      assert.deepEqual((0, _metal.getProperties)(obj, 'firstName', 'lastName'), {
        firstName: 'Steve',
        lastName: 'Jobs'
      });
      assert.deepEqual((0, _metal.getProperties)(obj, 'firstName', 'lastName'), {
        firstName: 'Steve',
        lastName: 'Jobs'
      });
      assert.deepEqual((0, _metal.getProperties)(obj, 'lastName'), {
        lastName: 'Jobs'
      });
      assert.deepEqual((0, _metal.getProperties)(obj), {});
      assert.deepEqual((0, _metal.getProperties)(obj, ['firstName', 'lastName']), {
        firstName: 'Steve',
        lastName: 'Jobs'
      });
      assert.deepEqual((0, _metal.getProperties)(obj, ['firstName']), {
        firstName: 'Steve'
      });
      assert.deepEqual((0, _metal.getProperties)(obj, []), {});
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/accessors/get_test", ["ember-babel", "@ember/-internals/environment", "@ember/-internals/runtime", "@ember/-internals/metal", "internal-test-helpers", "@ember/runloop"], function (_emberBabel, _environment, _runtime, _metal, _internalTestHelpers, _runloop) {
  "use strict";

  function aget(x, y) {
    return x[y];
  }

  (0, _internalTestHelpers.moduleFor)('get',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test should get arbitrary properties on an object'] = function testShouldGetArbitraryPropertiesOnAnObject(assert) {
      var obj = {
        string: 'string',
        number: 23,
        boolTrue: true,
        boolFalse: false,
        nullValue: null
      };

      for (var key in obj) {
        if (!obj.hasOwnProperty(key)) {
          continue;
        }

        assert.equal((0, _metal.get)(obj, key), obj[key], key);
      }
    };

    _proto['@test should retrieve a number key on an object'] = function testShouldRetrieveANumberKeyOnAnObject(assert) {
      var obj = {
        1: 'first'
      };
      assert.equal((0, _metal.get)(obj, 1), 'first');
    };

    _proto['@test should retrieve an array index'] = function testShouldRetrieveAnArrayIndex(assert) {
      var arr = ['first', 'second'];
      assert.equal((0, _metal.get)(arr, 0), 'first');
      assert.equal((0, _metal.get)(arr, 1), 'second');
    };

    _proto['@test should retrieve an empty string key on an object'] = function testShouldRetrieveAnEmptyStringKeyOnAnObject(assert) {
      var obj = {
        '': 'empty-string'
      };
      assert.equal((0, _metal.get)(obj, ''), 'empty-string');
    };

    _proto['@test should return undefined when passed an empty string if that key does not exist on an object'] = function testShouldReturnUndefinedWhenPassedAnEmptyStringIfThatKeyDoesNotExistOnAnObject(assert) {
      var obj = {
        tomster: true
      };
      assert.equal((0, _metal.get)(obj, ''), undefined);
    };

    _proto['@test should not access a property more than once'] = function testShouldNotAccessAPropertyMoreThanOnce(assert) {
      var count = 0;
      var obj = {
        get id() {
          return ++count;
        }

      };
      (0, _metal.get)(obj, 'id');
      assert.equal(count, 1);
    };

    _proto['@test should call unknownProperty on watched values if the value is undefined using getFromEmberMetal()/set()'] = function testShouldCallUnknownPropertyOnWatchedValuesIfTheValueIsUndefinedUsingGetFromEmberMetalSet(assert) {
      var obj = {
        unknownProperty: function (key) {
          assert.equal(key, 'foo', 'should pass key');
          return 'FOO';
        }
      };
      assert.equal((0, _metal.get)(obj, 'foo'), 'FOO', 'should return value from unknown');
    };

    _proto['@test should call unknownProperty on watched values if the value is undefined using accessors'] = function testShouldCallUnknownPropertyOnWatchedValuesIfTheValueIsUndefinedUsingAccessors(assert) {
      if (_environment.ENV.USES_ACCESSORS) {
        var obj = {
          unknownProperty: function (key) {
            assert.equal(key, 'foo', 'should pass key');
            return 'FOO';
          }
        };
        assert.equal(aget(obj, 'foo'), 'FOO', 'should return value from unknown');
      } else {
        assert.ok('SKIPPING ACCESSORS');
      }
    };

    _proto['@test get works with paths correctly'] = function testGetWorksWithPathsCorrectly(assert) {
      var func = function () {};

      func.bar = 'awesome';

      var destroyedObj = _runtime.Object.create({
        bar: 'great'
      });

      (0, _runloop.run)(function () {
        return destroyedObj.destroy();
      });
      assert.equal((0, _metal.get)({
        foo: null
      }, 'foo.bar'), undefined);
      assert.equal((0, _metal.get)({
        foo: {
          bar: 'hello'
        }
      }, 'foo.bar.length'), 5);
      assert.equal((0, _metal.get)({
        foo: func
      }, 'foo.bar'), 'awesome');
      assert.equal((0, _metal.get)({
        foo: func
      }, 'foo.bar.length'), 7);
      assert.equal((0, _metal.get)({}, 'foo.bar.length'), undefined);
      assert.equal((0, _metal.get)(function () {}, 'foo.bar.length'), undefined);
      assert.equal((0, _metal.get)('', 'foo.bar.length'), undefined);
      assert.equal((0, _metal.get)({
        foo: destroyedObj
      }, 'foo.bar'), undefined);
    };

    _proto['@test warn on attempts to call get with no arguments'] = function testWarnOnAttemptsToCallGetWithNoArguments() {
      expectAssertion(function () {
        (0, _metal.get)('aProperty');
      }, /Get must be called with two arguments;/i);
    };

    _proto['@test warn on attempts to call get with only one argument'] = function testWarnOnAttemptsToCallGetWithOnlyOneArgument() {
      expectAssertion(function () {
        (0, _metal.get)('aProperty');
      }, /Get must be called with two arguments;/i);
    };

    _proto['@test warn on attempts to call get with more then two arguments'] = function testWarnOnAttemptsToCallGetWithMoreThenTwoArguments() {
      expectAssertion(function () {
        (0, _metal.get)({}, 'aProperty', true);
      }, /Get must be called with two arguments;/i);
    };

    _proto['@test warn on attempts to get a property of undefined'] = function testWarnOnAttemptsToGetAPropertyOfUndefined() {
      expectAssertion(function () {
        (0, _metal.get)(undefined, 'aProperty');
      }, /Cannot call get with 'aProperty' on an undefined object/i);
    };

    _proto['@test warn on attempts to get a property path of undefined'] = function testWarnOnAttemptsToGetAPropertyPathOfUndefined() {
      expectAssertion(function () {
        (0, _metal.get)(undefined, 'aProperty.on.aPath');
      }, /Cannot call get with 'aProperty.on.aPath' on an undefined object/);
    };

    _proto['@test warn on attempts to get a property of null'] = function testWarnOnAttemptsToGetAPropertyOfNull() {
      expectAssertion(function () {
        (0, _metal.get)(null, 'aProperty');
      }, /Cannot call get with 'aProperty' on an undefined object/);
    };

    _proto['@test warn on attempts to get a property path of null'] = function testWarnOnAttemptsToGetAPropertyPathOfNull() {
      expectAssertion(function () {
        (0, _metal.get)(null, 'aProperty.on.aPath');
      }, /Cannot call get with 'aProperty.on.aPath' on an undefined object/);
    };

    _proto['@test warn on attempts to use get with an unsupported property path'] = function testWarnOnAttemptsToUseGetWithAnUnsupportedPropertyPath() {
      var obj = {};
      expectAssertion(function () {
        return (0, _metal.get)(obj, null);
      }, /The key provided to get must be a string or number, you passed null/);
      expectAssertion(function () {
        return (0, _metal.get)(obj, NaN);
      }, /The key provided to get must be a string or number, you passed NaN/);
      expectAssertion(function () {
        return (0, _metal.get)(obj, undefined);
      }, /The key provided to get must be a string or number, you passed undefined/);
      expectAssertion(function () {
        return (0, _metal.get)(obj, false);
      }, /The key provided to get must be a string or number, you passed false/);
    } // ..........................................................
    // BUGS
    //
    ;

    _proto['@test (regression) watched properties on unmodified inherited objects should still return their original value'] = function testRegressionWatchedPropertiesOnUnmodifiedInheritedObjectsShouldStillReturnTheirOriginalValue(assert) {
      var MyMixin = _metal.Mixin.create({
        someProperty: 'foo',
        propertyDidChange: (0, _metal.observer)('someProperty', function () {})
      });

      var baseObject = MyMixin.apply({});
      var theRealObject = Object.create(baseObject);
      assert.equal((0, _metal.get)(theRealObject, 'someProperty'), 'foo', 'should return the set value, not false');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('getWithDefault',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test should get arbitrary properties on an object'] = function testShouldGetArbitraryPropertiesOnAnObject(assert) {
      var obj = {
        string: 'string',
        number: 23,
        boolTrue: true,
        boolFalse: false,
        nullValue: null
      };

      for (var key in obj) {
        if (!obj.hasOwnProperty(key)) {
          continue;
        }

        assert.equal((0, _metal.getWithDefault)(obj, key, 'fail'), obj[key], key);
      }

      obj = {
        undef: undefined
      };
      assert.equal((0, _metal.getWithDefault)(obj, 'undef', 'default'), 'default', 'explicit undefined retrieves the default');
      assert.equal((0, _metal.getWithDefault)(obj, 'not-present', 'default'), 'default', 'non-present key retrieves the default');
    };

    _proto2['@test should call unknownProperty if defined and value is undefined'] = function testShouldCallUnknownPropertyIfDefinedAndValueIsUndefined(assert) {
      var obj = {
        count: 0,
        unknownProperty: function (key) {
          assert.equal(key, 'foo', 'should pass key');
          this.count++;
          return 'FOO';
        }
      };
      assert.equal((0, _metal.get)(obj, 'foo'), 'FOO', 'should return value from unknown');
      assert.equal(obj.count, 1, 'should have invoked');
    };

    _proto2['@test if unknownProperty is present, it is called using getFromEmberMetal()/set()'] = function testIfUnknownPropertyIsPresentItIsCalledUsingGetFromEmberMetalSet(assert) {
      var obj = {
        unknownProperty: function (key) {
          if (key === 'foo') {
            assert.equal(key, 'foo', 'should pass key');
            return 'FOO';
          }
        }
      };
      assert.equal((0, _metal.getWithDefault)(obj, 'foo', 'fail'), 'FOO', 'should return value from unknownProperty');
      assert.equal((0, _metal.getWithDefault)(obj, 'bar', 'default'), 'default', 'should convert undefined from unknownProperty into default');
    };

    _proto2['@test if unknownProperty is present, it is called using accessors'] = function testIfUnknownPropertyIsPresentItIsCalledUsingAccessors(assert) {
      if (_environment.ENV.USES_ACCESSORS) {
        var obj = {
          unknownProperty: function (key) {
            if (key === 'foo') {
              assert.equal(key, 'foo', 'should pass key');
              return 'FOO';
            }
          }
        };
        assert.equal(aget(obj, 'foo', 'fail'), 'FOO', 'should return value from unknownProperty');
        assert.equal(aget(obj, 'bar', 'default'), 'default', 'should convert undefined from unknownProperty into default');
      } else {
        assert.ok('SKIPPING ACCESSORS');
      }
    } // ..........................................................
    // BUGS
    //
    ;

    _proto2['@test (regression) watched properties on unmodified inherited objects should still return their original value'] = function testRegressionWatchedPropertiesOnUnmodifiedInheritedObjectsShouldStillReturnTheirOriginalValue(assert) {
      var MyMixin = _metal.Mixin.create({
        someProperty: 'foo',
        propertyDidChange: (0, _metal.observer)('someProperty', function () {
          /* nothing to do */
        })
      });

      var baseObject = MyMixin.apply({});
      var theRealObject = Object.create(baseObject);
      assert.equal((0, _metal.getWithDefault)(theRealObject, 'someProperty', 'fail'), 'foo', 'should return the set value, not false');
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/accessors/mandatory_setters_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/meta", "internal-test-helpers"], function (_emberBabel, _metal, _meta, _internalTestHelpers) {
  "use strict";

  function hasMandatorySetter(object, property) {
    try {
      return Object.getOwnPropertyDescriptor(object, property).set.isMandatorySetter === true;
    } catch (e) {
      return false;
    }
  }

  function hasMetaValue(object, property) {
    return (0, _meta.meta)(object).peekValues(property) !== undefined;
  }

  if (true
  /* DEBUG */
  && !false
  /* EMBER_METAL_TRACKED_PROPERTIES */
  ) {
      (0, _internalTestHelpers.moduleFor)('mandory-setters',
      /*#__PURE__*/
      function (_AbstractTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

        function _class() {
          return _AbstractTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto['@test does not assert if property is not being watched'] = function testDoesNotAssertIfPropertyIsNotBeingWatched(assert) {
          var obj = {
            someProp: null,
            toString: function () {
              return 'custom-object';
            }
          };
          obj.someProp = 'blastix';
          assert.equal((0, _metal.get)(obj, 'someProp'), 'blastix');
        };

        _proto['@test should not setup mandatory-setter if property is not writable'] = function testShouldNotSetupMandatorySetterIfPropertyIsNotWritable(assert) {
          assert.expect(6);
          var obj = {};
          Object.defineProperty(obj, 'a', {
            value: true
          });
          Object.defineProperty(obj, 'b', {
            value: false
          });
          Object.defineProperty(obj, 'c', {
            value: undefined
          });
          Object.defineProperty(obj, 'd', {
            value: undefined,
            writable: false
          });
          Object.defineProperty(obj, 'e', {
            value: undefined,
            configurable: false
          });
          Object.defineProperty(obj, 'f', {
            value: undefined,
            configurable: true
          });
          (0, _metal.watch)(obj, 'a');
          (0, _metal.watch)(obj, 'b');
          (0, _metal.watch)(obj, 'c');
          (0, _metal.watch)(obj, 'd');
          (0, _metal.watch)(obj, 'e');
          (0, _metal.watch)(obj, 'f');
          assert.ok(!hasMandatorySetter(obj, 'a'), 'mandatory-setter should not be installed');
          assert.ok(!hasMandatorySetter(obj, 'b'), 'mandatory-setter should not be installed');
          assert.ok(!hasMandatorySetter(obj, 'c'), 'mandatory-setter should not be installed');
          assert.ok(!hasMandatorySetter(obj, 'd'), 'mandatory-setter should not be installed');
          assert.ok(!hasMandatorySetter(obj, 'e'), 'mandatory-setter should not be installed');
          assert.ok(!hasMandatorySetter(obj, 'f'), 'mandatory-setter should not be installed');
        };

        _proto['@test should not teardown non mandatory-setter descriptor'] = function testShouldNotTeardownNonMandatorySetterDescriptor(assert) {
          assert.expect(1);
          var obj = {
            get a() {
              return 'hi';
            }

          };
          (0, _metal.watch)(obj, 'a');
          (0, _metal.unwatch)(obj, 'a');
          assert.equal(obj.a, 'hi');
        };

        _proto['@test should not confuse non descriptor watched gets'] = function testShouldNotConfuseNonDescriptorWatchedGets(assert) {
          assert.expect(2);
          var obj = {
            get a() {
              return 'hi';
            }

          };
          (0, _metal.watch)(obj, 'a');
          assert.equal((0, _metal.get)(obj, 'a'), 'hi');
          assert.equal(obj.a, 'hi');
        };

        _proto['@test should not setup mandatory-setter if setter is already setup on property'] = function testShouldNotSetupMandatorySetterIfSetterIsAlreadySetupOnProperty(assert) {
          assert.expect(2);
          var obj = {
            someProp: null
          };
          Object.defineProperty(obj, 'someProp', {
            get: function () {
              return null;
            },
            set: function (value) {
              assert.equal(value, 'foo-bar', 'custom setter was called');
            }
          });
          (0, _metal.watch)(obj, 'someProp');
          assert.ok(!hasMandatorySetter(obj, 'someProp'), 'mandatory-setter should not be installed');
          obj.someProp = 'foo-bar';
        };

        _proto['@test watched ES5 setter should not be smashed by mandatory setter'] = function testWatchedES5SetterShouldNotBeSmashedByMandatorySetter(assert) {
          var value;
          var obj = {
            get foo() {
              return value;
            },

            set foo(_value) {
              value = _value;
            }

          };
          (0, _metal.watch)(obj, 'foo');
          (0, _metal.set)(obj, 'foo', 2);
          assert.equal(value, 2);
        };

        _proto['@test should not setup mandatory-setter if setter is already setup on property in parent prototype'] = function testShouldNotSetupMandatorySetterIfSetterIsAlreadySetupOnPropertyInParentPrototype(assert) {
          assert.expect(2);

          function Foo() {}

          Object.defineProperty(Foo.prototype, 'someProp', {
            get: function () {
              return null;
            },
            set: function (value) {
              assert.equal(value, 'foo-bar', 'custom setter was called');
            }
          });
          var obj = new Foo();
          (0, _metal.watch)(obj, 'someProp');
          assert.ok(!hasMandatorySetter(obj, 'someProp'), 'mandatory-setter should not be installed');
          obj.someProp = 'foo-bar';
        };

        _proto['@test should not setup mandatory-setter if setter is already setup on property in grandparent prototype'] = function testShouldNotSetupMandatorySetterIfSetterIsAlreadySetupOnPropertyInGrandparentPrototype(assert) {
          assert.expect(2);

          function Foo() {}

          Object.defineProperty(Foo.prototype, 'someProp', {
            get: function () {
              return null;
            },
            set: function (value) {
              assert.equal(value, 'foo-bar', 'custom setter was called');
            }
          });

          function Bar() {}

          Bar.prototype = Object.create(Foo.prototype);
          Bar.prototype.constructor = Bar;
          var obj = new Bar();
          (0, _metal.watch)(obj, 'someProp');
          assert.ok(!hasMandatorySetter(obj, 'someProp'), 'mandatory-setter should not be installed');
          obj.someProp = 'foo-bar';
        };

        _proto['@test should not setup mandatory-setter if setter is already setup on property in great grandparent prototype'] = function testShouldNotSetupMandatorySetterIfSetterIsAlreadySetupOnPropertyInGreatGrandparentPrototype(assert) {
          assert.expect(2);

          function Foo() {}

          Object.defineProperty(Foo.prototype, 'someProp', {
            get: function () {
              return null;
            },
            set: function (value) {
              assert.equal(value, 'foo-bar', 'custom setter was called');
            }
          });

          function Bar() {}

          Bar.prototype = Object.create(Foo.prototype);
          Bar.prototype.constructor = Bar;

          function Qux() {}

          Qux.prototype = Object.create(Bar.prototype);
          Qux.prototype.constructor = Qux;
          var obj = new Qux();
          (0, _metal.watch)(obj, 'someProp');
          assert.ok(!hasMandatorySetter(obj, 'someProp'), 'mandatory-setter should not be installed');
          obj.someProp = 'foo-bar';
        };

        _proto['@test should assert if set without set when property is being watched'] = function testShouldAssertIfSetWithoutSetWhenPropertyIsBeingWatched() {
          var obj = {
            someProp: null,
            toString: function () {
              return 'custom-object';
            }
          };
          (0, _metal.watch)(obj, 'someProp');
          expectAssertion(function () {
            obj.someProp = 'foo-bar';
          }, 'You must use set() to set the `someProp` property (of custom-object) to `foo-bar`.');
        };

        _proto['@test should not assert if set with set when property is being watched'] = function testShouldNotAssertIfSetWithSetWhenPropertyIsBeingWatched(assert) {
          var obj = {
            someProp: null,
            toString: function () {
              return 'custom-object';
            }
          };
          (0, _metal.watch)(obj, 'someProp');
          (0, _metal.set)(obj, 'someProp', 'foo-bar');
          assert.equal((0, _metal.get)(obj, 'someProp'), 'foo-bar');
        };

        _proto['@test does not setup mandatory-setter if non-configurable'] = function testDoesNotSetupMandatorySetterIfNonConfigurable(assert) {
          var obj = {
            someProp: null,
            toString: function () {
              return 'custom-object';
            }
          };
          Object.defineProperty(obj, 'someProp', {
            configurable: false,
            enumerable: true,
            value: 'blastix'
          });
          (0, _metal.watch)(obj, 'someProp');
          assert.ok(!hasMandatorySetter(obj, 'someProp'), 'blastix');
        };

        _proto['@test ensure after watch the property is restored (and the value is no-longer stored in meta) [non-enumerable]'] = function testEnsureAfterWatchThePropertyIsRestoredAndTheValueIsNoLongerStoredInMetaNonEnumerable(assert) {
          var obj = {
            someProp: null,
            toString: function () {
              return 'custom-object';
            }
          };
          Object.defineProperty(obj, 'someProp', {
            configurable: true,
            enumerable: false,
            value: 'blastix'
          });
          (0, _metal.watch)(obj, 'someProp');
          assert.equal(hasMandatorySetter(obj, 'someProp'), true, 'should have a mandatory setter');
          var descriptor = Object.getOwnPropertyDescriptor(obj, 'someProp');
          assert.equal(descriptor.enumerable, false, 'property should remain non-enumerable');
          assert.equal(descriptor.configurable, true, 'property should remain configurable');
          assert.equal(obj.someProp, 'blastix', 'expected value to be the getter');
          assert.equal(descriptor.value, undefined, 'expected existing value to NOT remain');
          assert.ok(hasMetaValue(obj, 'someProp'), 'someProp is stored in meta.values');
          (0, _metal.unwatch)(obj, 'someProp');
          assert.ok(!hasMetaValue(obj, 'someProp'), 'someProp is no longer stored in meta.values');
          descriptor = Object.getOwnPropertyDescriptor(obj, 'someProp');
          assert.equal(hasMandatorySetter(obj, 'someProp'), false, 'should no longer have a mandatory setter');
          assert.equal(descriptor.enumerable, false, 'property should remain non-enumerable');
          assert.equal(descriptor.configurable, true, 'property should remain configurable');
          assert.equal(obj.someProp, 'blastix', 'expected value to be the getter');
          assert.equal(descriptor.value, 'blastix', 'expected existing value to remain');
          obj.someProp = 'new value'; // make sure the descriptor remains correct (nothing funky, like a redefined, happened in the setter);

          descriptor = Object.getOwnPropertyDescriptor(obj, 'someProp');
          assert.equal(descriptor.enumerable, false, 'property should remain non-enumerable');
          assert.equal(descriptor.configurable, true, 'property should remain configurable');
          assert.equal(descriptor.value, 'new value', 'expected existing value to NOT remain');
          assert.equal(obj.someProp, 'new value', 'expected value to be the getter');
          assert.equal(obj.someProp, 'new value');
        };

        _proto['@test ensure after watch the property is restored (and the value is no-longer stored in meta) [enumerable]'] = function testEnsureAfterWatchThePropertyIsRestoredAndTheValueIsNoLongerStoredInMetaEnumerable(assert) {
          var obj = {
            someProp: null,
            toString: function () {
              return 'custom-object';
            }
          };
          Object.defineProperty(obj, 'someProp', {
            configurable: true,
            enumerable: true,
            value: 'blastix'
          });
          (0, _metal.watch)(obj, 'someProp');
          assert.equal(hasMandatorySetter(obj, 'someProp'), true, 'should have a mandatory setter');
          var descriptor = Object.getOwnPropertyDescriptor(obj, 'someProp');
          assert.equal(descriptor.enumerable, true, 'property should remain enumerable');
          assert.equal(descriptor.configurable, true, 'property should remain configurable');
          assert.equal(obj.someProp, 'blastix', 'expected value to be the getter');
          assert.equal(descriptor.value, undefined, 'expected existing value to NOT remain');
          assert.ok(hasMetaValue(obj, 'someProp'), 'someProp is stored in meta.values');
          (0, _metal.unwatch)(obj, 'someProp');
          assert.ok(!hasMetaValue(obj, 'someProp'), 'someProp is no longer stored in meta.values');
          descriptor = Object.getOwnPropertyDescriptor(obj, 'someProp');
          assert.equal(hasMandatorySetter(obj, 'someProp'), false, 'should no longer have a mandatory setter');
          assert.equal(descriptor.enumerable, true, 'property should remain enumerable');
          assert.equal(descriptor.configurable, true, 'property should remain configurable');
          assert.equal(obj.someProp, 'blastix', 'expected value to be the getter');
          assert.equal(descriptor.value, 'blastix', 'expected existing value to remain');
          obj.someProp = 'new value'; // make sure the descriptor remains correct (nothing funky, like a redefined, happened in the setter);

          descriptor = Object.getOwnPropertyDescriptor(obj, 'someProp');
          assert.equal(descriptor.enumerable, true, 'property should remain enumerable');
          assert.equal(descriptor.configurable, true, 'property should remain configurable');
          assert.equal(descriptor.value, 'new value', 'expected existing value to NOT remain');
          assert.equal(obj.someProp, 'new value');
        };

        _proto['@test sets up mandatory-setter if property comes from prototype'] = function testSetsUpMandatorySetterIfPropertyComesFromPrototype(assert) {
          assert.expect(2);
          var obj = {
            someProp: null,
            toString: function () {
              return 'custom-object';
            }
          };
          var obj2 = Object.create(obj);
          (0, _metal.watch)(obj2, 'someProp');
          assert.ok(hasMandatorySetter(obj2, 'someProp'), 'mandatory setter has been setup');
          expectAssertion(function () {
            obj2.someProp = 'foo-bar';
          }, 'You must use set() to set the `someProp` property (of custom-object) to `foo-bar`.');
        };

        _proto['@test inheritance remains live'] = function testInheritanceRemainsLive(assert) {
          function Parent() {}

          Parent.prototype.food = 'chips';
          var child = new Parent();
          assert.equal(child.food, 'chips');
          (0, _metal.watch)(child, 'food');
          assert.equal(child.food, 'chips');
          Parent.prototype.food = 'icecreame';
          assert.equal(child.food, 'icecreame');
          (0, _metal.unwatch)(child, 'food');
          assert.equal(child.food, 'icecreame');
          Parent.prototype.food = 'chips';
          assert.equal(child.food, 'chips');
        };

        _proto['@test inheritance remains live and preserves this'] = function testInheritanceRemainsLiveAndPreservesThis(assert) {
          function Parent(food) {
            this._food = food;
          }

          Object.defineProperty(Parent.prototype, 'food', {
            get: function () {
              return this._food;
            }
          });
          var child = new Parent('chips');
          assert.equal(child.food, 'chips');
          (0, _metal.watch)(child, 'food');
          assert.equal(child.food, 'chips');
          child._food = 'icecreame';
          assert.equal(child.food, 'icecreame');
          (0, _metal.unwatch)(child, 'food');
          assert.equal(child.food, 'icecreame');
          var foodDesc = Object.getOwnPropertyDescriptor(Parent.prototype, 'food');
          assert.ok(!foodDesc.configurable, 'Parent.prototype.food desc should be non configable');
          assert.ok(!foodDesc.enumerable, 'Parent.prototype.food desc should be non enumerable');
          assert.equal(foodDesc.get.call({
            _food: 'hi'
          }), 'hi');
          assert.equal(foodDesc.set, undefined);
          assert.equal(child.food, 'icecreame');
        };

        return _class;
      }(_internalTestHelpers.AbstractTestCase));
    }
});
enifed("@ember/-internals/metal/tests/accessors/set_path_test", ["ember-babel", "@ember/-internals/environment", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _environment, _metal, _internalTestHelpers) {
  "use strict";

  var originalLookup = _environment.context.lookup;
  var lookup;
  var obj;

  function commonSetup() {
    _environment.context.lookup = lookup = {};
    obj = {
      foo: {
        bar: {
          baz: {
            biff: 'BIFF'
          }
        }
      }
    };
  }

  function commonTeardown() {
    _environment.context.lookup = originalLookup;
    obj = null;
  }

  (0, _internalTestHelpers.moduleFor)('set with path',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      commonSetup();
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      commonTeardown();
    };

    _proto['@test [Foo, bar] -> Foo.bar'] = function testFooBarFooBar(assert) {
      lookup.Foo = {
        toString: function () {
          return 'Foo';
        }
      }; // Behave like an Ember.Namespace

      (0, _metal.set)(lookup.Foo, 'bar', 'baz');
      assert.equal((0, _metal.get)(lookup.Foo, 'bar'), 'baz');
    } // ..........................................................
    //
    // LOCAL PATHS
    ;

    _proto['@test [obj, foo] -> obj.foo'] = function testObjFooObjFoo(assert) {
      (0, _metal.set)(obj, 'foo', 'BAM');
      assert.equal((0, _metal.get)(obj, 'foo'), 'BAM');
    };

    _proto['@test [obj, foo.bar] -> obj.foo.bar'] = function testObjFooBarObjFooBar(assert) {
      (0, _metal.set)(obj, 'foo.bar', 'BAM');
      assert.equal((0, _metal.get)(obj, 'foo.bar'), 'BAM');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('set with path - deprecated',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      var _this2;

      _this2 = _AbstractTestCase2.call(this) || this;
      commonSetup();
      return _this2;
    }

    var _proto2 = _class2.prototype;

    _proto2.teardown = function teardown() {
      commonTeardown();
    } // ..........................................................
    // DEPRECATED
    //
    ;

    _proto2['@test [obj, bla.bla] gives a proper exception message'] = function testObjBlaBlaGivesAProperExceptionMessage(assert) {
      var exceptionMessage = 'Property set failed: object in path "bla" could not be found.';

      try {
        (0, _metal.set)(obj, 'bla.bla', 'BAM');
      } catch (ex) {
        assert.equal(ex.message, exceptionMessage);
      }
    };

    _proto2['@test [obj, foo.baz.bat] -> EXCEPTION'] = function testObjFooBazBatEXCEPTION(assert) {
      assert.throws(function () {
        return (0, _metal.set)(obj, 'foo.baz.bat', 'BAM');
      });
    };

    _proto2['@test [obj, foo.baz.bat] -> EXCEPTION'] = function testObjFooBazBatEXCEPTION(assert) {
      (0, _metal.trySet)(obj, 'foo.baz.bat', 'BAM');
      assert.ok(true, 'does not raise');
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/accessors/set_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('set',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test should set arbitrary properties on an object'] = function testShouldSetArbitraryPropertiesOnAnObject(assert) {
      var obj = {
        string: 'string',
        number: 23,
        boolTrue: true,
        boolFalse: false,
        nullValue: null,
        undefinedValue: undefined
      };
      var newObj = {};

      for (var key in obj) {
        if (!obj.hasOwnProperty(key)) {
          continue;
        }

        assert.equal((0, _metal.set)(newObj, key, obj[key]), obj[key], 'should return value');
        assert.ok(key in newObj, 'should have key');
        assert.ok(newObj.hasOwnProperty(key), 'should have key');
        assert.equal((0, _metal.get)(newObj, key), obj[key], 'should set value');
      }
    };

    _proto['@test should set a number key on an object'] = function testShouldSetANumberKeyOnAnObject(assert) {
      var obj = {};
      (0, _metal.set)(obj, 1, 'first');
      assert.equal(obj[1], 'first');
    };

    _proto['@test should set an array index'] = function testShouldSetAnArrayIndex(assert) {
      var arr = ['first', 'second'];
      (0, _metal.set)(arr, 1, 'lol');
      assert.deepEqual(arr, ['first', 'lol']);
    };

    _proto['@test should call setUnknownProperty if defined and value is undefined'] = function testShouldCallSetUnknownPropertyIfDefinedAndValueIsUndefined(assert) {
      var obj = {
        count: 0,
        unknownProperty: function () {
          assert.ok(false, 'should not invoke unknownProperty if setUnknownProperty is defined');
        },
        setUnknownProperty: function (key, value) {
          assert.equal(key, 'foo', 'should pass key');
          assert.equal(value, 'BAR', 'should pass key');
          this.count++;
          return 'FOO';
        }
      };
      assert.equal((0, _metal.set)(obj, 'foo', 'BAR'), 'BAR', 'should return set value');
      assert.equal(obj.count, 1, 'should have invoked');
    };

    _proto['@test warn on attempts to call set with undefined as object'] = function testWarnOnAttemptsToCallSetWithUndefinedAsObject() {
      expectAssertion(function () {
        return (0, _metal.set)(undefined, 'aProperty', 'BAM');
      }, /Cannot call set with 'aProperty' on an undefined object./);
    };

    _proto['@test warn on attempts to call set with null as object'] = function testWarnOnAttemptsToCallSetWithNullAsObject() {
      expectAssertion(function () {
        return (0, _metal.set)(null, 'aProperty', 'BAM');
      }, /Cannot call set with 'aProperty' on an undefined object./);
    };

    _proto['@test warn on attempts to use set with an unsupported property path'] = function testWarnOnAttemptsToUseSetWithAnUnsupportedPropertyPath() {
      var obj = {};
      expectAssertion(function () {
        return (0, _metal.set)(obj, null, 42);
      }, /The key provided to set must be a string or number, you passed null/);
      expectAssertion(function () {
        return (0, _metal.set)(obj, NaN, 42);
      }, /The key provided to set must be a string or number, you passed NaN/);
      expectAssertion(function () {
        return (0, _metal.set)(obj, undefined, 42);
      }, /The key provided to set must be a string or number, you passed undefined/);
      expectAssertion(function () {
        return (0, _metal.set)(obj, false, 42);
      }, /The key provided to set must be a string or number, you passed false/);
    };

    _proto['@test warn on attempts of calling set on a destroyed object'] = function testWarnOnAttemptsOfCallingSetOnADestroyedObject() {
      var obj = {
        isDestroyed: true
      };
      expectAssertion(function () {
        return (0, _metal.set)(obj, 'favoriteFood', 'hot dogs');
      }, 'calling set on destroyed object: [object Object].favoriteFood = hot dogs');
    };

    _proto['@test does not trigger auto-run assertion for objects that have not been tagged'] = function testDoesNotTriggerAutoRunAssertionForObjectsThatHaveNotBeenTagged(assert) {
      var obj = {};
      (0, _metal.set)(obj, 'foo', 'bar');
      assert.equal(obj.foo, 'bar');
    };

    _proto['@test does not warn on attempts of calling set on a destroyed object with `trySet`'] = function testDoesNotWarnOnAttemptsOfCallingSetOnADestroyedObjectWithTrySet(assert) {
      var obj = {
        isDestroyed: true
      };
      (0, _metal.trySet)(obj, 'favoriteFood', 'hot dogs');
      assert.equal(obj.favoriteFood, undefined, 'does not set and does not error');
    };

    _proto['@test should work with native setters'] = function testShouldWorkWithNativeSetters(assert) {
      var count = 0;

      var Foo =
      /*#__PURE__*/
      function () {
        function Foo() {
          this.__foo = '';
        }

        (0, _emberBabel.createClass)(Foo, [{
          key: "foo",
          get: function () {
            return this.__foo;
          },
          set: function (value) {
            count++;
            this.__foo = "computed " + value;
          }
        }]);
        return Foo;
      }();

      var obj = new Foo();
      assert.equal((0, _metal.set)(obj, 'foo', 'bar'), 'bar', 'should return set value');
      assert.equal(count, 1, 'should have native setter');
      assert.equal((0, _metal.get)(obj, 'foo'), 'computed bar', 'should return new value');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/alias_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/runtime", "internal-test-helpers"], function (_emberBabel, _metal, _runtime, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var obj, count;

  function incrementCount() {
    count++;
  }

  (0, _internalTestHelpers.moduleFor)('@ember/-internals/metal/alias',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      obj = {
        foo: {
          faz: 'FOO'
        }
      };
      count = 0;
    };

    _proto.afterEach = function afterEach() {
      obj = null;
    };

    _proto['@test should proxy get to alt key'] = function testShouldProxyGetToAltKey(assert) {
      (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('foo.faz'));
      assert.equal((0, _metal.get)(obj, 'bar'), 'FOO');
    };

    _proto['@test should proxy set to alt key'] = function testShouldProxySetToAltKey(assert) {
      (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('foo.faz'));
      (0, _metal.set)(obj, 'bar', 'BAR');
      assert.equal((0, _metal.get)(obj, 'foo.faz'), 'BAR');
    };

    _proto['@test old dependent keys should not trigger property changes'] =
    /*#__PURE__*/
    function () {
      var _testOldDependentKeysShouldNotTriggerPropertyChanges = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var obj1;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              obj1 = Object.create(null);
              (0, _metal.defineProperty)(obj1, 'foo', null, null);
              (0, _metal.defineProperty)(obj1, 'bar', (0, _metal.alias)('foo'));
              (0, _metal.defineProperty)(obj1, 'baz', (0, _metal.alias)('foo'));
              (0, _metal.defineProperty)(obj1, 'baz', (0, _metal.alias)('bar')); // redefine baz
              // bootstrap the alias

              obj1.baz;
              (0, _metal.addObserver)(obj1, 'baz', incrementCount);
              (0, _metal.set)(obj1, 'foo', 'FOO');
              _context.next = 10;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 10:
              assert.equal(count, 1);
              (0, _metal.removeObserver)(obj1, 'baz', incrementCount);
              (0, _metal.set)(obj1, 'foo', 'OOF');
              _context.next = 15;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 15:
              assert.equal(count, 1);

            case 16:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function testOldDependentKeysShouldNotTriggerPropertyChanges(_x) {
        return _testOldDependentKeysShouldNotTriggerPropertyChanges.apply(this, arguments);
      }

      return testOldDependentKeysShouldNotTriggerPropertyChanges;
    }();

    _proto["@test inheriting an observer of the alias from the prototype then\n    redefining the alias on the instance to another property dependent on same key\n    does not call the observer twice"] =
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        var obj1, obj2;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              obj1 = _runtime.Object.extend({
                foo: null,
                bar: (0, _metal.alias)('foo'),
                baz: (0, _metal.alias)('foo'),
                incrementCount: incrementCount
              });
              (0, _metal.addObserver)(obj1.prototype, 'baz', null, 'incrementCount');
              obj2 = obj1.create();
              (0, _metal.defineProperty)(obj2, 'baz', (0, _metal.alias)('bar')); // override baz
              // bootstrap the alias

              obj2.baz;
              (0, _metal.set)(obj2, 'foo', 'FOO');
              _context2.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              assert.equal(count, 1);
              (0, _metal.removeObserver)(obj2, 'baz', null, 'incrementCount');
              (0, _metal.set)(obj2, 'foo', 'OOF');
              _context2.next = 13;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 13:
              assert.equal(count, 1);

            case 14:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));

      return function (_x2) {
        return _ref.apply(this, arguments);
      };
    }();

    _proto['@test an observer of the alias works if added after defining the alias'] =
    /*#__PURE__*/
    function () {
      var _testAnObserverOfTheAliasWorksIfAddedAfterDefiningTheAlias = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(assert) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('foo.faz')); // bootstrap the alias

              obj.bar;
              (0, _metal.addObserver)(obj, 'bar', incrementCount);
              (0, _metal.set)(obj, 'foo.faz', 'BAR');
              _context3.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              assert.equal(count, 1);

            case 7:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));

      function testAnObserverOfTheAliasWorksIfAddedAfterDefiningTheAlias(_x3) {
        return _testAnObserverOfTheAliasWorksIfAddedAfterDefiningTheAlias.apply(this, arguments);
      }

      return testAnObserverOfTheAliasWorksIfAddedAfterDefiningTheAlias;
    }();

    _proto['@test an observer of the alias works if added before defining the alias'] =
    /*#__PURE__*/
    function () {
      var _testAnObserverOfTheAliasWorksIfAddedBeforeDefiningTheAlias = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(assert) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              (0, _metal.addObserver)(obj, 'bar', incrementCount);
              (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('foo.faz')); // bootstrap the alias

              obj.bar;
              (0, _metal.set)(obj, 'foo.faz', 'BAR');
              _context4.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              assert.equal(count, 1);

            case 7:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));

      function testAnObserverOfTheAliasWorksIfAddedBeforeDefiningTheAlias(_x4) {
        return _testAnObserverOfTheAliasWorksIfAddedBeforeDefiningTheAlias.apply(this, arguments);
      }

      return testAnObserverOfTheAliasWorksIfAddedBeforeDefiningTheAlias;
    }();

    _proto['@test alias is dirtied if interior object of alias is set after consumption'] = function testAliasIsDirtiedIfInteriorObjectOfAliasIsSetAfterConsumption(assert) {
      (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('foo.faz'));
      (0, _metal.get)(obj, 'bar');
      var tag = false
      /* EMBER_METAL_TRACKED_PROPERTIES */
      ? (0, _metal.tagForProperty)(obj, 'bar') : (0, _metal.tagFor)(obj);
      var tagValue = tag.value();
      (0, _metal.set)(obj, 'foo.faz', 'BAR');
      assert.ok(!tag.validate(tagValue), 'setting the aliased key should dirty the object');
    };

    _proto['@test setting alias on self should fail assertion'] = function testSettingAliasOnSelfShouldFailAssertion() {
      expectAssertion(function () {
        return (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('bar'));
      }, "Setting alias 'bar' on self");
    };

    _proto['@test destroyed alias does not disturb watch count'] = function testDestroyedAliasDoesNotDisturbWatchCount(assert) {
      if (!false
      /* EMBER_METAL_TRACKED_PROPERTIES */
      ) {
          (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('foo.faz'));
          assert.equal((0, _metal.get)(obj, 'bar'), 'FOO');
          assert.ok((0, _metal.isWatching)(obj, 'foo.faz'));
          (0, _metal.defineProperty)(obj, 'bar', null);
          assert.notOk((0, _metal.isWatching)(obj, 'foo.faz'));
        } else {
        assert.expect(0);
      }
    };

    _proto['@test setting on oneWay alias does not disturb watch count'] = function testSettingOnOneWayAliasDoesNotDisturbWatchCount(assert) {
      if (!false
      /* EMBER_METAL_TRACKED_PROPERTIES */
      ) {
          (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('foo.faz').oneWay());
          assert.equal((0, _metal.get)(obj, 'bar'), 'FOO');
          assert.ok((0, _metal.isWatching)(obj, 'foo.faz'));
          (0, _metal.set)(obj, 'bar', null);
          assert.notOk((0, _metal.isWatching)(obj, 'foo.faz'));
        } else {
        assert.expect(0);
      }
    };

    _proto['@test redefined alias with observer does not disturb watch count'] = function testRedefinedAliasWithObserverDoesNotDisturbWatchCount(assert) {
      if (!false
      /* EMBER_METAL_TRACKED_PROPERTIES */
      ) {
          (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('foo.faz').oneWay());
          assert.equal((0, _metal.get)(obj, 'bar'), 'FOO');
          assert.ok((0, _metal.isWatching)(obj, 'foo.faz'));
          (0, _metal.addObserver)(obj, 'bar', incrementCount);
          assert.equal(count, 0);
          (0, _metal.set)(obj, 'bar', null);
          assert.equal(count, 1);
          assert.notOk((0, _metal.isWatching)(obj, 'foo.faz'));
          (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('foo.faz'));
          assert.equal(count, 1);
          assert.ok((0, _metal.isWatching)(obj, 'foo.faz'));
          (0, _metal.set)(obj, 'foo.faz', 'great');
          assert.equal(count, 2);
        } else {
        assert.expect(0);
      }
    };

    _proto['@test property tags are bumped when the source changes [GH#17243]'] = function testPropertyTagsAreBumpedWhenTheSourceChangesGH17243(assert) {
      function assertPropertyTagChanged(obj, keyName, callback) {
        var tag = (0, _metal.tagForProperty)(obj, keyName);
        var before = tag.value();
        callback();
        var after = tag.value();
        assert.notEqual(after, before, "tagForProperty " + keyName + " should change");
      }

      function assertPropertyTagUnchanged(obj, keyName, callback) {
        var tag = (0, _metal.tagForProperty)(obj, keyName);
        var before = tag.value();
        callback();
        var after = tag.value();
        assert.equal(after, before, "tagForProperty " + keyName + " should not change");
      }

      (0, _metal.defineProperty)(obj, 'bar', (0, _metal.alias)('foo.faz'));
      assertPropertyTagUnchanged(obj, 'bar', function () {
        assert.equal((0, _metal.get)(obj, 'bar'), 'FOO');
      });
      assertPropertyTagChanged(obj, 'bar', function () {
        (0, _metal.set)(obj, 'foo.faz', 'BAR');
      });
      assertPropertyTagUnchanged(obj, 'bar', function () {
        assert.equal((0, _metal.get)(obj, 'bar'), 'BAR');
      });
      assertPropertyTagUnchanged(obj, 'bar', function () {
        // trigger willWatch, then didUnwatch
        (0, _metal.addObserver)(obj, 'bar', incrementCount);
        (0, _metal.removeObserver)(obj, 'bar', incrementCount);
      });
      assertPropertyTagChanged(obj, 'bar', function () {
        (0, _metal.set)(obj, 'foo.faz', 'FOO');
      });
      assertPropertyTagUnchanged(obj, 'bar', function () {
        assert.equal((0, _metal.get)(obj, 'bar'), 'FOO');
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/chains_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/meta", "internal-test-helpers"], function (_emberBabel, _metal, _meta, _internalTestHelpers) {
  "use strict";

  if (!false
  /* EMBER_METAL_TRACKED_PROPERTIES */
  ) {
      (0, _internalTestHelpers.moduleFor)('Chains',
      /*#__PURE__*/
      function (_AbstractTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

        function _class() {
          return _AbstractTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto['@test finishChains should properly copy chains from prototypes to instances'] = function testFinishChainsShouldProperlyCopyChainsFromPrototypesToInstances(assert) {
          function didChange() {}

          var obj = {};
          (0, _metal.addObserver)(obj, 'foo.bar', null, didChange);
          var childObj = Object.create(obj);
          var parentMeta = (0, _meta.meta)(obj);
          var childMeta = (0, _meta.meta)(childObj);
          (0, _metal.finishChains)(childMeta);
          assert.ok(parentMeta.readableChains() !== childMeta.readableChains(), 'The chains object is copied');
        };

        _proto['@test does not observe primitive values'] = function testDoesNotObservePrimitiveValues(assert) {
          var obj = {
            foo: {
              bar: 'STRING'
            }
          };
          (0, _metal.addObserver)(obj, 'foo.bar.baz', null, function () {});
          var meta = (0, _meta.peekMeta)(obj);
          assert.notOk(meta._object);
        };

        _proto['@test observer and CP chains'] = function testObserverAndCPChains(assert) {
          var obj = {};
          (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('qux.[]', function () {}));
          (0, _metal.defineProperty)(obj, 'qux', (0, _metal.computed)(function () {})); // create DK chains

          (0, _metal.get)(obj, 'foo'); // create observer chain

          (0, _metal.addObserver)(obj, 'qux.length', function () {});
          /*
                +-----+
                | qux |   root CP
                +-----+
                    ^
            +------+-----+
            |            |
          +--------+    +----+
          | length |    | [] |  chainWatchers
          +--------+    +----+
          observer       CP(foo, 'qux.[]')
          */
          // invalidate qux

          (0, _metal.notifyPropertyChange)(obj, 'qux'); // CP chain is blown away

          /*
                +-----+
                | qux |   root CP
                +-----+
                    ^
            +------+xxxxxx
            |            x
          +--------+    xxxxxx
          | length |    x [] x  chainWatchers
          +--------+    xxxxxx
          observer       CP(foo, 'qux.[]')
          */

          (0, _metal.get)(obj, 'qux'); // CP chain re-recreated

          assert.ok(true, 'no crash');
        };

        _proto['@test checks cache correctly'] = function testChecksCacheCorrectly(assert) {
          var obj = {};
          var parentChainNode = new _metal.ChainNode(null, null, obj);
          var chainNode = new _metal.ChainNode(parentChainNode, 'foo');
          (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)(function () {
            return undefined;
          }));
          (0, _metal.get)(obj, 'foo');
          assert.strictEqual(chainNode.value(), undefined);
        };

        _proto['@test chains are watched correctly'] = function testChainsAreWatchedCorrectly(assert) {
          var obj = {
            foo: {
              bar: {
                baz: 1
              }
            }
          };
          (0, _metal.watch)(obj, 'foo.bar.baz');
          assert.equal((0, _metal.watcherCount)(obj, 'foo'), 1);
          assert.equal((0, _metal.watcherCount)(obj, 'foo.bar'), 0);
          assert.equal((0, _metal.watcherCount)(obj, 'foo.bar.baz'), 1);
          assert.equal((0, _metal.watcherCount)(obj.foo, 'bar'), 1);
          assert.equal((0, _metal.watcherCount)(obj.foo, 'bar.baz'), 0);
          assert.equal((0, _metal.watcherCount)(obj.foo.bar, 'baz'), 1);
          (0, _metal.unwatch)(obj, 'foo.bar.baz');
          assert.equal((0, _metal.watcherCount)(obj, 'foo'), 0);
          assert.equal((0, _metal.watcherCount)(obj, 'foo.bar'), 0);
          assert.equal((0, _metal.watcherCount)(obj, 'foo.bar.baz'), 0);
          assert.equal((0, _metal.watcherCount)(obj.foo, 'bar'), 0);
          assert.equal((0, _metal.watcherCount)(obj.foo, 'bar.baz'), 0);
          assert.equal((0, _metal.watcherCount)(obj.foo.bar, 'baz'), 0);
        };

        _proto['@test chains with single character keys are watched correctly'] = function testChainsWithSingleCharacterKeysAreWatchedCorrectly(assert) {
          var obj = {
            a: {
              b: {
                c: 1
              }
            }
          };
          (0, _metal.watch)(obj, 'a.b.c');
          assert.equal((0, _metal.watcherCount)(obj, 'a'), 1);
          assert.equal((0, _metal.watcherCount)(obj, 'a.b'), 0);
          assert.equal((0, _metal.watcherCount)(obj, 'a.b.c'), 1);
          assert.equal((0, _metal.watcherCount)(obj.a, 'b'), 1);
          assert.equal((0, _metal.watcherCount)(obj.a, 'b.c'), 0);
          assert.equal((0, _metal.watcherCount)(obj.a.b, 'c'), 1);
          (0, _metal.unwatch)(obj, 'a.b.c');
          assert.equal((0, _metal.watcherCount)(obj, 'a'), 0);
          assert.equal((0, _metal.watcherCount)(obj, 'a.b'), 0);
          assert.equal((0, _metal.watcherCount)(obj, 'a.b.c'), 0);
          assert.equal((0, _metal.watcherCount)(obj.a, 'b'), 0);
          assert.equal((0, _metal.watcherCount)(obj.a, 'b.c'), 0);
          assert.equal((0, _metal.watcherCount)(obj.a.b, 'c'), 0);
        };

        _proto['@test writable chains is not defined more than once'] = function testWritableChainsIsNotDefinedMoreThanOnce(assert) {
          assert.expect(0);

          var Base =
          /*#__PURE__*/
          function () {
            function Base() {
              (0, _metal.finishChains)((0, _meta.meta)(this));
            }

            var _proto2 = Base.prototype;

            _proto2.didChange = function didChange() {};

            return Base;
          }();

          Base.prototype.foo = {
            bar: {
              baz: {
                value: 123
              }
            }
          }; // Define a standard computed property, which will eventually setup dependencies

          (0, _metal.defineProperty)(Base.prototype, 'bar', (0, _metal.computed)('foo.bar', {
            get: function () {
              return this.foo.bar;
            }
          })); // Define some aliases, which will proxy chains along

          (0, _metal.defineProperty)(Base.prototype, 'baz', (0, _metal.alias)('bar.baz'));
          (0, _metal.defineProperty)(Base.prototype, 'value', (0, _metal.alias)('baz.value')); // Define an observer, which will eagerly attempt to setup chains and watch
          // their values. This follows the aliases eagerly, and forces the first
          // computed to actually set up its values/dependencies for chains. If
          // writableChains was not already defined, this results in multiple root
          // chain nodes being defined on the same object meta.

          (0, _metal.addObserver)(Base.prototype, 'value', null, 'didChange');

          var Child =
          /*#__PURE__*/
          function (_Base) {
            (0, _emberBabel.inheritsLoose)(Child, _Base);

            function Child() {
              return _Base.apply(this, arguments) || this;
            }

            return Child;
          }(Base);

          var childObj = new Child();
          (0, _metal.set)(childObj, 'foo.bar', {
            baz: {
              value: 456
            }
          });
        };

        return _class;
      }(_internalTestHelpers.AbstractTestCase));
    }
});
enifed("@ember/-internals/metal/tests/computed_decorator_test", ["ember-babel", "@ember/-internals/runtime", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _runtime, _metal, _internalTestHelpers) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }

    return desc;
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');
  }

  if (true
  /* EMBER_NATIVE_DECORATOR_SUPPORT */
  ) {
      (0, _internalTestHelpers.moduleFor)('computed - decorator - compatibility',
      /*#__PURE__*/
      function (_AbstractTestCase) {
        (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase);

        function _class2() {
          return _AbstractTestCase.apply(this, arguments) || this;
        }

        var _proto = _class2.prototype;

        _proto['@test computed can be used to compose new decorators'] = function testComputedCanBeUsedToComposeNewDecorators(assert) {
          var _class, _descriptor, _temp;

          var firstName = 'Diana';
          var firstNameAlias = (0, _metal.computed)('firstName', {
            get: function () {
              return this.firstName;
            }
          });
          var Class1 = (_class = (_temp = function Class1() {
            this.firstName = firstName;

            _initializerDefineProperty(this, "otherFirstName", _descriptor, this);
          }, _temp), _descriptor = _applyDecoratedDescriptor(_class.prototype, "otherFirstName", [firstNameAlias], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: null
          }), _class);

          var Class2 = _runtime.Object.extend({
            firstName: firstName,
            otherFirstName: firstNameAlias
          });

          var obj1 = new Class1();
          var obj2 = Class2.create();
          assert.equal(firstName, obj1.otherFirstName);
          assert.equal(firstName, obj2.otherFirstName);
        };

        _proto['@test decorator can still have a configuration object'] = function testDecoratorCanStillHaveAConfigurationObject(assert) {
          var _dec, _class3, _descriptor2, _temp2;

          var Foo = (_dec = (0, _metal.computed)('foo', {
            get: function () {
              return this.bar;
            }
          }), (_class3 = (_temp2 = function Foo() {
            this.bar = 'something';
            this.foo = 'else';

            _initializerDefineProperty(this, "baz", _descriptor2, this);
          }, _temp2), _descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "baz", [_dec], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: null
          }), _class3));
          var obj1 = new Foo();
          assert.equal('something', obj1.baz);
        };

        _proto['@test it works with functions'] = function testItWorksWithFunctions(assert) {
          var _dec2, _class5, _descriptor3, _temp3;

          assert.expect(2);
          var Foo = (_dec2 = (0, _metal.computed)('first', 'last', function () {
            assert.equal(this.first, 'rob');
            assert.equal(this.last, 'jackson');
          }), (_class5 = (_temp3 = function Foo() {
            this.first = 'rob';
            this.last = 'jackson';

            _initializerDefineProperty(this, "fullName", _descriptor3, this);
          }, _temp3), _descriptor3 = _applyDecoratedDescriptor(_class5.prototype, "fullName", [_dec2], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: null
          }), _class5));
          var obj = new Foo();
          (0, _metal.get)(obj, 'fullName');
        };

        _proto['@test computed property can be defined and accessed on a class constructor'] = function testComputedPropertyCanBeDefinedAndAccessedOnAClassConstructor(assert) {
          var _class7, _class8, _temp4;

          var count = 0;
          var Obj = (_class7 = (_temp4 = _class8 =
          /*#__PURE__*/
          function () {
            function Obj() {}

            (0, _emberBabel.createClass)(Obj, null, [{
              key: "foo",
              get: function () {
                count++;
                return this.bar;
              }
            }]);
            return Obj;
          }(), _class8.bar = 123, _temp4), _applyDecoratedDescriptor(_class7, "foo", [_metal.computed], Object.getOwnPropertyDescriptor(_class7, "foo"), _class7), _class7);
          assert.equal(Obj.foo, 123, 'should return value');
          Obj.foo;
          assert.equal(count, 1, 'should only call getter once');
        };

        _proto['@test it works with computed desc'] = function testItWorksWithComputedDesc(assert) {
          var _dec3, _class9, _descriptor4, _temp5;

          assert.expect(4);
          var expectedName = 'rob jackson';
          var expectedFirst = 'rob';
          var expectedLast = 'jackson';
          var Foo = (_dec3 = (0, _metal.computed)('first', 'last', {
            get: function () {
              assert.equal(this.first, expectedFirst, 'getter: first name matches');
              assert.equal(this.last, expectedLast, 'getter: last name matches');
              return this.first + " " + this.last;
            },
            set: function (key, name) {
              assert.equal(name, expectedName, 'setter: name matches');

              var _name$split = name.split(' '),
                  first = _name$split[0],
                  last = _name$split[1];

              (0, _metal.setProperties)(this, {
                first: first,
                last: last
              });
              return name;
            }
          }), (_class9 = (_temp5 = function Foo() {
            this.first = 'rob';
            this.last = 'jackson';

            _initializerDefineProperty(this, "fullName", _descriptor4, this);
          }, _temp5), _descriptor4 = _applyDecoratedDescriptor(_class9.prototype, "fullName", [_dec3], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: null
          }), _class9));
          var obj = new Foo();
          (0, _metal.get)(obj, 'fullName');
          expectedName = 'yehuda katz';
          expectedFirst = 'yehuda';
          expectedLast = 'katz';
          (0, _metal.set)(obj, 'fullName', 'yehuda katz');
          assert.strictEqual((0, _metal.get)(obj, 'fullName'), expectedName, 'return value of getter is new value of property');
        };

        _proto['@test it throws if it receives a desc and decorates a getter/setter'] = function testItThrowsIfItReceivesADescAndDecoratesAGetterSetter() {
          expectAssertion(function () {
            var _dec4, _class11, _temp6;

            var Foo = (_dec4 = (0, _metal.computed)('bar', {
              get: function () {
                return this.bar;
              }
            }), (_class11 = (_temp6 =
            /*#__PURE__*/
            function () {
              function Foo() {
                this.bar = void 0;
              }

              (0, _emberBabel.createClass)(Foo, [{
                key: "foo",
                set: function (value) {
                  (0, _metal.set)(this, 'bar', value);
                }
              }]);
              return Foo;
            }(), _temp6), _applyDecoratedDescriptor(_class11.prototype, "foo", [_dec4], Object.getOwnPropertyDescriptor(_class11.prototype, "foo"), _class11.prototype), _class11));
            new Foo();
          }, /Attempted to apply a computed property that already has a getter\/setter to a foo, but it is a method or an accessor./);
        };

        _proto['@test it throws if a CP is passed to it'] = function testItThrowsIfACPIsPassedToIt() {
          expectAssertion(function () {
            var _dec5, _class13, _descriptor5, _temp7;

            var Foo = (_dec5 = (0, _metal.computed)('bar', (0, _metal.computed)({
              get: function () {
                return this._foo;
              }
            })), (_class13 = (_temp7 = function Foo() {
              this.bar = void 0;

              _initializerDefineProperty(this, "foo", _descriptor5, this);
            }, _temp7), _descriptor5 = _applyDecoratedDescriptor(_class13.prototype, "foo", [_dec5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class13));
            new Foo();
          }, 'You attempted to pass a computed property instance to computed(). Computed property instances are decorator functions, and cannot be passed to computed() because they cannot be turned into decorators twice');
        };

        return _class2;
      }(_internalTestHelpers.AbstractTestCase));
      (0, _internalTestHelpers.moduleFor)('computed - decorator - usage tests',
      /*#__PURE__*/
      function (_AbstractTestCase2) {
        (0, _emberBabel.inheritsLoose)(_class4, _AbstractTestCase2);

        function _class4() {
          return _AbstractTestCase2.apply(this, arguments) || this;
        }

        var _proto2 = _class4.prototype;

        _proto2['@test computed property asserts the presence of a getter'] = function testComputedPropertyAssertsThePresenceOfAGetter() {
          expectAssertion(function () {
            var _dec6, _class15;

            var TestObj = (_dec6 = (0, _metal.computed)(), (_class15 =
            /*#__PURE__*/
            function () {
              function TestObj() {}

              var _proto3 = TestObj.prototype;

              _proto3.nonGetter = function nonGetter() {
                return true;
              };

              return TestObj;
            }(), _applyDecoratedDescriptor(_class15.prototype, "nonGetter", [_dec6], Object.getOwnPropertyDescriptor(_class15.prototype, "nonGetter"), _class15.prototype), _class15));
            new TestObj();
          }, /Try converting it to a getter/);
        };

        _proto2['@test computed property works with a getter'] = function testComputedPropertyWorksWithAGetter(assert) {
          var _class16;

          var TestObj = (_class16 =
          /*#__PURE__*/
          function () {
            function TestObj() {}

            (0, _emberBabel.createClass)(TestObj, [{
              key: "someGetter",
              get: function () {
                return true;
              }
            }]);
            return TestObj;
          }(), _applyDecoratedDescriptor(_class16.prototype, "someGetter", [_metal.computed], Object.getOwnPropertyDescriptor(_class16.prototype, "someGetter"), _class16.prototype), _class16);
          var instance = new TestObj();
          assert.ok(instance.someGetter);
        };

        _proto2['@test computed property with dependent key and getter'] = function testComputedPropertyWithDependentKeyAndGetter(assert) {
          var _dec7, _class17, _temp8;

          var TestObj = (_dec7 = (0, _metal.computed)('other'), (_class17 = (_temp8 =
          /*#__PURE__*/
          function () {
            function TestObj() {
              this.other = true;
            }

            (0, _emberBabel.createClass)(TestObj, [{
              key: "someGetter",
              get: function () {
                return "" + this.other;
              }
            }]);
            return TestObj;
          }(), _temp8), _applyDecoratedDescriptor(_class17.prototype, "someGetter", [_dec7], Object.getOwnPropertyDescriptor(_class17.prototype, "someGetter"), _class17.prototype), _class17));
          var instance = new TestObj();
          assert.equal(instance.someGetter, 'true');
          (0, _metal.set)(instance, 'other', false);
          assert.equal(instance.someGetter, 'false');
        };

        _proto2['@test computed property can be accessed without `get`'] = function testComputedPropertyCanBeAccessedWithoutGet(assert) {
          var _dec8, _class19;

          var count = 0;
          var Obj = (_dec8 = (0, _metal.computed)(), (_class19 =
          /*#__PURE__*/
          function () {
            function Obj() {}

            (0, _emberBabel.createClass)(Obj, [{
              key: "foo",
              get: function () {
                count++;
                return "computed foo";
              }
            }]);
            return Obj;
          }(), _applyDecoratedDescriptor(_class19.prototype, "foo", [_dec8], Object.getOwnPropertyDescriptor(_class19.prototype, "foo"), _class19.prototype), _class19));
          var obj = new Obj();
          assert.equal(obj.foo, 'computed foo', 'should return value');
          assert.equal(count, 1, 'should have invoked computed property');
        };

        _proto2['@test defining computed property should invoke property on get'] = function testDefiningComputedPropertyShouldInvokePropertyOnGet(assert) {
          var _dec9, _class20;

          var count = 0;
          var Obj = (_dec9 = (0, _metal.computed)(), (_class20 =
          /*#__PURE__*/
          function () {
            function Obj() {}

            (0, _emberBabel.createClass)(Obj, [{
              key: "foo",
              get: function () {
                count++;
                return "computed foo";
              }
            }]);
            return Obj;
          }(), _applyDecoratedDescriptor(_class20.prototype, "foo", [_dec9], Object.getOwnPropertyDescriptor(_class20.prototype, "foo"), _class20.prototype), _class20));
          var obj = new Obj();
          assert.equal(obj.foo, 'computed foo', 'should return value');
          assert.equal(count, 1, 'should have invoked computed property');
        };

        _proto2['@test setter is invoked with correct parameters'] = function testSetterIsInvokedWithCorrectParameters(assert) {
          var _dec10, _class21, _temp9;

          var count = 0;
          var Obj = (_dec10 = (0, _metal.computed)(), (_class21 = (_temp9 =
          /*#__PURE__*/
          function () {
            function Obj() {
              this.__foo = 'not set';
            }

            (0, _emberBabel.createClass)(Obj, [{
              key: "foo",
              get: function () {
                return this.__foo;
              },
              set: function (value) {
                count++;
                this.__foo = "computed " + value;
              }
            }]);
            return Obj;
          }(), _temp9), _applyDecoratedDescriptor(_class21.prototype, "foo", [_dec10], Object.getOwnPropertyDescriptor(_class21.prototype, "foo"), _class21.prototype), _class21));
          var obj = new Obj();
          assert.equal((0, _metal.set)(obj, 'foo', 'bar'), 'bar', 'should return set value with set()');
          assert.equal(count, 1, 'should have invoked computed property');
          assert.equal((0, _metal.get)(obj, 'foo'), 'computed bar', 'should return new value with get()');
        };

        _proto2['@test when not returning from setter, getter is called'] = function testWhenNotReturningFromSetterGetterIsCalled(assert) {
          var _dec11, _class23, _temp10;

          var count = 0;
          var Obj = (_dec11 = (0, _metal.computed)(), (_class23 = (_temp10 =
          /*#__PURE__*/
          function () {
            function Obj() {
              this.__foo = 'not set';
            }

            (0, _emberBabel.createClass)(Obj, [{
              key: "foo",
              get: function () {
                count++;
                return this.__foo;
              },
              set: function (value) {
                this.__foo = "computed " + value;
              }
            }]);
            return Obj;
          }(), _temp10), _applyDecoratedDescriptor(_class23.prototype, "foo", [_dec11], Object.getOwnPropertyDescriptor(_class23.prototype, "foo"), _class23.prototype), _class23));
          var obj = new Obj();
          assert.equal((0, _metal.set)(obj, 'foo', 'bar'), 'bar', 'should return set value with set()');
          assert.equal(count, 1, 'should have invoked getter');
        };

        _proto2['@test when returning from setter, getter is not called'] = function testWhenReturningFromSetterGetterIsNotCalled(assert) {
          var _dec12, _class25, _temp11;

          var count = 0;
          var Obj = (_dec12 = (0, _metal.computed)(), (_class25 = (_temp11 =
          /*#__PURE__*/
          function () {
            function Obj() {
              this.__foo = 'not set';
            }

            (0, _emberBabel.createClass)(Obj, [{
              key: "foo",
              get: function () {
                count++;
                return this.__foo;
              },
              set: function (value) {
                this.__foo = "computed " + value;
                return this.__foo;
              }
            }]);
            return Obj;
          }(), _temp11), _applyDecoratedDescriptor(_class25.prototype, "foo", [_dec12], Object.getOwnPropertyDescriptor(_class25.prototype, "foo"), _class25.prototype), _class25));
          var obj = new Obj();
          assert.equal((0, _metal.set)(obj, 'foo', 'bar'), 'bar', 'should return set value with set()');
          assert.equal(count, 0, 'should not have invoked getter');
        };

        _proto2['@test throws if a value is decorated twice'] = function testThrowsIfAValueIsDecoratedTwice() {
          expectAssertion(function () {
            var _class27;

            var Obj = (_class27 =
            /*#__PURE__*/
            function () {
              function Obj() {}

              (0, _emberBabel.createClass)(Obj, [{
                key: "foo",
                get: function () {
                  return this._foo;
                }
              }]);
              return Obj;
            }(), _applyDecoratedDescriptor(_class27.prototype, "foo", [_metal.computed, _metal.computed], Object.getOwnPropertyDescriptor(_class27.prototype, "foo"), _class27.prototype), _class27);
            new Obj();
          }, "Only one computed property decorator can be applied to a class field or accessor, but 'foo' was decorated twice. You may have added the decorator to both a getter and setter, which is unecessary.");
        };

        return _class4;
      }(_internalTestHelpers.AbstractTestCase));
    } else {
    (0, _internalTestHelpers.moduleFor)('computed - decorator - disabled',
    /*#__PURE__*/
    function (_AbstractTestCase3) {
      (0, _emberBabel.inheritsLoose)(_class6, _AbstractTestCase3);

      function _class6() {
        return _AbstractTestCase3.apply(this, arguments) || this;
      }

      var _proto4 = _class6.prototype;

      _proto4['@test using a native decorator throws if the feature flag is disabled'] = function testUsingANativeDecoratorThrowsIfTheFeatureFlagIsDisabled() {
        expectAssertion(function () {
          var _dec13, _class28, _descriptor6, _temp12;

          var Foo = (_dec13 = (0, _metal.computed)('foo', {
            get: function () {
              return this.bar;
            }
          }), (_class28 = (_temp12 = function Foo() {
            _initializerDefineProperty(this, "baz", _descriptor6, this);
          }, _temp12), _descriptor6 = _applyDecoratedDescriptor(_class28.prototype, "baz", [_dec13], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: null
          }), _class28));
          new Foo();
        }, 'Native decorators are not enabled without the EMBER_NATIVE_DECORATOR_SUPPORT flag');
      };

      return _class6;
    }(_internalTestHelpers.AbstractTestCase));
  }
});
enifed("@ember/-internals/metal/tests/computed_test", ["ember-babel", "@ember/-internals/runtime", "@ember/-internals/metal", "@ember/-internals/meta", "internal-test-helpers"], function (_emberBabel, _runtime, _metal, _meta, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var obj, count;
  (0, _internalTestHelpers.moduleFor)('computed',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test isComputed is true for computed property on a factory'] = function testIsComputedIsTrueForComputedPropertyOnAFactory(assert) {
      var Obj = _runtime.Object.extend({
        foo: (0, _metal.computed)(function () {})
      });

      Obj.proto(); // ensure the prototype is "collapsed" / merged

      assert.ok((0, _metal.isComputed)(Obj.prototype, 'foo'));
    };

    _proto['@test isComputed is true for computed property on an instance'] = function testIsComputedIsTrueForComputedPropertyOnAnInstance(assert) {
      var obj = _runtime.Object.extend({
        foo: (0, _metal.computed)(function () {})
      }).create();

      assert.ok((0, _metal.isComputed)(obj, 'foo'));
    };

    _proto['@test computed property should be an instance of descriptor'] = function testComputedPropertyShouldBeAnInstanceOfDescriptor(assert) {
      assert.ok((0, _metal.isClassicDecorator)((0, _metal.computed)(function () {})));
    };

    _proto['@test computed properties assert the presence of a getter or setter function'] = function testComputedPropertiesAssertThePresenceOfAGetterOrSetterFunction() {
      expectAssertion(function () {
        var obj = {};
        (0, _metal.defineProperty)(obj, 'someProp', (0, _metal.computed)('nogetternorsetter', {}));
      }, 'Computed properties must receive a getter or a setter, you passed none.');
    };

    _proto['@test computed properties check for the presence of a function or configuration object'] = function testComputedPropertiesCheckForThePresenceOfAFunctionOrConfigurationObject() {
      expectAssertion(function () {
        var obj = {};
        (0, _metal.defineProperty)(obj, 'someProp', (0, _metal.computed)('nolastargument'));
      }, 'Attempted to use @computed on someProp, but it did not have a getter or a setter. You must either pass a get a function or getter/setter to @computed directly (e.g. `@computed({ get() { ... } })`) or apply @computed directly to a getter/setter');
    } // non valid properties are stripped away in the process of creating a computed property descriptor
    ;

    _proto['@test computed properties defined with an object only allow `get` and `set` keys'] = function testComputedPropertiesDefinedWithAnObjectOnlyAllowGetAndSetKeys() {
      expectAssertion(function () {
        var obj = _runtime.Object.extend({
          someProp: (0, _metal.computed)({
            get: function () {},
            set: function () {},
            other: function () {}
          })
        });

        obj.create().someProp;
      }, 'Config object passed to computed can only contain `get` and `set` keys.');
    };

    _proto['@test computed property can be accessed without `get`'] = function testComputedPropertyCanBeAccessedWithoutGet(assert) {
      var obj = {};
      var count = 0;
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)(function (key) {
        count++;
        return 'computed ' + key;
      }));
      assert.equal(obj.foo, 'computed foo', 'should return value');
      assert.equal(count, 1, 'should have invoked computed property');
    };

    _proto['@test defining computed property should invoke property on get'] = function testDefiningComputedPropertyShouldInvokePropertyOnGet(assert) {
      var obj = {};
      var count = 0;
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)(function (key) {
        count++;
        return 'computed ' + key;
      }));
      assert.equal((0, _metal.get)(obj, 'foo'), 'computed foo', 'should return value');
      assert.equal(count, 1, 'should have invoked computed property');
    };

    _proto['@test computed property can be defined and accessed on a class constructor'] = function testComputedPropertyCanBeDefinedAndAccessedOnAClassConstructor(assert) {
      var count = 0;

      var Obj = _runtime.Object.extend();

      Obj.reopenClass({
        bar: 123,
        foo: (0, _metal.computed)(function () {
          count++;
          return this.bar;
        })
      });
      assert.equal(Obj.foo, 123, 'should return value');
      Obj.foo;
      assert.equal(count, 1, 'should only call getter once');
    };

    _proto['@test can override volatile computed property'] = function testCanOverrideVolatileComputedProperty(assert) {
      var obj = {};
      expectDeprecation(function () {
        (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)(function () {}).volatile());
      }, 'Setting a computed property as volatile has been deprecated. Instead, consider using a native getter with native class syntax.');
      expectDeprecation(function () {
        (0, _metal.set)(obj, 'foo', 'boom');
      }, /The \[object Object\]#foo computed property was just overriden./);
      assert.equal(obj.foo, 'boom');
    };

    _proto['@test defining computed property should invoke property on set'] = function testDefiningComputedPropertyShouldInvokePropertyOnSet(assert) {
      var obj = {};
      var count = 0;
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)({
        get: function (key) {
          return this['__' + key];
        },
        set: function (key, value) {
          count++;
          this['__' + key] = 'computed ' + value;
          return this['__' + key];
        }
      }));
      assert.equal((0, _metal.set)(obj, 'foo', 'bar'), 'bar', 'should return set value');
      assert.equal(count, 1, 'should have invoked computed property');
      assert.equal((0, _metal.get)(obj, 'foo'), 'computed bar', 'should return new value');
    } // this should be a unit test elsewhere
    // computed is more integration-like, and this test asserts on implementation details.
    // ['@test defining a computed property with a dependent key ending with @each is expanded to []'](
    //   assert
    // ) {
    //   let cp = computed('blazo.@each', function() {});
    //   assert.deepEqual(cp._dependentKeys, ['blazo.[]']);
    //   cp = computed('qux', 'zoopa.@each', function() {});
    //   assert.deepEqual(cp._dependentKeys, ['qux', 'zoopa.[]']);
    // }
    ;

    _proto['@test defining a computed property with a dependent key more than one level deep beyond @each is not supported'] = function testDefiningAComputedPropertyWithADependentKeyMoreThanOneLevelDeepBeyondEachIsNotSupported() {
      expectNoWarning(function () {
        var obj = {};
        (0, _metal.defineProperty)(obj, 'someProp', (0, _metal.computed)('todos', function () {}));
      });
      expectNoWarning(function () {
        var obj = {};
        (0, _metal.defineProperty)(obj, 'someProp', (0, _metal.computed)('todos.@each.owner', function () {}));
      });
      expectWarning(function () {
        var obj = {};
        (0, _metal.defineProperty)(obj, 'someProp', (0, _metal.computed)('todos.@each.owner.name', function () {}));
      }, /You used the key "todos\.@each\.owner\.name" which is invalid\. /);
      expectWarning(function () {
        var obj = {};
        (0, _metal.defineProperty)(obj, 'someProp', (0, _metal.computed)('todos.@each.owner.@each.name', function () {}));
      }, /You used the key "todos\.@each\.owner\.@each\.name" which is invalid\. /);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  var objA, objB;
  (0, _internalTestHelpers.moduleFor)('computed should inherit through prototype',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2.beforeEach = function beforeEach() {
      objA = {
        __foo: 'FOO'
      };
      (0, _metal.defineProperty)(objA, 'foo', (0, _metal.computed)({
        get: function (key) {
          return this['__' + key];
        },
        set: function (key, value) {
          this['__' + key] = 'computed ' + value;
          return this['__' + key];
        }
      }));
      objB = Object.create(objA);
      objB.__foo = 'FOO'; // make a copy;
    };

    _proto2.afterEach = function afterEach() {
      objA = objB = null;
    };

    _proto2['@test using get() and set()'] = function testUsingGetAndSet(assert) {
      assert.equal((0, _metal.get)(objA, 'foo'), 'FOO', 'should get FOO from A');
      assert.equal((0, _metal.get)(objB, 'foo'), 'FOO', 'should get FOO from B');
      (0, _metal.set)(objA, 'foo', 'BIFF');
      assert.equal((0, _metal.get)(objA, 'foo'), 'computed BIFF', 'should change A');
      assert.equal((0, _metal.get)(objB, 'foo'), 'FOO', 'should NOT change B');
      (0, _metal.set)(objB, 'foo', 'bar');
      assert.equal((0, _metal.get)(objB, 'foo'), 'computed bar', 'should change B');
      assert.equal((0, _metal.get)(objA, 'foo'), 'computed BIFF', 'should NOT change A');
      (0, _metal.set)(objA, 'foo', 'BAZ');
      assert.equal((0, _metal.get)(objA, 'foo'), 'computed BAZ', 'should change A');
      assert.equal((0, _metal.get)(objB, 'foo'), 'computed bar', 'should NOT change B');
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('redefining computed property to normal',
  /*#__PURE__*/
  function (_AbstractTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class3, _AbstractTestCase3);

    function _class3() {
      return _AbstractTestCase3.apply(this, arguments) || this;
    }

    var _proto3 = _class3.prototype;

    _proto3.beforeEach = function beforeEach() {
      objA = {
        __foo: 'FOO'
      };
      (0, _metal.defineProperty)(objA, 'foo', (0, _metal.computed)({
        get: function (key) {
          return this['__' + key];
        },
        set: function (key, value) {
          this['__' + key] = 'computed ' + value;
          return this['__' + key];
        }
      }));
      objB = Object.create(objA);
      (0, _metal.defineProperty)(objB, 'foo'); // make this just a normal property.
    };

    _proto3.afterEach = function afterEach() {
      objA = objB = null;
    };

    _proto3['@test using get() and set()'] = function testUsingGetAndSet(assert) {
      assert.equal((0, _metal.get)(objA, 'foo'), 'FOO', 'should get FOO from A');
      assert.equal((0, _metal.get)(objB, 'foo'), undefined, 'should get undefined from B');
      (0, _metal.set)(objA, 'foo', 'BIFF');
      assert.equal((0, _metal.get)(objA, 'foo'), 'computed BIFF', 'should change A');
      assert.equal((0, _metal.get)(objB, 'foo'), undefined, 'should NOT change B');
      (0, _metal.set)(objB, 'foo', 'bar');
      assert.equal((0, _metal.get)(objB, 'foo'), 'bar', 'should change B');
      assert.equal((0, _metal.get)(objA, 'foo'), 'computed BIFF', 'should NOT change A');
      (0, _metal.set)(objA, 'foo', 'BAZ');
      assert.equal((0, _metal.get)(objA, 'foo'), 'computed BAZ', 'should change A');
      assert.equal((0, _metal.get)(objB, 'foo'), 'bar', 'should NOT change B');
    };

    return _class3;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('redefining computed property to another property',
  /*#__PURE__*/
  function (_AbstractTestCase4) {
    (0, _emberBabel.inheritsLoose)(_class4, _AbstractTestCase4);

    function _class4() {
      return _AbstractTestCase4.apply(this, arguments) || this;
    }

    var _proto4 = _class4.prototype;

    _proto4.beforeEach = function beforeEach() {
      objA = {
        __foo: 'FOO'
      };
      (0, _metal.defineProperty)(objA, 'foo', (0, _metal.computed)({
        get: function (key) {
          return this['__' + key];
        },
        set: function (key, value) {
          this['__' + key] = 'A ' + value;
          return this['__' + key];
        }
      }));
      objB = Object.create(objA);
      objB.__foo = 'FOO';
      (0, _metal.defineProperty)(objB, 'foo', (0, _metal.computed)({
        get: function (key) {
          return this['__' + key];
        },
        set: function (key, value) {
          this['__' + key] = 'B ' + value;
          return this['__' + key];
        }
      }));
    };

    _proto4.afterEach = function afterEach() {
      objA = objB = null;
    };

    _proto4['@test using get() and set()'] = function testUsingGetAndSet(assert) {
      assert.equal((0, _metal.get)(objA, 'foo'), 'FOO', 'should get FOO from A');
      assert.equal((0, _metal.get)(objB, 'foo'), 'FOO', 'should get FOO from B');
      (0, _metal.set)(objA, 'foo', 'BIFF');
      assert.equal((0, _metal.get)(objA, 'foo'), 'A BIFF', 'should change A');
      assert.equal((0, _metal.get)(objB, 'foo'), 'FOO', 'should NOT change B');
      (0, _metal.set)(objB, 'foo', 'bar');
      assert.equal((0, _metal.get)(objB, 'foo'), 'B bar', 'should change B');
      assert.equal((0, _metal.get)(objA, 'foo'), 'A BIFF', 'should NOT change A');
      (0, _metal.set)(objA, 'foo', 'BAZ');
      assert.equal((0, _metal.get)(objA, 'foo'), 'A BAZ', 'should change A');
      assert.equal((0, _metal.get)(objB, 'foo'), 'B bar', 'should NOT change B');
    };

    return _class4;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('computed - metadata',
  /*#__PURE__*/
  function (_AbstractTestCase5) {
    (0, _emberBabel.inheritsLoose)(_class5, _AbstractTestCase5);

    function _class5() {
      return _AbstractTestCase5.apply(this, arguments) || this;
    }

    var _proto5 = _class5.prototype;

    _proto5['@test can set metadata on a computed property'] = function testCanSetMetadataOnAComputedProperty(assert) {
      var computedProperty = (0, _metal.computed)(function () {});
      computedProperty.meta({
        key: 'keyValue'
      });
      assert.equal(computedProperty.meta().key, 'keyValue', 'saves passed meta hash to the _meta property');
    };

    _proto5['@test meta should return an empty hash if no meta is set'] = function testMetaShouldReturnAnEmptyHashIfNoMetaIsSet(assert) {
      var computedProperty = (0, _metal.computed)(function () {});
      assert.deepEqual(computedProperty.meta(), {}, 'returned value is an empty hash');
    };

    return _class5;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // CACHEABLE
  //

  (0, _internalTestHelpers.moduleFor)('computed - cacheable',
  /*#__PURE__*/
  function (_AbstractTestCase6) {
    (0, _emberBabel.inheritsLoose)(_class6, _AbstractTestCase6);

    function _class6() {
      return _AbstractTestCase6.apply(this, arguments) || this;
    }

    var _proto6 = _class6.prototype;

    _proto6.beforeEach = function beforeEach() {
      obj = {};
      count = 0;

      var func = function () {
        count++;
        return 'bar ' + count;
      };

      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)({
        get: func,
        set: func
      }));
    };

    _proto6.afterEach = function afterEach() {
      obj = count = null;
    };

    _proto6['@test cacheable should cache'] = function testCacheableShouldCache(assert) {
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1', 'first get');
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1', 'second get');
      assert.equal(count, 1, 'should only invoke once');
    };

    _proto6['@test modifying a cacheable property should update cache'] = function testModifyingACacheablePropertyShouldUpdateCache(assert) {
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1', 'first get');
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1', 'second get');
      assert.equal((0, _metal.set)(obj, 'foo', 'baz'), 'baz', 'setting');
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 2', 'third get');
      assert.equal(count, 2, 'should not invoke again');
    };

    _proto6['@test inherited property should not pick up cache'] = function testInheritedPropertyShouldNotPickUpCache(assert) {
      var objB = Object.create(obj);
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1', 'obj first get');
      assert.equal((0, _metal.get)(objB, 'foo'), 'bar 2', 'objB first get');
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1', 'obj second get');
      assert.equal((0, _metal.get)(objB, 'foo'), 'bar 2', 'objB second get');
      (0, _metal.set)(obj, 'foo', 'baz'); // modify A

      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 3', 'obj third get');
      assert.equal((0, _metal.get)(objB, 'foo'), 'bar 2', 'objB third get');
    };

    _proto6['@test getCachedValueFor should return the cached value'] = function testGetCachedValueForShouldReturnTheCachedValue(assert) {
      assert.equal((0, _metal.getCachedValueFor)(obj, 'foo'), undefined, 'should not yet be a cached value');
      (0, _metal.get)(obj, 'foo');
      assert.equal((0, _metal.getCachedValueFor)(obj, 'foo'), 'bar 1', 'should retrieve cached value');
    };

    _proto6['@test getCachedValueFor should return falsy cached values'] = function testGetCachedValueForShouldReturnFalsyCachedValues(assert) {
      (0, _metal.defineProperty)(obj, 'falsy', (0, _metal.computed)(function () {
        return false;
      }));
      assert.equal((0, _metal.getCachedValueFor)(obj, 'falsy'), undefined, 'should not yet be a cached value');
      (0, _metal.get)(obj, 'falsy');
      assert.equal((0, _metal.getCachedValueFor)(obj, 'falsy'), false, 'should retrieve cached value');
    };

    _proto6['@test setting a cached computed property passes the old value as the third argument'] = function testSettingACachedComputedPropertyPassesTheOldValueAsTheThirdArgument(assert) {
      var obj = {
        foo: 0
      };
      var receivedOldValue;
      (0, _metal.defineProperty)(obj, 'plusOne', (0, _metal.computed)('foo', {
        get: function () {},
        set: function (key, value, oldValue) {
          receivedOldValue = oldValue;
          return value;
        }
      }));
      (0, _metal.set)(obj, 'plusOne', 1);
      assert.strictEqual(receivedOldValue, undefined, 'oldValue should be undefined');
      (0, _metal.set)(obj, 'plusOne', 2);
      assert.strictEqual(receivedOldValue, 1, 'oldValue should be 1');
      (0, _metal.set)(obj, 'plusOne', 3);
      assert.strictEqual(receivedOldValue, 2, 'oldValue should be 2');
    };

    return _class6;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // DEPENDENT KEYS
  //

  (0, _internalTestHelpers.moduleFor)('computed - dependentkey',
  /*#__PURE__*/
  function (_AbstractTestCase7) {
    (0, _emberBabel.inheritsLoose)(_class7, _AbstractTestCase7);

    function _class7() {
      return _AbstractTestCase7.apply(this, arguments) || this;
    }

    var _proto7 = _class7.prototype;

    _proto7.beforeEach = function beforeEach() {
      obj = {
        bar: 'baz'
      };
      count = 0;

      var getterAndSetter = function () {
        count++;
        (0, _metal.get)(this, 'bar');
        return 'bar ' + count;
      };

      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('bar', {
        get: getterAndSetter,
        set: getterAndSetter
      }));
    };

    _proto7.afterEach = function afterEach() {
      obj = count = null;
    };

    _proto7['@test circular keys should not blow up'] = function testCircularKeysShouldNotBlowUp(assert) {
      var func = function () {
        count++;
        return 'bar ' + count;
      };

      (0, _metal.defineProperty)(obj, 'bar', (0, _metal.computed)('foo', {
        get: func,
        set: func
      }));
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('bar', function () {
        count++;
        return 'foo ' + count;
      }));
      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 1', 'get once');
      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 1', 'cached retrieve');
      (0, _metal.set)(obj, 'bar', 'BIFF'); // should invalidate bar -> foo -> bar

      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 3', 'should recache');
      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 3', 'cached retrieve');
    };

    _proto7['@test redefining a property should undo old dependent keys'] = function testRedefiningAPropertyShouldUndoOldDependentKeys(assert) {
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1');
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('baz', function () {
        count++;
        return 'baz ' + count;
      }));
      assert.equal((0, _metal.get)(obj, 'foo'), 'baz 2');
      (0, _metal.set)(obj, 'bar', 'BIFF'); // should not kill cache

      assert.equal((0, _metal.get)(obj, 'foo'), 'baz 2');
      (0, _metal.set)(obj, 'baz', 'BOP');
      assert.equal((0, _metal.get)(obj, 'foo'), 'baz 3');
    };

    _proto7['@test can watch multiple dependent keys specified declaratively via brace expansion'] = function testCanWatchMultipleDependentKeysSpecifiedDeclarativelyViaBraceExpansion(assert) {
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('qux.{bar,baz}', function () {
        count++;
        return 'foo ' + count;
      }));
      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 1', 'get once');
      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 1', 'cached retrieve');
      (0, _metal.set)(obj, 'qux', {});
      (0, _metal.set)(obj, 'qux.bar', 'bar'); // invalidate foo

      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 2', 'foo invalidated from bar');
      (0, _metal.set)(obj, 'qux.baz', 'baz'); // invalidate foo

      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 3', 'foo invalidated from baz');
      (0, _metal.set)(obj, 'qux.quux', 'quux'); // do not invalidate foo

      assert.equal((0, _metal.get)(obj, 'foo'), 'foo 3', 'foo not invalidated by quux');
    };

    _proto7['@test throws assertion if brace expansion notation has spaces'] = function testThrowsAssertionIfBraceExpansionNotationHasSpaces() {
      expectAssertion(function () {
        (0, _metal.defineProperty)(obj, 'roo', (0, _metal.computed)('fee.{bar, baz,bop , }', function () {
          count++;
          return 'roo ' + count;
        }));
      }, /cannot contain spaces/);
    };

    _proto7['@test throws an assertion if an uncached `get` is called after object is destroyed'] = function testThrowsAnAssertionIfAnUncachedGetIsCalledAfterObjectIsDestroyed() {
      var meta = (0, _meta.meta)(obj);
      meta.destroy();

      obj.toString = function () {
        return '<custom-obj:here>';
      };

      var message = false
      /* EMBER_METAL_TRACKED_PROPERTIES */
      ? 'Attempted to access the computed <custom-obj:here>.foo on a destroyed object, which is not allowed' : 'Cannot modify dependent keys for `foo` on `<custom-obj:here>` after it has been destroyed.';
      expectAssertion(function () {
        return (0, _metal.get)(obj, 'foo');
      }, message);
    };

    return _class7;
  }(_internalTestHelpers.AbstractTestCase));

  if (!false
  /* EMBER_METAL_TRACKED_PROPERTIES */
  ) {
      (0, _internalTestHelpers.moduleFor)('computed - dependentkey - watching',
      /*#__PURE__*/
      function (_AbstractTestCase8) {
        (0, _emberBabel.inheritsLoose)(_class8, _AbstractTestCase8);

        function _class8() {
          return _AbstractTestCase8.apply(this, arguments) || this;
        }

        var _proto8 = _class8.prototype;

        _proto8.beforeEach = function beforeEach() {
          obj = {
            bar: 'baz'
          };
          count = 0;

          var getterAndSetter = function () {
            count++;
            (0, _metal.get)(this, 'bar');
            return 'bar ' + count;
          };

          (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('bar', {
            get: getterAndSetter,
            set: getterAndSetter
          }));
        };

        _proto8.afterEach = function afterEach() {
          obj = count = null;
        };

        _proto8['@test should lazily watch dependent keys on set'] = function testShouldLazilyWatchDependentKeysOnSet(assert) {
          assert.equal((0, _metal.isWatching)(obj, 'bar'), false, 'precond not watching dependent key');
          (0, _metal.set)(obj, 'foo', 'bar');
          assert.equal((0, _metal.isWatching)(obj, 'bar'), true, 'lazily watching dependent key');
        };

        _proto8['@test should lazily watch dependent keys on get'] = function testShouldLazilyWatchDependentKeysOnGet(assert) {
          assert.equal((0, _metal.isWatching)(obj, 'bar'), false, 'precond not watching dependent key');
          (0, _metal.get)(obj, 'foo');
          assert.equal((0, _metal.isWatching)(obj, 'bar'), true, 'lazily watching dependent key');
        };

        _proto8['@test local dependent key should invalidate cache'] = function testLocalDependentKeyShouldInvalidateCache(assert) {
          assert.equal((0, _metal.isWatching)(obj, 'bar'), false, 'precond not watching dependent key');
          assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1', 'get once');
          assert.equal((0, _metal.isWatching)(obj, 'bar'), true, 'lazily setup watching dependent key');
          assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1', 'cached retrieve');
          (0, _metal.set)(obj, 'bar', 'BIFF'); // should invalidate foo

          assert.equal((0, _metal.get)(obj, 'foo'), 'bar 2', 'should recache');
          assert.equal((0, _metal.get)(obj, 'foo'), 'bar 2', 'cached retrieve');
        };

        _proto8['@test should invalidate multiple nested dependent keys'] = function testShouldInvalidateMultipleNestedDependentKeys(assert) {
          var count = 0;
          (0, _metal.defineProperty)(obj, 'bar', (0, _metal.computed)('baz', function () {
            count++;
            (0, _metal.get)(this, 'baz');
            return 'baz ' + count;
          }));
          assert.equal((0, _metal.isWatching)(obj, 'bar'), false, 'precond not watching dependent key');
          assert.equal((0, _metal.isWatching)(obj, 'baz'), false, 'precond not watching dependent key');
          assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1', 'get once');
          assert.equal((0, _metal.isWatching)(obj, 'bar'), true, 'lazily setup watching dependent key');
          assert.equal((0, _metal.isWatching)(obj, 'baz'), true, 'lazily setup watching dependent key');
          assert.equal((0, _metal.get)(obj, 'foo'), 'bar 1', 'cached retrieve');
          (0, _metal.set)(obj, 'baz', 'BIFF'); // should invalidate bar -> foo

          assert.equal((0, _metal.isWatching)(obj, 'bar'), false, 'should not be watching dependent key after cache cleared');
          assert.equal((0, _metal.isWatching)(obj, 'baz'), false, 'should not be watching dependent key after cache cleared');
          assert.equal((0, _metal.get)(obj, 'foo'), 'bar 2', 'should recache');
          assert.equal((0, _metal.get)(obj, 'foo'), 'bar 2', 'cached retrieve');
          assert.equal((0, _metal.isWatching)(obj, 'bar'), true, 'lazily setup watching dependent key');
          assert.equal((0, _metal.isWatching)(obj, 'baz'), true, 'lazily setup watching dependent key');
        };

        return _class8;
      }(_internalTestHelpers.AbstractTestCase));
    } // ..........................................................
  // CHAINED DEPENDENT KEYS
  //


  var func;
  (0, _internalTestHelpers.moduleFor)('computed - dependentkey with chained properties',
  /*#__PURE__*/
  function (_AbstractTestCase9) {
    (0, _emberBabel.inheritsLoose)(_class9, _AbstractTestCase9);

    function _class9() {
      return _AbstractTestCase9.apply(this, arguments) || this;
    }

    var _proto9 = _class9.prototype;

    _proto9.beforeEach = function beforeEach() {
      obj = {
        foo: {
          bar: {
            baz: {
              biff: 'BIFF'
            }
          }
        }
      };
      count = 0;

      func = function () {
        count++;
        return (0, _metal.get)(obj, 'foo.bar.baz.biff') + ' ' + count;
      };
    };

    _proto9.afterEach = function afterEach() {
      obj = count = func = null;
    };

    _proto9['@test depending on simple chain'] = function testDependingOnSimpleChain(assert) {
      // assign computed property
      (0, _metal.defineProperty)(obj, 'prop', (0, _metal.computed)('foo.bar.baz.biff', func));
      assert.equal((0, _metal.get)(obj, 'prop'), 'BIFF 1');
      (0, _metal.set)((0, _metal.get)(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BUZZ 2');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BUZZ 2');
      (0, _metal.set)((0, _metal.get)(obj, 'foo.bar'), 'baz', {
        biff: 'BLOB'
      });
      assert.equal((0, _metal.get)(obj, 'prop'), 'BLOB 3');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BLOB 3');
      (0, _metal.set)((0, _metal.get)(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BUZZ 4');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BUZZ 4');
      (0, _metal.set)((0, _metal.get)(obj, 'foo'), 'bar', {
        baz: {
          biff: 'BOOM'
        }
      });
      assert.equal((0, _metal.get)(obj, 'prop'), 'BOOM 5');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BOOM 5');
      (0, _metal.set)((0, _metal.get)(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BUZZ 6');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BUZZ 6');
      (0, _metal.set)(obj, 'foo', {
        bar: {
          baz: {
            biff: 'BLARG'
          }
        }
      });
      assert.equal((0, _metal.get)(obj, 'prop'), 'BLARG 7');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BLARG 7');
      (0, _metal.set)((0, _metal.get)(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BUZZ 8');
      assert.equal((0, _metal.get)(obj, 'prop'), 'BUZZ 8');
      (0, _metal.defineProperty)(obj, 'prop');
      (0, _metal.set)(obj, 'prop', 'NONE');
      assert.equal((0, _metal.get)(obj, 'prop'), 'NONE');
      (0, _metal.set)(obj, 'foo', {
        bar: {
          baz: {
            biff: 'BLARG'
          }
        }
      });
      assert.equal((0, _metal.get)(obj, 'prop'), 'NONE'); // should do nothing

      assert.equal(count, 8, 'should be not have invoked computed again');
    };

    _proto9['@test chained dependent keys should evaluate computed properties lazily'] = function testChainedDependentKeysShouldEvaluateComputedPropertiesLazily(assert) {
      (0, _metal.defineProperty)(obj.foo.bar, 'b', (0, _metal.computed)(func));
      (0, _metal.defineProperty)(obj.foo, 'c', (0, _metal.computed)('bar.b', function () {}));
      assert.equal(count, 0, 'b should not run');
    };

    return _class9;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // improved-cp-syntax
  //

  (0, _internalTestHelpers.moduleFor)('computed - improved cp syntax',
  /*#__PURE__*/
  function (_AbstractTestCase10) {
    (0, _emberBabel.inheritsLoose)(_class10, _AbstractTestCase10);

    function _class10() {
      return _AbstractTestCase10.apply(this, arguments) || this;
    }

    var _proto10 = _class10.prototype;

    _proto10['@test setter and getters are passed using an object'] = function testSetterAndGettersArePassedUsingAnObject(assert) {
      var testObj = _runtime.Object.extend({
        a: '1',
        b: '2',
        aInt: (0, _metal.computed)('a', {
          get: function (keyName) {
            assert.equal(keyName, 'aInt', 'getter receives the keyName');
            return parseInt(this.get('a'));
          },
          set: function (keyName, value, oldValue) {
            assert.equal(keyName, 'aInt', 'setter receives the keyName');
            assert.equal(value, 123, 'setter receives the new value');
            assert.equal(oldValue, 1, 'setter receives the old value');
            this.set('a', String(value)); // side effect

            return parseInt(this.get('a'));
          }
        })
      }).create();

      assert.ok(testObj.get('aInt') === 1, 'getter works');
      testObj.set('aInt', 123);
      assert.ok(testObj.get('a') === '123', 'setter works');
      assert.ok(testObj.get('aInt') === 123, 'cp has been updated too');
    };

    _proto10['@test setter can be omited'] = function testSetterCanBeOmited(assert) {
      var testObj = _runtime.Object.extend({
        a: '1',
        b: '2',
        aInt: (0, _metal.computed)('a', {
          get: function (keyName) {
            assert.equal(keyName, 'aInt', 'getter receives the keyName');
            return parseInt(this.get('a'));
          }
        })
      }).create();

      assert.ok(testObj.get('aInt') === 1, 'getter works');
      assert.ok(testObj.get('a') === '1');
      expectDeprecation(function () {
        testObj.set('aInt', '123');
      }, /The <\(unknown\):ember\d*>#aInt computed property was just overriden/);
      assert.ok(testObj.get('aInt') === '123', 'cp has been updated too');
    };

    _proto10['@test getter can be omited'] = function testGetterCanBeOmited(assert) {
      var testObj = _runtime.Object.extend({
        com: (0, _metal.computed)({
          set: function (key, value) {
            return value;
          }
        })
      }).create();

      assert.ok(testObj.get('com') === undefined);
      testObj.set('com', '123');
      assert.ok(testObj.get('com') === '123', 'cp has been updated');
    };

    _proto10['@test the return value of the setter gets cached'] = function testTheReturnValueOfTheSetterGetsCached(assert) {
      var testObj = _runtime.Object.extend({
        a: '1',
        sampleCP: (0, _metal.computed)('a', {
          get: function () {
            assert.ok(false, 'The getter should not be invoked');
            return 'get-value';
          },
          set: function () {
            return 'set-value';
          }
        })
      }).create();

      testObj.set('sampleCP', 'abcd');
      assert.ok(testObj.get('sampleCP') === 'set-value', 'The return value of the CP was cached');
    };

    return _class10;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // BUGS
  //

  (0, _internalTestHelpers.moduleFor)('computed edge cases',
  /*#__PURE__*/
  function (_AbstractTestCase11) {
    (0, _emberBabel.inheritsLoose)(_class11, _AbstractTestCase11);

    function _class11() {
      return _AbstractTestCase11.apply(this, arguments) || this;
    }

    var _proto11 = _class11.prototype;

    _proto11['@test adding a computed property should show up in key iteration'] = function testAddingAComputedPropertyShouldShowUpInKeyIteration(assert) {
      var obj = {};
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)(function () {}));
      var found = [];

      for (var key in obj) {
        found.push(key);
      }

      assert.ok(found.indexOf('foo') >= 0, 'should find computed property in iteration found=' + found);
      assert.ok('foo' in obj, 'foo in obj should pass');
    };

    _proto11["@test when setting a value after it had been retrieved empty don't pass function UNDEFINED as oldValue"] = function testWhenSettingAValueAfterItHadBeenRetrievedEmptyDonTPassFunctionUNDEFINEDAsOldValue(assert) {
      var obj = {};
      var oldValueIsNoFunction = true;
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)({
        get: function () {},
        set: function (key, value, oldValue) {
          if (typeof oldValue === 'function') {
            oldValueIsNoFunction = false;
          }

          return undefined;
        }
      }));
      (0, _metal.get)(obj, 'foo');
      (0, _metal.set)(obj, 'foo', undefined);
      assert.ok(oldValueIsNoFunction);
    };

    return _class11;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('computed - setter',
  /*#__PURE__*/
  function (_AbstractTestCase12) {
    (0, _emberBabel.inheritsLoose)(_class12, _AbstractTestCase12);

    function _class12() {
      return _AbstractTestCase12.apply(this, arguments) || this;
    }

    var _proto12 = _class12.prototype;

    _proto12['@test setting a watched computed property'] =
    /*#__PURE__*/
    function () {
      var _testSettingAWatchedComputedProperty = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var obj, fullNameDidChange, firstNameDidChange, lastNameDidChange;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              obj = {
                firstName: 'Yehuda',
                lastName: 'Katz'
              };
              (0, _metal.defineProperty)(obj, 'fullName', (0, _metal.computed)('firstName', 'lastName', {
                get: function () {
                  return (0, _metal.get)(this, 'firstName') + ' ' + (0, _metal.get)(this, 'lastName');
                },
                set: function (key, value) {
                  var values = value.split(' ');
                  (0, _metal.set)(this, 'firstName', values[0]);
                  (0, _metal.set)(this, 'lastName', values[1]);
                  return value;
                }
              }));
              fullNameDidChange = 0;
              firstNameDidChange = 0;
              lastNameDidChange = 0;
              (0, _metal.addObserver)(obj, 'fullName', function () {
                fullNameDidChange++;
              });
              (0, _metal.addObserver)(obj, 'firstName', function () {
                firstNameDidChange++;
              });
              (0, _metal.addObserver)(obj, 'lastName', function () {
                lastNameDidChange++;
              });
              assert.equal((0, _metal.get)(obj, 'fullName'), 'Yehuda Katz');
              (0, _metal.set)(obj, 'fullName', 'Yehuda Katz');
              (0, _metal.set)(obj, 'fullName', 'Kris Selden');
              assert.equal((0, _metal.get)(obj, 'fullName'), 'Kris Selden');
              assert.equal((0, _metal.get)(obj, 'firstName'), 'Kris');
              assert.equal((0, _metal.get)(obj, 'lastName'), 'Selden');
              _context.next = 16;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 16:
              assert.equal(fullNameDidChange, 1);
              assert.equal(firstNameDidChange, 1);
              assert.equal(lastNameDidChange, 1);

            case 19:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function testSettingAWatchedComputedProperty(_x) {
        return _testSettingAWatchedComputedProperty.apply(this, arguments);
      }

      return testSettingAWatchedComputedProperty;
    }();

    _proto12['@test setting a cached computed property that modifies the value you give it'] =
    /*#__PURE__*/
    function () {
      var _testSettingACachedComputedPropertyThatModifiesTheValueYouGiveIt = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        var obj, plusOneDidChange;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              obj = {
                foo: 0
              };
              (0, _metal.defineProperty)(obj, 'plusOne', (0, _metal.computed)('foo', {
                get: function () {
                  return (0, _metal.get)(this, 'foo') + 1;
                },
                set: function (key, value) {
                  (0, _metal.set)(this, 'foo', value);
                  return value + 1;
                }
              }));
              plusOneDidChange = 0;
              (0, _metal.addObserver)(obj, 'plusOne', function () {
                plusOneDidChange++;
              });
              assert.equal((0, _metal.get)(obj, 'plusOne'), 1);
              (0, _metal.set)(obj, 'plusOne', 1);
              _context2.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              assert.equal((0, _metal.get)(obj, 'plusOne'), 2);
              (0, _metal.set)(obj, 'plusOne', 1);
              _context2.next = 12;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 12:
              assert.equal((0, _metal.get)(obj, 'plusOne'), 2);
              assert.equal(plusOneDidChange, 1);
              (0, _metal.set)(obj, 'foo', 5);
              _context2.next = 17;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 17:
              assert.equal((0, _metal.get)(obj, 'plusOne'), 6);
              assert.equal(plusOneDidChange, 2);

            case 19:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));

      function testSettingACachedComputedPropertyThatModifiesTheValueYouGiveIt(_x2) {
        return _testSettingACachedComputedPropertyThatModifiesTheValueYouGiveIt.apply(this, arguments);
      }

      return testSettingACachedComputedPropertyThatModifiesTheValueYouGiveIt;
    }();

    return _class12;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('computed - default setter',
  /*#__PURE__*/
  function (_AbstractTestCase13) {
    (0, _emberBabel.inheritsLoose)(_class13, _AbstractTestCase13);

    function _class13() {
      return _AbstractTestCase13.apply(this, arguments) || this;
    }

    var _proto13 = _class13.prototype;

    _proto13["@test when setting a value on a computed property that doesn't handle sets"] =
    /*#__PURE__*/
    function () {
      var _testWhenSettingAValueOnAComputedPropertyThatDoesnTHandleSets = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(assert) {
        var obj, observerFired;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              obj = {};
              observerFired = false;
              (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)(function () {
                return 'foo';
              }));
              (0, _metal.addObserver)(obj, 'foo', null, function () {
                return observerFired = true;
              });
              expectDeprecation(function () {
                (0, _metal.set)(obj, 'foo', 'bar');
              }, /The \[object Object\]#foo computed property was just overriden./);
              assert.equal((0, _metal.get)(obj, 'foo'), 'bar', 'The set value is properly returned');
              assert.ok(typeof obj.foo === 'string', 'The computed property was removed');
              _context3.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              assert.ok(observerFired, 'The observer was still notified');

            case 10:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));

      function testWhenSettingAValueOnAComputedPropertyThatDoesnTHandleSets(_x3) {
        return _testWhenSettingAValueOnAComputedPropertyThatDoesnTHandleSets.apply(this, arguments);
      }

      return testWhenSettingAValueOnAComputedPropertyThatDoesnTHandleSets;
    }();

    return _class13;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('computed - readOnly',
  /*#__PURE__*/
  function (_AbstractTestCase14) {
    (0, _emberBabel.inheritsLoose)(_class14, _AbstractTestCase14);

    function _class14() {
      return _AbstractTestCase14.apply(this, arguments) || this;
    }

    var _proto14 = _class14.prototype;

    _proto14['@test is chainable'] = function testIsChainable(assert) {
      var cp = (0, _metal.computed)(function () {});
      var readOnlyCp = cp.readOnly();
      assert.equal(cp, readOnlyCp);
    };

    _proto14['@test throws assertion if called over a CP with a setter defined with the new syntax'] = function testThrowsAssertionIfCalledOverACPWithASetterDefinedWithTheNewSyntax() {
      expectAssertion(function () {
        var obj = {};
        (0, _metal.defineProperty)(obj, 'someProp', (0, _metal.computed)({
          get: function () {},
          set: function () {}
        }).readOnly());
      }, /Computed properties that define a setter using the new syntax cannot be read-only/);
    };

    _proto14['@test protects against setting'] = function testProtectsAgainstSetting(assert) {
      var obj = {};
      (0, _metal.defineProperty)(obj, 'bar', (0, _metal.computed)(function () {
        return 'barValue';
      }).readOnly());
      assert.equal((0, _metal.get)(obj, 'bar'), 'barValue');
      assert.throws(function () {
        (0, _metal.set)(obj, 'bar', 'newBar');
      }, /Cannot set read\-only property "bar" on object:/);
      assert.equal((0, _metal.get)(obj, 'bar'), 'barValue');
    };

    return _class14;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/events_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/props/events_test',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test listener should receive event - removing should remove'] = function testListenerShouldReceiveEventRemovingShouldRemove(assert) {
      var obj = {};
      var count = 0;

      function F() {
        count++;
      }

      (0, _metal.addListener)(obj, 'event!', F);
      assert.equal(count, 0, 'nothing yet');
      (0, _metal.sendEvent)(obj, 'event!');
      assert.equal(count, 1, 'received event');
      (0, _metal.removeListener)(obj, 'event!', F);
      count = 0;
      (0, _metal.sendEvent)(obj, 'event!');
      assert.equal(count, 0, 'received event');
    };

    _proto['@test listeners should be inherited'] = function testListenersShouldBeInherited(assert) {
      var count = 0;
      var obj = {
        func: function () {
          count++;
        }
      };
      (0, _metal.addListener)(obj, 'event!', null, 'func');
      var obj2 = Object.create(obj);
      assert.equal(count, 0, 'nothing yet');
      (0, _metal.sendEvent)(obj2, 'event!');
      assert.equal(count, 1, 'received event');
      (0, _metal.removeListener)(obj2, 'event!', null, 'func');
      count = 0;
      (0, _metal.sendEvent)(obj2, 'event!');
      assert.equal(count, 0, 'did not receive event');
      (0, _metal.sendEvent)(obj, 'event!');
      assert.equal(count, 1, 'should still invoke on parent');
    };

    _proto['@test adding a listener more than once should only invoke once'] = function testAddingAListenerMoreThanOnceShouldOnlyInvokeOnce(assert) {
      var count = 0;
      var obj = {
        func: function () {
          count++;
        }
      };
      (0, _metal.addListener)(obj, 'event!', null, 'func');
      (0, _metal.addListener)(obj, 'event!', null, 'func');
      (0, _metal.sendEvent)(obj, 'event!');
      assert.equal(count, 1, 'should only invoke once');
    };

    _proto['@test adding a listener with a target should invoke with target'] = function testAddingAListenerWithATargetShouldInvokeWithTarget(assert) {
      var obj = {};
      var target;
      target = {
        count: 0,
        method: function () {
          this.count++;
        }
      };
      (0, _metal.addListener)(obj, 'event!', target, target.method);
      (0, _metal.sendEvent)(obj, 'event!');
      assert.equal(target.count, 1, 'should invoke');
    };

    _proto['@test adding a listener with string method should lookup method on event delivery'] = function testAddingAListenerWithStringMethodShouldLookupMethodOnEventDelivery(assert) {
      var obj = {};
      var target;
      target = {
        count: 0,
        method: function () {}
      };
      (0, _metal.addListener)(obj, 'event!', target, 'method');
      (0, _metal.sendEvent)(obj, 'event!');
      assert.equal(target.count, 0, 'should invoke but do nothing');

      target.method = function () {
        this.count++;
      };

      (0, _metal.sendEvent)(obj, 'event!');
      assert.equal(target.count, 1, 'should invoke now');
    };

    _proto['@test calling sendEvent with extra params should be passed to listeners'] = function testCallingSendEventWithExtraParamsShouldBePassedToListeners(assert) {
      var obj = {};
      var params = null;
      (0, _metal.addListener)(obj, 'event!', function () {
        params = Array.prototype.slice.call(arguments);
      });
      (0, _metal.sendEvent)(obj, 'event!', ['foo', 'bar']);
      assert.deepEqual(params, ['foo', 'bar'], 'params should be saved');
    };

    _proto['@test hasListeners tells you if there are listeners for a given event'] = function testHasListenersTellsYouIfThereAreListenersForAGivenEvent(assert) {
      var obj = {};

      function F() {}

      function F2() {}

      assert.equal((0, _metal.hasListeners)(obj, 'event!'), false, 'no listeners at first');
      (0, _metal.addListener)(obj, 'event!', F);
      (0, _metal.addListener)(obj, 'event!', F2);
      assert.equal((0, _metal.hasListeners)(obj, 'event!'), true, 'has listeners');
      (0, _metal.removeListener)(obj, 'event!', F);
      assert.equal((0, _metal.hasListeners)(obj, 'event!'), true, 'has listeners');
      (0, _metal.removeListener)(obj, 'event!', F2);
      assert.equal((0, _metal.hasListeners)(obj, 'event!'), false, 'has no more listeners');
      (0, _metal.addListener)(obj, 'event!', F);
      assert.equal((0, _metal.hasListeners)(obj, 'event!'), true, 'has listeners');
    };

    _proto['@test a listener can be added as part of a mixin'] = function testAListenerCanBeAddedAsPartOfAMixin(assert) {
      var triggered = 0;

      var MyMixin = _metal.Mixin.create({
        foo1: (0, _metal.on)('bar', function () {
          triggered++;
        }),
        foo2: (0, _metal.on)('bar', function () {
          triggered++;
        })
      });

      var obj = {};
      MyMixin.apply(obj);
      (0, _metal.sendEvent)(obj, 'bar');
      assert.equal(triggered, 2, 'should invoke listeners');
    };

    _proto["@test 'on' asserts for invalid arguments"] = function () {
      expectAssertion(function () {
        _metal.Mixin.create({
          foo1: (0, _metal.on)('bar')
        });
      }, 'on expects function as last argument');
      expectAssertion(function () {
        _metal.Mixin.create({
          foo1: (0, _metal.on)(function () {})
        });
      }, 'on called without valid event names');
    };

    _proto['@test a listener added as part of a mixin may be overridden'] = function testAListenerAddedAsPartOfAMixinMayBeOverridden(assert) {
      var triggered = 0;

      var FirstMixin = _metal.Mixin.create({
        foo: (0, _metal.on)('bar', function () {
          triggered++;
        })
      });

      var SecondMixin = _metal.Mixin.create({
        foo: (0, _metal.on)('baz', function () {
          triggered++;
        })
      });

      var obj = {};
      FirstMixin.apply(obj);
      SecondMixin.apply(obj);
      (0, _metal.sendEvent)(obj, 'bar');
      assert.equal(triggered, 0, 'should not invoke from overridden property');
      (0, _metal.sendEvent)(obj, 'baz');
      assert.equal(triggered, 1, 'should invoke from subclass property');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/expand_properties_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  var foundProperties = [];

  function addProperty(property) {
    foundProperties.push(property);
  }

  (0, _internalTestHelpers.moduleFor)('Property Brace Expansion Test',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      foundProperties = [];
    };

    _proto['@test Properties without expansions are unaffected'] = function testPropertiesWithoutExpansionsAreUnaffected(assert) {
      assert.expect(1);
      (0, _metal.expandProperties)('a', addProperty);
      (0, _metal.expandProperties)('a.b', addProperty);
      (0, _metal.expandProperties)('a.b.[]', addProperty);
      (0, _metal.expandProperties)('a.b.@each.c', addProperty);
      assert.deepEqual(['a', 'a.b', 'a.b.[]', 'a.b.@each.c'].sort(), foundProperties.sort());
    };

    _proto['@test A single expansion at the end expands properly'] = function testASingleExpansionAtTheEndExpandsProperly(assert) {
      assert.expect(1);
      (0, _metal.expandProperties)('a.b.{c,d}', addProperty);
      assert.deepEqual(['a.b.c', 'a.b.d'].sort(), foundProperties.sort());
    };

    _proto['@test A property with only a brace expansion expands correctly'] = function testAPropertyWithOnlyABraceExpansionExpandsCorrectly(assert) {
      assert.expect(1);
      (0, _metal.expandProperties)('{a,b,c}', addProperty);
      var expected = ['a', 'b', 'c'];
      assert.deepEqual(expected.sort(), foundProperties.sort());
    };

    _proto['@test Expansions with single properties only expand once'] = function testExpansionsWithSinglePropertiesOnlyExpandOnce(assert) {
      assert.expect(1);
      (0, _metal.expandProperties)('a.b.{c}.d.{e}', addProperty);
      assert.deepEqual(['a.b.c.d.e'], foundProperties);
    };

    _proto['@test A single brace expansion expands correctly'] = function testASingleBraceExpansionExpandsCorrectly(assert) {
      assert.expect(1);
      (0, _metal.expandProperties)('a.{b,c,d}.e', addProperty);
      var expected = ['a.b.e', 'a.c.e', 'a.d.e'];
      assert.deepEqual(expected.sort(), foundProperties.sort());
    };

    _proto['@test Multiple brace expansions work correctly'] = function testMultipleBraceExpansionsWorkCorrectly(assert) {
      assert.expect(1);
      (0, _metal.expandProperties)('{a,b,c}.d.{e,f}.g', addProperty);
      var expected = ['a.d.e.g', 'a.d.f.g', 'b.d.e.g', 'b.d.f.g', 'c.d.e.g', 'c.d.f.g'];
      assert.deepEqual(expected.sort(), foundProperties.sort());
    };

    _proto['@test A property with only brace expansions expands correctly'] = function testAPropertyWithOnlyBraceExpansionsExpandsCorrectly(assert) {
      assert.expect(1);
      (0, _metal.expandProperties)('{a,b,c}.{d}.{e,f}', addProperty);
      var expected = ['a.d.e', 'a.d.f', 'b.d.e', 'b.d.f', 'c.d.e', 'c.d.f'];
      assert.deepEqual(expected.sort(), foundProperties.sort());
    };

    _proto['@test Nested brace expansions are not allowed'] = function testNestedBraceExpansionsAreNotAllowed() {
      var nestedBraceProperties = ['a.{b.{c,d}}', 'a.{{b}.c}', 'a.{b,c}.{d.{e,f}.g', 'a.{b.{c}', 'a.{b,c}}', 'model.{bar,baz'];
      nestedBraceProperties.forEach(function (invalidProperties) {
        expectAssertion(function () {
          return (0, _metal.expandProperties)(invalidProperties, addProperty);
        });
      }, /Brace expanded properties have to be balanced and cannot be nested/);
    };

    _proto['@test A property with no braces does not expand'] = function testAPropertyWithNoBracesDoesNotExpand(assert) {
      assert.expect(1);
      (0, _metal.expandProperties)('a,b,c.d.e,f', addProperty);
      assert.deepEqual(foundProperties, ['a,b,c.d.e,f']);
    };

    _proto['@test A pattern must be a string'] = function testAPatternMustBeAString(assert) {
      assert.expect(1);
      expectAssertion(function () {
        (0, _metal.expandProperties)([1, 2], addProperty);
      }, /A computed property key must be a string/);
    };

    _proto['@test A pattern must not contain a space'] = function testAPatternMustNotContainASpace(assert) {
      assert.expect(1);
      expectAssertion(function () {
        (0, _metal.expandProperties)('{a, b}', addProperty);
      }, /Brace expanded properties cannot contain spaces, e.g. "user.{firstName, lastName}" should be "user.{firstName,lastName}"/);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/injected_property_test", ["ember-babel", "@ember/-internals/owner", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _owner, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('inject',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test injected properties should be descriptors'] = function testInjectedPropertiesShouldBeDescriptors(assert) {
      assert.ok((0, _metal.isClassicDecorator)((0, _metal.inject)('type')));
    };

    _proto['@test injected properties should be overridable'] = function testInjectedPropertiesShouldBeOverridable(assert) {
      var obj = {};
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.inject)('type'));
      (0, _metal.set)(obj, 'foo', 'bar');
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar', 'should return the overridden value');
    };

    _proto['@test getting on an object without an owner or container should fail assertion'] = function testGettingOnAnObjectWithoutAnOwnerOrContainerShouldFailAssertion() {
      var obj = {};
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.inject)('type', 'name'));
      expectAssertion(function () {
        (0, _metal.get)(obj, 'foo');
      }, /Attempting to lookup an injected property on an object without a container, ensure that the object was instantiated via a container./);
    };

    _proto['@test getting on an object without an owner but with a container should not fail'] = function testGettingOnAnObjectWithoutAnOwnerButWithAContainerShouldNotFail(assert) {
      var obj = {
        container: {
          lookup: function (key) {
            assert.ok(true, 'should call container.lookup');
            return key;
          }
        }
      };
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.inject)('type', 'name'));
      assert.equal((0, _metal.get)(obj, 'foo'), 'type:name', 'should return the value of container.lookup');
    };

    _proto['@test getting should return a lookup on the container'] = function testGettingShouldReturnALookupOnTheContainer(assert) {
      assert.expect(2);
      var obj = {};
      (0, _owner.setOwner)(obj, {
        lookup: function (key) {
          assert.ok(true, 'should call container.lookup');
          return key;
        }
      });
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.inject)('type', 'name'));
      assert.equal((0, _metal.get)(obj, 'foo'), 'type:name', 'should return the value of container.lookup');
    };

    _proto['@test omitting the lookup name should default to the property name'] = function testOmittingTheLookupNameShouldDefaultToThePropertyName(assert) {
      var obj = {};
      (0, _owner.setOwner)(obj, {
        lookup: function (key) {
          return key;
        }
      });
      (0, _metal.defineProperty)(obj, 'foo', (0, _metal.inject)('type'));
      assert.equal((0, _metal.get)(obj, 'foo'), 'type:foo', 'should lookup the type using the property name');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/is_blank_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('isBlank',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test isBlank'] = function testIsBlank(assert) {
      var string = 'string';

      var fn = function () {};

      var object = {
        length: 0
      };
      assert.equal(true, (0, _metal.isBlank)(null), 'for null');
      assert.equal(true, (0, _metal.isBlank)(undefined), 'for undefined');
      assert.equal(true, (0, _metal.isBlank)(''), 'for an empty String');
      assert.equal(true, (0, _metal.isBlank)('  '), 'for a whitespace String');
      assert.equal(true, (0, _metal.isBlank)('\n\t'), 'for another whitespace String');
      assert.equal(false, (0, _metal.isBlank)('\n\t Hi'), 'for a String with whitespaces');
      assert.equal(false, (0, _metal.isBlank)(true), 'for true');
      assert.equal(false, (0, _metal.isBlank)(false), 'for false');
      assert.equal(false, (0, _metal.isBlank)(string), 'for a String');
      assert.equal(false, (0, _metal.isBlank)(fn), 'for a Function');
      assert.equal(false, (0, _metal.isBlank)(0), 'for 0');
      assert.equal(true, (0, _metal.isBlank)([]), 'for an empty Array');
      assert.equal(false, (0, _metal.isBlank)({}), 'for an empty Object');
      assert.equal(true, (0, _metal.isBlank)(object), "for an Object that has zero 'length'");
      assert.equal(false, (0, _metal.isBlank)([1, 2, 3]), 'for a non-empty array');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/is_empty_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('isEmpty',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test isEmpty'] = function testIsEmpty(assert) {
      var string = 'string';

      var fn = function () {};

      var object = {
        length: 0
      };
      assert.equal(true, (0, _metal.isEmpty)(null), 'for null');
      assert.equal(true, (0, _metal.isEmpty)(undefined), 'for undefined');
      assert.equal(true, (0, _metal.isEmpty)(''), 'for an empty String');
      assert.equal(false, (0, _metal.isEmpty)('  '), 'for a whitespace String');
      assert.equal(false, (0, _metal.isEmpty)('\n\t'), 'for another whitespace String');
      assert.equal(false, (0, _metal.isEmpty)(true), 'for true');
      assert.equal(false, (0, _metal.isEmpty)(false), 'for false');
      assert.equal(false, (0, _metal.isEmpty)(string), 'for a String');
      assert.equal(false, (0, _metal.isEmpty)(fn), 'for a Function');
      assert.equal(false, (0, _metal.isEmpty)(0), 'for 0');
      assert.equal(true, (0, _metal.isEmpty)([]), 'for an empty Array');
      assert.equal(false, (0, _metal.isEmpty)({}), 'for an empty Object');
      assert.equal(true, (0, _metal.isEmpty)(object), "for an Object that has zero 'length'");
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/is_none_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('isNone',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test isNone'] = function testIsNone(assert) {
      var string = 'string';

      var fn = function () {};

      assert.equal(true, (0, _metal.isNone)(null), 'for null');
      assert.equal(true, (0, _metal.isNone)(undefined), 'for undefined');
      assert.equal(false, (0, _metal.isNone)(''), 'for an empty String');
      assert.equal(false, (0, _metal.isNone)(true), 'for true');
      assert.equal(false, (0, _metal.isNone)(false), 'for false');
      assert.equal(false, (0, _metal.isNone)(string), 'for a String');
      assert.equal(false, (0, _metal.isNone)(fn), 'for a Function');
      assert.equal(false, (0, _metal.isNone)(0), 'for 0');
      assert.equal(false, (0, _metal.isNone)([]), 'for an empty Array');
      assert.equal(false, (0, _metal.isNone)({}), 'for an empty Object');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/is_present_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('isPresent',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test isPresent'] = function testIsPresent(assert) {
      var string = 'string';

      var fn = function () {};

      var object = {
        length: 0
      };
      assert.equal(false, (0, _metal.isPresent)(), 'for no params');
      assert.equal(false, (0, _metal.isPresent)(null), 'for null');
      assert.equal(false, (0, _metal.isPresent)(undefined), 'for undefined');
      assert.equal(false, (0, _metal.isPresent)(''), 'for an empty String');
      assert.equal(false, (0, _metal.isPresent)('  '), 'for a whitespace String');
      assert.equal(false, (0, _metal.isPresent)('\n\t'), 'for another whitespace String');
      assert.equal(true, (0, _metal.isPresent)('\n\t Hi'), 'for a String with whitespaces');
      assert.equal(true, (0, _metal.isPresent)(true), 'for true');
      assert.equal(true, (0, _metal.isPresent)(false), 'for false');
      assert.equal(true, (0, _metal.isPresent)(string), 'for a String');
      assert.equal(true, (0, _metal.isPresent)(fn), 'for a Function');
      assert.equal(true, (0, _metal.isPresent)(0), 'for 0');
      assert.equal(false, (0, _metal.isPresent)([]), 'for an empty Array');
      assert.equal(true, (0, _metal.isPresent)({}), 'for an empty Object');
      assert.equal(false, (0, _metal.isPresent)(object), "for an Object that has zero 'length'");
      assert.equal(true, (0, _metal.isPresent)([1, 2, 3]), 'for a non-empty array');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/libraries_test", ["ember-babel", "@ember/debug", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _debug, _metal, _internalTestHelpers) {
  "use strict";

  /* globals EmberDev */
  var libs, registry;
  var originalWarn = (0, _debug.getDebugFunction)('warn');

  function noop() {}

  (0, _internalTestHelpers.moduleFor)('Libraries registry',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      libs = new _metal.Libraries();
      registry = libs._registry;
    };

    _proto.afterEach = function afterEach() {
      libs = null;
      registry = null;
      (0, _debug.setDebugFunction)('warn', originalWarn);
    };

    _proto['@test core libraries come before other libraries'] = function testCoreLibrariesComeBeforeOtherLibraries(assert) {
      assert.expect(2);
      libs.register('my-lib', '2.0.0a');
      libs.registerCoreLibrary('DS', '1.0.0-beta.2');
      assert.equal(registry[0].name, 'DS');
      assert.equal(registry[1].name, 'my-lib');
    };

    _proto['@test only the first registration of a library is stored'] = function testOnlyTheFirstRegistrationOfALibraryIsStored(assert) {
      assert.expect(3); // overwrite warn to supress the double registration warning (see https://github.com/emberjs/ember.js/issues/16391)

      (0, _debug.setDebugFunction)('warn', noop);
      libs.register('magic', 1.23);
      libs.register('magic', 2.23);
      assert.equal(registry[0].name, 'magic');
      assert.equal(registry[0].version, 1.23);
      assert.equal(registry.length, 1);
    };

    _proto['@test isRegistered returns correct value'] = function testIsRegisteredReturnsCorrectValue(assert) {
      if (false
      /* EMBER_LIBRARIES_ISREGISTERED */
      ) {
          assert.expect(3);
          assert.equal(libs.isRegistered('magic'), false);
          libs.register('magic', 1.23);
          assert.equal(libs.isRegistered('magic'), true);
          libs.deRegister('magic');
          assert.equal(libs.isRegistered('magic'), false);
        } else {
        assert.expect(0);
      }
    };

    _proto['@test attempting to register a library that is already registered warns you'] = function testAttemptingToRegisterALibraryThatIsAlreadyRegisteredWarnsYou(assert) {
      if (EmberDev && EmberDev.runningProdBuild) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }

      assert.expect(1);
      libs.register('magic', 1.23);
      (0, _debug.setDebugFunction)('warn', function (msg, test) {
        if (!test) {
          assert.equal(msg, 'Library "magic" is already registered with Ember.');
        }
      }); // Should warn us

      libs.register('magic', 2.23);
    };

    _proto['@test libraries can be de-registered'] = function testLibrariesCanBeDeRegistered(assert) {
      assert.expect(2);
      libs.register('lib1', '1.0.0b');
      libs.register('lib2', '1.0.0b');
      libs.register('lib3', '1.0.0b');
      libs.deRegister('lib1');
      libs.deRegister('lib3');
      assert.equal(registry[0].name, 'lib2');
      assert.equal(registry.length, 1);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/main_test", ["ember-babel", "ember/version", "internal-test-helpers"], function (_emberBabel, _version, _internalTestHelpers) {
  "use strict";

  // From https://github.com/semver/semver.org/issues/59 & https://regex101.com/r/vW1jA8/6
  var SEMVER_REGEX = /^((?:0|(?:[1-9]\d*)))\.((?:0|(?:[1-9]\d*)))\.((?:0|(?:[1-9]\d*)))(?:-([0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*))?(?:\+([0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*))?$/;
  (0, _internalTestHelpers.moduleFor)('@ember/-internals/metal/core/main',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Ember.VERSION is in alignment with SemVer v2.0.0'] = function testEmberVERSIONIsInAlignmentWithSemVerV200(assert) {
      assert.ok(SEMVER_REGEX.test(_version.default), "Ember.VERSION (" + _version.default + ")is valid SemVer v2.0.0");
    };

    _proto['@test SEMVER_REGEX properly validates and invalidates version numbers'] = function testSEMVER_REGEXProperlyValidatesAndInvalidatesVersionNumbers(assert) {
      function validateVersionString(versionString, expectedResult) {
        assert.equal(SEMVER_REGEX.test(versionString), expectedResult);
      } // Positive test cases


      validateVersionString('1.11.3', true);
      validateVersionString('1.0.0-beta.16.1', true);
      validateVersionString('1.12.1+canary.aba1412', true);
      validateVersionString('2.0.0-beta.1+canary.bb344775', true);
      validateVersionString('3.1.0-foobarBaz+30d70bd3', true); // Negative test cases

      validateVersionString('1.11.3.aba18a', false);
      validateVersionString('1.11', false);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/mixin/accessor_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Mixin Accessors',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test works with getters'] = function testWorksWithGetters(assert) {
      var count = 0;

      var MixinA = _metal.Mixin.create({
        get prop() {
          return count++;
        }

      });

      var obj = {};
      MixinA.apply(obj);
      assert.equal(obj.prop, 0, 'getter defined correctly');
      assert.equal(obj.prop, 1, 'getter defined correctly');
    };

    _proto['@test works with setters'] = function testWorksWithSetters(assert) {
      var MixinA = _metal.Mixin.create({
        set prop(value) {
          this._prop = value + 1;
        }

      });

      var obj = {};
      MixinA.apply(obj);
      obj.prop = 0;
      assert.equal(obj._prop, 1, 'setter defined correctly');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/mixin/alias_method_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  function validateAliasMethod(assert, obj) {
    assert.equal(obj.fooMethod(), 'FOO', 'obj.fooMethod()');
    assert.equal(obj.barMethod(), 'FOO', 'obj.barMethod should be a copy of foo');
  }

  (0, _internalTestHelpers.moduleFor)('aliasMethod',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test methods of another name are aliased when the mixin is applied'] = function testMethodsOfAnotherNameAreAliasedWhenTheMixinIsApplied(assert) {
      expectDeprecation(function () {
        var MyMixin = _metal.Mixin.create({
          fooMethod: function () {
            return 'FOO';
          },
          barMethod: (0, _metal.aliasMethod)('fooMethod')
        });

        var obj = MyMixin.apply({});
        validateAliasMethod(assert, obj);
      }, /aliasMethod has been deprecated. Consider extracting the method into a shared utility function/);
    };

    _proto['@test should follow aliasMethods all the way down'] = function testShouldFollowAliasMethodsAllTheWayDown(assert) {
      expectDeprecation(function () {
        var MyMixin = _metal.Mixin.create({
          bar: (0, _metal.aliasMethod)('foo'),
          // put first to break ordered iteration
          baz: function () {
            return 'baz';
          },
          foo: (0, _metal.aliasMethod)('baz')
        });

        var obj = MyMixin.apply({});
        assert.equal((0, _metal.get)(obj, 'bar')(), 'baz', 'should have followed aliasMethods');
      }, /aliasMethod has been deprecated. Consider extracting the method into a shared utility function/);
    };

    _proto['@test should alias methods from other dependent mixins'] = function testShouldAliasMethodsFromOtherDependentMixins(assert) {
      expectDeprecation(function () {
        var BaseMixin = _metal.Mixin.create({
          fooMethod: function () {
            return 'FOO';
          }
        });

        var MyMixin = _metal.Mixin.create(BaseMixin, {
          barMethod: (0, _metal.aliasMethod)('fooMethod')
        });

        var obj = MyMixin.apply({});
        validateAliasMethod(assert, obj);
      }, /aliasMethod has been deprecated. Consider extracting the method into a shared utility function/);
    };

    _proto['@test should alias methods from other mixins applied at same time'] = function testShouldAliasMethodsFromOtherMixinsAppliedAtSameTime(assert) {
      expectDeprecation(function () {
        var BaseMixin = _metal.Mixin.create({
          fooMethod: function () {
            return 'FOO';
          }
        });

        var MyMixin = _metal.Mixin.create({
          barMethod: (0, _metal.aliasMethod)('fooMethod')
        });

        var obj = (0, _metal.mixin)({}, BaseMixin, MyMixin);
        validateAliasMethod(assert, obj);
      }, /aliasMethod has been deprecated. Consider extracting the method into a shared utility function/);
    };

    _proto['@test should alias methods from mixins already applied on object'] = function testShouldAliasMethodsFromMixinsAlreadyAppliedOnObject(assert) {
      expectDeprecation(function () {
        var BaseMixin = _metal.Mixin.create({
          quxMethod: function () {
            return 'qux';
          }
        });

        var MyMixin = _metal.Mixin.create({
          bar: (0, _metal.aliasMethod)('foo'),
          barMethod: (0, _metal.aliasMethod)('fooMethod')
        });

        var obj = {
          fooMethod: function () {
            return 'FOO';
          }
        };
        BaseMixin.apply(obj);
        MyMixin.apply(obj);
        validateAliasMethod(assert, obj);
      }, /aliasMethod has been deprecated. Consider extracting the method into a shared utility function/);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/mixin/apply_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  function K() {}

  (0, _internalTestHelpers.moduleFor)('Mixin.apply',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test using apply() should apply properties'] = function testUsingApplyShouldApplyProperties(assert) {
      var MixinA = _metal.Mixin.create({
        foo: 'FOO',
        baz: K
      });

      var obj = {};
      (0, _metal.mixin)(obj, MixinA);
      assert.equal((0, _metal.get)(obj, 'foo'), 'FOO', 'should apply foo');
      assert.equal((0, _metal.get)(obj, 'baz'), K, 'should apply foo');
    };

    _proto['@test applying anonymous properties'] = function testApplyingAnonymousProperties(assert) {
      var obj = {};
      (0, _metal.mixin)(obj, {
        foo: 'FOO',
        baz: K
      });
      assert.equal((0, _metal.get)(obj, 'foo'), 'FOO', 'should apply foo');
      assert.equal((0, _metal.get)(obj, 'baz'), K, 'should apply foo');
    };

    _proto['@test applying null values'] = function testApplyingNullValues() {
      expectAssertion(function () {
        return (0, _metal.mixin)({}, null);
      });
    };

    _proto['@test applying a property with an undefined value'] = function testApplyingAPropertyWithAnUndefinedValue(assert) {
      var obj = {
        tagName: ''
      };
      (0, _metal.mixin)(obj, {
        tagName: undefined
      });
      assert.strictEqual((0, _metal.get)(obj, 'tagName'), '');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/mixin/computed_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  function K() {
    return this;
  }

  (0, _internalTestHelpers.moduleFor)('Mixin Computed Properties',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test overriding computed properties'] = function testOverridingComputedProperties(assert) {
      var MixinA, MixinB, MixinC, MixinD;
      var obj;
      window.testStarted = true;
      MixinA = _metal.Mixin.create({
        aProp: (0, _metal.computed)(function () {
          return 'A';
        })
      });
      MixinB = _metal.Mixin.create(MixinA, {
        aProp: (0, _metal.computed)(function () {
          return this._super.apply(this, arguments) + 'B';
        })
      });
      MixinC = _metal.Mixin.create(MixinA, {
        aProp: (0, _metal.computed)(function () {
          return this._super.apply(this, arguments) + 'C';
        })
      });
      MixinD = _metal.Mixin.create({
        aProp: (0, _metal.computed)(function () {
          return this._super.apply(this, arguments) + 'D';
        })
      });
      obj = {};
      MixinB.apply(obj);
      assert.equal((0, _metal.get)(obj, 'aProp'), 'AB', 'should expose super for B');
      obj = {};
      MixinC.apply(obj);
      assert.equal((0, _metal.get)(obj, 'aProp'), 'AC', 'should expose super for C');
      obj = {};
      MixinA.apply(obj);
      MixinD.apply(obj);
      assert.equal((0, _metal.get)(obj, 'aProp'), 'AD', 'should define super for D');
      obj = {};
      (0, _metal.defineProperty)(obj, 'aProp', (0, _metal.computed)(function () {
        return 'obj';
      }));
      MixinD.apply(obj);
      assert.equal((0, _metal.get)(obj, 'aProp'), 'objD', 'should preserve original computed property');
    };

    _proto['@test calling set on overridden computed properties'] = function testCallingSetOnOverriddenComputedProperties(assert) {
      var SuperMixin, SubMixin;
      var obj;
      var superGetOccurred = false;
      var superSetOccurred = false;
      SuperMixin = _metal.Mixin.create({
        aProp: (0, _metal.computed)({
          get: function () {
            superGetOccurred = true;
          },
          set: function () {
            superSetOccurred = true;
          }
        })
      });
      SubMixin = _metal.Mixin.create(SuperMixin, {
        aProp: (0, _metal.computed)({
          get: function () {
            return this._super.apply(this, arguments);
          },
          set: function () {
            return this._super.apply(this, arguments);
          }
        })
      });
      obj = {};
      SubMixin.apply(obj);
      (0, _metal.set)(obj, 'aProp', 'set thyself');
      assert.ok(superSetOccurred, 'should pass set to _super');
      superSetOccurred = false; // reset the set assertion

      obj = {};
      SubMixin.apply(obj);
      (0, _metal.get)(obj, 'aProp');
      assert.ok(superGetOccurred, 'should pass get to _super');
      (0, _metal.set)(obj, 'aProp', 'set thyself');
      assert.ok(superSetOccurred, 'should pass set to _super after getting');
    };

    _proto['@test setter behavior works properly when overriding computed properties'] = function testSetterBehaviorWorksProperlyWhenOverridingComputedProperties(assert) {
      var obj = {};

      var MixinA = _metal.Mixin.create({
        cpWithSetter2: (0, _metal.computed)(K),
        cpWithSetter3: (0, _metal.computed)(K),
        cpWithoutSetter: (0, _metal.computed)(K)
      });

      var cpWasCalled = false;

      var MixinB = _metal.Mixin.create({
        cpWithSetter2: (0, _metal.computed)({
          get: K,
          set: function () {
            cpWasCalled = true;
          }
        }),
        cpWithSetter3: (0, _metal.computed)({
          get: K,
          set: function () {
            cpWasCalled = true;
          }
        }),
        cpWithoutSetter: (0, _metal.computed)(function () {
          cpWasCalled = true;
        })
      });

      MixinA.apply(obj);
      MixinB.apply(obj);
      (0, _metal.set)(obj, 'cpWithSetter2', 'test');
      assert.ok(cpWasCalled, 'The computed property setter was called when defined with two args');
      cpWasCalled = false;
      (0, _metal.set)(obj, 'cpWithSetter3', 'test');
      assert.ok(cpWasCalled, 'The computed property setter was called when defined with three args');
      cpWasCalled = false;
      expectDeprecation(function () {
        (0, _metal.set)(obj, 'cpWithoutSetter', 'test');
      }, /The \[object Object\]#cpWithoutSetter computed property was just overriden./);
      assert.equal((0, _metal.get)(obj, 'cpWithoutSetter'), 'test', 'The default setter was called, the value is correct');
      assert.ok(!cpWasCalled, 'The default setter was called, not the CP itself');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/mixin/concatenated_properties_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Mixin concatenatedProperties',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test defining concatenated properties should concat future version'] = function testDefiningConcatenatedPropertiesShouldConcatFutureVersion(assert) {
      var MixinA = _metal.Mixin.create({
        concatenatedProperties: ['foo'],
        foo: ['a', 'b', 'c']
      });

      var MixinB = _metal.Mixin.create({
        foo: ['d', 'e', 'f']
      });

      var obj = (0, _metal.mixin)({}, MixinA, MixinB);
      assert.deepEqual((0, _metal.get)(obj, 'foo'), ['a', 'b', 'c', 'd', 'e', 'f']);
    };

    _proto['@test defining concatenated properties should concat future version'] = function testDefiningConcatenatedPropertiesShouldConcatFutureVersion(assert) {
      var MixinA = _metal.Mixin.create({
        concatenatedProperties: null
      });

      var MixinB = _metal.Mixin.create({
        concatenatedProperties: null
      });

      var obj = (0, _metal.mixin)({}, MixinA, MixinB);
      assert.deepEqual(obj.concatenatedProperties, []);
    };

    _proto['@test concatenatedProperties should be concatenated'] = function testConcatenatedPropertiesShouldBeConcatenated(assert) {
      var MixinA = _metal.Mixin.create({
        concatenatedProperties: ['foo'],
        foo: ['a', 'b', 'c']
      });

      var MixinB = _metal.Mixin.create({
        concatenatedProperties: 'bar',
        foo: ['d', 'e', 'f'],
        bar: [1, 2, 3]
      });

      var MixinC = _metal.Mixin.create({
        bar: [4, 5, 6]
      });

      var obj = (0, _metal.mixin)({}, MixinA, MixinB, MixinC);
      assert.deepEqual((0, _metal.get)(obj, 'concatenatedProperties'), ['foo', 'bar'], 'get concatenatedProperties');
      assert.deepEqual((0, _metal.get)(obj, 'foo'), ['a', 'b', 'c', 'd', 'e', 'f'], 'get foo');
      assert.deepEqual((0, _metal.get)(obj, 'bar'), [1, 2, 3, 4, 5, 6], 'get bar');
    };

    _proto['@test adding a prop that is not an array should make array'] = function testAddingAPropThatIsNotAnArrayShouldMakeArray(assert) {
      var MixinA = _metal.Mixin.create({
        concatenatedProperties: ['foo'],
        foo: [1, 2, 3]
      });

      var MixinB = _metal.Mixin.create({
        foo: 4
      });

      var obj = (0, _metal.mixin)({}, MixinA, MixinB);
      assert.deepEqual((0, _metal.get)(obj, 'foo'), [1, 2, 3, 4]);
    };

    _proto['@test adding a prop that is not an array should make array'] = function testAddingAPropThatIsNotAnArrayShouldMakeArray(assert) {
      var MixinA = _metal.Mixin.create({
        concatenatedProperties: ['foo'],
        foo: 'bar'
      });

      var obj = (0, _metal.mixin)({}, MixinA);
      assert.deepEqual((0, _metal.get)(obj, 'foo'), ['bar']);
    };

    _proto['@test adding a non-concatenable property that already has a defined value should result in an array with both values'] = function testAddingANonConcatenablePropertyThatAlreadyHasADefinedValueShouldResultInAnArrayWithBothValues(assert) {
      var mixinA = _metal.Mixin.create({
        foo: 1
      });

      var mixinB = _metal.Mixin.create({
        concatenatedProperties: ['foo'],
        foo: 2
      });

      var obj = (0, _metal.mixin)({}, mixinA, mixinB);
      assert.deepEqual((0, _metal.get)(obj, 'foo'), [1, 2]);
    };

    _proto['@test adding a concatenable property that already has a defined value should result in a concatenated value'] = function testAddingAConcatenablePropertyThatAlreadyHasADefinedValueShouldResultInAConcatenatedValue(assert) {
      var mixinA = _metal.Mixin.create({
        foobar: 'foo'
      });

      var mixinB = _metal.Mixin.create({
        concatenatedProperties: ['foobar'],
        foobar: 'bar'
      });

      var obj = (0, _metal.mixin)({}, mixinA, mixinB);
      assert.deepEqual((0, _metal.get)(obj, 'foobar'), ['foo', 'bar']);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/mixin/detect_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Mixin.detect',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test detect() finds a directly applied mixin'] = function testDetectFindsADirectlyAppliedMixin(assert) {
      var MixinA = _metal.Mixin.create();

      var obj = {};
      assert.equal(MixinA.detect(obj), false, 'MixinA.detect(obj) before apply()');
      MixinA.apply(obj);
      assert.equal(MixinA.detect(obj), true, 'MixinA.detect(obj) after apply()');
    };

    _proto['@test detect() finds nested mixins'] = function testDetectFindsNestedMixins(assert) {
      var MixinA = _metal.Mixin.create({});

      var MixinB = _metal.Mixin.create(MixinA);

      var obj = {};
      assert.equal(MixinA.detect(obj), false, 'MixinA.detect(obj) before apply()');
      MixinB.apply(obj);
      assert.equal(MixinA.detect(obj), true, 'MixinA.detect(obj) after apply()');
    };

    _proto['@test detect() finds mixins on other mixins'] = function testDetectFindsMixinsOnOtherMixins(assert) {
      var MixinA = _metal.Mixin.create({});

      var MixinB = _metal.Mixin.create(MixinA);

      assert.equal(MixinA.detect(MixinB), true, 'MixinA is part of MixinB');
      assert.equal(MixinB.detect(MixinA), false, 'MixinB is not part of MixinA');
    };

    _proto['@test detect handles null values'] = function testDetectHandlesNullValues(assert) {
      var MixinA = _metal.Mixin.create();

      assert.equal(MixinA.detect(null), false);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/mixin/introspection_test", ["ember-babel", "@ember/-internals/utils", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _utils, _metal, _internalTestHelpers) {
  "use strict";

  // NOTE: A previous iteration differentiated between public and private props
  // as well as methods vs props.  We are just keeping these for testing; the
  // current impl doesn't care about the differences as much...
  var PrivateProperty = _metal.Mixin.create({
    _foo: '_FOO'
  });

  var PublicProperty = _metal.Mixin.create({
    foo: 'FOO'
  });

  var PrivateMethod = _metal.Mixin.create({
    _fooMethod: function () {}
  });

  var PublicMethod = _metal.Mixin.create({
    fooMethod: function () {}
  });

  var BarProperties = _metal.Mixin.create({
    _bar: '_BAR',
    bar: 'bar'
  });

  var BarMethods = _metal.Mixin.create({
    _barMethod: function () {},
    barMethod: function () {}
  });

  var Combined = _metal.Mixin.create(BarProperties, BarMethods);

  var obj;
  (0, _internalTestHelpers.moduleFor)('Basic introspection',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      obj = {};
      (0, _metal.mixin)(obj, PrivateProperty, PublicProperty, PrivateMethod, PublicMethod, Combined);
    };

    _proto['@test Ember.mixins()'] = function testEmberMixins(assert) {
      function mapGuids(ary) {
        return ary.map(function (x) {
          return (0, _utils.guidFor)(x);
        });
      }

      assert.deepEqual(mapGuids(_metal.Mixin.mixins(obj)), mapGuids([PrivateProperty, PublicProperty, PrivateMethod, PublicMethod, Combined, BarProperties, BarMethods]), 'should return included mixins');
    };

    _proto['@test setting a NAME_KEY on a mixin does not error'] = function testSettingANAME_KEYOnAMixinDoesNotError(assert) {
      assert.expect(0);

      var instance = _metal.Mixin.create();

      instance[_utils.NAME_KEY] = 'My special name!';
    };

    _proto['@test setting a NAME_KEY on a mixin instance does not error'] = function testSettingANAME_KEYOnAMixinInstanceDoesNotError(assert) {
      var _Mixin$create;

      assert.expect(0);

      _metal.Mixin.create((_Mixin$create = {}, _Mixin$create[_utils.NAME_KEY] = 'My special name', _Mixin$create));
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/mixin/merged_properties_test", ["ember-babel", "@ember/-internals/runtime", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _runtime, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Mixin mergedProperties',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test defining mergedProperties should merge future version'] = function testDefiningMergedPropertiesShouldMergeFutureVersion(assert) {
      var MixinA = _metal.Mixin.create({
        mergedProperties: ['foo'],
        foo: {
          a: true,
          b: true,
          c: true
        }
      });

      var MixinB = _metal.Mixin.create({
        foo: {
          d: true,
          e: true,
          f: true
        }
      });

      var obj = (0, _metal.mixin)({}, MixinA, MixinB);
      assert.deepEqual((0, _metal.get)(obj, 'foo'), {
        a: true,
        b: true,
        c: true,
        d: true,
        e: true,
        f: true
      });
    };

    _proto['@test defining mergedProperties on future mixin should merged into past'] = function testDefiningMergedPropertiesOnFutureMixinShouldMergedIntoPast(assert) {
      var MixinA = _metal.Mixin.create({
        foo: {
          a: true,
          b: true,
          c: true
        }
      });

      var MixinB = _metal.Mixin.create({
        mergedProperties: ['foo'],
        foo: {
          d: true,
          e: true,
          f: true
        }
      });

      var obj = (0, _metal.mixin)({}, MixinA, MixinB);
      assert.deepEqual((0, _metal.get)(obj, 'foo'), {
        a: true,
        b: true,
        c: true,
        d: true,
        e: true,
        f: true
      });
    };

    _proto['@test defining mergedProperties with null properties should keep properties null'] = function testDefiningMergedPropertiesWithNullPropertiesShouldKeepPropertiesNull(assert) {
      var MixinA = _metal.Mixin.create({
        mergedProperties: ['foo'],
        foo: null
      });

      var MixinB = _metal.Mixin.create({
        foo: null
      });

      var obj = (0, _metal.mixin)({}, MixinA, MixinB);
      assert.equal((0, _metal.get)(obj, 'foo'), null);
    };

    _proto["@test mergedProperties' properties can get overwritten"] = function testMergedPropertiesPropertiesCanGetOverwritten(assert) {
      var MixinA = _metal.Mixin.create({
        mergedProperties: ['foo'],
        foo: {
          a: 1
        }
      });

      var MixinB = _metal.Mixin.create({
        foo: {
          a: 2
        }
      });

      var obj = (0, _metal.mixin)({}, MixinA, MixinB);
      assert.deepEqual((0, _metal.get)(obj, 'foo'), {
        a: 2
      });
    };

    _proto['@test mergedProperties should be concatenated'] = function testMergedPropertiesShouldBeConcatenated(assert) {
      var MixinA = _metal.Mixin.create({
        mergedProperties: ['foo'],
        foo: {
          a: true,
          b: true,
          c: true
        }
      });

      var MixinB = _metal.Mixin.create({
        mergedProperties: 'bar',
        foo: {
          d: true,
          e: true,
          f: true
        },
        bar: {
          a: true,
          l: true
        }
      });

      var MixinC = _metal.Mixin.create({
        bar: {
          e: true,
          x: true
        }
      });

      var obj = (0, _metal.mixin)({}, MixinA, MixinB, MixinC);
      assert.deepEqual((0, _metal.get)(obj, 'mergedProperties'), ['foo', 'bar'], 'get mergedProperties');
      assert.deepEqual((0, _metal.get)(obj, 'foo'), {
        a: true,
        b: true,
        c: true,
        d: true,
        e: true,
        f: true
      }, 'get foo');
      assert.deepEqual((0, _metal.get)(obj, 'bar'), {
        a: true,
        l: true,
        e: true,
        x: true
      }, 'get bar');
    };

    _proto['@test mergedProperties should exist even if not explicitly set on create'] = function testMergedPropertiesShouldExistEvenIfNotExplicitlySetOnCreate(assert) {
      var AnObj = _runtime.Object.extend({
        mergedProperties: ['options'],
        options: {
          a: 'a',
          b: {
            c: 'ccc'
          }
        }
      });

      var obj = AnObj.create({
        options: {
          a: 'A'
        }
      });
      assert.equal((0, _metal.get)(obj, 'options').a, 'A');
      assert.equal((0, _metal.get)(obj, 'options').b.c, 'ccc');
    };

    _proto['@test defining mergedProperties at create time should not modify the prototype'] = function testDefiningMergedPropertiesAtCreateTimeShouldNotModifyThePrototype(assert) {
      var AnObj = _runtime.Object.extend({
        mergedProperties: ['options'],
        options: {
          a: 1
        }
      });

      var objA = AnObj.create({
        options: {
          a: 2
        }
      });
      var objB = AnObj.create({
        options: {
          a: 3
        }
      });
      assert.equal((0, _metal.get)(objA, 'options').a, 2);
      assert.equal((0, _metal.get)(objB, 'options').a, 3);
    };

    _proto["@test mergedProperties' overwriting methods can call _super"] = function testMergedPropertiesOverwritingMethodsCanCall_super(assert) {
      assert.expect(4);

      var MixinA = _metal.Mixin.create({
        mergedProperties: ['foo'],
        foo: {
          meth: function (a) {
            assert.equal(a, 'WOOT', "_super successfully called MixinA's `foo.meth` method");
            return 'WAT';
          }
        }
      });

      var MixinB = _metal.Mixin.create({
        foo: {
          meth: function () {
            assert.ok(true, "MixinB's `foo.meth` method called");
            return this._super.apply(this, arguments);
          }
        }
      });

      var MixinC = _metal.Mixin.create({
        foo: {
          meth: function (a) {
            assert.ok(true, "MixinC's `foo.meth` method called");
            return this._super(a);
          }
        }
      });

      var obj = (0, _metal.mixin)({}, MixinA, MixinB, MixinC);
      assert.equal(obj.foo.meth('WOOT'), 'WAT');
    };

    _proto['@test Merging an Array should raise an error'] = function testMergingAnArrayShouldRaiseAnError(assert) {
      assert.expect(1);

      var MixinA = _metal.Mixin.create({
        mergedProperties: ['foo'],
        foo: {
          a: true,
          b: true,
          c: true
        }
      });

      var MixinB = _metal.Mixin.create({
        foo: ['a']
      });

      expectAssertion(function () {
        (0, _metal.mixin)({}, MixinA, MixinB);
      }, 'You passed in `["a"]` as the value for `foo` but `foo` cannot be an Array');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/mixin/method_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Mixin Methods',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test defining simple methods'] = function testDefiningSimpleMethods(assert) {
      var MixinA, obj, props;
      props = {
        publicMethod: function () {
          return 'publicMethod';
        },
        _privateMethod: function () {
          return 'privateMethod';
        }
      };
      MixinA = _metal.Mixin.create(props);
      obj = {};
      MixinA.apply(obj); // but should be defined

      assert.equal(props.publicMethod(), 'publicMethod', 'publicMethod is func');
      assert.equal(props._privateMethod(), 'privateMethod', 'privateMethod is func');
    };

    _proto['@test overriding public methods'] = function testOverridingPublicMethods(assert) {
      var MixinA, MixinB, MixinD, MixinF, obj;
      MixinA = _metal.Mixin.create({
        publicMethod: function () {
          return 'A';
        }
      });
      MixinB = _metal.Mixin.create(MixinA, {
        publicMethod: function () {
          return this._super.apply(this, arguments) + 'B';
        }
      });
      MixinD = _metal.Mixin.create(MixinA, {
        publicMethod: function () {
          return this._super.apply(this, arguments) + 'D';
        }
      });
      MixinF = _metal.Mixin.create({
        publicMethod: function () {
          return this._super.apply(this, arguments) + 'F';
        }
      });
      obj = {};
      MixinB.apply(obj);
      assert.equal(obj.publicMethod(), 'AB', 'should define super for A and B');
      obj = {};
      MixinD.apply(obj);
      assert.equal(obj.publicMethod(), 'AD', 'should define super for A and B');
      obj = {};
      MixinA.apply(obj);
      MixinF.apply(obj);
      assert.equal(obj.publicMethod(), 'AF', 'should define super for A and F');
      obj = {
        publicMethod: function () {
          return 'obj';
        }
      };
      MixinF.apply(obj);
      assert.equal(obj.publicMethod(), 'objF', 'should define super for F');
    };

    _proto['@test overriding inherited objects'] = function testOverridingInheritedObjects(assert) {
      var cnt = 0;

      var MixinA = _metal.Mixin.create({
        foo: function () {
          cnt++;
        }
      });

      var MixinB = _metal.Mixin.create({
        foo: function () {
          this._super.apply(this, arguments);

          cnt++;
        }
      });

      var objA = {};
      MixinA.apply(objA);
      var objB = Object.create(objA);
      MixinB.apply(objB);
      cnt = 0;
      objB.foo();
      assert.equal(cnt, 2, 'should invoke both methods');
      cnt = 0;
      objA.foo();
      assert.equal(cnt, 1, 'should not screw w/ parent obj');
    };

    _proto['@test Including the same mixin more than once will only run once'] = function testIncludingTheSameMixinMoreThanOnceWillOnlyRunOnce(assert) {
      var cnt = 0;

      var MixinA = _metal.Mixin.create({
        foo: function () {
          cnt++;
        }
      });

      var MixinB = _metal.Mixin.create(MixinA, {
        foo: function () {
          this._super.apply(this, arguments);
        }
      });

      var MixinC = _metal.Mixin.create(MixinA, {
        foo: function () {
          this._super.apply(this, arguments);
        }
      });

      var MixinD = _metal.Mixin.create(MixinB, MixinC, MixinA, {
        foo: function () {
          this._super.apply(this, arguments);
        }
      });

      var obj = {};
      MixinD.apply(obj);
      MixinA.apply(obj); // try to apply again..

      cnt = 0;
      obj.foo();
      assert.equal(cnt, 1, 'should invoke MixinA.foo one time');
    };

    _proto['@test _super from a single mixin with no superclass does not error'] = function test_superFromASingleMixinWithNoSuperclassDoesNotError(assert) {
      var MixinA = _metal.Mixin.create({
        foo: function () {
          this._super.apply(this, arguments);
        }
      });

      var obj = {};
      MixinA.apply(obj);
      obj.foo();
      assert.ok(true);
    };

    _proto['@test _super from a first-of-two mixins with no superclass function does not error'] = function test_superFromAFirstOfTwoMixinsWithNoSuperclassFunctionDoesNotError(assert) {
      // _super was previously calling itself in the second assertion.
      // Use remaining count of calls to ensure it doesn't loop indefinitely.
      var remaining = 3;

      var MixinA = _metal.Mixin.create({
        foo: function () {
          if (remaining-- > 0) {
            this._super.apply(this, arguments);
          }
        }
      });

      var MixinB = _metal.Mixin.create({
        foo: function () {
          this._super.apply(this, arguments);
        }
      });

      var obj = {};
      MixinA.apply(obj);
      MixinB.apply(obj);
      obj.foo();
      assert.ok(true);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // CONFLICTS
  //

  (0, _internalTestHelpers.moduleFor)('Method Conflicts',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test overriding toString'] = function testOverridingToString(assert) {
      var MixinA = _metal.Mixin.create({
        toString: function () {
          return 'FOO';
        }
      });

      var obj = {};
      MixinA.apply(obj);
      assert.equal(obj.toString(), 'FOO', 'should override toString w/o error');
      obj = {};
      (0, _metal.mixin)(obj, {
        toString: function () {
          return 'FOO';
        }
      });
      assert.equal(obj.toString(), 'FOO', 'should override toString w/o error');
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // BUGS
  //

  (0, _internalTestHelpers.moduleFor)('system/mixin/method_test BUGS',
  /*#__PURE__*/
  function (_AbstractTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class3, _AbstractTestCase3);

    function _class3() {
      return _AbstractTestCase3.apply(this, arguments) || this;
    }

    var _proto3 = _class3.prototype;

    _proto3['@test applying several mixins at once with sup already defined causes infinite loop'] = function testApplyingSeveralMixinsAtOnceWithSupAlreadyDefinedCausesInfiniteLoop(assert) {
      var cnt = 0;

      var MixinA = _metal.Mixin.create({
        foo: function () {
          cnt++;
        }
      });

      var MixinB = _metal.Mixin.create({
        foo: function () {
          this._super.apply(this, arguments);

          cnt++;
        }
      });

      var MixinC = _metal.Mixin.create({
        foo: function () {
          this._super.apply(this, arguments);

          cnt++;
        }
      });

      var obj = {};
      (0, _metal.mixin)(obj, MixinA); // sup already exists

      (0, _metal.mixin)(obj, MixinB, MixinC); // must be more than one mixin

      cnt = 0;
      obj.foo();
      assert.equal(cnt, 3, 'should invoke all 3 methods');
    };

    return _class3;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/mixin/observer_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('Mixin observer',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test global observer helper'] =
    /*#__PURE__*/
    function () {
      var _testGlobalObserverHelper = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var MyMixin, obj;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              MyMixin = _metal.Mixin.create({
                count: 0,
                foo: (0, _metal.observer)('bar', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              });
              obj = (0, _metal.mixin)({}, MyMixin);
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer immediately');
              (0, _metal.set)(obj, 'bar', 'BAZ');
              _context.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              assert.equal((0, _metal.get)(obj, 'count'), 1, 'should invoke observer after change');

            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function testGlobalObserverHelper(_x) {
        return _testGlobalObserverHelper.apply(this, arguments);
      }

      return testGlobalObserverHelper;
    }();

    _proto['@test global observer helper takes multiple params'] =
    /*#__PURE__*/
    function () {
      var _testGlobalObserverHelperTakesMultipleParams = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        var MyMixin, obj;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              MyMixin = _metal.Mixin.create({
                count: 0,
                foo: (0, _metal.observer)('bar', 'baz', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              });
              obj = (0, _metal.mixin)({}, MyMixin);
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer immediately');
              (0, _metal.set)(obj, 'bar', 'BAZ');
              _context2.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              (0, _metal.set)(obj, 'baz', 'BAZ');
              _context2.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              assert.equal((0, _metal.get)(obj, 'count'), 2, 'should invoke observer after change');

            case 10:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));

      function testGlobalObserverHelperTakesMultipleParams(_x2) {
        return _testGlobalObserverHelperTakesMultipleParams.apply(this, arguments);
      }

      return testGlobalObserverHelperTakesMultipleParams;
    }();

    _proto['@test replacing observer should remove old observer'] =
    /*#__PURE__*/
    function () {
      var _testReplacingObserverShouldRemoveOldObserver = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(assert) {
        var MyMixin, Mixin2, obj;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              MyMixin = _metal.Mixin.create({
                count: 0,
                foo: (0, _metal.observer)('bar', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              });
              Mixin2 = _metal.Mixin.create({
                foo: (0, _metal.observer)('baz', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 10);
                })
              });
              obj = (0, _metal.mixin)({}, MyMixin, Mixin2);
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer immediately');
              (0, _metal.set)(obj, 'bar', 'BAZ');
              _context3.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer after change');
              (0, _metal.set)(obj, 'baz', 'BAZ');
              _context3.next = 11;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 11:
              assert.equal((0, _metal.get)(obj, 'count'), 10, 'should invoke observer after change');

            case 12:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));

      function testReplacingObserverShouldRemoveOldObserver(_x3) {
        return _testReplacingObserverShouldRemoveOldObserver.apply(this, arguments);
      }

      return testReplacingObserverShouldRemoveOldObserver;
    }();

    _proto['@test observing chain with property before'] =
    /*#__PURE__*/
    function () {
      var _testObservingChainWithPropertyBefore = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(assert) {
        var obj2, MyMixin, obj;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              obj2 = {
                baz: 'baz'
              };
              MyMixin = _metal.Mixin.create({
                count: 0,
                bar: obj2,
                foo: (0, _metal.observer)('bar.baz', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              });
              obj = (0, _metal.mixin)({}, MyMixin);
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer immediately');
              (0, _metal.set)(obj2, 'baz', 'BAZ');
              _context4.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              assert.equal((0, _metal.get)(obj, 'count'), 1, 'should invoke observer after change');

            case 8:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));

      function testObservingChainWithPropertyBefore(_x4) {
        return _testObservingChainWithPropertyBefore.apply(this, arguments);
      }

      return testObservingChainWithPropertyBefore;
    }();

    _proto['@test observing chain with property after'] =
    /*#__PURE__*/
    function () {
      var _testObservingChainWithPropertyAfter = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(assert) {
        var obj2, MyMixin, obj;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              obj2 = {
                baz: 'baz'
              };
              MyMixin = _metal.Mixin.create({
                count: 0,
                foo: (0, _metal.observer)('bar.baz', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                }),
                bar: obj2
              });
              obj = (0, _metal.mixin)({}, MyMixin);
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer immediately');
              (0, _metal.set)(obj2, 'baz', 'BAZ');
              _context5.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              assert.equal((0, _metal.get)(obj, 'count'), 1, 'should invoke observer after change');

            case 8:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }));

      function testObservingChainWithPropertyAfter(_x5) {
        return _testObservingChainWithPropertyAfter.apply(this, arguments);
      }

      return testObservingChainWithPropertyAfter;
    }();

    _proto['@test observing chain with property in mixin applied later'] =
    /*#__PURE__*/
    function () {
      var _testObservingChainWithPropertyInMixinAppliedLater = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(assert) {
        var obj2, MyMixin, MyMixin2, obj;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              obj2 = {
                baz: 'baz'
              };
              MyMixin = _metal.Mixin.create({
                count: 0,
                foo: (0, _metal.observer)('bar.baz', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              });
              MyMixin2 = _metal.Mixin.create({
                bar: obj2
              });
              obj = (0, _metal.mixin)({}, MyMixin);
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer immediately');
              MyMixin2.apply(obj);
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer immediately');
              (0, _metal.set)(obj2, 'baz', 'BAZ');
              _context6.next = 10;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 10:
              assert.equal((0, _metal.get)(obj, 'count'), 1, 'should invoke observer after change');

            case 11:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));

      function testObservingChainWithPropertyInMixinAppliedLater(_x6) {
        return _testObservingChainWithPropertyInMixinAppliedLater.apply(this, arguments);
      }

      return testObservingChainWithPropertyInMixinAppliedLater;
    }();

    _proto['@test observing chain with existing property'] =
    /*#__PURE__*/
    function () {
      var _testObservingChainWithExistingProperty = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(assert) {
        var obj2, MyMixin, obj;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              obj2 = {
                baz: 'baz'
              };
              MyMixin = _metal.Mixin.create({
                count: 0,
                foo: (0, _metal.observer)('bar.baz', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              });
              obj = (0, _metal.mixin)({
                bar: obj2
              }, MyMixin);
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer immediately');
              (0, _metal.set)(obj2, 'baz', 'BAZ');
              _context7.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              assert.equal((0, _metal.get)(obj, 'count'), 1, 'should invoke observer after change');

            case 8:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      }));

      function testObservingChainWithExistingProperty(_x7) {
        return _testObservingChainWithExistingProperty.apply(this, arguments);
      }

      return testObservingChainWithExistingProperty;
    }();

    _proto['@test observing chain with property in mixin before'] =
    /*#__PURE__*/
    function () {
      var _testObservingChainWithPropertyInMixinBefore = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(assert) {
        var obj2, MyMixin2, MyMixin, obj;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              obj2 = {
                baz: 'baz'
              };
              MyMixin2 = _metal.Mixin.create({
                bar: obj2
              });
              MyMixin = _metal.Mixin.create({
                count: 0,
                foo: (0, _metal.observer)('bar.baz', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              });
              obj = (0, _metal.mixin)({}, MyMixin2, MyMixin);
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer immediately');
              (0, _metal.set)(obj2, 'baz', 'BAZ');
              _context8.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              assert.equal((0, _metal.get)(obj, 'count'), 1, 'should invoke observer after change');

            case 9:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      }));

      function testObservingChainWithPropertyInMixinBefore(_x8) {
        return _testObservingChainWithPropertyInMixinBefore.apply(this, arguments);
      }

      return testObservingChainWithPropertyInMixinBefore;
    }();

    _proto['@test observing chain with property in mixin after'] =
    /*#__PURE__*/
    function () {
      var _testObservingChainWithPropertyInMixinAfter = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee9(assert) {
        var obj2, MyMixin2, MyMixin, obj;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              obj2 = {
                baz: 'baz'
              };
              MyMixin2 = _metal.Mixin.create({
                bar: obj2
              });
              MyMixin = _metal.Mixin.create({
                count: 0,
                foo: (0, _metal.observer)('bar.baz', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              });
              obj = (0, _metal.mixin)({}, MyMixin, MyMixin2);
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer immediately');
              (0, _metal.set)(obj2, 'baz', 'BAZ');
              _context9.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              assert.equal((0, _metal.get)(obj, 'count'), 1, 'should invoke observer after change');

            case 9:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }));

      function testObservingChainWithPropertyInMixinAfter(_x9) {
        return _testObservingChainWithPropertyInMixinAfter.apply(this, arguments);
      }

      return testObservingChainWithPropertyInMixinAfter;
    }();

    _proto['@test observing chain with overridden property'] =
    /*#__PURE__*/
    function () {
      var _testObservingChainWithOverriddenProperty = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee10(assert) {
        var obj2, obj3, MyMixin2, MyMixin, obj;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              obj2 = {
                baz: 'baz'
              };
              obj3 = {
                baz: 'foo'
              };
              MyMixin2 = _metal.Mixin.create({
                bar: obj3
              });
              MyMixin = _metal.Mixin.create({
                count: 0,
                foo: (0, _metal.observer)('bar.baz', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              });
              obj = (0, _metal.mixin)({
                bar: obj2
              }, MyMixin, MyMixin2);
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer immediately');
              (0, _metal.set)(obj2, 'baz', 'BAZ');
              _context10.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer after change');
              (0, _metal.set)(obj3, 'baz', 'BEAR');
              _context10.next = 13;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 13:
              assert.equal((0, _metal.get)(obj, 'count'), 1, 'should invoke observer after change');

            case 14:
            case "end":
              return _context10.stop();
          }
        }, _callee10);
      }));

      function testObservingChainWithOverriddenProperty(_x10) {
        return _testObservingChainWithOverriddenProperty.apply(this, arguments);
      }

      return testObservingChainWithOverriddenProperty;
    }();

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/mixin/reopen_test", ["ember-babel", "@ember/-internals/runtime", "@ember/-internals/metal", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _runtime, _metal, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Mixin#reopen',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test using reopen() to add more properties to a simple'] = function testUsingReopenToAddMorePropertiesToASimple(assert) {
      var MixinA = _metal.Mixin.create({
        foo: 'FOO',
        baz: 'BAZ'
      });

      MixinA.reopen({
        bar: 'BAR',
        foo: 'FOO2'
      });
      var obj = {};
      MixinA.apply(obj);
      assert.equal((0, _metal.get)(obj, 'foo'), 'FOO2', 'mixin() should override');
      assert.equal((0, _metal.get)(obj, 'baz'), 'BAZ', 'preserve MixinA props');
      assert.equal((0, _metal.get)(obj, 'bar'), 'BAR', 'include MixinB props');
    };

    _proto['@test using reopen() and calling _super where there is not a super function does not cause infinite recursion'] = function testUsingReopenAndCalling_superWhereThereIsNotASuperFunctionDoesNotCauseInfiniteRecursion(assert) {
      var Taco = _runtime.Object.extend({
        createBreakfast: function () {
          // There is no original createBreakfast function.
          // Calling the wrapped _super function here
          // used to end in an infinite call loop
          this._super.apply(this, arguments);

          return 'Breakfast!';
        }
      });

      Taco.reopen({
        createBreakfast: function () {
          return this._super.apply(this, arguments);
        }
      });
      var taco = Taco.create();
      var result;
      (0, _runloop.run)(function () {
        try {
          result = taco.createBreakfast();
        } catch (e) {
          result = 'Your breakfast was interrupted by an infinite stack error.';
        }
      });
      assert.equal(result, 'Breakfast!');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/mixin/without_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('without',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test without should create a new mixin excluding named properties'] = function testWithoutShouldCreateANewMixinExcludingNamedProperties(assert) {
      var MixinA = _metal.Mixin.create({
        foo: 'FOO',
        bar: 'BAR'
      });

      var MixinB = MixinA.without('bar');
      var obj = {};
      MixinB.apply(obj);
      assert.equal(obj.foo, 'FOO', 'should defined foo');
      assert.equal(obj.bar, undefined, 'should not define bar');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/namespace_search_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('NamespaceSearch',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test classToString: null as this inside class must not throw error'] = function testClassToStringNullAsThisInsideClassMustNotThrowError(assert) {
      var mixin = _metal.Mixin.create();

      assert.equal(mixin.toString(), '(unknown)', 'this = null should be handled on Mixin.toString() call');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/native_desc_decorator_test", ["ember-babel", "@ember/-internals/runtime", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _runtime, _metal, _internalTestHelpers) {
  "use strict";

  var classes = [
  /*#__PURE__*/
  function () {
    _class.module = function module(title) {
      return title + ": using defineProperty on an object directly";
    };

    function _class() {
      this.object = {};
    }

    var _proto = _class.prototype;

    _proto.install = function install(key, desc, assert) {
      var object = this.object;
      (0, _metal.defineProperty)(object, key, desc);
      assert.ok(object.hasOwnProperty(key));
    };

    _proto.set = function set(key, value) {
      this.object[key] = value;
    };

    _proto.finalize = function finalize() {
      return this.object;
    };

    _proto.source = function source() {
      return this.object;
    };

    return _class;
  }(),
  /*#__PURE__*/
  function () {
    _class2.module = function module(title) {
      return title + ": using defineProperty on a prototype";
    };

    function _class2() {
      this.proto = {};
    }

    var _proto2 = _class2.prototype;

    _proto2.install = function install(key, desc, assert) {
      var proto = this.proto;
      (0, _metal.defineProperty)(proto, key, desc);
      assert.ok(proto.hasOwnProperty(key));
    };

    _proto2.set = function set(key, value) {
      this.proto[key] = value;
    };

    _proto2.finalize = function finalize() {
      return Object.create(this.proto);
    };

    _proto2.source = function source() {
      return this.proto;
    };

    return _class2;
  }(),
  /*#__PURE__*/
  function () {
    _class3.module = function module(title) {
      return title + ": in EmberObject.extend()";
    };

    function _class3() {
      this.klass = null;
      this.props = {};
    }

    var _proto3 = _class3.prototype;

    _proto3.install = function install(key, desc) {
      this.props[key] = desc;
    };

    _proto3.set = function set(key, value) {
      this.props[key] = value;
    };

    _proto3.finalize = function finalize() {
      this.klass = _runtime.Object.extend(this.props);
      return this.klass.create();
    };

    _proto3.source = function source() {
      return this.klass.prototype;
    };

    return _class3;
  }(),
  /*#__PURE__*/
  function () {
    _class4.module = function module(title) {
      return title + ": in EmberObject.extend() through a mixin";
    };

    function _class4() {
      this.klass = null;
      this.props = {};
    }

    var _proto4 = _class4.prototype;

    _proto4.install = function install(key, desc) {
      this.props[key] = desc;
    };

    _proto4.set = function set(key, value) {
      this.props[key] = value;
    };

    _proto4.finalize = function finalize() {
      this.klass = _runtime.Object.extend(_metal.Mixin.create(this.props));
      return this.klass.create();
    };

    _proto4.source = function source() {
      return this.klass.prototype;
    };

    return _class4;
  }(),
  /*#__PURE__*/
  function () {
    _class5.module = function module(title) {
      return title + ": inherited from another EmberObject super class";
    };

    function _class5() {
      this.superklass = null;
      this.props = {};
    }

    var _proto5 = _class5.prototype;

    _proto5.install = function install(key, desc) {
      this.props[key] = desc;
    };

    _proto5.set = function set(key, value) {
      this.props[key] = value;
    };

    _proto5.finalize = function finalize() {
      this.superklass = _runtime.Object.extend(this.props);
      return this.superklass.extend().create();
    };

    _proto5.source = function source() {
      return this.superklass.prototype;
    };

    return _class5;
  }()];
  classes.forEach(function (TestClass) {
    (0, _internalTestHelpers.moduleFor)(TestClass.module('@ember/-internals/metal/nativeDescDecorator'),
    /*#__PURE__*/
    function (_AbstractTestCase) {
      (0, _emberBabel.inheritsLoose)(_class6, _AbstractTestCase);

      function _class6() {
        return _AbstractTestCase.apply(this, arguments) || this;
      }

      var _proto6 = _class6.prototype;

      _proto6['@test defining a configurable property'] = function testDefiningAConfigurableProperty(assert) {
        var factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          configurable: true,
          value: 'bar'
        }), assert);
        var obj = factory.finalize();
        assert.equal(obj.foo, 'bar');
        var source = factory.source();
        delete source.foo;
        assert.strictEqual(obj.foo, undefined);
        Object.defineProperty(source, 'foo', {
          configurable: true,
          value: 'baz'
        });
        assert.equal(obj.foo, 'baz');
      };

      _proto6['@test defining a non-configurable property'] = function testDefiningANonConfigurableProperty(assert) {
        var factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          configurable: false,
          value: 'bar'
        }), assert);
        var obj = factory.finalize();
        assert.equal(obj.foo, 'bar');
        var source = factory.source();
        assert.throws(function () {
          return delete source.foo;
        }, TypeError);
        assert.throws(function () {
          return Object.defineProperty(source, 'foo', {
            configurable: true,
            value: 'baz'
          });
        }, TypeError);
        assert.equal(obj.foo, 'bar');
      };

      _proto6['@test defining an enumerable property'] = function testDefiningAnEnumerableProperty(assert) {
        var factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          enumerable: true,
          value: 'bar'
        }), assert);
        var obj = factory.finalize();
        assert.equal(obj.foo, 'bar');
        var source = factory.source();
        assert.ok(Object.keys(source).indexOf('foo') !== -1);
      };

      _proto6['@test defining a non-enumerable property'] = function testDefiningANonEnumerableProperty(assert) {
        var factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          enumerable: false,
          value: 'bar'
        }), assert);
        var obj = factory.finalize();
        assert.equal(obj.foo, 'bar');
        var source = factory.source();
        assert.ok(Object.keys(source).indexOf('foo') === -1);
      };

      _proto6['@test defining a writable property'] = function testDefiningAWritableProperty(assert) {
        var factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          writable: true,
          value: 'bar'
        }), assert);
        var obj = factory.finalize();
        assert.equal(obj.foo, 'bar');
        var source = factory.source();
        source.foo = 'baz';
        assert.equal(obj.foo, 'baz');
        obj.foo = 'bat';
        assert.equal(obj.foo, 'bat');
      };

      _proto6['@test defining a non-writable property'] = function testDefiningANonWritableProperty(assert) {
        var factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          writable: false,
          value: 'bar'
        }), assert);
        var obj = factory.finalize();
        assert.equal(obj.foo, 'bar');
        var source = factory.source();
        assert.throws(function () {
          return source.foo = 'baz';
        }, TypeError);
        assert.throws(function () {
          return obj.foo = 'baz';
        }, TypeError);
        assert.equal(obj.foo, 'bar');
      };

      _proto6['@test defining a getter'] = function testDefiningAGetter(assert) {
        var factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          get: function () {
            return this.__foo__;
          }
        }), assert);
        factory.set('__foo__', 'bar');
        var obj = factory.finalize();
        assert.equal(obj.foo, 'bar');
        obj.__foo__ = 'baz';
        assert.equal(obj.foo, 'baz');
      };

      _proto6['@test defining a setter'] = function testDefiningASetter(assert) {
        var factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          set: function (value) {
            this.__foo__ = value;
          }
        }), assert);
        factory.set('__foo__', 'bar');
        var obj = factory.finalize();
        assert.equal(obj.__foo__, 'bar');
        obj.foo = 'baz';
        assert.equal(obj.__foo__, 'baz');
      };

      _proto6['@test combining multiple setter and getters'] = function testCombiningMultipleSetterAndGetters(assert) {
        var factory = new TestClass(assert);
        factory.install('foo', (0, _metal.nativeDescDecorator)({
          get: function () {
            return this.__foo__;
          },
          set: function (value) {
            this.__foo__ = value;
          }
        }), assert);
        factory.set('__foo__', 'foo');
        factory.install('bar', (0, _metal.nativeDescDecorator)({
          get: function () {
            return this.__bar__;
          },
          set: function (value) {
            this.__bar__ = value;
          }
        }), assert);
        factory.set('__bar__', 'bar');
        factory.install('fooBar', (0, _metal.nativeDescDecorator)({
          get: function () {
            return this.foo + '-' + this.bar;
          }
        }), assert);
        var obj = factory.finalize();
        assert.equal(obj.fooBar, 'foo-bar');
        obj.foo = 'FOO';
        assert.equal(obj.fooBar, 'FOO-bar');
        obj.__bar__ = 'BAR';
        assert.equal(obj.fooBar, 'FOO-BAR');
        assert.throws(function () {
          return obj.fooBar = 'foobar';
        }, TypeError);
        assert.equal(obj.fooBar, 'FOO-BAR');
      };

      return _class6;
    }(_internalTestHelpers.AbstractTestCase));
  });
});
enifed("@ember/-internals/metal/tests/observer_test", ["ember-babel", "@ember/-internals/environment", "@ember/-internals/metal", "internal-test-helpers", "@ember/deprecated-features"], function (_emberBabel, _environment, _metal, _internalTestHelpers, _deprecatedFeatures) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function K() {} // ..........................................................
  // ADD OBSERVER
  //


  (0, _internalTestHelpers.moduleFor)('addObserver',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test observer should assert to invalid input'] = function testObserverShouldAssertToInvalidInput() {
      expectAssertion(function () {
        (0, _metal.observer)(function () {});
      }, 'observer called without valid path');
      expectAssertion(function () {
        (0, _metal.observer)(null);
      }, 'observer called without a function');
    };

    _proto['@test observer should fire when property is modified'] =
    /*#__PURE__*/
    function () {
      var _testObserverShouldFireWhenPropertyIsModified = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var obj, count;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              obj = {};
              count = 0;
              (0, _metal.addObserver)(obj, 'foo', function () {
                assert.equal((0, _metal.get)(obj, 'foo'), 'bar', 'should invoke AFTER value changed');
                count++;
              });
              (0, _metal.set)(obj, 'foo', 'bar');
              _context.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              assert.equal(count, 1, 'should have invoked observer');

            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function testObserverShouldFireWhenPropertyIsModified(_x) {
        return _testObserverShouldFireWhenPropertyIsModified.apply(this, arguments);
      }

      return testObserverShouldFireWhenPropertyIsModified;
    }();

    _proto['@test observer should fire when dependent property is modified'] =
    /*#__PURE__*/
    function () {
      var _testObserverShouldFireWhenDependentPropertyIsModified = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        var obj, count;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              obj = {
                bar: 'bar'
              };
              (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('bar', function () {
                return (0, _metal.get)(this, 'bar').toUpperCase();
              }));
              (0, _metal.get)(obj, 'foo');
              count = 0;
              (0, _metal.addObserver)(obj, 'foo', function () {
                assert.equal((0, _metal.get)(obj, 'foo'), 'BAZ', 'should have invoked after prop change');
                count++;
              });
              (0, _metal.set)(obj, 'bar', 'baz');
              _context2.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              assert.equal(count, 1, 'should have invoked observer');

            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));

      function testObserverShouldFireWhenDependentPropertyIsModified(_x2) {
        return _testObserverShouldFireWhenDependentPropertyIsModified.apply(this, arguments);
      }

      return testObserverShouldFireWhenDependentPropertyIsModified;
    }();

    _proto['@test observer should continue to fire after dependent properties are accessed'] =
    /*#__PURE__*/
    function () {
      var _testObserverShouldContinueToFireAfterDependentPropertiesAreAccessed = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(assert) {
        var observerCount, obj, i;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              observerCount = 0;
              obj = {};
              (0, _metal.defineProperty)(obj, 'prop', (0, _metal.computed)(function () {
                return Math.random();
              }));
              (0, _metal.defineProperty)(obj, 'anotherProp', (0, _metal.computed)('prop', function () {
                return (0, _metal.get)(this, 'prop') + Math.random();
              }));
              (0, _metal.addObserver)(obj, 'prop', function () {
                observerCount++;
              });
              (0, _metal.get)(obj, 'anotherProp');
              i = 0;

            case 7:
              if (!(i < 10)) {
                _context3.next = 14;
                break;
              }

              (0, _metal.notifyPropertyChange)(obj, 'prop');
              _context3.next = 11;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 11:
              i++;
              _context3.next = 7;
              break;

            case 14:
              assert.equal(observerCount, 10, 'should continue to fire indefinitely');

            case 15:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));

      function testObserverShouldContinueToFireAfterDependentPropertiesAreAccessed(_x3) {
        return _testObserverShouldContinueToFireAfterDependentPropertiesAreAccessed.apply(this, arguments);
      }

      return testObserverShouldContinueToFireAfterDependentPropertiesAreAccessed;
    }();

    _proto['@test observer added via Function.prototype extensions and brace expansion should fire when property changes'] =
    /*#__PURE__*/
    function () {
      var _testObserverAddedViaFunctionPrototypeExtensionsAndBraceExpansionShouldFireWhenPropertyChanges = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(assert) {
        var _obj, _count;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (!(!_deprecatedFeatures.FUNCTION_PROTOTYPE_EXTENSIONS && _environment.ENV.EXTEND_PROTOTYPES.Function)) {
                _context4.next = 18;
                break;
              }

              _obj = {};
              _count = 0;
              expectDeprecation(function () {
                (0, _metal.mixin)(_obj, {
                  observeFooAndBar: function () {
                    _count++;
                  }.observes('{foo,bar}')
                });
              }, /Function prototype extensions have been deprecated, please migrate from function\(\){}.observes\('foo'\) to observer\('foo', function\(\) {}\)/);
              (0, _metal.set)(_obj, 'foo', 'foo');
              _context4.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              assert.equal(_count, 1, 'observer specified via brace expansion invoked on property change');
              (0, _metal.set)(_obj, 'bar', 'bar');
              _context4.next = 11;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 11:
              assert.equal(_count, 2, 'observer specified via brace expansion invoked on property change');
              (0, _metal.set)(_obj, 'baz', 'baz');
              _context4.next = 15;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 15:
              assert.equal(_count, 2, 'observer not invoked on unspecified property');
              _context4.next = 19;
              break;

            case 18:
              assert.expect(0);

            case 19:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));

      function testObserverAddedViaFunctionPrototypeExtensionsAndBraceExpansionShouldFireWhenPropertyChanges(_x4) {
        return _testObserverAddedViaFunctionPrototypeExtensionsAndBraceExpansionShouldFireWhenPropertyChanges.apply(this, arguments);
      }

      return testObserverAddedViaFunctionPrototypeExtensionsAndBraceExpansionShouldFireWhenPropertyChanges;
    }();

    _proto['@test observer specified via Function.prototype extensions via brace expansion should fire when dependent property changes'] =
    /*#__PURE__*/
    function () {
      var _testObserverSpecifiedViaFunctionPrototypeExtensionsViaBraceExpansionShouldFireWhenDependentPropertyChanges = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(assert) {
        var _obj2, _count2;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (!(!_deprecatedFeatures.FUNCTION_PROTOTYPE_EXTENSIONS && _environment.ENV.EXTEND_PROTOTYPES.Function)) {
                _context5.next = 17;
                break;
              }

              _obj2 = {
                baz: 'Initial'
              };
              _count2 = 0;
              (0, _metal.defineProperty)(_obj2, 'foo', (0, _metal.computed)('bar', function () {
                return (0, _metal.get)(this, 'bar').toLowerCase();
              }));
              (0, _metal.defineProperty)(_obj2, 'bar', (0, _metal.computed)('baz', function () {
                return (0, _metal.get)(this, 'baz').toUpperCase();
              }));
              expectDeprecation(function () {
                (0, _metal.mixin)(_obj2, {
                  fooAndBarWatcher: function () {
                    _count2++;
                  }.observes('{foo,bar}')
                });
              }, /Function prototype extensions have been deprecated, please migrate from function\(\){}.observes\('foo'\) to observer\('foo', function\(\) {}\)/);
              (0, _metal.get)(_obj2, 'foo');
              (0, _metal.set)(_obj2, 'baz', 'Baz');
              _context5.next = 10;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 10:
              // fire once for foo, once for bar
              assert.equal(_count2, 2, 'observer specified via brace expansion invoked on dependent property change');
              (0, _metal.set)(_obj2, 'quux', 'Quux');
              _context5.next = 14;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 14:
              assert.equal(_count2, 2, 'observer not fired on unspecified property');
              _context5.next = 18;
              break;

            case 17:
              assert.expect(0);

            case 18:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }));

      function testObserverSpecifiedViaFunctionPrototypeExtensionsViaBraceExpansionShouldFireWhenDependentPropertyChanges(_x5) {
        return _testObserverSpecifiedViaFunctionPrototypeExtensionsViaBraceExpansionShouldFireWhenDependentPropertyChanges.apply(this, arguments);
      }

      return testObserverSpecifiedViaFunctionPrototypeExtensionsViaBraceExpansionShouldFireWhenDependentPropertyChanges;
    }();

    _proto['@test observers watching multiple properties via brace expansion should fire when the properties change'] =
    /*#__PURE__*/
    function () {
      var _testObserversWatchingMultiplePropertiesViaBraceExpansionShouldFireWhenThePropertiesChange = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(assert) {
        var obj, count;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              obj = {};
              count = 0;
              (0, _metal.mixin)(obj, {
                observeFooAndBar: (0, _metal.observer)('{foo,bar}', function () {
                  count++;
                })
              });
              (0, _metal.set)(obj, 'foo', 'foo');
              _context6.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              assert.equal(count, 1, 'observer specified via brace expansion invoked on property change');
              (0, _metal.set)(obj, 'bar', 'bar');
              _context6.next = 10;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 10:
              assert.equal(count, 2, 'observer specified via brace expansion invoked on property change');
              (0, _metal.set)(obj, 'baz', 'baz');
              _context6.next = 14;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 14:
              assert.equal(count, 2, 'observer not invoked on unspecified property');

            case 15:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));

      function testObserversWatchingMultiplePropertiesViaBraceExpansionShouldFireWhenThePropertiesChange(_x6) {
        return _testObserversWatchingMultiplePropertiesViaBraceExpansionShouldFireWhenThePropertiesChange.apply(this, arguments);
      }

      return testObserversWatchingMultiplePropertiesViaBraceExpansionShouldFireWhenThePropertiesChange;
    }();

    _proto['@test observers watching multiple properties via brace expansion should fire when dependent properties change'] =
    /*#__PURE__*/
    function () {
      var _testObserversWatchingMultiplePropertiesViaBraceExpansionShouldFireWhenDependentPropertiesChange = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(assert) {
        var obj, count;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              obj = {
                baz: 'Initial'
              };
              count = 0;
              (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('bar', function () {
                return (0, _metal.get)(this, 'bar').toLowerCase();
              }));
              (0, _metal.defineProperty)(obj, 'bar', (0, _metal.computed)('baz', function () {
                return (0, _metal.get)(this, 'baz').toUpperCase();
              }));
              (0, _metal.mixin)(obj, {
                fooAndBarWatcher: (0, _metal.observer)('{foo,bar}', function () {
                  count++;
                })
              });
              (0, _metal.get)(obj, 'foo');
              (0, _metal.set)(obj, 'baz', 'Baz');
              _context7.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              // fire once for foo, once for bar
              assert.equal(count, 2, 'observer specified via brace expansion invoked on dependent property change');
              (0, _metal.set)(obj, 'quux', 'Quux');
              _context7.next = 13;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 13:
              assert.equal(count, 2, 'observer not fired on unspecified property');

            case 14:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      }));

      function testObserversWatchingMultiplePropertiesViaBraceExpansionShouldFireWhenDependentPropertiesChange(_x7) {
        return _testObserversWatchingMultiplePropertiesViaBraceExpansionShouldFireWhenDependentPropertiesChange.apply(this, arguments);
      }

      return testObserversWatchingMultiplePropertiesViaBraceExpansionShouldFireWhenDependentPropertiesChange;
    }();

    _proto['@test nested observers should fire in order'] = function testNestedObserversShouldFireInOrder(assert) {
      if (false
      /* EMBER_METAL_TRACKED_PROPERTIES */
      ) {
          // We can no longer guarantee order
          return assert.expect(0);
        }

      var obj = {
        foo: 'foo',
        bar: 'bar'
      };
      var fooCount = 0;
      var barCount = 0;
      (0, _metal.addObserver)(obj, 'foo', function () {
        fooCount++;
      });
      (0, _metal.addObserver)(obj, 'bar', function () {
        (0, _metal.set)(obj, 'foo', 'BAZ');
        assert.equal(fooCount, 1, 'fooCount should have fired already');
        barCount++;
      });
      (0, _metal.set)(obj, 'bar', 'BIFF');
      assert.equal(barCount, 1, 'barCount should have fired');
      assert.equal(fooCount, 1, 'foo should have fired');
    };

    _proto['@test removing an chain observer on change should not fail'] =
    /*#__PURE__*/
    function () {
      var _testRemovingAnChainObserverOnChangeShouldNotFail = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(assert) {
        var foo, obj1, obj2, obj3, obj4, count1, count2, count3, count4, observer1, observer2, observer3, observer4;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              observer4 = function _ref4() {
                count4++;
              };

              observer3 = function _ref3() {
                count3++;
                (0, _metal.removeObserver)(obj1, 'foo.bar', observer1);
                (0, _metal.removeObserver)(obj2, 'foo.bar', observer2);
                (0, _metal.removeObserver)(obj4, 'foo.bar', observer4);
              };

              observer2 = function _ref2() {
                count2++;
              };

              observer1 = function _ref() {
                count1++;
              };

              foo = {
                bar: 'bar'
              };
              obj1 = {
                foo: foo
              };
              obj2 = {
                foo: foo
              };
              obj3 = {
                foo: foo
              };
              obj4 = {
                foo: foo
              };
              count1 = 0;
              count2 = 0;
              count3 = 0;
              count4 = 0;
              (0, _metal.addObserver)(obj1, 'foo.bar', observer1);
              (0, _metal.addObserver)(obj2, 'foo.bar', observer2);
              (0, _metal.addObserver)(obj3, 'foo.bar', observer3);
              (0, _metal.addObserver)(obj4, 'foo.bar', observer4);
              (0, _metal.set)(foo, 'bar', 'baz');
              _context8.next = 20;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 20:
              assert.equal(count1, 1, 'observer1 fired');
              assert.equal(count2, 1, 'observer2 fired');
              assert.equal(count3, 1, 'observer3 fired');
              assert.equal(count4, 0, 'observer4 did not fire');

            case 24:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      }));

      function testRemovingAnChainObserverOnChangeShouldNotFail(_x8) {
        return _testRemovingAnChainObserverOnChangeShouldNotFail.apply(this, arguments);
      }

      return testRemovingAnChainObserverOnChangeShouldNotFail;
    }();

    _proto['@test deferring property change notifications'] =
    /*#__PURE__*/
    function () {
      var _testDeferringPropertyChangeNotifications = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee9(assert) {
        var obj, fooCount;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              obj = {
                foo: 'foo'
              };
              fooCount = 0;
              (0, _metal.addObserver)(obj, 'foo', function () {
                fooCount++;
              });

              if (!false
              /* EMBER_METAL_TRACKED_PROPERTIES */
              ) {
                  (0, _metal.beginPropertyChanges)();
                }

              (0, _metal.set)(obj, 'foo', 'BIFF');
              (0, _metal.set)(obj, 'foo', 'BAZ');

              if (!false
              /* EMBER_METAL_TRACKED_PROPERTIES */
              ) {
                  (0, _metal.endPropertyChanges)();
                }

              _context9.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              assert.equal(fooCount, 1, 'foo should have fired once');

            case 10:
            case "end":
              return _context9.stop();
          }
        }, _callee9);
      }));

      function testDeferringPropertyChangeNotifications(_x9) {
        return _testDeferringPropertyChangeNotifications.apply(this, arguments);
      }

      return testDeferringPropertyChangeNotifications;
    }();

    _proto['@test deferring property change notifications safely despite exceptions'] =
    /*#__PURE__*/
    function () {
      var _testDeferringPropertyChangeNotificationsSafelyDespiteExceptions = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee10(assert) {
        var obj, fooCount, exc;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              if (!false
              /* EMBER_METAL_TRACKED_PROPERTIES */
              ) {
                  _context10.next = 2;
                  break;
                }

              return _context10.abrupt("return", assert.expect(0));

            case 2:
              obj = {
                foo: 'foo'
              };
              fooCount = 0;
              exc = new Error('Something unexpected happened!');
              assert.expect(2);
              (0, _metal.addObserver)(obj, 'foo', function () {
                fooCount++;
              });
              _context10.prev = 7;
              (0, _metal.changeProperties)(function () {
                (0, _metal.set)(obj, 'foo', 'BIFF');
                (0, _metal.set)(obj, 'foo', 'BAZ');
                throw exc;
              });
              _context10.next = 15;
              break;

            case 11:
              _context10.prev = 11;
              _context10.t0 = _context10["catch"](7);

              if (!(_context10.t0 !== exc)) {
                _context10.next = 15;
                break;
              }

              throw _context10.t0;

            case 15:
              assert.equal(fooCount, 1, 'foo should have fired once');
              (0, _metal.changeProperties)(function () {
                (0, _metal.set)(obj, 'foo', 'BIFF2');
                (0, _metal.set)(obj, 'foo', 'BAZ2');
              });
              assert.equal(fooCount, 2, 'foo should have fired again once');

            case 18:
            case "end":
              return _context10.stop();
          }
        }, _callee10, null, [[7, 11]]);
      }));

      function testDeferringPropertyChangeNotificationsSafelyDespiteExceptions(_x10) {
        return _testDeferringPropertyChangeNotificationsSafelyDespiteExceptions.apply(this, arguments);
      }

      return testDeferringPropertyChangeNotificationsSafelyDespiteExceptions;
    }();

    _proto['@test addObserver should propagate through prototype'] = function testAddObserverShouldPropagateThroughPrototype(assert) {
      if (false
      /* EMBER_METAL_TRACKED_PROPERTIES */
      ) {
          // We no longer inherit unless it's an EmberObject
          return assert.expect(0);
        }

      var obj = {
        foo: 'foo',
        count: 0
      };
      var obj2;
      (0, _metal.addObserver)(obj, 'foo', function () {
        this.count++;
      });
      obj2 = Object.create(obj);
      (0, _metal.set)(obj2, 'foo', 'bar');
      assert.equal(obj2.count, 1, 'should have invoked observer on inherited');
      assert.equal(obj.count, 0, 'should not have invoked observer on parent');
      obj2.count = 0;
      (0, _metal.set)(obj, 'foo', 'baz');
      assert.equal(obj.count, 0, 'should not have invoked observer on parent');
      assert.equal(obj2.count, 0, 'should not have invoked observer on inherited');
    };

    _proto['@test addObserver should respect targets with methods'] =
    /*#__PURE__*/
    function () {
      var _testAddObserverShouldRespectTargetsWithMethods = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee11(assert) {
        var observed, target1, target2;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              observed = {
                foo: 'foo'
              };
              target1 = {
                count: 0,
                didChange: function (obj, keyName) {
                  var value = (0, _metal.get)(obj, keyName);
                  assert.equal(this, target1, 'should invoke with this');
                  assert.equal(obj, observed, 'param1 should be observed object');
                  assert.equal(keyName, 'foo', 'param2 should be keyName');
                  assert.equal(value, 'BAZ', 'param3 should new value');
                  this.count++;
                }
              };
              target2 = {
                count: 0,
                didChange: function (obj, keyName) {
                  var value = (0, _metal.get)(obj, keyName);
                  assert.equal(this, target2, 'should invoke with this');
                  assert.equal(obj, observed, 'param1 should be observed object');
                  assert.equal(keyName, 'foo', 'param2 should be keyName');
                  assert.equal(value, 'BAZ', 'param3 should new value');
                  this.count++;
                }
              };
              (0, _metal.addObserver)(observed, 'foo', target1, 'didChange');
              (0, _metal.addObserver)(observed, 'foo', target2, target2.didChange);
              (0, _metal.set)(observed, 'foo', 'BAZ');
              _context11.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              assert.equal(target1.count, 1, 'target1 observer should have fired');
              assert.equal(target2.count, 1, 'target2 observer should have fired');

            case 10:
            case "end":
              return _context11.stop();
          }
        }, _callee11);
      }));

      function testAddObserverShouldRespectTargetsWithMethods(_x11) {
        return _testAddObserverShouldRespectTargetsWithMethods.apply(this, arguments);
      }

      return testAddObserverShouldRespectTargetsWithMethods;
    }();

    _proto['@test addObserver should allow multiple objects to observe a property'] =
    /*#__PURE__*/
    function () {
      var _testAddObserverShouldAllowMultipleObjectsToObserveAProperty = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee12(assert) {
        var observed, target1, target2;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              observed = {
                foo: 'foo'
              };
              target1 = {
                count: 0,
                didChange: function () {
                  this.count++;
                }
              };
              target2 = {
                count: 0,
                didChange: function () {
                  this.count++;
                }
              };
              (0, _metal.addObserver)(observed, 'foo', target1, 'didChange');
              (0, _metal.addObserver)(observed, 'foo', target2, 'didChange');
              (0, _metal.set)(observed, 'foo', 'BAZ');
              _context12.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              assert.equal(target1.count, 1, 'target1 observer should have fired');
              assert.equal(target2.count, 1, 'target2 observer should have fired');

            case 10:
            case "end":
              return _context12.stop();
          }
        }, _callee12);
      }));

      function testAddObserverShouldAllowMultipleObjectsToObserveAProperty(_x12) {
        return _testAddObserverShouldAllowMultipleObjectsToObserveAProperty.apply(this, arguments);
      }

      return testAddObserverShouldAllowMultipleObjectsToObserveAProperty;
    }();

    return _class;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // REMOVE OBSERVER
  //

  (0, _internalTestHelpers.moduleFor)('removeObserver',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test removing observer should stop firing'] =
    /*#__PURE__*/
    function () {
      var _testRemovingObserverShouldStopFiring = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee13(assert) {
        var obj, count, F;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              F = function _ref5() {
                count++;
              };

              obj = {};
              count = 0;
              (0, _metal.addObserver)(obj, 'foo', F);
              (0, _metal.set)(obj, 'foo', 'bar');
              _context13.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              assert.equal(count, 1, 'should have invoked observer');
              (0, _metal.removeObserver)(obj, 'foo', F);
              (0, _metal.set)(obj, 'foo', 'baz');
              _context13.next = 12;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 12:
              assert.equal(count, 1, "removed observer shouldn't fire");

            case 13:
            case "end":
              return _context13.stop();
          }
        }, _callee13);
      }));

      function testRemovingObserverShouldStopFiring(_x13) {
        return _testRemovingObserverShouldStopFiring.apply(this, arguments);
      }

      return testRemovingObserverShouldStopFiring;
    }();

    _proto2['@test local observers can be removed'] =
    /*#__PURE__*/
    function () {
      var _testLocalObserversCanBeRemoved = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee14(assert) {
        var barObserved, MyMixin, obj;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              barObserved = 0;
              MyMixin = _metal.Mixin.create({
                foo1: (0, _metal.observer)('bar', function () {
                  barObserved++;
                }),
                foo2: (0, _metal.observer)('bar', function () {
                  barObserved++;
                })
              });
              obj = {};
              MyMixin.apply(obj);
              (0, _metal.set)(obj, 'bar', 'HI!');
              _context14.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              assert.equal(barObserved, 2, 'precond - observers should be fired');
              (0, _metal.removeObserver)(obj, 'bar', null, 'foo1');
              barObserved = 0;
              (0, _metal.set)(obj, 'bar', 'HI AGAIN!');
              _context14.next = 13;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 13:
              assert.equal(barObserved, 1, 'removed observers should not be called');

            case 14:
            case "end":
              return _context14.stop();
          }
        }, _callee14);
      }));

      function testLocalObserversCanBeRemoved(_x14) {
        return _testLocalObserversCanBeRemoved.apply(this, arguments);
      }

      return testLocalObserversCanBeRemoved;
    }();

    _proto2['@test removeObserver should respect targets with methods'] =
    /*#__PURE__*/
    function () {
      var _testRemoveObserverShouldRespectTargetsWithMethods = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee15(assert) {
        var observed, target1, target2;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              observed = {
                foo: 'foo'
              };
              target1 = {
                count: 0,
                didChange: function () {
                  this.count++;
                }
              };
              target2 = {
                count: 0,
                didChange: function () {
                  this.count++;
                }
              };
              (0, _metal.addObserver)(observed, 'foo', target1, 'didChange');
              (0, _metal.addObserver)(observed, 'foo', target2, target2.didChange);
              (0, _metal.set)(observed, 'foo', 'BAZ');
              _context15.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              assert.equal(target1.count, 1, 'target1 observer should have fired');
              assert.equal(target2.count, 1, 'target2 observer should have fired');
              (0, _metal.removeObserver)(observed, 'foo', target1, 'didChange');
              (0, _metal.removeObserver)(observed, 'foo', target2, target2.didChange);
              target1.count = target2.count = 0;
              (0, _metal.set)(observed, 'foo', 'BAZ');
              _context15.next = 16;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 16:
              assert.equal(target1.count, 0, 'target1 observer should not fire again');
              assert.equal(target2.count, 0, 'target2 observer should not fire again');

            case 18:
            case "end":
              return _context15.stop();
          }
        }, _callee15);
      }));

      function testRemoveObserverShouldRespectTargetsWithMethods(_x15) {
        return _testRemoveObserverShouldRespectTargetsWithMethods.apply(this, arguments);
      }

      return testRemoveObserverShouldRespectTargetsWithMethods;
    }();

    return _class2;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // CHAINED OBSERVERS
  //

  var obj, count;
  (0, _internalTestHelpers.moduleFor)('addObserver - dependentkey with chained properties',
  /*#__PURE__*/
  function (_AbstractTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class3, _AbstractTestCase3);

    function _class3() {
      return _AbstractTestCase3.apply(this, arguments) || this;
    }

    var _proto3 = _class3.prototype;

    _proto3.beforeEach = function beforeEach() {
      obj = {
        foo: {
          bar: {
            baz: {
              biff: 'BIFF'
            }
          }
        },
        Capital: {
          foo: {
            bar: {
              baz: {
                biff: 'BIFF'
              }
            }
          }
        }
      };
      count = 0;
    };

    _proto3.afterEach = function afterEach() {
      obj = count = null;
    };

    _proto3['@test depending on a chain with a computed property'] =
    /*#__PURE__*/
    function () {
      var _testDependingOnAChainWithAComputedProperty = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee16(assert) {
        var changed;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              (0, _metal.defineProperty)(obj, 'computed', (0, _metal.computed)(function () {
                return {
                  foo: 'bar'
                };
              }));
              changed = 0;
              (0, _metal.addObserver)(obj, 'computed.foo', function () {
                changed++;
              });
              assert.equal((0, _metal.getCachedValueFor)(obj, 'computed'), undefined, 'addObserver should not compute CP');
              (0, _metal.set)(obj, 'computed.foo', 'baz');
              _context16.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              assert.equal(changed, 1, 'should fire observer');

            case 8:
            case "end":
              return _context16.stop();
          }
        }, _callee16);
      }));

      function testDependingOnAChainWithAComputedProperty(_x16) {
        return _testDependingOnAChainWithAComputedProperty.apply(this, arguments);
      }

      return testDependingOnAChainWithAComputedProperty;
    }();

    _proto3['@test depending on a simple chain'] =
    /*#__PURE__*/
    function () {
      var _testDependingOnASimpleChain = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee17(assert) {
        var val, foo;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              (0, _metal.addObserver)(obj, 'foo.bar.baz.biff', function (target, key) {
                val = (0, _metal.get)(target, key);
                count++;
              });
              (0, _metal.set)((0, _metal.get)(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
              _context17.next = 4;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 4:
              assert.equal(val, 'BUZZ');
              assert.equal(count, 1);
              (0, _metal.set)((0, _metal.get)(obj, 'foo.bar'), 'baz', {
                biff: 'BLARG'
              });
              _context17.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              assert.equal(val, 'BLARG');
              assert.equal(count, 2);
              (0, _metal.set)((0, _metal.get)(obj, 'foo'), 'bar', {
                baz: {
                  biff: 'BOOM'
                }
              });
              _context17.next = 14;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 14:
              assert.equal(val, 'BOOM');
              assert.equal(count, 3);
              (0, _metal.set)(obj, 'foo', {
                bar: {
                  baz: {
                    biff: 'BLARG'
                  }
                }
              });
              _context17.next = 19;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 19:
              assert.equal(val, 'BLARG');
              assert.equal(count, 4);
              (0, _metal.set)((0, _metal.get)(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
              _context17.next = 24;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 24:
              assert.equal(val, 'BUZZ');
              assert.equal(count, 5);
              foo = (0, _metal.get)(obj, 'foo');
              (0, _metal.set)(obj, 'foo', 'BOO');
              _context17.next = 30;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 30:
              assert.equal(val, undefined);
              assert.equal(count, 6);
              (0, _metal.set)(foo.bar.baz, 'biff', 'BOOM');
              _context17.next = 35;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 35:
              assert.equal(count, 6, 'should be not have invoked observer');

            case 36:
            case "end":
              return _context17.stop();
          }
        }, _callee17);
      }));

      function testDependingOnASimpleChain(_x17) {
        return _testDependingOnASimpleChain.apply(this, arguments);
      }

      return testDependingOnASimpleChain;
    }();

    _proto3['@test depending on a chain with a capitalized first key'] =
    /*#__PURE__*/
    function () {
      var _testDependingOnAChainWithACapitalizedFirstKey = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee18(assert) {
        var val, foo;
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              (0, _metal.addObserver)(obj, 'Capital.foo.bar.baz.biff', function (target, key) {
                val = (0, _metal.get)(obj, key);
                count++;
              });
              (0, _metal.set)((0, _metal.get)(obj, 'Capital.foo.bar.baz'), 'biff', 'BUZZ');
              _context18.next = 4;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 4:
              assert.equal(val, 'BUZZ');
              assert.equal(count, 1);
              (0, _metal.set)((0, _metal.get)(obj, 'Capital.foo.bar'), 'baz', {
                biff: 'BLARG'
              });
              _context18.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              assert.equal(val, 'BLARG');
              assert.equal(count, 2);
              (0, _metal.set)((0, _metal.get)(obj, 'Capital.foo'), 'bar', {
                baz: {
                  biff: 'BOOM'
                }
              });
              _context18.next = 14;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 14:
              assert.equal(val, 'BOOM');
              assert.equal(count, 3);
              (0, _metal.set)(obj, 'Capital.foo', {
                bar: {
                  baz: {
                    biff: 'BLARG'
                  }
                }
              });
              _context18.next = 19;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 19:
              assert.equal(val, 'BLARG');
              assert.equal(count, 4);
              (0, _metal.set)((0, _metal.get)(obj, 'Capital.foo.bar.baz'), 'biff', 'BUZZ');
              _context18.next = 24;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 24:
              assert.equal(val, 'BUZZ');
              assert.equal(count, 5);
              foo = (0, _metal.get)(obj, 'foo');
              (0, _metal.set)(obj, 'Capital.foo', 'BOO');
              _context18.next = 30;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 30:
              assert.equal(val, undefined);
              assert.equal(count, 6);
              (0, _metal.set)(foo.bar.baz, 'biff', 'BOOM');
              _context18.next = 35;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 35:
              assert.equal(count, 6, 'should be not have invoked observer');

            case 36:
            case "end":
              return _context18.stop();
          }
        }, _callee18);
      }));

      function testDependingOnAChainWithACapitalizedFirstKey(_x18) {
        return _testDependingOnAChainWithACapitalizedFirstKey.apply(this, arguments);
      }

      return testDependingOnAChainWithACapitalizedFirstKey;
    }();

    return _class3;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // SETTING IDENTICAL VALUES
  //

  (0, _internalTestHelpers.moduleFor)('props/observer_test - setting identical values',
  /*#__PURE__*/
  function (_AbstractTestCase4) {
    (0, _emberBabel.inheritsLoose)(_class4, _AbstractTestCase4);

    function _class4() {
      return _AbstractTestCase4.apply(this, arguments) || this;
    }

    var _proto4 = _class4.prototype;

    _proto4['@test setting simple prop should not trigger'] =
    /*#__PURE__*/
    function () {
      var _testSettingSimplePropShouldNotTrigger = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee19(assert) {
        var obj, count;
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              obj = {
                foo: 'bar'
              };
              count = 0;
              (0, _metal.addObserver)(obj, 'foo', function () {
                count++;
              });
              (0, _metal.set)(obj, 'foo', 'bar');
              _context19.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              assert.equal(count, 0, 'should not trigger observer');
              (0, _metal.set)(obj, 'foo', 'baz');
              _context19.next = 10;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 10:
              assert.equal(count, 1, 'should trigger observer');
              (0, _metal.set)(obj, 'foo', 'baz');
              _context19.next = 14;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 14:
              assert.equal(count, 1, 'should not trigger observer again');

            case 15:
            case "end":
              return _context19.stop();
          }
        }, _callee19);
      }));

      function testSettingSimplePropShouldNotTrigger(_x19) {
        return _testSettingSimplePropShouldNotTrigger.apply(this, arguments);
      }

      return testSettingSimplePropShouldNotTrigger;
    }() // The issue here is when a computed property is directly set with a value, then has a
    // dependent key change (which triggers a cache expiration and recomputation), observers will
    // not be fired if the CP setter is called with the last set value.
    ;

    _proto4['@test setting a cached computed property whose value has changed should trigger'] =
    /*#__PURE__*/
    function () {
      var _testSettingACachedComputedPropertyWhoseValueHasChangedShouldTrigger = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee20(assert) {
        var obj, count;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              obj = {};
              (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)('baz', {
                get: function () {
                  return (0, _metal.get)(this, 'baz');
                },
                set: function (key, value) {
                  return value;
                }
              }));
              count = 0;
              (0, _metal.addObserver)(obj, 'foo', function () {
                count++;
              });
              (0, _metal.set)(obj, 'foo', 'bar');
              _context20.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              assert.equal(count, 1);
              assert.equal((0, _metal.get)(obj, 'foo'), 'bar');
              (0, _metal.set)(obj, 'baz', 'qux');
              _context20.next = 12;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 12:
              assert.equal(count, 2);
              assert.equal((0, _metal.get)(obj, 'foo'), 'qux');
              (0, _metal.set)(obj, 'foo', 'bar');
              _context20.next = 17;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 17:
              assert.equal(count, 3);
              assert.equal((0, _metal.get)(obj, 'foo'), 'bar');

            case 19:
            case "end":
              return _context20.stop();
          }
        }, _callee20);
      }));

      function testSettingACachedComputedPropertyWhoseValueHasChangedShouldTrigger(_x20) {
        return _testSettingACachedComputedPropertyWhoseValueHasChangedShouldTrigger.apply(this, arguments);
      }

      return testSettingACachedComputedPropertyWhoseValueHasChangedShouldTrigger;
    }();

    return _class4;
  }(_internalTestHelpers.AbstractTestCase));

  if (!false
  /* EMBER_METAL_TRACKED_PROPERTIES */
  ) {
      (0, _internalTestHelpers.moduleFor)('changeProperties',
      /*#__PURE__*/
      function (_AbstractTestCase5) {
        (0, _emberBabel.inheritsLoose)(_class5, _AbstractTestCase5);

        function _class5() {
          return _AbstractTestCase5.apply(this, arguments) || this;
        }

        var _proto5 = _class5.prototype;

        _proto5['@test observers added/removed during changeProperties should do the right thing.'] = function testObserversAddedRemovedDuringChangePropertiesShouldDoTheRightThing(assert) {
          var obj = {
            foo: 0
          };

          function Observer() {
            this.didChangeCount = 0;
          }

          Observer.prototype = {
            add: function () {
              (0, _metal.addObserver)(obj, 'foo', this, 'didChange');
            },
            remove: function () {
              (0, _metal.removeObserver)(obj, 'foo', this, 'didChange');
            },
            didChange: function () {
              this.didChangeCount++;
            }
          };
          var addedBeforeFirstChangeObserver = new Observer();
          var addedAfterFirstChangeObserver = new Observer();
          var addedAfterLastChangeObserver = new Observer();
          var removedBeforeFirstChangeObserver = new Observer();
          var removedBeforeLastChangeObserver = new Observer();
          var removedAfterLastChangeObserver = new Observer();
          removedBeforeFirstChangeObserver.add();
          removedBeforeLastChangeObserver.add();
          removedAfterLastChangeObserver.add();
          (0, _metal.changeProperties)(function () {
            removedBeforeFirstChangeObserver.remove();
            addedBeforeFirstChangeObserver.add();
            (0, _metal.set)(obj, 'foo', 1);
            assert.equal(addedBeforeFirstChangeObserver.didChangeCount, 0, 'addObserver called before the first change is deferred');
            addedAfterFirstChangeObserver.add();
            removedBeforeLastChangeObserver.remove();
            (0, _metal.set)(obj, 'foo', 2);
            assert.equal(addedAfterFirstChangeObserver.didChangeCount, 0, 'addObserver called after the first change is deferred');
            addedAfterLastChangeObserver.add();
            removedAfterLastChangeObserver.remove();
          });
          assert.equal(removedBeforeFirstChangeObserver.didChangeCount, 0, 'removeObserver called before the first change sees none');
          assert.equal(addedBeforeFirstChangeObserver.didChangeCount, 1, 'addObserver called before the first change sees only 1');
          assert.equal(addedAfterFirstChangeObserver.didChangeCount, 1, 'addObserver called after the first change sees 1');
          assert.equal(addedAfterLastChangeObserver.didChangeCount, 1, 'addObserver called after the last change sees 1');
          assert.equal(removedBeforeLastChangeObserver.didChangeCount, 0, 'removeObserver called before the last change sees none');
          assert.equal(removedAfterLastChangeObserver.didChangeCount, 0, 'removeObserver called after the last change sees none');
        };

        _proto5['@test calling changeProperties while executing deferred observers works correctly'] = function testCallingChangePropertiesWhileExecutingDeferredObserversWorksCorrectly(assert) {
          var obj = {
            foo: 0
          };
          var fooDidChange = 0;
          (0, _metal.addObserver)(obj, 'foo', function () {
            fooDidChange++;
            (0, _metal.changeProperties)(function () {});
          });
          (0, _metal.changeProperties)(function () {
            (0, _metal.set)(obj, 'foo', 1);
          });
          assert.equal(fooDidChange, 1);
        };

        return _class5;
      }(_internalTestHelpers.AbstractTestCase));
    }

  (0, _internalTestHelpers.moduleFor)('Keys behavior with observers',
  /*#__PURE__*/
  function (_AbstractTestCase6) {
    (0, _emberBabel.inheritsLoose)(_class6, _AbstractTestCase6);

    function _class6() {
      return _AbstractTestCase6.apply(this, arguments) || this;
    }

    var _proto6 = _class6.prototype;

    _proto6['@test should not leak properties on the prototype'] = function testShouldNotLeakPropertiesOnThePrototype(assert) {
      function Beer() {}

      Beer.prototype.type = 'ipa';
      var beer = new Beer();
      (0, _metal.addObserver)(beer, 'type', K);
      assert.deepEqual(Object.keys(beer), []);
      (0, _metal.removeObserver)(beer, 'type', K);
    };

    _proto6['@test observing a non existent property'] = function testObservingANonExistentProperty(assert) {
      function Beer() {}

      Beer.prototype.type = 'ipa';
      var beer = new Beer();
      (0, _metal.addObserver)(beer, 'brand', K);
      assert.deepEqual(Object.keys(beer), []);
      (0, _metal.set)(beer, 'brand', 'Corona');
      assert.deepEqual(Object.keys(beer), ['brand']);
      (0, _metal.removeObserver)(beer, 'brand', K);
    };

    _proto6['@test with observers switched on and off'] = function testWithObserversSwitchedOnAndOff(assert) {
      function Beer() {}

      Beer.prototype.type = 'ipa';
      var beer = new Beer();
      (0, _metal.addObserver)(beer, 'type', K);
      (0, _metal.removeObserver)(beer, 'type', K);
      assert.deepEqual(Object.keys(beer), []);
    };

    _proto6['@test observers switched on and off with setter in between'] = function testObserversSwitchedOnAndOffWithSetterInBetween(assert) {
      function Beer() {}

      Beer.prototype.type = 'ipa';
      var beer = new Beer();
      (0, _metal.addObserver)(beer, 'type', K);
      (0, _metal.set)(beer, 'type', 'ale');
      (0, _metal.removeObserver)(beer, 'type', K);
      assert.deepEqual(Object.keys(beer), ['type']);
    };

    _proto6['@test observer switched on and off and then setter'] = function testObserverSwitchedOnAndOffAndThenSetter(assert) {
      function Beer() {}

      Beer.prototype.type = 'ipa';
      var beer = new Beer();
      (0, _metal.addObserver)(beer, 'type', K);
      (0, _metal.removeObserver)(beer, 'type', K);
      (0, _metal.set)(beer, 'type', 'ale');
      assert.deepEqual(Object.keys(beer), ['type']);
    };

    _proto6['@test observers switched on and off with setter in between (observed property is not shadowing)'] = function testObserversSwitchedOnAndOffWithSetterInBetweenObservedPropertyIsNotShadowing(assert) {
      function Beer() {}

      var beer = new Beer();
      (0, _metal.set)(beer, 'type', 'ale');
      assert.deepEqual(Object.keys(beer), ['type'], 'only set');
      var otherBeer = new Beer();
      (0, _metal.addObserver)(otherBeer, 'type', K);
      (0, _metal.set)(otherBeer, 'type', 'ale');
      assert.deepEqual(Object.keys(otherBeer), ['type'], 'addObserver -> set');
      var yetAnotherBeer = new Beer();
      (0, _metal.addObserver)(yetAnotherBeer, 'type', K);
      (0, _metal.set)(yetAnotherBeer, 'type', 'ale');
      (0, _metal.addObserver)(beer, 'type', K);
      (0, _metal.removeObserver)(beer, 'type', K);
      assert.deepEqual(Object.keys(yetAnotherBeer), ['type'], 'addObserver -> set -> removeObserver');
      var itsMyLastBeer = new Beer();
      (0, _metal.set)(itsMyLastBeer, 'type', 'ale');
      (0, _metal.addObserver)(beer, 'type', K);
      (0, _metal.removeObserver)(beer, 'type', K);
      assert.deepEqual(Object.keys(itsMyLastBeer), ['type'], 'set -> removeObserver');
    };

    _proto6['@test observers switched on and off with setter in between (observed property is shadowing one on the prototype)'] = function testObserversSwitchedOnAndOffWithSetterInBetweenObservedPropertyIsShadowingOneOnThePrototype(assert) {
      function Beer() {}

      Beer.prototype.type = 'ipa';
      var beer = new Beer();
      (0, _metal.set)(beer, 'type', 'ale');
      assert.deepEqual(Object.keys(beer), ['type'], 'after set');
      var otherBeer = new Beer();
      (0, _metal.addObserver)(otherBeer, 'type', K);
      (0, _metal.set)(otherBeer, 'type', 'ale');
      assert.deepEqual(Object.keys(otherBeer), ['type'], 'addObserver -> set');
      var yetAnotherBeer = new Beer();
      (0, _metal.addObserver)(yetAnotherBeer, 'type', K);
      (0, _metal.set)(yetAnotherBeer, 'type', 'ale');
      (0, _metal.addObserver)(beer, 'type', K);
      (0, _metal.removeObserver)(beer, 'type', K);
      assert.deepEqual(Object.keys(yetAnotherBeer), ['type'], 'addObserver -> set -> removeObserver');
      var itsMyLastBeer = new Beer();
      (0, _metal.set)(itsMyLastBeer, 'type', 'ale');
      (0, _metal.addObserver)(beer, 'type', K);
      (0, _metal.removeObserver)(beer, 'type', K);
      assert.deepEqual(Object.keys(itsMyLastBeer), ['type'], 'set -> removeObserver');
    };

    return _class6;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/performance_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  /*
    This test file is designed to capture performance regressions related to
    deferred computation. Things like run loops, computed properties, and bindings
    should run the minimum amount of times to achieve best performance, so any
    bugs that cause them to get evaluated more than necessary should be put here.
  */
  (0, _internalTestHelpers.moduleFor)('Computed Properties - Number of times evaluated',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test computed properties that depend on multiple properties should run only once per run loop'] =
    /*#__PURE__*/
    function () {
      var _testComputedPropertiesThatDependOnMultiplePropertiesShouldRunOnlyOncePerRunLoop = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var obj, cpCount, obsCount;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              obj = {
                a: 'a',
                b: 'b',
                c: 'c'
              };
              cpCount = 0;
              obsCount = 0;
              (0, _metal.defineProperty)(obj, 'abc', (0, _metal.computed)('a', 'b', 'c', function (key) {
                cpCount++;
                return 'computed ' + key;
              }));
              (0, _metal.get)(obj, 'abc');
              cpCount = 0;
              (0, _metal.addObserver)(obj, 'abc', function () {
                obsCount++;
              });
              (0, _metal.beginPropertyChanges)();
              (0, _metal.set)(obj, 'a', 'aa');
              (0, _metal.set)(obj, 'b', 'bb');
              (0, _metal.set)(obj, 'c', 'cc');
              (0, _metal.endPropertyChanges)();
              (0, _metal.get)(obj, 'abc');
              _context.next = 15;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 15:
              assert.equal(cpCount, 1, 'The computed property is only invoked once');
              assert.equal(obsCount, 1, 'The observer is only invoked once');

            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function testComputedPropertiesThatDependOnMultiplePropertiesShouldRunOnlyOncePerRunLoop(_x) {
        return _testComputedPropertiesThatDependOnMultiplePropertiesShouldRunOnlyOncePerRunLoop.apply(this, arguments);
      }

      return testComputedPropertiesThatDependOnMultiplePropertiesShouldRunOnlyOncePerRunLoop;
    }();

    _proto['@test computed properties are not executed if they are the last segment of an observer chain pain'] = function testComputedPropertiesAreNotExecutedIfTheyAreTheLastSegmentOfAnObserverChainPain(assert) {
      var foo = {
        bar: {
          baz: {}
        }
      };
      var count = 0;
      (0, _metal.defineProperty)(foo.bar.baz, 'bam', (0, _metal.computed)(function () {
        count++;
      }));
      (0, _metal.addObserver)(foo, 'bar.baz.bam', function () {});
      (0, _metal.notifyPropertyChange)((0, _metal.get)(foo, 'bar.baz'), 'bam');
      assert.equal(count, 0, 'should not have recomputed property');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/properties_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('defineProperty',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test toString'] = function testToString(assert) {
      var obj = {};
      (0, _metal.defineProperty)(obj, 'toString', undefined, function () {
        return 'FOO';
      });
      assert.equal(obj.toString(), 'FOO', 'should replace toString');
    };

    _proto['@test for data properties, didDefineProperty hook should be called if implemented'] = function testForDataPropertiesDidDefinePropertyHookShouldBeCalledIfImplemented(assert) {
      assert.expect(2);
      var obj = {
        didDefineProperty: function (obj, keyName, value) {
          assert.equal(keyName, 'foo', 'key name should be foo');
          assert.equal(value, 'bar', 'value should be bar');
        }
      };
      (0, _metal.defineProperty)(obj, 'foo', undefined, 'bar');
    };

    _proto['@test for computed properties, didDefineProperty hook should be called if implemented'] = function testForComputedPropertiesDidDefinePropertyHookShouldBeCalledIfImplemented(assert) {
      assert.expect(2);
      var computedProperty = (0, _metal.computed)(function () {
        return this;
      });
      var obj = {
        didDefineProperty: function (obj, keyName, value) {
          assert.equal(keyName, 'foo', 'key name should be foo');
          assert.strictEqual(value, computedProperty, 'value should be passed as computed property');
        }
      };
      (0, _metal.defineProperty)(obj, 'foo', computedProperty);
    };

    _proto['@test for descriptor properties, didDefineProperty hook should be called if implemented'] = function testForDescriptorPropertiesDidDefinePropertyHookShouldBeCalledIfImplemented(assert) {
      assert.expect(2);
      var descriptor = {
        writable: true,
        configurable: false,
        enumerable: true,
        value: 42
      };
      var obj = {
        didDefineProperty: function (obj, keyName, value) {
          assert.equal(keyName, 'answer', 'key name should be answer');
          assert.strictEqual(value, descriptor, 'value should be passed as descriptor');
        }
      };
      (0, _metal.defineProperty)(obj, 'answer', descriptor);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Ember.deprecateProperty',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test enables access to deprecated property and returns the value of the new property'] = function testEnablesAccessToDeprecatedPropertyAndReturnsTheValueOfTheNewProperty(assert) {
      assert.expect(3);
      var obj = {
        foo: 'bar'
      };
      (0, _metal.deprecateProperty)(obj, 'baz', 'foo', {
        id: 'baz-deprecation',
        until: 'some.version'
      });
      expectDeprecation();
      assert.equal(obj.baz, obj.foo, 'baz and foo are equal');
      obj.foo = 'blammo';
      assert.equal(obj.baz, obj.foo, 'baz and foo are equal');
    };

    _proto2['@test deprecatedKey is not enumerable'] = function testDeprecatedKeyIsNotEnumerable(assert) {
      assert.expect(2);
      var obj = {
        foo: 'bar',
        blammo: 'whammy'
      };
      (0, _metal.deprecateProperty)(obj, 'baz', 'foo', {
        id: 'baz-deprecation',
        until: 'some.version'
      });

      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          assert.notEqual(prop, 'baz');
        }
      }
    };

    _proto2['@test enables setter to deprecated property and updates the value of the new property'] = function testEnablesSetterToDeprecatedPropertyAndUpdatesTheValueOfTheNewProperty(assert) {
      assert.expect(3);
      var obj = {
        foo: 'bar'
      };
      (0, _metal.deprecateProperty)(obj, 'baz', 'foo', {
        id: 'baz-deprecation',
        until: 'some.version'
      });
      expectDeprecation();
      obj.baz = 'bloop';
      assert.equal(obj.foo, 'bloop', 'updating baz updates foo');
      assert.equal(obj.baz, obj.foo, 'baz and foo are equal');
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/property_did_change_hook", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('PROPERTY_DID_CHANGE',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test alias and cp'] = function testAliasAndCp(assert) {
      var _obj;

      var counts = {};
      var obj = (_obj = {
        child: {}
      }, _obj[_metal.PROPERTY_DID_CHANGE] = function (keyName) {
        counts[keyName] = (counts[keyName] || 0) + 1;
      }, _obj);
      (0, _metal.defineProperty)(obj, 'cost', (0, _metal.alias)('child.cost'));
      (0, _metal.defineProperty)(obj, 'tax', (0, _metal.alias)('child.tax'));
      (0, _metal.defineProperty)(obj, 'total', (0, _metal.computed)('cost', 'tax', {
        get: function () {
          return (0, _metal.get)(this, 'cost') + (0, _metal.get)(this, 'tax');
        }
      }));
      assert.ok(!(0, _metal.isWatching)(obj, 'child.cost'), 'precond alias target `child.cost` is not watched');
      assert.equal((0, _metal.get)(obj, 'cost'), undefined); // this is how PROPERTY_DID_CHANGE will get notified

      assert.ok((0, _metal.isWatching)(obj, 'child.cost'), 'alias target `child.cost` is watched after consumption');
      assert.ok(!(0, _metal.isWatching)(obj, 'child.tax'), 'precond alias target `child.tax` is not watched');
      assert.equal((0, _metal.get)(obj, 'tax'), undefined); // this is how PROPERTY_DID_CHANGE will get notified

      assert.ok((0, _metal.isWatching)(obj, 'child.tax'), 'alias target `child.cost` is watched after consumption'); // increments the watching count on the alias itself to 1

      assert.ok(isNaN((0, _metal.get)(obj, 'total')), 'total is initialized'); // decrements the watching count on the alias itself to 0

      (0, _metal.set)(obj, 'child', {
        cost: 399.0,
        tax: 32.93
      }); // this should have called PROPERTY_DID_CHANGE for all of them

      assert.equal(counts['cost'], 1, 'PROPERTY_DID_CHANGE called with cost');
      assert.equal(counts['tax'], 1, 'PROPERTY_DID_CHANGE called with tax');
      assert.equal(counts['total'], 1, 'PROPERTY_DID_CHANGE called with total'); // we should still have a dependency installed

      assert.ok((0, _metal.isWatching)(obj, 'child.cost'), 'watching child.cost');
      assert.ok((0, _metal.isWatching)(obj, 'child.tax'), 'watching child.tax');
      (0, _metal.set)(obj, 'child', {
        cost: 100.0,
        tax: 10.0
      });
      assert.equal(counts['cost'], 2, 'PROPERTY_DID_CHANGE called with cost');
      assert.equal(counts['tax'], 2, 'PROPERTY_DID_CHANGE called with tax');
      assert.equal(counts['total'], 1, 'PROPERTY_DID_CHANGE called with total');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/property_events_test", ["ember-babel", "@ember/-internals/meta", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _meta, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('notifyPropertyChange',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test notifies property changes on instances'] = function testNotifiesPropertyChangesOnInstances(assert) {
      var Foo =
      /*#__PURE__*/
      function () {
        function Foo() {}

        var _proto2 = Foo.prototype;

        _proto2[_metal.PROPERTY_DID_CHANGE] = function (prop) {
          assert.equal(prop, 'bar', 'property change notified');
        };

        return Foo;
      }();

      var foo = new Foo();
      (0, _metal.notifyPropertyChange)(foo, 'bar');
    };

    _proto['@test notifies property changes on instances with meta'] = function testNotifiesPropertyChangesOnInstancesWithMeta(assert) {
      var Foo =
      /*#__PURE__*/
      function () {
        function Foo() {}

        var _proto3 = Foo.prototype;

        _proto3[_metal.PROPERTY_DID_CHANGE] = function (prop) {
          assert.equal(prop, 'bar', 'property change notified');
        };

        return Foo;
      }();

      var foo = new Foo();
      (0, _meta.meta)(foo); // setup meta

      (0, _metal.notifyPropertyChange)(foo, 'bar');
    };

    _proto['@test does not notify on class prototypes with meta'] = function testDoesNotNotifyOnClassPrototypesWithMeta(assert) {
      assert.expect(0);

      var Foo =
      /*#__PURE__*/
      function () {
        function Foo() {}

        var _proto4 = Foo.prototype;

        _proto4[_metal.PROPERTY_DID_CHANGE] = function (prop) {
          assert.equal(prop, 'bar', 'property change notified');
        };

        return Foo;
      }();

      var foo = new Foo();
      (0, _meta.meta)(foo.constructor.prototype); // setup meta for prototype

      (0, _metal.notifyPropertyChange)(foo.constructor.prototype, 'bar');
    };

    _proto['@test does not notify on non-class prototypes with meta'] = function testDoesNotNotifyOnNonClassPrototypesWithMeta(assert) {
      var _foo;

      assert.expect(0);
      var foo = (_foo = {}, _foo[_metal.PROPERTY_DID_CHANGE] = function (prop) {
        assert.equal(prop, 'baz', 'property change notified');
      }, _foo);
      var bar = Object.create(foo);
      (0, _meta.meta)(foo); // setup meta for prototype

      (0, _meta.meta)(bar); // setup meta for instance, switch prototype

      (0, _metal.notifyPropertyChange)(foo, 'baz');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/set_properties_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('setProperties',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test supports setting multiple attributes at once'] = function testSupportsSettingMultipleAttributesAtOnce(assert) {
      assert.deepEqual((0, _metal.setProperties)(null, null), null, 'noop for null properties and null object');
      assert.deepEqual((0, _metal.setProperties)(undefined, undefined), undefined, 'noop for undefined properties and undefined object');
      assert.deepEqual((0, _metal.setProperties)({}), undefined, 'noop for no properties');
      assert.deepEqual((0, _metal.setProperties)({}, undefined), undefined, 'noop for undefined');
      assert.deepEqual((0, _metal.setProperties)({}, null), null, 'noop for null');
      assert.deepEqual((0, _metal.setProperties)({}, NaN), NaN, 'noop for NaN');
      assert.deepEqual((0, _metal.setProperties)({}, {}), {}, 'meh');
      var props = (0, _metal.setProperties)({}, {
        foo: undefined
      });
      assert.deepEqual(props, {
        foo: undefined
      }, 'Setting undefined value');
      assert.ok('foo' in props, 'Setting undefined value');
      assert.deepEqual(Object.keys(props), ['foo'], 'Setting undefined value');
      assert.deepEqual((0, _metal.setProperties)({}, {
        foo: 1
      }), {
        foo: 1
      }, 'Set a single property');
      assert.deepEqual((0, _metal.setProperties)({}, {
        foo: 1,
        bar: 1
      }), {
        foo: 1,
        bar: 1
      }, 'Set multiple properties');
      assert.deepEqual((0, _metal.setProperties)({
        foo: 2,
        baz: 2
      }, {
        foo: 1
      }), {
        foo: 1
      }, 'Set one of multiple properties');
      assert.deepEqual((0, _metal.setProperties)({
        foo: 2,
        baz: 2
      }, {
        bar: 2
      }), {
        bar: 2
      }, 'Set an additional, previously unset property');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/metal/tests/tracked/classic_classes_test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _metal) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }

    return desc;
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');
  }

  if (false
  /* EMBER_METAL_TRACKED_PROPERTIES */
  ) {
      (0, _internalTestHelpers.moduleFor)('@tracked decorator - classic classes',
      /*#__PURE__*/
      function (_AbstractTestCase) {
        (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase);

        function _class2() {
          return _AbstractTestCase.apply(this, arguments) || this;
        }

        var _proto = _class2.prototype;

        _proto["@test validators for tracked getters with dependencies should invalidate when the dependencies invalidate"] = function (assert) {
          var obj = {};
          (0, _metal.defineProperty)(obj, 'first', (0, _metal.tracked)());
          (0, _metal.defineProperty)(obj, 'last', (0, _metal.tracked)());
          (0, _metal.defineProperty)(obj, 'full', (0, _metal.nativeDescDecorator)({
            get: function () {
              return this.first + " " + this.last;
            },
            set: function (value) {
              var _value$split = value.split(' '),
                  first = _value$split[0],
                  last = _value$split[1];

              this.first = first;
              this.last = last;
            }
          }));
          obj.first = 'Tom';
          obj.last = 'Dale';
          var tag = (0, _metal.track)(function () {
            return obj.full;
          });
          var snapshot = tag.value();
          assert.equal(obj.full, 'Tom Dale', 'The full name starts correct');
          assert.equal(tag.validate(snapshot), true);
          snapshot = tag.value();
          assert.equal(tag.validate(snapshot), true);
          obj.full = 'Melanie Sumner';
          assert.equal(tag.validate(snapshot), false);
          assert.equal(obj.full, 'Melanie Sumner');
          assert.equal(obj.first, 'Melanie');
          assert.equal(obj.last, 'Sumner');
          snapshot = tag.value();
          assert.equal(tag.validate(snapshot), true);
        };

        _proto["@test can pass a default value to the tracked decorator"] = function (assert) {
          var Tracked =
          /*#__PURE__*/
          function () {
            function Tracked() {}

            (0, _emberBabel.createClass)(Tracked, [{
              key: "full",
              get: function () {
                return this.first + " " + this.last;
              }
            }]);
            return Tracked;
          }();

          (0, _metal.defineProperty)(Tracked.prototype, 'first', (0, _metal.tracked)({
            value: 'Tom'
          }));
          (0, _metal.defineProperty)(Tracked.prototype, 'last', (0, _metal.tracked)({
            value: 'Dale'
          }));
          var obj = new Tracked();
          assert.equal(obj.full, 'Tom Dale', 'Default values are correctly assign');
        };

        _proto["@test errors if used directly on a classic class"] = function () {
          expectAssertion(function () {
            var Tracked =
            /*#__PURE__*/
            function () {
              function Tracked() {}

              (0, _emberBabel.createClass)(Tracked, [{
                key: "full",
                get: function () {
                  return this.first + " " + this.last;
                }
              }]);
              return Tracked;
            }();

            (0, _metal.defineProperty)(Tracked.prototype, 'first', _metal.tracked);
          }, "@tracked can only be used directly as a native decorator. If you're using tracked in classic classes, add parenthesis to call it like a function: tracked()");
        };

        _proto["@test errors on any keys besides 'value', 'get', or 'set' being passed"] = function () {
          expectAssertion(function () {
            var Tracked =
            /*#__PURE__*/
            function () {
              function Tracked() {}

              (0, _emberBabel.createClass)(Tracked, [{
                key: "full",
                get: function () {
                  return this.first + " " + this.last;
                }
              }]);
              return Tracked;
            }();

            (0, _metal.defineProperty)(Tracked.prototype, 'first', (0, _metal.tracked)({
              foo: function () {}
            }));
          }, "The options object passed to tracked() may only contain a 'value' or 'initializer' property, not both. Received: [foo]");
        };

        _proto["@test errors if 'value' and 'get'/'set' are passed together"] = function () {
          expectAssertion(function () {
            var Tracked =
            /*#__PURE__*/
            function () {
              function Tracked() {}

              (0, _emberBabel.createClass)(Tracked, [{
                key: "full",
                get: function () {
                  return this.first + " " + this.last;
                }
              }]);
              return Tracked;
            }();

            (0, _metal.defineProperty)(Tracked.prototype, 'first', (0, _metal.tracked)({
              value: 123,
              initializer: function () {
                return 123;
              }
            }));
          }, "The options object passed to tracked() may only contain a 'value' or 'initializer' property, not both. Received: [value,initializer]");
        };

        _proto["@test errors on anything besides an options object being passed"] = function () {
          expectAssertion(function () {
            var Tracked =
            /*#__PURE__*/
            function () {
              function Tracked() {}

              (0, _emberBabel.createClass)(Tracked, [{
                key: "full",
                get: function () {
                  return this.first + " " + this.last;
                }
              }]);
              return Tracked;
            }();

            (0, _metal.defineProperty)(Tracked.prototype, 'first', (0, _metal.tracked)(null));
          }, "tracked() may only receive an options object containing 'value' or 'initializer', received null");
        };

        return _class2;
      }(_internalTestHelpers.AbstractTestCase));

      if (true
      /* EMBER_NATIVE_DECORATOR_SUPPORT */
      ) {
          (0, _internalTestHelpers.moduleFor)('@tracked decorator - native decorator behavior',
          /*#__PURE__*/
          function (_AbstractTestCase2) {
            (0, _emberBabel.inheritsLoose)(_class4, _AbstractTestCase2);

            function _class4() {
              return _AbstractTestCase2.apply(this, arguments) || this;
            }

            var _proto2 = _class4.prototype;

            _proto2["@test errors if options are passed to native decorator"] = function () {
              expectAssertion(function () {
                var _dec, _class, _descriptor, _temp;

                var Tracked = (_dec = (0, _metal.tracked)(), (_class = (_temp =
                /*#__PURE__*/
                function () {
                  function Tracked() {
                    _initializerDefineProperty(this, "first", _descriptor, this);
                  }

                  (0, _emberBabel.createClass)(Tracked, [{
                    key: "full",
                    get: function () {
                      return this.first + " " + this.last;
                    }
                  }]);
                  return Tracked;
                }(), _temp), _descriptor = _applyDecoratedDescriptor(_class.prototype, "first", [_dec], {
                  configurable: true,
                  enumerable: true,
                  writable: true,
                  initializer: null
                }), _class));
                new Tracked();
              }, "You attempted to set a default value for first with the @tracked({ value: 'default' }) syntax. You can only use this syntax with classic classes. For native classes, you can use class initializers: @tracked field = 'default';");
            };

            _proto2["@test errors if options are passed to native decorator (GH#17764)"] = function (assert) {
              var _class3, _descriptor2, _temp2;

              var Tracked = (_class3 = (_temp2 = function Tracked() {
                _initializerDefineProperty(this, "value", _descriptor2, this);
              }, _temp2), _descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "value", [_metal.tracked], {
                configurable: true,
                enumerable: true,
                writable: true,
                initializer: null
              }), _class3);
              var obj = new Tracked();
              assert.strictEqual(obj.value, undefined, 'uninitilized value defaults to undefined');
            };

            return _class4;
          }(_internalTestHelpers.AbstractTestCase));
        } else {
        (0, _internalTestHelpers.moduleFor)('@tracked decorator - native decorator behavior',
        /*#__PURE__*/
        function (_AbstractTestCase3) {
          (0, _emberBabel.inheritsLoose)(_class6, _AbstractTestCase3);

          function _class6() {
            return _AbstractTestCase3.apply(this, arguments) || this;
          }

          var _proto3 = _class6.prototype;

          _proto3["@test errors if used as a native decorator"] = function () {
            expectAssertion(function () {
              var _class5, _descriptor3, _temp3;

              var Tracked = (_class5 = (_temp3 = function Tracked() {
                _initializerDefineProperty(this, "first", _descriptor3, this);
              }, _temp3), _descriptor3 = _applyDecoratedDescriptor(_class5.prototype, "first", [_metal.tracked], {
                configurable: true,
                enumerable: true,
                writable: true,
                initializer: null
              }), _class5);
              new Tracked();
            }, 'Native decorators are not enabled without the EMBER_NATIVE_DECORATOR_SUPPORT flag');
          };

          return _class6;
        }(_internalTestHelpers.AbstractTestCase));
      }
    }
});
enifed("@ember/-internals/metal/tests/tracked/get_test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _metal) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }

    return desc;
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');
  }

  if (false
  /* EMBER_METAL_TRACKED_PROPERTIES */
  && true
  /* EMBER_NATIVE_DECORATOR_SUPPORT */
  ) {
      var createObj = function () {
        var _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _temp;

        var Obj = (_class = (_temp = function Obj() {
          _initializerDefineProperty(this, "string", _descriptor, this);

          _initializerDefineProperty(this, "number", _descriptor2, this);

          _initializerDefineProperty(this, "boolTrue", _descriptor3, this);

          _initializerDefineProperty(this, "boolFalse", _descriptor4, this);

          _initializerDefineProperty(this, "nullValue", _descriptor5, this);
        }, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, "string", [_metal.tracked], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return 'string';
          }
        }), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "number", [_metal.tracked], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return 23;
          }
        }), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, "boolTrue", [_metal.tracked], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return true;
          }
        }), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, "boolFalse", [_metal.tracked], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return false;
          }
        }), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, "nullValue", [_metal.tracked], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return null;
          }
        })), _class);
        return new Obj();
      };

      (0, _internalTestHelpers.moduleFor)('@tracked decorator: get',
      /*#__PURE__*/
      function (_AbstractTestCase) {
        (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase);

        function _class2() {
          return _AbstractTestCase.apply(this, arguments) || this;
        }

        var _proto = _class2.prototype;

        _proto['@test should get arbitrary properties on an object'] = function testShouldGetArbitraryPropertiesOnAnObject() {
          var obj = createObj();

          for (var key in obj) {
            this.assert.equal((0, _metal.get)(obj, key), obj[key], key);
          }
        };

        _proto['@test should get a @tracked path'] = function testShouldGetATrackedPath() {
          var _class3, _descriptor6, _temp2, _class5, _descriptor7, _temp3, _class7, _descriptor8, _temp4;

          var Key = (_class3 = (_temp2 = function Key() {
            _initializerDefineProperty(this, "value", _descriptor6, this);
          }, _temp2), _descriptor6 = _applyDecoratedDescriptor(_class3.prototype, "value", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: function () {
              return 'value';
            }
          }), _class3);
          var Path = (_class5 = (_temp3 = function Path() {
            _initializerDefineProperty(this, "key", _descriptor7, this);
          }, _temp3), _descriptor7 = _applyDecoratedDescriptor(_class5.prototype, "key", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: function () {
              return new Key();
            }
          }), _class5);
          var Obj = (_class7 = (_temp4 = function Obj() {
            _initializerDefineProperty(this, "path", _descriptor8, this);
          }, _temp4), _descriptor8 = _applyDecoratedDescriptor(_class7.prototype, "path", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: function () {
              return new Path();
            }
          }), _class7);
          var obj = new Obj();
          this.assert.equal((0, _metal.get)(obj, 'path.key.value'), 'value');
        };

        _proto['@test should get arbitrary properties on an object'] = function testShouldGetArbitraryPropertiesOnAnObject() {
          var _class9, _descriptor9, _temp5;

          var obj = createObj();

          for (var key in obj) {
            this.assert.equal((0, _metal.getWithDefault)(obj, key, 'fail'), obj[key], key);
          }

          var Obj = (_class9 = (_temp5 = function Obj() {
            _initializerDefineProperty(this, "undef", _descriptor9, this);
          }, _temp5), _descriptor9 = _applyDecoratedDescriptor(_class9.prototype, "undef", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: function () {
              return undefined;
            }
          }), _class9);
          var obj2 = new Obj();
          this.assert.equal((0, _metal.getWithDefault)(obj2, 'undef', 'default'), 'default', 'explicit undefined retrieves the default');
          this.assert.equal((0, _metal.getWithDefault)(obj2, 'not-present', 'default'), 'default', 'non-present key retrieves the default');
        };

        return _class2;
      }(_internalTestHelpers.AbstractTestCase));
    }
});
enifed("@ember/-internals/metal/tests/tracked/set_test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _metal) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }

    return desc;
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');
  }

  if (false
  /* EMBER_METAL_TRACKED_PROPERTIES */
  && true
  /* EMBER_NATIVE_DECORATOR_SUPPORT */
  ) {
      var createObj = function () {
        var _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _temp;

        var Obj = (_class = (_temp = function Obj() {
          _initializerDefineProperty(this, "string", _descriptor, this);

          _initializerDefineProperty(this, "number", _descriptor2, this);

          _initializerDefineProperty(this, "boolTrue", _descriptor3, this);

          _initializerDefineProperty(this, "boolFalse", _descriptor4, this);

          _initializerDefineProperty(this, "nullValue", _descriptor5, this);

          _initializerDefineProperty(this, "undefinedValue", _descriptor6, this);
        }, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, "string", [_metal.tracked], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return 'string';
          }
        }), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, "number", [_metal.tracked], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return 23;
          }
        }), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, "boolTrue", [_metal.tracked], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return true;
          }
        }), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, "boolFalse", [_metal.tracked], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return false;
          }
        }), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, "nullValue", [_metal.tracked], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return null;
          }
        }), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, "undefinedValue", [_metal.tracked], {
          configurable: true,
          enumerable: true,
          writable: true,
          initializer: function () {
            return undefined;
          }
        })), _class);
        return new Obj();
      };

      (0, _internalTestHelpers.moduleFor)('@tracked set',
      /*#__PURE__*/
      function (_AbstractTestCase) {
        (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase);

        function _class2() {
          return _AbstractTestCase.apply(this, arguments) || this;
        }

        var _proto = _class2.prototype;

        _proto['@test should set arbitrary properties on an object'] = function testShouldSetArbitraryPropertiesOnAnObject(assert) {
          var _class3, _descriptor7, _temp2;

          var obj = createObj();
          var Obj = (_class3 = (_temp2 = function Obj() {
            _initializerDefineProperty(this, "undefinedValue", _descriptor7, this);
          }, _temp2), _descriptor7 = _applyDecoratedDescriptor(_class3.prototype, "undefinedValue", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: function () {
              return 'emberjs';
            }
          }), _class3);
          var newObj = new Obj();

          for (var key in obj) {
            assert.equal((0, _metal.set)(newObj, key, obj[key]), obj[key], 'should return value');
            assert.equal((0, _metal.get)(newObj, key), obj[key], 'should set value');
          }
        };

        return _class2;
      }(_internalTestHelpers.AbstractTestCase));
    }
});
enifed("@ember/-internals/metal/tests/tracked/validation_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/utils", "internal-test-helpers"], function (_emberBabel, _metal, _utils, _internalTestHelpers) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }

    return desc;
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');
  }

  if (false
  /* EMBER_METAL_TRACKED_PROPERTIES */
  && true
  /* EMBER_NATIVE_DECORATOR_SUPPORT */
  ) {
      (0, _internalTestHelpers.moduleFor)('@tracked get validation',
      /*#__PURE__*/
      function (_AbstractTestCase) {
        (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase);

        function _class2() {
          return _AbstractTestCase.apply(this, arguments) || this;
        }

        var _proto = _class2.prototype;

        _proto["@test autotracking should work with tracked fields"] = function (assert) {
          var _class, _descriptor, _temp;

          var Tracked = (_class = (_temp = function Tracked(first) {
            _initializerDefineProperty(this, "first", _descriptor, this);

            this.first = first;
          }, _temp), _descriptor = _applyDecoratedDescriptor(_class.prototype, "first", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: function () {
              return undefined;
            }
          }), _class);
          var obj = new Tracked('Tom', 'Dale');
          var tag = (0, _metal.track)(function () {
            return obj.first;
          });
          var snapshot = tag.value();
          assert.equal(obj.first, 'Tom', 'The full name starts correct');
          assert.equal(tag.validate(snapshot), true);
          snapshot = tag.value();
          assert.equal(tag.validate(snapshot), true);
          obj.first = 'Thomas';
          assert.equal(tag.validate(snapshot), false);
          assert.equal(obj.first, 'Thomas');
          snapshot = tag.value();
          assert.equal(tag.validate(snapshot), true);
        };

        _proto["@test autotracking should work with native getters"] = function (assert) {
          var _class3, _descriptor2, _descriptor3, _temp2;

          var Tracked = (_class3 = (_temp2 =
          /*#__PURE__*/
          function () {
            function Tracked(first, last) {
              _initializerDefineProperty(this, "first", _descriptor2, this);

              _initializerDefineProperty(this, "last", _descriptor3, this);

              this.first = first;
              this.last = last;
            }

            (0, _emberBabel.createClass)(Tracked, [{
              key: "full",
              get: function () {
                return this.first + " " + this.last;
              }
            }]);
            return Tracked;
          }(), _temp2), (_descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "first", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: function () {
              return undefined;
            }
          }), _descriptor3 = _applyDecoratedDescriptor(_class3.prototype, "last", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: function () {
              return undefined;
            }
          })), _class3);
          var obj = new Tracked('Tom', 'Dale');
          var tag = (0, _metal.track)(function () {
            return obj.full;
          });
          var snapshot = tag.value();
          assert.equal(obj.full, 'Tom Dale', 'The full name starts correct');
          assert.equal(tag.validate(snapshot), true);
          snapshot = tag.value();
          assert.equal(tag.validate(snapshot), true);
          obj.first = 'Thomas';
          assert.equal(tag.validate(snapshot), false);
          assert.equal(obj.full, 'Thomas Dale');
          snapshot = tag.value();
          assert.equal(tag.validate(snapshot), true);
        };

        _proto["@test autotracking should work with native setters"] = function (assert) {
          var _class5, _descriptor4, _descriptor5, _temp3;

          var Tracked = (_class5 = (_temp3 =
          /*#__PURE__*/
          function () {
            function Tracked(first, last) {
              _initializerDefineProperty(this, "first", _descriptor4, this);

              _initializerDefineProperty(this, "last", _descriptor5, this);

              this.first = first;
              this.last = last;
            }

            (0, _emberBabel.createClass)(Tracked, [{
              key: "full",
              get: function () {
                return this.first + " " + this.last;
              },
              set: function (value) {
                var _value$split = value.split(' '),
                    first = _value$split[0],
                    last = _value$split[1];

                this.first = first;
                this.last = last;
              }
            }]);
            return Tracked;
          }(), _temp3), (_descriptor4 = _applyDecoratedDescriptor(_class5.prototype, "first", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: function () {
              return undefined;
            }
          }), _descriptor5 = _applyDecoratedDescriptor(_class5.prototype, "last", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: function () {
              return undefined;
            }
          })), _class5);
          var obj = new Tracked('Tom', 'Dale');
          var tag = (0, _metal.track)(function () {
            return obj.full;
          });
          var snapshot = tag.value();
          assert.equal(obj.full, 'Tom Dale', 'The full name starts correct');
          assert.equal(tag.validate(snapshot), true);
          snapshot = tag.value();
          assert.equal(tag.validate(snapshot), true);
          obj.full = 'Melanie Sumner';
          assert.equal(tag.validate(snapshot), false);
          assert.equal(obj.full, 'Melanie Sumner');
          assert.equal(obj.first, 'Melanie');
          assert.equal(obj.last, 'Sumner');
          snapshot = tag.value();
          assert.equal(tag.validate(snapshot), true);
        };

        _proto["@test interaction with Ember object model (tracked property depending on Ember property)"] = function (assert) {
          var Tracked =
          /*#__PURE__*/
          function () {
            function Tracked(name) {
              this.name = name;
            }

            (0, _emberBabel.createClass)(Tracked, [{
              key: "full",
              get: function () {
                return (0, _metal.get)(this, 'name.first') + " " + (0, _metal.get)(this, 'name.last');
              }
            }]);
            return Tracked;
          }();

          var tom = {
            first: 'Tom',
            last: 'Dale'
          };
          var obj = new Tracked(tom);
          var tag = (0, _metal.track)(function () {
            return obj.full;
          });
          var snapshot = tag.value();
          assert.equal(obj.full, 'Tom Dale');
          assert.equal(tag.validate(snapshot), true);
          snapshot = tag.value();
          assert.equal(tag.validate(snapshot), true);
          (0, _metal.set)(tom, 'first', 'Thomas');
          assert.equal(tag.validate(snapshot), false, 'invalid after setting with Ember set');
          assert.equal(obj.full, 'Thomas Dale');
          snapshot = tag.value();
          assert.equal(tag.validate(snapshot), true);
          (0, _metal.set)(obj, 'name', {
            first: 'Ricardo',
            last: 'Mendes'
          });
          assert.equal(tag.validate(snapshot), false, 'invalid after setting with Ember set');
          assert.equal(obj.full, 'Ricardo Mendes');
          snapshot = tag.value();
          assert.equal(tag.validate(snapshot), true);
        };

        _proto["@test interaction with Ember object model (Ember computed property depending on tracked property)"] = function (assert) {
          var _class7, _descriptor6, _descriptor7, _temp4;

          var EmberObject = function EmberObject(name) {
            this.name = name;
          };

          (0, _metal.defineProperty)(EmberObject.prototype, 'full', (0, _metal.computed)('name.first', 'name.last', function () {
            var name = (0, _metal.get)(this, 'name');
            return name.first + " " + name.last;
          }));
          var Name = (_class7 = (_temp4 = function Name(first, last) {
            _initializerDefineProperty(this, "first", _descriptor6, this);

            _initializerDefineProperty(this, "last", _descriptor7, this);

            this.first = first;
            this.last = last;
          }, _temp4), (_descriptor6 = _applyDecoratedDescriptor(_class7.prototype, "first", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: null
          }), _descriptor7 = _applyDecoratedDescriptor(_class7.prototype, "last", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: null
          })), _class7);
          var tom = new Name('Tom', 'Dale');
          var obj = new EmberObject(tom);
          var tag = (0, _metal.tagForProperty)(obj, 'full');
          var snapshot = tag.value();
          var full = (0, _metal.get)(obj, 'full');
          assert.equal(full, 'Tom Dale');
          assert.equal(tag.validate(snapshot), true);
          snapshot = tag.value();
          assert.equal(tag.validate(snapshot), true);
          tom.first = 'Thomas';
          assert.equal(tag.validate(snapshot), false, 'invalid after setting with tracked properties');
          assert.equal((0, _metal.get)(obj, 'full'), 'Thomas Dale');
          snapshot = tag.value();
          assert.equal(tag.validate(snapshot), true);
        };

        _proto['@test interaction with the Ember object model (paths going through tracked properties)'] = function testInteractionWithTheEmberObjectModelPathsGoingThroughTrackedProperties(assert) {
          var _class9, _descriptor8, _temp5;

          var self;

          var EmberObject = function EmberObject(contact) {
            this.contact = void 0;
            this.contact = contact;
            self = this;
          };

          (0, _metal.defineProperty)(EmberObject.prototype, 'full', (0, _metal.computed)('contact.name.first', 'contact.name.last', function () {
            var contact = (0, _metal.get)(self, 'contact');
            return (0, _metal.get)(contact.name, 'first') + " " + (0, _metal.get)(contact.name, 'last');
          }));
          var Contact = (_class9 = (_temp5 = function Contact(name) {
            _initializerDefineProperty(this, "name", _descriptor8, this);

            this.name = name;
          }, _temp5), _descriptor8 = _applyDecoratedDescriptor(_class9.prototype, "name", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: function () {
              return undefined;
            }
          }), _class9);

          var EmberName = function EmberName(first, last) {
            this.first = void 0;
            this.last = void 0;
            this.first = first;
            this.last = last;
          };

          var tom = new EmberName('Tom', 'Dale');
          var contact = new Contact(tom);
          var obj = new EmberObject(contact);
          var tag = (0, _metal.tagForProperty)(obj, 'full');
          var snapshot = tag.value();
          var full = (0, _metal.get)(obj, 'full');
          assert.equal(full, 'Tom Dale');
          assert.equal(tag.validate(snapshot), true);
          snapshot = tag.value();
          assert.equal(tag.validate(snapshot), true);
          (0, _metal.set)(tom, 'first', 'Thomas');
          assert.equal(tag.validate(snapshot), false, 'invalid after setting with Ember.set');
          assert.equal((0, _metal.get)(obj, 'full'), 'Thomas Dale');
          snapshot = tag.value();
          tom = contact.name = new EmberName('T', 'Dale');
          assert.equal(tag.validate(snapshot), false, 'invalid after setting with Ember.set');
          assert.equal((0, _metal.get)(obj, 'full'), 'T Dale');
          snapshot = tag.value();
          (0, _metal.set)(tom, 'first', 'Tizzle');
          assert.equal(tag.validate(snapshot), false, 'invalid after setting with Ember.set');
          assert.equal((0, _metal.get)(obj, 'full'), 'Tizzle Dale');
        };

        _proto['@test interaction with arrays'] = function testInteractionWithArrays(assert) {
          var _class11, _descriptor9, _temp6;

          var EmberObject = (_class11 = (_temp6 = function EmberObject() {
            _initializerDefineProperty(this, "array", _descriptor9, this);
          }, _temp6), _descriptor9 = _applyDecoratedDescriptor(_class11.prototype, "array", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: function () {
              return [];
            }
          }), _class11);
          var obj = new EmberObject();
          var tag = (0, _metal.tagForProperty)(obj, 'array');
          var snapshot = tag.value();
          var array = (0, _metal.get)(obj, 'array');
          assert.deepEqual(array, []);
          assert.equal(tag.validate(snapshot), true);
          array.push(1);
          (0, _metal.notifyPropertyChange)(array, '[]');
          assert.equal(tag.validate(snapshot), false, 'invalid after pushing an object and notifying on the array');
        };

        _proto['@test interaction with ember arrays'] = function testInteractionWithEmberArrays(assert) {
          var _class13, _descriptor10, _temp7;

          var EmberObject = (_class13 = (_temp7 = function EmberObject() {
            _initializerDefineProperty(this, "emberArray", _descriptor10, this);
          }, _temp7), _descriptor10 = _applyDecoratedDescriptor(_class13.prototype, "emberArray", [_metal.tracked], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: function () {
              var _ref;

              return _ref = {}, _ref[_utils.EMBER_ARRAY] = true, _ref;
            }
          }), _class13);
          var obj = new EmberObject();
          var tag = (0, _metal.tagForProperty)(obj, 'emberArray');
          var snapshot = tag.value();
          var emberArray = (0, _metal.get)(obj, 'emberArray');
          assert.equal(tag.validate(snapshot), true);
          (0, _metal.notifyPropertyChange)(emberArray, '[]');
          assert.equal(tag.validate(snapshot), false, 'invalid after setting a property on the object');
        };

        return _class2;
      }(_internalTestHelpers.AbstractTestCase));
    }
});
enifed("@ember/-internals/metal/tests/watching/is_watching_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  function testObserver(assert, setup, teardown) {
    var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'key';
    var obj = {};
    assert.equal((0, _metal.isWatching)(obj, key), false, 'precond - isWatching is false by default');
    setup(obj, key, 'fn');
    assert.equal((0, _metal.isWatching)(obj, key), true, 'isWatching is true when observers are added');
    teardown(obj, key, 'fn');
    assert.equal((0, _metal.isWatching)(obj, key), false, 'isWatching is false after observers are removed');
  }

  if (!false
  /* EMBER_METAL_TRACKED_PROPERTIES */
  ) {
      (0, _internalTestHelpers.moduleFor)('isWatching',
      /*#__PURE__*/
      function (_AbstractTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

        function _class() {
          return _AbstractTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto['@test isWatching is true for regular local observers'] = function testIsWatchingIsTrueForRegularLocalObservers(assert) {
          testObserver(assert, function (obj, key, fn) {
            var _Mixin$create;

            _metal.Mixin.create((_Mixin$create = {}, _Mixin$create[fn] = (0, _metal.observer)(key, function () {}), _Mixin$create)).apply(obj);
          }, function (obj, key, fn) {
            return (0, _metal.removeObserver)(obj, key, obj, fn);
          });
        };

        _proto['@test isWatching is true for nonlocal observers'] = function testIsWatchingIsTrueForNonlocalObservers(assert) {
          testObserver(assert, function (obj, key, fn) {
            (0, _metal.addObserver)(obj, key, obj, fn);
          }, function (obj, key, fn) {
            return (0, _metal.removeObserver)(obj, key, obj, fn);
          });
        };

        _proto['@test isWatching is true for chained observers'] = function testIsWatchingIsTrueForChainedObservers(assert) {
          testObserver(assert, function (obj, key, fn) {
            (0, _metal.addObserver)(obj, key + '.bar', obj, fn);
          }, function (obj, key, fn) {
            (0, _metal.removeObserver)(obj, key + '.bar', obj, fn);
          });
        };

        _proto['@test isWatching is true for computed properties'] = function testIsWatchingIsTrueForComputedProperties(assert) {
          testObserver(assert, function (obj, key, fn) {
            (0, _metal.defineProperty)(obj, fn, (0, _metal.computed)(key, function () {}));
            (0, _metal.get)(obj, fn);
          }, function (obj, key, fn) {
            return (0, _metal.defineProperty)(obj, fn, null);
          });
        };

        _proto['@test isWatching is true for chained computed properties'] = function testIsWatchingIsTrueForChainedComputedProperties(assert) {
          testObserver(assert, function (obj, key, fn) {
            (0, _metal.defineProperty)(obj, fn, (0, _metal.computed)(key + '.bar', function () {}));
            (0, _metal.get)(obj, fn);
          }, function (obj, key, fn) {
            return (0, _metal.defineProperty)(obj, fn, null);
          });
        } // can't watch length on Array - it is special...
        // But you should be able to watch a length property of an object
        ;

        _proto["@test isWatching is true for 'length' property on object"] = function testIsWatchingIsTrueForLengthPropertyOnObject(assert) {
          testObserver(assert, function (obj, key, fn) {
            (0, _metal.defineProperty)(obj, 'length', null, '26.2 miles');
            (0, _metal.addObserver)(obj, 'length', obj, fn);
          }, function (obj, key, fn) {
            return (0, _metal.removeObserver)(obj, 'length', obj, fn);
          }, 'length');
        };

        return _class;
      }(_internalTestHelpers.AbstractTestCase));
    }
});
enifed("@ember/-internals/metal/tests/watching/unwatch_test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _metal, _internalTestHelpers) {
  "use strict";

  var didCount;

  function addListeners(obj, keyPath) {
    (0, _metal.addListener)(obj, keyPath + ':change', function () {
      return didCount++;
    });
  }

  if (!false
  /* EMBER_METAL_TRACKED_PROPERTIES */
  ) {
      (0, _internalTestHelpers.moduleFor)('unwatch',
      /*#__PURE__*/
      function (_AbstractTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

        function _class() {
          return _AbstractTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto.beforeEach = function beforeEach() {
          didCount = 0;
        };

        _proto['@test unwatching a computed property - regular get/set'] = function testUnwatchingAComputedPropertyRegularGetSet(assert) {
          var obj = {};
          (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)({
            get: function () {
              return this.__foo;
            },
            set: function (keyName, value) {
              this.__foo = value;
              return this.__foo;
            }
          }));
          addListeners(obj, 'foo');
          (0, _metal.watch)(obj, 'foo');
          (0, _metal.set)(obj, 'foo', 'bar');
          assert.equal(didCount, 1, 'should have invoked didCount');
          (0, _metal.unwatch)(obj, 'foo');
          didCount = 0;
          (0, _metal.set)(obj, 'foo', 'BAZ');
          assert.equal(didCount, 0, 'should NOT have invoked didCount');
        };

        _proto['@test unwatching a regular property - regular get/set'] = function testUnwatchingARegularPropertyRegularGetSet(assert) {
          var obj = {
            foo: 'BIFF'
          };
          addListeners(obj, 'foo');
          (0, _metal.watch)(obj, 'foo');
          (0, _metal.set)(obj, 'foo', 'bar');
          assert.equal(didCount, 1, 'should have invoked didCount');
          (0, _metal.unwatch)(obj, 'foo');
          didCount = 0;
          (0, _metal.set)(obj, 'foo', 'BAZ');
          assert.equal(didCount, 0, 'should NOT have invoked didCount');
        };

        _proto['@test unwatching should be nested'] = function testUnwatchingShouldBeNested(assert) {
          var obj = {
            foo: 'BIFF'
          };
          addListeners(obj, 'foo');
          (0, _metal.watch)(obj, 'foo');
          (0, _metal.watch)(obj, 'foo');
          (0, _metal.set)(obj, 'foo', 'bar');
          assert.equal(didCount, 1, 'should have invoked didCount');
          (0, _metal.unwatch)(obj, 'foo');
          didCount = 0;
          (0, _metal.set)(obj, 'foo', 'BAZ');
          assert.equal(didCount, 1, 'should NOT have invoked didCount');
          (0, _metal.unwatch)(obj, 'foo');
          didCount = 0;
          (0, _metal.set)(obj, 'foo', 'BAZ');
          assert.equal(didCount, 0, 'should NOT have invoked didCount');
        };

        _proto['@test unwatching "length" property on an object'] = function testUnwatchingLengthPropertyOnAnObject(assert) {
          var obj = {
            foo: 'RUN'
          };
          addListeners(obj, 'length'); // Can watch length when it is undefined

          (0, _metal.watch)(obj, 'length');
          (0, _metal.set)(obj, 'length', '10k');
          assert.equal(didCount, 1, 'should have invoked didCount'); // Should stop watching despite length now being defined (making object 'array-like')

          (0, _metal.unwatch)(obj, 'length');
          didCount = 0;
          (0, _metal.set)(obj, 'length', '5k');
          assert.equal(didCount, 0, 'should NOT have invoked didCount');
        };

        _proto['@test unwatching should not destroy non MANDATORY_SETTER descriptor'] = function testUnwatchingShouldNotDestroyNonMANDATORY_SETTERDescriptor(assert) {
          var obj = {
            get foo() {
              return 'RUN';
            }

          };
          assert.equal(obj.foo, 'RUN', 'obj.foo');
          (0, _metal.watch)(obj, 'foo');
          assert.equal(obj.foo, 'RUN', 'obj.foo after watch');
          (0, _metal.unwatch)(obj, 'foo');
          assert.equal(obj.foo, 'RUN', 'obj.foo after unwatch');
        };

        return _class;
      }(_internalTestHelpers.AbstractTestCase));
    }
});
enifed("@ember/-internals/metal/tests/watching/watch_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/environment", "@ember/-internals/meta", "internal-test-helpers"], function (_emberBabel, _metal, _environment, _meta, _internalTestHelpers) {
  "use strict";

  var didCount, didKeys, originalLookup;

  function addListeners(obj, keyPath) {
    (0, _metal.addListener)(obj, keyPath + ':change', function () {
      didCount++;
      didKeys.push(keyPath);
    });
  }

  if (!false
  /* EMBER_METAL_TRACKED_PROPERTIES */
  ) {
      (0, _internalTestHelpers.moduleFor)('watch',
      /*#__PURE__*/
      function (_AbstractTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

        function _class() {
          return _AbstractTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto.beforeEach = function beforeEach() {
          didCount = 0;
          didKeys = [];
          originalLookup = _environment.context.lookup;
          _environment.context.lookup = {};
        };

        _proto.afterEach = function afterEach() {
          _environment.context.lookup = originalLookup;
        };

        _proto['@test watching a computed property'] = function testWatchingAComputedProperty(assert) {
          var obj = {};
          (0, _metal.defineProperty)(obj, 'foo', (0, _metal.computed)({
            get: function () {
              return this.__foo;
            },
            set: function (keyName, value) {
              if (value !== undefined) {
                this.__foo = value;
              }

              return this.__foo;
            }
          }));
          addListeners(obj, 'foo');
          (0, _metal.watch)(obj, 'foo');
          (0, _metal.set)(obj, 'foo', 'bar');
          assert.equal(didCount, 1, 'should have invoked didCount');
        };

        _proto['@test watching a regular defined property'] = function testWatchingARegularDefinedProperty(assert) {
          var obj = {
            foo: 'baz'
          };
          addListeners(obj, 'foo');
          (0, _metal.watch)(obj, 'foo');
          assert.equal((0, _metal.get)(obj, 'foo'), 'baz', 'should have original prop');
          (0, _metal.set)(obj, 'foo', 'bar');
          assert.equal(didCount, 1, 'should have invoked didCount');
          assert.equal((0, _metal.get)(obj, 'foo'), 'bar', 'should get new value');
          assert.equal(obj.foo, 'bar', 'property should be accessible on obj');
        };

        _proto['@test watching a regular undefined property'] = function testWatchingARegularUndefinedProperty(assert) {
          var obj = {};
          addListeners(obj, 'foo');
          (0, _metal.watch)(obj, 'foo');
          assert.equal('foo' in obj, false, 'precond undefined');
          (0, _metal.set)(obj, 'foo', 'bar');
          assert.equal(didCount, 1, 'should have invoked didCount');
          assert.equal((0, _metal.get)(obj, 'foo'), 'bar', 'should get new value');
          assert.equal(obj.foo, 'bar', 'property should be accessible on obj');
        };

        _proto['@test watches should inherit'] = function testWatchesShouldInherit(assert) {
          var obj = {
            foo: 'baz'
          };
          var objB = Object.create(obj);
          addListeners(obj, 'foo');
          (0, _metal.watch)(obj, 'foo');
          assert.equal((0, _metal.get)(obj, 'foo'), 'baz', 'should have original prop');
          (0, _metal.set)(objB, 'foo', 'bar');
          (0, _metal.set)(obj, 'foo', 'baz');
          assert.equal(didCount, 1, 'should have invoked didCount once only');
        };

        _proto['@test watching an object THEN defining it should work also'] = function testWatchingAnObjectTHENDefiningItShouldWorkAlso(assert) {
          var obj = {};
          addListeners(obj, 'foo');
          (0, _metal.watch)(obj, 'foo');
          (0, _metal.defineProperty)(obj, 'foo');
          (0, _metal.set)(obj, 'foo', 'bar');
          assert.equal((0, _metal.get)(obj, 'foo'), 'bar', 'should have set');
          assert.equal(didCount, 1, 'should have invoked didChange once');
        };

        _proto['@test watching a chain then defining the property'] = function testWatchingAChainThenDefiningTheProperty(assert) {
          var obj = {};
          var foo = {
            bar: 'bar'
          };
          addListeners(obj, 'foo.bar');
          addListeners(foo, 'bar');
          (0, _metal.watch)(obj, 'foo.bar');
          (0, _metal.defineProperty)(obj, 'foo', undefined, foo);
          (0, _metal.set)(foo, 'bar', 'baz');
          assert.deepEqual(didKeys, ['foo.bar', 'bar'], 'should have invoked didChange with bar, foo.bar');
          assert.equal(didCount, 2, 'should have invoked didChange twice');
        };

        _proto['@test watching a chain then defining the nested property'] = function testWatchingAChainThenDefiningTheNestedProperty(assert) {
          var bar = {};
          var obj = {
            foo: bar
          };
          var baz = {
            baz: 'baz'
          };
          addListeners(obj, 'foo.bar.baz');
          addListeners(baz, 'baz');
          (0, _metal.watch)(obj, 'foo.bar.baz');
          (0, _metal.defineProperty)(bar, 'bar', undefined, baz);
          (0, _metal.set)(baz, 'baz', 'BOO');
          assert.deepEqual(didKeys, ['foo.bar.baz', 'baz'], 'should have invoked didChange with bar, foo.bar');
          assert.equal(didCount, 2, 'should have invoked didChange twice');
        };

        _proto['@test watching an object value then unwatching should restore old value'] = function testWatchingAnObjectValueThenUnwatchingShouldRestoreOldValue(assert) {
          var obj = {
            foo: {
              bar: {
                baz: {
                  biff: 'BIFF'
                }
              }
            }
          };
          addListeners(obj, 'foo.bar.baz.biff');
          (0, _metal.watch)(obj, 'foo.bar.baz.biff');
          var foo = (0, _metal.get)(obj, 'foo');
          assert.equal((0, _metal.get)((0, _metal.get)((0, _metal.get)(foo, 'bar'), 'baz'), 'biff'), 'BIFF', 'biff should exist');
          (0, _metal.unwatch)(obj, 'foo.bar.baz.biff');
          assert.equal((0, _metal.get)((0, _metal.get)((0, _metal.get)(foo, 'bar'), 'baz'), 'biff'), 'BIFF', 'biff should exist');
        };

        _proto['@test when watching another object, destroy should remove chain watchers from the other object'] = function testWhenWatchingAnotherObjectDestroyShouldRemoveChainWatchersFromTheOtherObject(assert) {
          var objA = {};
          var objB = {
            foo: 'bar'
          };
          objA.b = objB;
          addListeners(objA, 'b.foo');
          (0, _metal.watch)(objA, 'b.foo');
          var meta_objB = (0, _meta.meta)(objB);
          var chainNode = (0, _meta.meta)(objA).readableChains().chains.b.chains.foo;
          assert.equal(meta_objB.peekWatching('foo'), 1, 'should be watching foo');
          assert.equal(meta_objB.readableChainWatchers().has('foo', chainNode), true, 'should have chain watcher');
          (0, _meta.deleteMeta)(objA);
          assert.equal(meta_objB.peekWatching('foo'), 0, 'should not be watching foo');
          assert.equal(meta_objB.readableChainWatchers().has('foo', chainNode), false, 'should not have chain watcher');
        } // TESTS for length property
        ;

        _proto['@test watching "length" property on an object'] = function testWatchingLengthPropertyOnAnObject(assert) {
          var obj = {
            length: '26.2 miles'
          };
          addListeners(obj, 'length');
          (0, _metal.watch)(obj, 'length');
          assert.equal((0, _metal.get)(obj, 'length'), '26.2 miles', 'should have original prop');
          (0, _metal.set)(obj, 'length', '10k');
          assert.equal(didCount, 1, 'should have invoked didCount');
          assert.equal((0, _metal.get)(obj, 'length'), '10k', 'should get new value');
          assert.equal(obj.length, '10k', 'property should be accessible on obj');
        };

        _proto['@test watching "length" property on an array'] = function testWatchingLengthPropertyOnAnArray(assert) {
          var arr = [];
          addListeners(arr, 'length');
          (0, _metal.watch)(arr, 'length');
          assert.equal((0, _metal.get)(arr, 'length'), 0, 'should have original prop');
          (0, _metal.set)(arr, 'length', '10');
          assert.equal(didCount, 1, 'should NOT have invoked didCount');
          assert.equal((0, _metal.get)(arr, 'length'), 10, 'should get new value');
          assert.equal(arr.length, 10, 'property should be accessible on arr');
        };

        _proto['@test watch + ES5 getter'] = function testWatchES5Getter(assert) {
          var parent = {
            b: 1
          };
          var child = {
            get b() {
              return parent.b;
            }

          };
          assert.equal(parent.b, 1, 'parent.b should be 1');
          assert.equal(child.b, 1, 'child.b should be 1');
          assert.equal((0, _metal.get)(child, 'b'), 1, 'get(child, "b") should be 1');
          (0, _metal.watch)(child, 'b');
          assert.equal(parent.b, 1, 'parent.b should be 1 (after watch)');
          assert.equal(child.b, 1, 'child.b should be 1  (after watch)');
          assert.equal((0, _metal.get)(child, 'b'), 1, 'get(child, "b") should be 1 (after watch)');
        };

        _proto['@test watch + set + no-descriptor'] = function testWatchSetNoDescriptor(assert) {
          var child = {};
          assert.equal(child.b, undefined, 'child.b ');
          assert.equal((0, _metal.get)(child, 'b'), undefined, 'get(child, "b")');
          (0, _metal.watch)(child, 'b');
          (0, _metal.set)(child, 'b', 1);
          assert.equal(child.b, 1, 'child.b (after watch)');
          assert.equal((0, _metal.get)(child, 'b'), 1, 'get(child, "b") (after watch)');
        };

        return _class;
      }(_internalTestHelpers.AbstractTestCase));
    }
});
enifed("@ember/-internals/routing/tests/ext/controller_test", ["ember-babel", "@ember/-internals/owner", "@ember/controller", "internal-test-helpers"], function (_emberBabel, _owner, _controller, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('@ember/-internals/routing/ext/controller',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto["@test transitionToRoute considers an engine's mountPoint"] = function testTransitionToRouteConsidersAnEngineSMountPoint(assert) {
      var router = {
        transitionTo: function (route) {
          return route;
        }
      };
      var engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true,
          mountPoint: 'foo.bar'
        }
      });

      var controller = _controller.default.create({
        target: router
      });

      (0, _owner.setOwner)(controller, engineInstance);
      assert.strictEqual(controller.transitionToRoute('application'), 'foo.bar.application', 'properly prefixes application route');
      assert.strictEqual(controller.transitionToRoute('posts'), 'foo.bar.posts', 'properly prefixes child routes');
      assert.throws(function () {
        return controller.transitionToRoute('/posts');
      }, 'throws when trying to use a url');
      var queryParams = {};
      assert.strictEqual(controller.transitionToRoute(queryParams), queryParams, 'passes query param only transitions through');
    };

    _proto["@test replaceRoute considers an engine's mountPoint"] = function testReplaceRouteConsidersAnEngineSMountPoint(assert) {
      var router = {
        replaceWith: function (route) {
          return route;
        }
      };
      var engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true,
          mountPoint: 'foo.bar'
        }
      });

      var controller = _controller.default.create({
        target: router
      });

      (0, _owner.setOwner)(controller, engineInstance);
      assert.strictEqual(controller.replaceRoute('application'), 'foo.bar.application', 'properly prefixes application route');
      assert.strictEqual(controller.replaceRoute('posts'), 'foo.bar.posts', 'properly prefixes child routes');
      assert.throws(function () {
        return controller.replaceRoute('/posts');
      }, 'throws when trying to use a url');
      var queryParams = {};
      assert.strictEqual(controller.replaceRoute(queryParams), queryParams, 'passes query param only transitions through');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/routing/tests/location/auto_location_test", ["ember-babel", "@ember/-internals/owner", "@ember/polyfills", "@ember/-internals/browser-environment", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/routing/lib/location/auto_location", "@ember/-internals/routing/lib/location/history_location", "@ember/-internals/routing/lib/location/hash_location", "@ember/-internals/routing/lib/location/none_location", "internal-test-helpers"], function (_emberBabel, _owner, _polyfills, _browserEnvironment, _runloop, _metal, _auto_location, _history_location, _hash_location, _none_location, _internalTestHelpers) {
  "use strict";

  function mockBrowserLocation(overrides, assert) {
    return (0, _polyfills.assign)({
      href: 'http://test.com/',
      pathname: '/',
      hash: '',
      search: '',
      replace: function () {
        assert.ok(false, 'location.replace should not be called during testing');
      }
    }, overrides);
  }

  function mockBrowserHistory(overrides, assert) {
    return (0, _polyfills.assign)({
      pushState: function () {
        assert.ok(false, 'history.pushState should not be called during testing');
      },
      replaceState: function () {
        assert.ok(false, 'history.replaceState should not be called during testing');
      }
    }, overrides);
  }

  function createLocation(location, history) {
    var _AutoLocation$create;

    owner = (0, _internalTestHelpers.buildOwner)();
    owner.register('location:history', _history_location.default);
    owner.register('location:hash', _hash_location.default);
    owner.register('location:none', _none_location.default);

    var autolocation = _auto_location.default.create((_AutoLocation$create = {}, _AutoLocation$create[_owner.OWNER] = owner, _AutoLocation$create.location = location, _AutoLocation$create.history = history, _AutoLocation$create.global = {}, _AutoLocation$create));

    return autolocation;
  }

  var location, owner;
  (0, _internalTestHelpers.moduleFor)('AutoLocation',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      if (owner) {
        (0, _runloop.run)(owner, 'destroy');
        owner = location = undefined;
      }
    };

    _proto['@test AutoLocation should have the `global`'] = function testAutoLocationShouldHaveTheGlobal(assert) {
      var location = _auto_location.default.create();

      assert.ok(location.global, 'has a global defined');
      assert.strictEqual(location.global, _browserEnvironment.window, 'has the environments window global');
    };

    _proto["@test AutoLocation should return concrete implementation's value for `getURL`"] = function testAutoLocationShouldReturnConcreteImplementationSValueForGetURL(assert) {
      var browserLocation = mockBrowserLocation({}, assert);
      var browserHistory = mockBrowserHistory({}, assert);
      location = createLocation(browserLocation, browserHistory);
      location.detect();
      var concreteImplementation = (0, _metal.get)(location, 'concreteImplementation');

      concreteImplementation.getURL = function () {
        return '/lincoln/park';
      };

      assert.equal(location.getURL(), '/lincoln/park');
    };

    _proto['@test AutoLocation should use a HistoryLocation instance when pushStates is supported'] = function testAutoLocationShouldUseAHistoryLocationInstanceWhenPushStatesIsSupported(assert) {
      var browserLocation = mockBrowserLocation({}, assert);
      var browserHistory = mockBrowserHistory({}, assert);
      location = createLocation(browserLocation, browserHistory);
      location.detect();
      assert.ok((0, _metal.get)(location, 'concreteImplementation') instanceof _history_location.default);
    };

    _proto['@test AutoLocation should use a HashLocation instance when pushStates are not supported, but hashchange events are and the URL is already in the HashLocation format'] = function testAutoLocationShouldUseAHashLocationInstanceWhenPushStatesAreNotSupportedButHashchangeEventsAreAndTheURLIsAlreadyInTheHashLocationFormat(assert) {
      var browserLocation = mockBrowserLocation({
        hash: '#/testd'
      }, assert);
      location = createLocation(browserLocation);
      location.global = {
        onhashchange: function () {}
      };
      location.detect();
      assert.ok((0, _metal.get)(location, 'concreteImplementation') instanceof _hash_location.default);
    };

    _proto['@test AutoLocation should use a NoneLocation instance when neither history nor hashchange are supported.'] = function testAutoLocationShouldUseANoneLocationInstanceWhenNeitherHistoryNorHashchangeAreSupported(assert) {
      location = createLocation(mockBrowserLocation({}, assert));
      location.detect();
      assert.ok((0, _metal.get)(location, 'concreteImplementation') instanceof _none_location.default);
    };

    _proto["@test AutoLocation should use an index path (i.e. '/') without any location.hash as OK for HashLocation"] = function testAutoLocationShouldUseAnIndexPathIEWithoutAnyLocationHashAsOKForHashLocation(assert) {
      var browserLocation = mockBrowserLocation({
        href: 'http://test.com/',
        pathname: '/',
        hash: '',
        search: '',
        replace: function () {
          assert.ok(false, 'location.replace should not be called');
        }
      }, assert);
      location = createLocation(browserLocation);
      location.global = {
        onhashchange: function () {}
      };
      location.detect();
      assert.ok((0, _metal.get)(location, 'concreteImplementation') instanceof _hash_location.default, 'uses a HashLocation');
    };

    _proto['@test AutoLocation should transform the URL for hashchange-only browsers viewing a HistoryLocation-formatted path'] = function testAutoLocationShouldTransformTheURLForHashchangeOnlyBrowsersViewingAHistoryLocationFormattedPath(assert) {
      assert.expect(3);
      var browserLocation = mockBrowserLocation({
        hash: '',
        hostname: 'test.com',
        href: 'http://test.com/test',
        pathname: '/test',
        protocol: 'http:',
        port: '',
        search: '',
        replace: function (path) {
          assert.equal(path, 'http://test.com/#/test', 'location.replace should be called with normalized HashLocation path');
        }
      }, assert);
      var location = createLocation(browserLocation);
      location.global = {
        onhashchange: function () {}
      };
      location.detect();
      assert.ok((0, _metal.get)(location, 'concreteImplementation') instanceof _none_location.default, 'NoneLocation should be used while we attempt to location.replace()');
      assert.equal((0, _metal.get)(location, 'cancelRouterSetup'), true, 'cancelRouterSetup should be set so the router knows.');
    };

    _proto['@test AutoLocation should replace the URL for pushState-supported browsers viewing a HashLocation-formatted url'] = function testAutoLocationShouldReplaceTheURLForPushStateSupportedBrowsersViewingAHashLocationFormattedUrl(assert) {
      assert.expect(2);
      var browserLocation = mockBrowserLocation({
        hash: '#/test',
        hostname: 'test.com',
        href: 'http://test.com/#/test',
        pathname: '/',
        protocol: 'http:',
        port: '',
        search: ''
      }, assert);
      var browserHistory = mockBrowserHistory({
        replaceState: function (state, title, path) {
          assert.equal(path, '/test', 'history.replaceState should be called with normalized HistoryLocation url');
        }
      }, assert);
      var location = createLocation(browserLocation, browserHistory);
      location.detect();
      assert.ok((0, _metal.get)(location, 'concreteImplementation'), _history_location.default);
    };

    _proto['@test AutoLocation requires any rootURL given to end in a trailing forward slash'] = function testAutoLocationRequiresAnyRootURLGivenToEndInATrailingForwardSlash(assert) {
      var browserLocation = mockBrowserLocation({}, assert);
      var expectedMsg = /rootURL must end with a trailing forward slash e.g. "\/app\/"/;
      location = createLocation(browserLocation);
      location.rootURL = 'app';
      expectAssertion(function () {
        location.detect();
      }, expectedMsg);
      location.rootURL = '/app';
      expectAssertion(function () {
        location.detect();
      }, expectedMsg); // Note the trailing whitespace

      location.rootURL = '/app/ ';
      expectAssertion(function () {
        location.detect();
      }, expectedMsg);
    };

    _proto['@test AutoLocation provides its rootURL to the concreteImplementation'] = function testAutoLocationProvidesItsRootURLToTheConcreteImplementation(assert) {
      var browserLocation = mockBrowserLocation({
        pathname: '/some/subdir/derp'
      }, assert);
      var browserHistory = mockBrowserHistory({}, assert);
      location = createLocation(browserLocation, browserHistory);
      location.rootURL = '/some/subdir/';
      location.detect();
      var concreteLocation = (0, _metal.get)(location, 'concreteImplementation');
      assert.equal(location.rootURL, concreteLocation.rootURL);
    };

    _proto['@test getHistoryPath() should return a normalized, HistoryLocation-supported path'] = function testGetHistoryPathShouldReturnANormalizedHistoryLocationSupportedPath(assert) {
      var browserLocation = mockBrowserLocation({
        href: 'http://test.com/app/about?foo=bar#foo',
        pathname: '/app/about',
        search: '?foo=bar',
        hash: '#foo'
      }, assert);
      assert.equal((0, _auto_location.getHistoryPath)('/app/', browserLocation), '/app/about?foo=bar#foo', 'URLs already in HistoryLocation form should come out the same');
      browserLocation = mockBrowserLocation({
        href: 'http://test.com/app/#/about?foo=bar#foo',
        pathname: '/app/',
        search: '',
        hash: '#/about?foo=bar#foo'
      }, assert);
      assert.equal((0, _auto_location.getHistoryPath)('/app/', browserLocation), '/app/about?foo=bar#foo', 'HashLocation formed URLs should be normalized');
      browserLocation = mockBrowserLocation({
        href: 'http://test.com/app/#about?foo=bar#foo',
        pathname: '/app/',
        search: '',
        hash: '#about?foo=bar#foo'
      }, assert);
      assert.equal((0, _auto_location.getHistoryPath)('/app', browserLocation), '/app/#about?foo=bar#foo', "URLs with a hash not following #/ convention shouldn't be normalized as a route");
    };

    _proto['@test getHashPath() should return a normalized, HashLocation-supported path'] = function testGetHashPathShouldReturnANormalizedHashLocationSupportedPath(assert) {
      var browserLocation = mockBrowserLocation({
        href: 'http://test.com/app/#/about?foo=bar#foo',
        pathname: '/app/',
        search: '',
        hash: '#/about?foo=bar#foo'
      }, assert);
      assert.equal((0, _auto_location.getHashPath)('/app/', browserLocation), '/app/#/about?foo=bar#foo', 'URLs already in HistoryLocation form should come out the same');
      browserLocation = mockBrowserLocation({
        href: 'http://test.com/app/about?foo=bar#foo',
        pathname: '/app/about',
        search: '?foo=bar',
        hash: '#foo'
      }, assert);
      assert.equal((0, _auto_location.getHashPath)('/app/', browserLocation), '/app/#/about?foo=bar#foo', 'HistoryLocation formed URLs should be normalized');
      browserLocation = mockBrowserLocation({
        href: 'http://test.com/app/#about?foo=bar#foo',
        pathname: '/app/',
        search: '',
        hash: '#about?foo=bar#foo'
      }, assert);
      assert.equal((0, _auto_location.getHashPath)('/app/', browserLocation), '/app/#/#about?foo=bar#foo', "URLs with a hash not following #/ convention shouldn't be normalized as a route");
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/routing/tests/location/hash_location_test", ["ember-babel", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/routing/lib/location/hash_location", "internal-test-helpers"], function (_emberBabel, _runloop, _metal, _hash_location, _internalTestHelpers) {
  "use strict";

  var location;

  function createLocation(options, assert) {
    var HashTestLocation = _hash_location.default.extend({
      _location: {
        href: 'http://test.com/',
        pathname: '/',
        hash: '',
        search: '',
        replace: function () {
          assert.ok(false, 'location.replace should not be called during testing');
        }
      }
    });

    if (!options) {
      options = {};
    }

    location = HashTestLocation.create(options);
  }

  function mockBrowserLocation(path) {
    // This is a neat trick to auto-magically extract the hostname from any
    // url by letting the browser do the work ;)
    var tmp = document.createElement('a');
    tmp.href = path;
    var protocol = !tmp.protocol || tmp.protocol === ':' ? 'http' : tmp.protocol;
    var pathname = tmp.pathname.match(/^\//) ? tmp.pathname : '/' + tmp.pathname;
    return {
      hash: tmp.hash,
      host: tmp.host || 'localhost',
      hostname: tmp.hostname || 'localhost',
      href: tmp.href,
      pathname: pathname,
      port: tmp.port || '',
      protocol: protocol,
      search: tmp.search
    };
  }

  function triggerHashchange() {
    var event = document.createEvent('HTMLEvents');
    event.initEvent('hashchange', true, false);
    window.dispatchEvent(event);
  }

  (0, _internalTestHelpers.moduleFor)('HashLocation',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _runloop.run)(function () {
        if (location) {
          location.destroy();
        }
      });
    };

    _proto['@test HashLocation.getURL() returns the current url'] = function testHashLocationGetURLReturnsTheCurrentUrl(assert) {
      createLocation({
        _location: mockBrowserLocation('/#/foo/bar')
      }, assert);
      assert.equal(location.getURL(), '/foo/bar');
    };

    _proto['@test HashLocation.getURL() includes extra hashes'] = function testHashLocationGetURLIncludesExtraHashes(assert) {
      createLocation({
        _location: mockBrowserLocation('/#/foo#bar#car')
      }, assert);
      assert.equal(location.getURL(), '/foo#bar#car');
    };

    _proto['@test HashLocation.getURL() assumes location.hash without #/ prefix is not a route path'] = function testHashLocationGetURLAssumesLocationHashWithoutPrefixIsNotARoutePath(assert) {
      createLocation({
        _location: mockBrowserLocation('/#foo#bar')
      }, assert);
      assert.equal(location.getURL(), '/#foo#bar');
    };

    _proto['@test HashLocation.getURL() returns a normal forward slash when there is no location.hash'] = function testHashLocationGetURLReturnsANormalForwardSlashWhenThereIsNoLocationHash(assert) {
      createLocation({
        _location: mockBrowserLocation('/')
      }, assert);
      assert.equal(location.getURL(), '/');
    };

    _proto['@test HashLocation.setURL() correctly sets the url'] = function testHashLocationSetURLCorrectlySetsTheUrl(assert) {
      createLocation({}, assert);
      location.setURL('/bar');
      assert.equal((0, _metal.get)(location, 'location.hash'), '/bar');
      assert.equal((0, _metal.get)(location, 'lastSetURL'), '/bar');
    };

    _proto['@test HashLocation.replaceURL() correctly replaces to the path with a page reload'] = function testHashLocationReplaceURLCorrectlyReplacesToThePathWithAPageReload(assert) {
      assert.expect(2);
      createLocation({
        _location: {
          replace: function (path) {
            assert.equal(path, '#/foo');
          }
        }
      }, assert);
      location.replaceURL('/foo');
      assert.equal((0, _metal.get)(location, 'lastSetURL'), '/foo');
    };

    _proto['@test HashLocation.onUpdateURL callback executes as expected'] = function testHashLocationOnUpdateURLCallbackExecutesAsExpected(assert) {
      assert.expect(1);
      createLocation({
        _location: mockBrowserLocation('/#/foo/bar')
      }, assert);

      var callback = function (param) {
        assert.equal(param, '/foo/bar', 'path is passed as param');
      };

      location.onUpdateURL(callback);
      triggerHashchange();
    };

    _proto["@test HashLocation.onUpdateURL doesn't execute callback if lastSetURL === path"] = function testHashLocationOnUpdateURLDoesnTExecuteCallbackIfLastSetURLPath(assert) {
      assert.expect(0);
      createLocation({
        _location: {
          hash: '#/foo/bar'
        },
        lastSetURL: '/foo/bar'
      }, assert);

      var callback = function () {
        assert.ok(false, 'callback should not be called');
      };

      location.onUpdateURL(callback);
      triggerHashchange();
    };

    _proto['@test HashLocation.formatURL() prepends a # to the provided string'] = function testHashLocationFormatURLPrependsAToTheProvidedString(assert) {
      createLocation({}, assert);
      assert.equal(location.formatURL('/foo#bar'), '#/foo#bar');
    };

    _proto['@test HashLocation.willDestroy() cleans up hashchange event listener'] = function testHashLocationWillDestroyCleansUpHashchangeEventListener(assert) {
      assert.expect(1);
      createLocation({}, assert);

      var callback = function () {
        assert.ok(true, 'should invoke callback once');
      };

      location.onUpdateURL(callback);
      triggerHashchange();
      (0, _runloop.run)(location, 'destroy');
      location = null;
      triggerHashchange();
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/routing/tests/location/history_location_test", ["ember-babel", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/routing/lib/location/history_location", "internal-test-helpers"], function (_emberBabel, _runloop, _metal, _history_location, _internalTestHelpers) {
  "use strict";

  var FakeHistory, HistoryTestLocation, location;

  function createLocation(options) {
    if (!options) {
      options = {};
    }

    location = HistoryTestLocation.create(options);
  }

  function mockBrowserLocation(path) {
    // This is a neat trick to auto-magically extract the hostname from any
    // url by letting the browser do the work ;)
    var tmp = document.createElement('a');
    tmp.href = path;
    var protocol = !tmp.protocol || tmp.protocol === ':' ? 'http' : tmp.protocol;
    var pathname = tmp.pathname.match(/^\//) ? tmp.pathname : '/' + tmp.pathname;
    return {
      hash: tmp.hash,
      host: tmp.host || 'localhost',
      hostname: tmp.hostname || 'localhost',
      href: tmp.href,
      pathname: pathname,
      port: tmp.port || '',
      protocol: protocol,
      search: tmp.search
    };
  }

  (0, _internalTestHelpers.moduleFor)('HistoryLocation',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      FakeHistory = {
        state: null,
        _states: [],
        replaceState: function (state) {
          this.state = state;
          this._states[0] = state;
        },
        pushState: function (state) {
          this.state = state;

          this._states.unshift(state);
        }
      };
      HistoryTestLocation = _history_location.default.extend({
        history: FakeHistory
      });
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _runloop.run)(function () {
        if (location) {
          location.destroy();
        }
      });
    };

    _proto['@test HistoryLocation initState does not get fired on init'] = function testHistoryLocationInitStateDoesNotGetFiredOnInit(assert) {
      assert.expect(1);
      HistoryTestLocation.reopen({
        init: function () {
          assert.ok(true, 'init was called');

          this._super.apply(this, arguments);
        },
        initState: function () {
          assert.ok(false, 'initState() should not be called automatically');
        }
      });
      createLocation();
    };

    _proto["@test webkit doesn't fire popstate on page load"] = function testWebkitDoesnTFirePopstateOnPageLoad(assert) {
      assert.expect(1);
      HistoryTestLocation.reopen({
        initState: function () {
          this._super.apply(this, arguments); // these two should be equal to be able
          // to successfully detect webkit initial popstate


          assert.equal(this._previousURL, this.getURL());
        }
      });
      createLocation();
      location.initState();
    };

    _proto['@test base URL is removed when retrieving the current pathname'] = function testBaseURLIsRemovedWhenRetrievingTheCurrentPathname(assert) {
      assert.expect(1);
      HistoryTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'location', mockBrowserLocation('/base/foo/bar'));
          (0, _metal.set)(this, 'baseURL', '/base/');
        },
        initState: function () {
          this._super.apply(this, arguments);

          assert.equal(this.getURL(), '/foo/bar');
        }
      });
      createLocation();
      location.initState();
    };

    _proto['@test base URL is preserved when moving around'] = function testBaseURLIsPreservedWhenMovingAround(assert) {
      assert.expect(2);
      HistoryTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'location', mockBrowserLocation('/base/foo/bar'));
          (0, _metal.set)(this, 'baseURL', '/base/');
        }
      });
      createLocation();
      location.initState();
      location.setURL('/one/two');
      assert.equal(location._historyState.path, '/base/one/two');
      assert.ok(location._historyState.uuid);
    };

    _proto['@test setURL continues to set even with a null state (iframes may set this)'] = function testSetURLContinuesToSetEvenWithANullStateIframesMaySetThis(assert) {
      createLocation();
      location.initState();
      FakeHistory.pushState(null);
      location.setURL('/three/four');
      assert.equal(location._historyState.path, '/three/four');
      assert.ok(location._historyState.uuid);
    };

    _proto['@test replaceURL continues to set even with a null state (iframes may set this)'] = function testReplaceURLContinuesToSetEvenWithANullStateIframesMaySetThis(assert) {
      createLocation();
      location.initState();
      FakeHistory.pushState(null);
      location.replaceURL('/three/four');
      assert.equal(location._historyState.path, '/three/four');
      assert.ok(location._historyState.uuid);
    };

    _proto['@test HistoryLocation.getURL() returns the current url, excluding both rootURL and baseURL'] = function testHistoryLocationGetURLReturnsTheCurrentUrlExcludingBothRootURLAndBaseURL(assert) {
      HistoryTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'location', mockBrowserLocation('/base/foo/bar'));
          (0, _metal.set)(this, 'rootURL', '/app/');
          (0, _metal.set)(this, 'baseURL', '/base/');
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/foo/bar');
    };

    _proto['@test HistoryLocation.getURL() returns the current url, does not remove rootURL if its not at start of url'] = function testHistoryLocationGetURLReturnsTheCurrentUrlDoesNotRemoveRootURLIfItsNotAtStartOfUrl(assert) {
      HistoryTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'location', mockBrowserLocation('/foo/bar/baz'));
          (0, _metal.set)(this, 'rootURL', '/bar/');
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/foo/bar/baz');
    };

    _proto['@test HistoryLocation.getURL() will not remove the rootURL when only a partial match'] = function testHistoryLocationGetURLWillNotRemoveTheRootURLWhenOnlyAPartialMatch(assert) {
      HistoryTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'location', mockBrowserLocation('/bars/baz'));
          (0, _metal.set)(this, 'rootURL', '/bar/');
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/bars/baz');
    };

    _proto['@test HistoryLocation.getURL() returns the current url, does not remove baseURL if its not at start of url'] = function testHistoryLocationGetURLReturnsTheCurrentUrlDoesNotRemoveBaseURLIfItsNotAtStartOfUrl(assert) {
      HistoryTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'location', mockBrowserLocation('/foo/bar/baz'));
          (0, _metal.set)(this, 'baseURL', '/bar/');
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/foo/bar/baz');
    };

    _proto['@test HistoryLocation.getURL() will not remove the baseURL when only a partial match'] = function testHistoryLocationGetURLWillNotRemoveTheBaseURLWhenOnlyAPartialMatch(assert) {
      HistoryTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'location', mockBrowserLocation('/bars/baz'));
          (0, _metal.set)(this, 'baseURL', '/bar/');
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/bars/baz');
    };

    _proto['@test HistoryLocation.getURL() includes location.search'] = function testHistoryLocationGetURLIncludesLocationSearch(assert) {
      HistoryTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'location', mockBrowserLocation('/foo/bar?time=morphin'));
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/foo/bar?time=morphin');
    };

    _proto['@test HistoryLocation.getURL() includes location.hash'] = function testHistoryLocationGetURLIncludesLocationHash(assert) {
      HistoryTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'location', mockBrowserLocation('/foo/bar#pink-power-ranger'));
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/foo/bar#pink-power-ranger');
    };

    _proto['@test HistoryLocation.getURL() includes location.hash and location.search'] = function testHistoryLocationGetURLIncludesLocationHashAndLocationSearch(assert) {
      HistoryTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'location', mockBrowserLocation('/foo/bar?time=morphin#pink-power-ranger'));
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/foo/bar?time=morphin#pink-power-ranger');
    };

    _proto['@test HistoryLocation.getURL() drops duplicate slashes'] = function testHistoryLocationGetURLDropsDuplicateSlashes(assert) {
      HistoryTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          var location = mockBrowserLocation('//');
          location.pathname = '//'; // mockBrowserLocation does not allow for `//`, so force it

          (0, _metal.set)(this, 'location', location);
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/');
    };

    _proto['@test Existing state is preserved on init'] = function testExistingStateIsPreservedOnInit(assert) {
      var existingState = {
        path: '/route/path',
        uuid: 'abcd'
      };
      FakeHistory.state = existingState;
      HistoryTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'location', mockBrowserLocation('/route/path'));
        }
      });
      createLocation();
      location.initState();
      assert.deepEqual(location.getState(), existingState);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/routing/tests/location/none_location_test", ["ember-babel", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/routing/lib/location/none_location", "internal-test-helpers"], function (_emberBabel, _runloop, _metal, _none_location, _internalTestHelpers) {
  "use strict";

  var NoneTestLocation, location;

  function createLocation(options) {
    if (!options) {
      options = {};
    }

    location = NoneTestLocation.create(options);
  }

  (0, _internalTestHelpers.moduleFor)('NoneLocation',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      NoneTestLocation = _none_location.default.extend({});
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _runloop.run)(function () {
        if (location) {
          location.destroy();
        }
      });
    };

    _proto['@test NoneLocation.formatURL() returns the current url always appending rootURL'] = function testNoneLocationFormatURLReturnsTheCurrentUrlAlwaysAppendingRootURL(assert) {
      NoneTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'rootURL', '/en/');
        }
      });
      createLocation();
      assert.equal(location.formatURL('/foo/bar'), '/en/foo/bar');
    };

    _proto['@test NoneLocation.getURL() returns the current path minus rootURL'] = function testNoneLocationGetURLReturnsTheCurrentPathMinusRootURL(assert) {
      NoneTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'rootURL', '/foo/');
          (0, _metal.set)(this, 'path', '/foo/bar');
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/bar');
    };

    _proto['@test NoneLocation.getURL() will remove the rootURL only from the beginning of a url'] = function testNoneLocationGetURLWillRemoveTheRootURLOnlyFromTheBeginningOfAUrl(assert) {
      NoneTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'rootURL', '/bar/');
          (0, _metal.set)(this, 'path', '/foo/bar/baz');
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/foo/bar/baz');
    };

    _proto['@test NoneLocation.getURL() will not remove the rootURL when only a partial match'] = function testNoneLocationGetURLWillNotRemoveTheRootURLWhenOnlyAPartialMatch(assert) {
      NoneTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'rootURL', '/bar/');
          (0, _metal.set)(this, 'path', '/bars/baz');
        }
      });
      createLocation();
      assert.equal(location.getURL(), '/bars/baz');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/routing/tests/location/util_test", ["ember-babel", "@ember/polyfills", "@ember/-internals/routing/lib/location/util", "internal-test-helpers"], function (_emberBabel, _polyfills, _util, _internalTestHelpers) {
  "use strict";

  function mockBrowserLocation(overrides, assert) {
    return (0, _polyfills.assign)({
      href: 'http://test.com/',
      pathname: '/',
      hash: '',
      search: '',
      replace: function () {
        assert.ok(false, 'location.replace should not be called during testing');
      }
    }, overrides);
  }

  (0, _internalTestHelpers.moduleFor)('Location Utilities',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test replacePath cannot be used to redirect to a different origin'] = function testReplacePathCannotBeUsedToRedirectToADifferentOrigin(assert) {
      assert.expect(1);
      var expectedURL;
      var location = {
        protocol: 'http:',
        hostname: 'emberjs.com',
        port: '1337',
        replace: function (url) {
          assert.equal(url, expectedURL);
        }
      };
      expectedURL = 'http://emberjs.com:1337//google.com';
      (0, _util.replacePath)(location, '//google.com');
    };

    _proto['@test getPath() should normalize location.pathname, making sure it always returns a leading slash'] = function testGetPathShouldNormalizeLocationPathnameMakingSureItAlwaysReturnsALeadingSlash(assert) {
      var location = mockBrowserLocation({
        pathname: 'test'
      }, assert);
      assert.equal((0, _util.getPath)(location), '/test', 'When there is no leading slash, one is added.');
      location = mockBrowserLocation({
        pathname: '/test'
      }, assert);
      assert.equal((0, _util.getPath)(location), '/test', "When a leading slash is already there, it isn't added again");
    };

    _proto['@test getQuery() should return location.search as-is'] = function testGetQueryShouldReturnLocationSearchAsIs(assert) {
      var location = mockBrowserLocation({
        search: '?foo=bar'
      }, assert);
      assert.equal((0, _util.getQuery)(location), '?foo=bar');
    };

    _proto['@test getFullPath() should return full pathname including query and hash'] = function testGetFullPathShouldReturnFullPathnameIncludingQueryAndHash(assert) {
      var location = mockBrowserLocation({
        href: 'http://test.com/about?foo=bar#foo',
        pathname: '/about',
        search: '?foo=bar',
        hash: '#foo'
      }, assert);
      assert.equal((0, _util.getFullPath)(location), '/about?foo=bar#foo');
    };

    _proto['@test Feature-Detecting onhashchange'] = function testFeatureDetectingOnhashchange(assert) {
      assert.equal((0, _util.supportsHashChange)(undefined, {
        onhashchange: function () {}
      }), true, 'When not in IE, use onhashchange existence as evidence of the feature');
      assert.equal((0, _util.supportsHashChange)(undefined, {}), false, 'When not in IE, use onhashchange absence as evidence of the feature absence');
      assert.equal((0, _util.supportsHashChange)(7, {
        onhashchange: function () {}
      }), false, 'When in IE7 compatibility mode, never report existence of the feature');
      assert.equal((0, _util.supportsHashChange)(8, {
        onhashchange: function () {}
      }), true, 'When in IE8+, use onhashchange existence as evidence of the feature');
    };

    _proto['@test Feature-detecting the history API'] = function testFeatureDetectingTheHistoryAPI(assert) {
      assert.equal((0, _util.supportsHistory)('', {
        pushState: true
      }), true, 'returns true if not Android Gingerbread and history.pushState exists');
      assert.equal((0, _util.supportsHistory)('', {}), false, "returns false if history.pushState doesn't exist");
      assert.equal((0, _util.supportsHistory)('', undefined), false, "returns false if history doesn't exist");
      assert.equal((0, _util.supportsHistory)('Mozilla/5.0 (Linux; U; Android 2.3.5; en-us; HTC Vision Build/GRI40) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1', {
        pushState: true
      }), false, 'returns false if Android 2.x stock browser (not Chrome) claiming to support pushState');
      assert.equal((0, _util.supportsHistory)('Mozilla/5.0 (Linux; U; Android 4.0.3; nl-nl; GT-N7000 Build/IML74K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30', {
        pushState: true
      }), false, 'returns false for Android 4.0.x stock browser (not Chrome) claiming to support pushState');
      assert.equal((0, _util.supportsHistory)('Mozilla/5.0 (Linux; U; Android 20.3.5; en-us; HTC Vision Build/GRI40) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1', {
        pushState: true
      }), true, 'returns true if Android version begins with 2, but is greater than 2');
      assert.equal((0, _util.supportsHistory)('Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19', {
        pushState: true
      }), true, 'returns true for Chrome (not stock browser) on Android 4.0.x'); // Windows Phone UA and History API: https://github.com/Modernizr/Modernizr/issues/1471

      assert.equal((0, _util.supportsHistory)('Mozilla/5.0 (Mobile; Windows Phone 8.1; Android 4.0; ARM; Trident/7.0; Touch; rv:11.0; IEMobile/11.0; Microsoft; Virtual) like iPhone OS 7_0_3 Mac OS X AppleWebKit/537 (KHTML, like Gecko) Mobile Safari/537', {
        pushState: true
      }), true, 'returns true for Windows Phone 8.1 with misleading user agent string');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/routing/tests/system/cache_test", ["ember-babel", "@ember/-internals/routing/lib/system/cache", "internal-test-helpers"], function (_emberBabel, _cache, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('BucketCache',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      _this.cache = new _cache.default();
      return _this;
    }

    var _proto = _class.prototype;

    _proto['@test has - returns false when bucket is not in cache'] = function testHasReturnsFalseWhenBucketIsNotInCache(assert) {
      assert.strictEqual(this.cache.has('foo'), false);
      assert.strictEqual(this.cache.has('constructor'), false);
    };

    _proto['@test has - returns true when bucket is in cache'] = function testHasReturnsTrueWhenBucketIsInCache(assert) {
      var token = {};
      this.cache.stash('foo', 'bar', token);
      this.cache.stash('constructor', 'bar', token);
      assert.strictEqual(this.cache.has('foo'), true);
      assert.strictEqual(this.cache.has('constructor'), true);
    };

    _proto['@test lookup - returns stashed value if key does exist in bucket'] = function testLookupReturnsStashedValueIfKeyDoesExistInBucket(assert) {
      var token = {};
      var defaultValue = {};
      this.cache.stash('foo', 'bar', token);
      assert.strictEqual(this.cache.lookup('foo', 'bar', defaultValue), token);
    };

    _proto['@test lookup - returns default value if key does not exist in bucket'] = function testLookupReturnsDefaultValueIfKeyDoesNotExistInBucket(assert) {
      var token = {};
      var defaultValue = {};
      this.cache.stash('foo', 'bar', token);
      assert.strictEqual(this.cache.lookup('foo', 'boo', defaultValue), defaultValue);
      assert.strictEqual(this.cache.lookup('foo', 'constructor', defaultValue), defaultValue);
    };

    _proto['@test lookup - returns default value if bucket does not exist'] = function testLookupReturnsDefaultValueIfBucketDoesNotExist(assert) {
      var defaultValue = {};
      assert.strictEqual(this.cache.lookup('boo', 'bar', defaultValue), defaultValue);
      assert.strictEqual(this.cache.lookup('constructor', 'bar', defaultValue), defaultValue);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/routing/tests/system/controller_for_test", ["ember-babel", "@ember/controller", "@ember/-internals/routing/lib/system/controller_for", "@ember/-internals/routing/lib/system/generate_controller", "internal-test-helpers", "@ember/debug"], function (_emberBabel, _controller, _controller_for, _generate_controller, _internalTestHelpers, _debug) {
  "use strict";

  var originalDebug = (0, _debug.getDebugFunction)('debug');

  var noop = function () {};

  (0, _internalTestHelpers.moduleFor)('controllerFor',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      (0, _debug.setDebugFunction)('debug', noop);
      return _ApplicationTestCase.call(this) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _debug.setDebugFunction)('debug', originalDebug);
    };

    _proto['@test controllerFor should lookup for registered controllers'] = function testControllerForShouldLookupForRegisteredControllers(assert) {
      var _this = this;

      this.add('controller:app', _controller.default.extend());
      return this.visit('/').then(function () {
        var appInstance = _this.applicationInstance;
        var appController = appInstance.lookup('controller:app');
        var controller = (0, _controller_for.default)(appInstance, 'app');
        assert.equal(appController, controller, 'should find app controller');
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('generateController',
  /*#__PURE__*/
  function (_ApplicationTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase2);

    function _class2() {
      (0, _debug.setDebugFunction)('debug', noop);
      return _ApplicationTestCase2.call(this) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2.teardown = function teardown() {
      (0, _debug.setDebugFunction)('debug', originalDebug);
    };

    _proto2['@test generateController should return Controller'] = function testGenerateControllerShouldReturnController(assert) {
      var _this2 = this;

      return this.visit('/').then(function () {
        var controller = (0, _generate_controller.default)(_this2.applicationInstance, 'home');
        assert.ok(controller instanceof _controller.default, 'should return controller');
      });
    };

    _proto2['@test generateController should return controller:basic if resolved'] = function testGenerateControllerShouldReturnControllerBasicIfResolved(assert) {
      var _this3 = this;

      var BasicController = _controller.default.extend();

      this.add('controller:basic', BasicController);
      return this.visit('/').then(function () {
        var controller = (0, _generate_controller.default)(_this3.applicationInstance, 'home');
        assert.ok(controller instanceof BasicController, 'should return controller');
      });
    };

    _proto2['@test generateController should return controller:basic if registered'] = function testGenerateControllerShouldReturnControllerBasicIfRegistered(assert) {
      var _this4 = this;

      var BasicController = _controller.default.extend();

      this.application.register('controller:basic', BasicController);
      return this.visit('/').then(function () {
        var controller = (0, _generate_controller.default)(_this4.applicationInstance, 'home');
        assert.ok(controller instanceof BasicController, 'should return base class of controller');
      });
    };

    return _class2;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/-internals/routing/tests/system/dsl_test", ["ember-babel", "@ember/-internals/owner", "@ember/-internals/routing/lib/system/router", "internal-test-helpers"], function (_emberBabel, _owner, _router, _internalTestHelpers) {
  "use strict";

  var Router;
  (0, _internalTestHelpers.moduleFor)('Ember Router DSL',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      Router = _router.default.extend();
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      Router = null;
    };

    _proto['@test should fail when using a reserved route name'] = function testShouldFailWhenUsingAReservedRouteName(assert) {
      var reservedNames = ['basic', 'application'];
      assert.expect(reservedNames.length);
      reservedNames.forEach(function (reservedName) {
        expectAssertion(function () {
          Router = _router.default.extend();
          Router.map(function () {
            this.route(reservedName);
          });
          var router = Router.create();

          router._initRouterJs();
        }, "'" + reservedName + "' cannot be used as a route name.");
      });
    };

    _proto['@test [GH#16642] better error when using a colon in a route name'] = function testGH16642BetterErrorWhenUsingAColonInARouteName() {
      expectAssertion(function () {
        Router = _router.default.extend();
        Router.map(function () {
          this.route('resource/:id');
        });
        var router = Router.create();

        router._initRouterJs();
      }, "'resource/:id' is not a valid route name. It cannot contain a ':'. You may want to use the 'path' option instead.");
    };

    _proto['@test should retain resource namespace if nested with routes'] = function testShouldRetainResourceNamespaceIfNestedWithRoutes(assert) {
      Router = Router.map(function () {
        this.route('bleep', function () {
          this.route('bloop', function () {
            this.route('blork');
          });
        });
      });
      var router = Router.create();

      router._initRouterJs();

      assert.ok(router._routerMicrolib.recognizer.names['bleep'], 'parent name was used as base of nested routes');
      assert.ok(router._routerMicrolib.recognizer.names['bleep.bloop'], 'parent name was used as base of nested routes');
      assert.ok(router._routerMicrolib.recognizer.names['bleep.bloop.blork'], 'parent name was used as base of nested routes');
    };

    _proto['@test should add loading and error routes if _isRouterMapResult is true'] = function testShouldAddLoadingAndErrorRoutesIf_isRouterMapResultIsTrue(assert) {
      Router.map(function () {
        this.route('blork');
      });
      var router = Router.create({
        _hasModuleBasedResolver: function () {
          return true;
        }
      });

      router._initRouterJs();

      assert.ok(router._routerMicrolib.recognizer.names['blork'], 'main route was created');
      assert.ok(router._routerMicrolib.recognizer.names['blork_loading'], 'loading route was added');
      assert.ok(router._routerMicrolib.recognizer.names['blork_error'], 'error route was added');
    };

    _proto['@test should not add loading and error routes if _isRouterMapResult is false'] = function testShouldNotAddLoadingAndErrorRoutesIf_isRouterMapResultIsFalse(assert) {
      Router.map(function () {
        this.route('blork');
      });
      var router = Router.create();

      router._initRouterJs(false);

      assert.ok(router._routerMicrolib.recognizer.names['blork'], 'main route was created');
      assert.ok(!router._routerMicrolib.recognizer.names['blork_loading'], 'loading route was not added');
      assert.ok(!router._routerMicrolib.recognizer.names['blork_error'], 'error route was not added');
    };

    _proto['@test should reset namespace of loading and error routes for routes with resetNamespace'] = function testShouldResetNamespaceOfLoadingAndErrorRoutesForRoutesWithResetNamespace(assert) {
      Router.map(function () {
        this.route('blork', function () {
          this.route('blorp');
          this.route('bleep', {
            resetNamespace: true
          });
        });
      });
      var router = Router.create({
        _hasModuleBasedResolver: function () {
          return true;
        }
      });

      router._initRouterJs();

      assert.ok(router._routerMicrolib.recognizer.names['blork.blorp'], 'nested route was created');
      assert.ok(router._routerMicrolib.recognizer.names['blork.blorp_loading'], 'nested loading route was added');
      assert.ok(router._routerMicrolib.recognizer.names['blork.blorp_error'], 'nested error route was added');
      assert.ok(router._routerMicrolib.recognizer.names['bleep'], 'reset route was created');
      assert.ok(router._routerMicrolib.recognizer.names['bleep_loading'], 'reset loading route was added');
      assert.ok(router._routerMicrolib.recognizer.names['bleep_error'], 'reset error route was added');
      assert.ok(!router._routerMicrolib.recognizer.names['blork.bleep'], 'nested reset route was not created');
      assert.ok(!router._routerMicrolib.recognizer.names['blork.bleep_loading'], 'nested reset loading route was not added');
      assert.ok(!router._routerMicrolib.recognizer.names['blork.bleep_error'], 'nested reset error route was not added');
    };

    _proto['@test should throw an error when defining a route serializer outside an engine'] = function testShouldThrowAnErrorWhenDefiningARouteSerializerOutsideAnEngine(assert) {
      Router.map(function () {
        var _this2 = this;

        assert.throws(function () {
          _this2.route('posts', {
            serialize: function () {}
          });
        }, /Defining a route serializer on route 'posts' outside an Engine is not allowed/);
      });

      Router.create()._initRouterJs();
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Ember Router DSL with engines',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      var _this3;

      _this3 = _AbstractTestCase2.call(this) || this;
      Router = _router.default.extend();
      return _this3;
    }

    var _proto2 = _class2.prototype;

    _proto2.teardown = function teardown() {
      Router = null;
    };

    _proto2['@test should allow mounting of engines'] = function testShouldAllowMountingOfEngines(assert) {
      assert.expect(3);
      Router = Router.map(function () {
        this.route('bleep', function () {
          this.route('bloop', function () {
            this.mount('chat');
          });
        });
      });
      var engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true
        }
      });
      var router = Router.create();
      (0, _owner.setOwner)(router, engineInstance);

      router._initRouterJs();

      assert.ok(router._routerMicrolib.recognizer.names['bleep'], 'parent name was used as base of nested routes');
      assert.ok(router._routerMicrolib.recognizer.names['bleep.bloop'], 'parent name was used as base of nested routes');
      assert.ok(router._routerMicrolib.recognizer.names['bleep.bloop.chat'], 'parent name was used as base of mounted engine');
    };

    _proto2['@test should allow mounting of engines at a custom path'] = function testShouldAllowMountingOfEnginesAtACustomPath(assert) {
      assert.expect(1);
      Router = Router.map(function () {
        this.route('bleep', function () {
          this.route('bloop', function () {
            this.mount('chat', {
              path: 'custom-chat'
            });
          });
        });
      });
      var engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true
        }
      });
      var router = Router.create();
      (0, _owner.setOwner)(router, engineInstance);

      router._initRouterJs();

      assert.deepEqual(router._routerMicrolib.recognizer.names['bleep.bloop.chat'].segments.slice(1, 4).map(function (s) {
        return s.value;
      }), ['bleep', 'bloop', 'custom-chat'], 'segments are properly associated with mounted engine');
    };

    _proto2['@test should allow aliasing of engine names with `as`'] = function testShouldAllowAliasingOfEngineNamesWithAs(assert) {
      assert.expect(1);
      Router = Router.map(function () {
        this.route('bleep', function () {
          this.route('bloop', function () {
            this.mount('chat', {
              as: 'blork'
            });
          });
        });
      });
      var engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true
        }
      });
      var router = Router.create();
      (0, _owner.setOwner)(router, engineInstance);

      router._initRouterJs();

      assert.deepEqual(router._routerMicrolib.recognizer.names['bleep.bloop.blork'].segments.slice(1, 4).map(function (s) {
        return s.value;
      }), ['bleep', 'bloop', 'blork'], 'segments are properly associated with mounted engine with aliased name');
    };

    _proto2['@test should add loading and error routes to a mount if _isRouterMapResult is true'] = function testShouldAddLoadingAndErrorRoutesToAMountIf_isRouterMapResultIsTrue(assert) {
      Router.map(function () {
        this.mount('chat');
      });
      var engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true
        }
      });
      var router = Router.create({
        _hasModuleBasedResolver: function () {
          return true;
        }
      });
      (0, _owner.setOwner)(router, engineInstance);

      router._initRouterJs();

      assert.ok(router._routerMicrolib.recognizer.names['chat'], 'main route was created');
      assert.ok(router._routerMicrolib.recognizer.names['chat_loading'], 'loading route was added');
      assert.ok(router._routerMicrolib.recognizer.names['chat_error'], 'error route was added');
    };

    _proto2['@test should add loading and error routes to a mount alias if _isRouterMapResult is true'] = function testShouldAddLoadingAndErrorRoutesToAMountAliasIf_isRouterMapResultIsTrue(assert) {
      Router.map(function () {
        this.mount('chat', {
          as: 'shoutbox'
        });
      });
      var engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true
        }
      });
      var router = Router.create({
        _hasModuleBasedResolver: function () {
          return true;
        }
      });
      (0, _owner.setOwner)(router, engineInstance);

      router._initRouterJs();

      assert.ok(router._routerMicrolib.recognizer.names['shoutbox'], 'main route was created');
      assert.ok(router._routerMicrolib.recognizer.names['shoutbox_loading'], 'loading route was added');
      assert.ok(router._routerMicrolib.recognizer.names['shoutbox_error'], 'error route was added');
    };

    _proto2['@test should not add loading and error routes to a mount if _isRouterMapResult is false'] = function testShouldNotAddLoadingAndErrorRoutesToAMountIf_isRouterMapResultIsFalse(assert) {
      Router.map(function () {
        this.mount('chat');
      });
      var engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true
        }
      });
      var router = Router.create();
      (0, _owner.setOwner)(router, engineInstance);

      router._initRouterJs(false);

      assert.ok(router._routerMicrolib.recognizer.names['chat'], 'main route was created');
      assert.ok(!router._routerMicrolib.recognizer.names['chat_loading'], 'loading route was not added');
      assert.ok(!router._routerMicrolib.recognizer.names['chat_error'], 'error route was not added');
    };

    _proto2['@test should reset namespace of loading and error routes for mounts with resetNamespace'] = function testShouldResetNamespaceOfLoadingAndErrorRoutesForMountsWithResetNamespace(assert) {
      Router.map(function () {
        this.route('news', function () {
          this.mount('chat');
          this.mount('blog', {
            resetNamespace: true
          });
        });
      });
      var engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true
        }
      });
      var router = Router.create({
        _hasModuleBasedResolver: function () {
          return true;
        }
      });
      (0, _owner.setOwner)(router, engineInstance);

      router._initRouterJs();

      assert.ok(router._routerMicrolib.recognizer.names['news.chat'], 'nested route was created');
      assert.ok(router._routerMicrolib.recognizer.names['news.chat_loading'], 'nested loading route was added');
      assert.ok(router._routerMicrolib.recognizer.names['news.chat_error'], 'nested error route was added');
      assert.ok(router._routerMicrolib.recognizer.names['blog'], 'reset route was created');
      assert.ok(router._routerMicrolib.recognizer.names['blog_loading'], 'reset loading route was added');
      assert.ok(router._routerMicrolib.recognizer.names['blog_error'], 'reset error route was added');
      assert.ok(!router._routerMicrolib.recognizer.names['news.blog'], 'nested reset route was not created');
      assert.ok(!router._routerMicrolib.recognizer.names['news.blog_loading'], 'nested reset loading route was not added');
      assert.ok(!router._routerMicrolib.recognizer.names['news.blog_error'], 'nested reset error route was not added');
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/routing/tests/system/route_test", ["ember-babel", "@ember/-internals/owner", "internal-test-helpers", "@ember/service", "@ember/-internals/runtime", "@ember/-internals/routing/lib/system/route", "@ember/-internals/metal"], function (_emberBabel, _owner, _internalTestHelpers, _service, _runtime, _route, _metal) {
  "use strict";

  var route, routeOne, routeTwo, lookupHash;
  (0, _internalTestHelpers.moduleFor)('Route',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      route = _route.default.create();
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _AbstractTestCase.prototype.teardown.call(this);

      (0, _internalTestHelpers.runDestroy)(route);
      route = routeOne = routeTwo = lookupHash = undefined;
    };

    _proto['@test default store utilizes the container to acquire the model factory'] = function testDefaultStoreUtilizesTheContainerToAcquireTheModelFactory(assert) {
      assert.expect(4);

      var Post = _runtime.Object.extend();

      var post = {};
      Post.reopenClass({
        find: function () {
          return post;
        }
      });
      var ownerOptions = {
        ownerOptions: {
          hasRegistration: function () {
            return true;
          },
          factoryFor: function (fullName) {
            assert.equal(fullName, 'model:post', 'correct factory was looked up');
            return {
              class: Post,
              create: function () {
                return Post.create();
              }
            };
          }
        }
      };
      var owner = (0, _internalTestHelpers.buildOwner)(ownerOptions);
      (0, _owner.setOwner)(route, owner); // Override the computed property by redefining it

      (0, _metal.defineProperty)(route, '_qp', null, null);
      assert.equal(route.model({
        post_id: 1
      }), post);
      assert.equal(route.findModel('post', 1), post, '#findModel returns the correct post');
      (0, _internalTestHelpers.runDestroy)(owner);
    };

    _proto["@test 'store' can be injected by data persistence frameworks"] = function testStoreCanBeInjectedByDataPersistenceFrameworks(assert) {
      assert.expect(8);
      (0, _internalTestHelpers.runDestroy)(route);
      var owner = (0, _internalTestHelpers.buildOwner)();
      var post = {
        id: 1
      };

      var Store = _runtime.Object.extend({
        find: function (type, value) {
          assert.ok(true, 'injected model was called');
          assert.equal(type, 'post', 'correct type was called');
          assert.equal(value, 1, 'correct value was called');
          return post;
        }
      });

      owner.register('route:index', _route.default);
      owner.register('store:main', Store);
      owner.inject('route', 'store', 'store:main');
      route = owner.lookup('route:index');
      assert.equal(route.model({
        post_id: 1
      }), post, '#model returns the correct post');
      assert.equal(route.findModel('post', 1), post, '#findModel returns the correct post');
      (0, _internalTestHelpers.runDestroy)(owner);
    };

    _proto["@test assert if 'store.find' method is not found"] = function testAssertIfStoreFindMethodIsNotFound() {
      (0, _internalTestHelpers.runDestroy)(route);
      var owner = (0, _internalTestHelpers.buildOwner)();

      var Post = _runtime.Object.extend();

      owner.register('route:index', _route.default);
      owner.register('model:post', Post);
      route = owner.lookup('route:index');
      expectAssertion(function () {
        route.findModel('post', 1);
      }, 'Post has no method `find`.');
      (0, _internalTestHelpers.runDestroy)(owner);
    };

    _proto['@test asserts if model class is not found'] = function testAssertsIfModelClassIsNotFound() {
      (0, _internalTestHelpers.runDestroy)(route);
      var owner = (0, _internalTestHelpers.buildOwner)();
      owner.register('route:index', _route.default);
      route = owner.lookup('route:index');
      expectAssertion(function () {
        route.model({
          post_id: 1
        });
      }, /You used the dynamic segment post_id in your route undefined, but <Ember.Object:ember\d+>.Post did not exist and you did not override your route\'s `model` hook./);
      (0, _internalTestHelpers.runDestroy)(owner);
    };

    _proto["@test 'store' does not need to be injected"] = function testStoreDoesNotNeedToBeInjected(assert) {
      (0, _internalTestHelpers.runDestroy)(route);
      var owner = (0, _internalTestHelpers.buildOwner)();
      owner.register('route:index', _route.default);
      route = owner.lookup('route:index');
      ignoreAssertion(function () {
        route.model({
          post_id: 1
        });
      });
      assert.ok(true, 'no error was raised');
      (0, _internalTestHelpers.runDestroy)(owner);
    };

    _proto["@test modelFor doesn't require the router"] = function testModelForDoesnTRequireTheRouter(assert) {
      var owner = (0, _internalTestHelpers.buildOwner)();
      (0, _owner.setOwner)(route, owner);
      var foo = {
        name: 'foo'
      };

      var FooRoute = _route.default.extend({
        currentModel: foo
      });

      owner.register('route:foo', FooRoute);
      assert.strictEqual(route.modelFor('foo'), foo);
      (0, _internalTestHelpers.runDestroy)(owner);
    };

    _proto["@test modelFor doesn't require the routerMicrolib"] = function testModelForDoesnTRequireTheRouterMicrolib(assert) {
      var route = _route.default.create({
        _router: {
          _routerMicrolib: null
        }
      });

      var owner = (0, _internalTestHelpers.buildOwner)();
      (0, _owner.setOwner)(route, owner);
      var foo = {
        name: 'foo'
      };

      var FooRoute = _route.default.extend({
        currentModel: foo
      });

      owner.register('route:foo', FooRoute);
      assert.strictEqual(route.modelFor('foo'), foo);
      (0, _internalTestHelpers.runDestroy)(owner);
    };

    _proto['@test .send just calls an action if the router is absent'] = function testSendJustCallsAnActionIfTheRouterIsAbsent(assert) {
      assert.expect(7);

      var route = _route.default.extend({
        actions: {
          returnsTrue: function (foo, bar) {
            assert.equal(foo, 1);
            assert.equal(bar, 2);
            assert.equal(this, route);
            return true;
          },
          returnsFalse: function () {
            assert.ok(true, 'returnsFalse was called');
            return false;
          }
        }
      }).create();

      assert.equal(route.send('returnsTrue', 1, 2), true);
      assert.equal(route.send('returnsFalse'), false);
      assert.equal(route.send('nonexistent', 1, 2, 3), undefined);
      (0, _internalTestHelpers.runDestroy)(route);
    };

    _proto['@test .send just calls an action if the routers internal router property is absent'] = function testSendJustCallsAnActionIfTheRoutersInternalRouterPropertyIsAbsent(assert) {
      assert.expect(7);

      var route = _route.default.extend({
        router: {},
        actions: {
          returnsTrue: function (foo, bar) {
            assert.equal(foo, 1);
            assert.equal(bar, 2);
            assert.equal(this, route);
            return true;
          },
          returnsFalse: function () {
            assert.ok(true, 'returnsFalse was called');
            return false;
          }
        }
      }).create();

      assert.equal(true, route.send('returnsTrue', 1, 2));
      assert.equal(false, route.send('returnsFalse'));
      assert.equal(undefined, route.send('nonexistent', 1, 2, 3));
      (0, _internalTestHelpers.runDestroy)(route);
    };

    _proto['@test .send asserts if called on a destroyed route'] = function testSendAssertsIfCalledOnADestroyedRoute() {
      route.routeName = 'rip-alley';
      (0, _internalTestHelpers.runDestroy)(route);
      expectAssertion(function () {
        route.send('trigger-me-dead');
      }, "Attempted to call .send() with the action 'trigger-me-dead' on the destroyed route 'rip-alley'.");
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Route serialize',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      var _this2;

      _this2 = _AbstractTestCase2.call(this) || this;
      route = _route.default.create();
      return _this2;
    }

    var _proto2 = _class2.prototype;

    _proto2.teardown = function teardown() {
      (0, _internalTestHelpers.runDestroy)(route);
    };

    _proto2['@test returns the models properties if params does not include *_id'] = function testReturnsTheModelsPropertiesIfParamsDoesNotInclude_id(assert) {
      var model = {
        id: 2,
        firstName: 'Ned',
        lastName: 'Ryerson'
      };
      assert.deepEqual(route.serialize(model, ['firstName', 'lastName']), {
        firstName: 'Ned',
        lastName: 'Ryerson'
      }, 'serialized correctly');
    };

    _proto2['@test returns model.id if params include *_id'] = function testReturnsModelIdIfParamsInclude_id(assert) {
      var model = {
        id: 2
      };
      assert.deepEqual(route.serialize(model, ['post_id']), {
        post_id: 2
      }, 'serialized correctly');
    };

    _proto2['@test returns checks for existence of model.post_id before trying model.id'] = function testReturnsChecksForExistenceOfModelPost_idBeforeTryingModelId(assert) {
      var model = {
        post_id: 3
      };
      assert.deepEqual(route.serialize(model, ['post_id']), {
        post_id: 3
      }, 'serialized correctly');
    };

    _proto2['@test returns undefined if model is not set'] = function testReturnsUndefinedIfModelIsNotSet(assert) {
      assert.equal(route.serialize(undefined, ['post_id']), undefined, 'serialized correctly');
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Route interaction',
  /*#__PURE__*/
  function (_AbstractTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class3, _AbstractTestCase3);

    function _class3() {
      var _this3;

      _this3 = _AbstractTestCase3.call(this) || this;
      var owner = {
        lookup: function (fullName) {
          return lookupHash[fullName];
        }
      };
      routeOne = _route.default.create({
        routeName: 'one'
      });
      routeTwo = _route.default.create({
        routeName: 'two'
      });
      (0, _owner.setOwner)(routeOne, owner);
      (0, _owner.setOwner)(routeTwo, owner);
      lookupHash = {
        'route:one': routeOne,
        'route:two': routeTwo
      };
      return _this3;
    }

    var _proto3 = _class3.prototype;

    _proto3.teardown = function teardown() {
      (0, _internalTestHelpers.runDestroy)(routeOne);
      (0, _internalTestHelpers.runDestroy)(routeTwo);
    };

    _proto3['@test route._qp does not crash if the controller has no QP, or setProperties'] = function testRoute_qpDoesNotCrashIfTheControllerHasNoQPOrSetProperties(assert) {
      lookupHash['controller:test'] = {};
      routeOne.controllerName = 'test';
      var qp = routeOne.get('_qp');
      assert.deepEqual(qp.map, {}, 'map should be empty');
      assert.deepEqual(qp.propertyNames, [], 'property names should be empty');
      assert.deepEqual(qp.qps, [], 'qps is should be empty');
    };

    _proto3["@test controllerFor uses route's controllerName if specified"] = function testControllerForUsesRouteSControllerNameIfSpecified(assert) {
      var testController = {};
      lookupHash['controller:test'] = testController;
      routeOne.controllerName = 'test';
      assert.equal(routeTwo.controllerFor('one'), testController);
    };

    return _class3;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Route injected properties',
  /*#__PURE__*/
  function (_AbstractTestCase4) {
    (0, _emberBabel.inheritsLoose)(_class4, _AbstractTestCase4);

    function _class4() {
      return _AbstractTestCase4.apply(this, arguments) || this;
    }

    var _proto4 = _class4.prototype;

    _proto4['@test services can be injected into routes'] = function testServicesCanBeInjectedIntoRoutes(assert) {
      var owner = (0, _internalTestHelpers.buildOwner)();
      owner.register('route:application', _route.default.extend({
        authService: (0, _service.inject)('auth')
      }));
      owner.register('service:auth', _service.default.extend());
      var appRoute = owner.lookup('route:application');
      var authService = owner.lookup('service:auth');
      assert.equal(authService, appRoute.get('authService'), 'service.auth is injected');
    };

    return _class4;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Route with engines',
  /*#__PURE__*/
  function (_AbstractTestCase5) {
    (0, _emberBabel.inheritsLoose)(_class5, _AbstractTestCase5);

    function _class5() {
      return _AbstractTestCase5.apply(this, arguments) || this;
    }

    var _proto5 = _class5.prototype;

    _proto5["@test paramsFor considers an engine's mountPoint"] = function testParamsForConsidersAnEngineSMountPoint(assert) {
      var router = {
        _deserializeQueryParams: function () {},
        _routerMicrolib: {
          state: {
            routeInfos: [{
              name: 'posts'
            }],
            params: {
              'foo.bar': {
                a: 'b'
              },
              'foo.bar.posts': {
                c: 'd'
              }
            }
          }
        }
      };
      var engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true,
          mountPoint: 'foo.bar',
          lookup: function (name) {
            if (name === 'route:posts') {
              return postsRoute;
            } else if (name === 'route:application') {
              return applicationRoute;
            }
          }
        }
      });

      var applicationRoute = _route.default.create({
        _router: router,
        routeName: 'application',
        fullRouteName: 'foo.bar'
      });

      var postsRoute = _route.default.create({
        _router: router,
        routeName: 'posts',
        fullRouteName: 'foo.bar.posts'
      });

      var route = _route.default.create({
        _router: router
      });

      (0, _owner.setOwner)(applicationRoute, engineInstance);
      (0, _owner.setOwner)(postsRoute, engineInstance);
      (0, _owner.setOwner)(route, engineInstance);
      assert.deepEqual(route.paramsFor('application'), {
        a: 'b'
      }, 'params match for root `application` route in engine');
      assert.deepEqual(route.paramsFor('posts'), {
        c: 'd'
      }, 'params match for `posts` route in engine');
    };

    _proto5["@test modelFor considers an engine's mountPoint"] = function testModelForConsidersAnEngineSMountPoint(assert) {
      var applicationModel = {
        id: '1'
      };
      var postsModel = {
        id: '2'
      };
      var router = {
        _routerMicrolib: {
          activeTransition: {
            resolvedModels: {
              'foo.bar': applicationModel,
              'foo.bar.posts': postsModel
            }
          }
        }
      };
      var engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true,
          mountPoint: 'foo.bar',
          lookup: function (name) {
            if (name === 'route:posts') {
              return postsRoute;
            } else if (name === 'route:application') {
              return applicationRoute;
            }
          }
        }
      });

      var applicationRoute = _route.default.create({
        _router: router,
        routeName: 'application'
      });

      var postsRoute = _route.default.create({
        _router: router,
        routeName: 'posts'
      });

      var route = _route.default.create({
        _router: router
      });

      (0, _owner.setOwner)(applicationRoute, engineInstance);
      (0, _owner.setOwner)(postsRoute, engineInstance);
      (0, _owner.setOwner)(route, engineInstance);
      assert.strictEqual(route.modelFor('application'), applicationModel);
      assert.strictEqual(route.modelFor('posts'), postsModel);
    };

    _proto5["@test transitionTo considers an engine's mountPoint"] = function testTransitionToConsidersAnEngineSMountPoint(assert) {
      var router = {
        transitionTo: function (route) {
          return route;
        }
      };
      var engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true,
          mountPoint: 'foo.bar'
        }
      });

      var route = _route.default.create({
        _router: router
      });

      (0, _owner.setOwner)(route, engineInstance);
      assert.strictEqual(route.transitionTo('application'), 'foo.bar.application', 'properly prefixes application route');
      assert.strictEqual(route.transitionTo('posts'), 'foo.bar.posts', 'properly prefixes child routes');
      assert.throws(function () {
        return route.transitionTo('/posts');
      }, 'throws when trying to use a url');
      var queryParams = {};
      assert.strictEqual(route.transitionTo(queryParams), queryParams, 'passes query param only transitions through');
    };

    _proto5["@test intermediateTransitionTo considers an engine's mountPoint"] = function testIntermediateTransitionToConsidersAnEngineSMountPoint(assert) {
      var lastRoute;
      var router = {
        intermediateTransitionTo: function (route) {
          lastRoute = route;
        }
      };
      var engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true,
          mountPoint: 'foo.bar'
        }
      });

      var route = _route.default.create({
        _router: router
      });

      (0, _owner.setOwner)(route, engineInstance);
      route.intermediateTransitionTo('application');
      assert.strictEqual(lastRoute, 'foo.bar.application', 'properly prefixes application route');
      route.intermediateTransitionTo('posts');
      assert.strictEqual(lastRoute, 'foo.bar.posts', 'properly prefixes child routes');
      assert.throws(function () {
        return route.intermediateTransitionTo('/posts');
      }, 'throws when trying to use a url');
      var queryParams = {};
      route.intermediateTransitionTo(queryParams);
      assert.strictEqual(lastRoute, queryParams, 'passes query param only transitions through');
    };

    _proto5["@test replaceWith considers an engine's mountPoint"] = function testReplaceWithConsidersAnEngineSMountPoint(assert) {
      var router = {
        replaceWith: function (route) {
          return route;
        }
      };
      var engineInstance = (0, _internalTestHelpers.buildOwner)({
        ownerOptions: {
          routable: true,
          mountPoint: 'foo.bar'
        }
      });

      var route = _route.default.create({
        _router: router
      });

      (0, _owner.setOwner)(route, engineInstance);
      assert.strictEqual(route.replaceWith('application'), 'foo.bar.application', 'properly prefixes application route');
      assert.strictEqual(route.replaceWith('posts'), 'foo.bar.posts', 'properly prefixes child routes');
      assert.throws(function () {
        return route.replaceWith('/posts');
      }, 'throws when trying to use a url');
      var queryParams = {};
      assert.strictEqual(route.replaceWith(queryParams), queryParams, 'passes query param only transitions through');
    };

    return _class5;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/routing/tests/system/router_test", ["ember-babel", "@ember/-internals/owner", "@ember/-internals/routing/lib/location/hash_location", "@ember/-internals/routing/lib/location/history_location", "@ember/-internals/routing/lib/location/auto_location", "@ember/-internals/routing/lib/location/none_location", "@ember/-internals/routing/lib/system/router", "internal-test-helpers"], function (_emberBabel, _owner, _hash_location, _history_location, _auto_location, _none_location, _router, _internalTestHelpers) {
  "use strict";

  var owner;

  function createRouter(settings) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var CustomRouter = _router.default.extend();

    var router = CustomRouter.create(settings);

    if (!options.skipOwner) {
      (0, _owner.setOwner)(router, owner);
    }

    if (!options.disableSetup) {
      router.setupRouter();
    }

    return router;
  }

  (0, _internalTestHelpers.moduleFor)('Ember Router',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      owner = (0, _internalTestHelpers.buildOwner)(); //register the HashLocation (the default)

      owner.register('location:hash', _hash_location.default);
      owner.register('location:history', _history_location.default);
      owner.register('location:auto', _auto_location.default);
      owner.register('location:none', _none_location.default);
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _internalTestHelpers.runDestroy)(owner);
      owner = null;
    };

    _proto['@test can create a router without an owner'] = function testCanCreateARouterWithoutAnOwner(assert) {
      createRouter(undefined, {
        disableSetup: true,
        skipOwner: true
      });
      assert.ok(true, 'no errors were thrown when creating without a container');
    };

    _proto['@test [GH#15237] EmberError is imported correctly'] = function testGH15237EmberErrorIsImportedCorrectly(assert) {
      // If we get the right message it means Error is being imported correctly.
      assert.throws(function () {
        (0, _router.triggerEvent)(null, false, []);
      }, /because your app hasn't finished transitioning/);
    };

    _proto['@test should not create a router.js instance upon init'] = function testShouldNotCreateARouterJsInstanceUponInit(assert) {
      var router = createRouter(undefined, {
        disableSetup: true
      });
      assert.ok(!router._routerMicrolib);
    };

    _proto['@test should not reify location until setupRouter is called'] = function testShouldNotReifyLocationUntilSetupRouterIsCalled(assert) {
      var router = createRouter(undefined, {
        disableSetup: true
      });
      assert.equal(typeof router.location, 'string', 'location is specified as a string');
      router.setupRouter();
      assert.equal(typeof router.location, 'object', 'location is reified into an object');
    };

    _proto['@test should destroy its location upon destroying the routers owner.'] = function testShouldDestroyItsLocationUponDestroyingTheRoutersOwner(assert) {
      var router = createRouter();
      var location = router.get('location');
      (0, _internalTestHelpers.runDestroy)(owner);
      assert.ok(location.isDestroyed, 'location should be destroyed');
    };

    _proto['@test should instantiate its location with its `rootURL`'] = function testShouldInstantiateItsLocationWithItsRootURL(assert) {
      var router = createRouter({
        rootURL: '/rootdir/'
      });
      var location = router.get('location');
      assert.equal(location.get('rootURL'), '/rootdir/');
    };

    _proto['@test replacePath should be called with the right path'] = function testReplacePathShouldBeCalledWithTheRightPath(assert) {
      assert.expect(1);
      var location = owner.lookup('location:auto');
      var browserLocation = {
        href: 'http://test.com/rootdir/welcome',
        origin: 'http://test.com',
        pathname: '/rootdir/welcome',
        hash: '',
        search: '',
        replace: function (url) {
          assert.equal(url, 'http://test.com/rootdir/#/welcome');
        }
      };
      location.location = browserLocation;
      location.global = {
        onhashchange: function () {}
      };
      location.history = null;
      createRouter({
        location: 'auto',
        rootURL: '/rootdir/'
      });
    };

    _proto['@test Router._routePath should consume identical prefixes'] = function testRouter_routePathShouldConsumeIdenticalPrefixes(assert) {
      createRouter();

      function routePath() {
        var routeInfos = Array.prototype.slice.call(arguments).map(function (s) {
          return {
            name: s
          };
        });
        routeInfos.unshift({
          name: 'ignored'
        });
        return _router.default._routePath(routeInfos);
      }

      assert.equal(routePath('foo'), 'foo');
      assert.equal(routePath('foo', 'bar', 'baz'), 'foo.bar.baz');
      assert.equal(routePath('foo', 'foo.bar'), 'foo.bar');
      assert.equal(routePath('foo', 'foo.bar', 'foo.bar.baz'), 'foo.bar.baz');
      assert.equal(routePath('foo', 'foo.bar', 'foo.bar.baz.wow'), 'foo.bar.baz.wow');
      assert.equal(routePath('foo', 'foo.bar.baz.wow'), 'foo.bar.baz.wow');
      assert.equal(routePath('foo.bar', 'bar.baz.wow'), 'foo.bar.baz.wow'); // This makes no sense, not trying to handle it, just
      // making sure it doesn't go boom.

      assert.equal(routePath('foo.bar.baz', 'foo'), 'foo.bar.baz.foo');
    };

    _proto['@test Router should cancel routing setup when the Location class says so via cancelRouterSetup'] = function testRouterShouldCancelRoutingSetupWhenTheLocationClassSaysSoViaCancelRouterSetup(assert) {
      assert.expect(0);
      var router;
      var FakeLocation = {
        cancelRouterSetup: true,
        create: function () {
          return this;
        }
      };
      owner.register('location:fake', FakeLocation);
      router = createRouter({
        location: 'fake',
        _setupRouter: function () {
          assert.ok(false, '_setupRouter should not be called');
        }
      });
      router.startRouting();
    };

    _proto["@test AutoLocation should replace the url when it's not in the preferred format"] = function testAutoLocationShouldReplaceTheUrlWhenItSNotInThePreferredFormat(assert) {
      assert.expect(1);
      var location = owner.lookup('location:auto');
      location.location = {
        href: 'http://test.com/rootdir/welcome',
        origin: 'http://test.com',
        pathname: '/rootdir/welcome',
        hash: '',
        search: '',
        replace: function (url) {
          assert.equal(url, 'http://test.com/rootdir/#/welcome');
        }
      };
      location.history = null;
      location.global = {
        onhashchange: function () {}
      };
      createRouter({
        location: 'auto',
        rootURL: '/rootdir/'
      });
    };

    _proto['@test Router#handleURL should remove any #hashes before doing URL transition'] = function testRouterHandleURLShouldRemoveAnyHashesBeforeDoingURLTransition(assert) {
      assert.expect(2);
      var router = createRouter({
        _doURLTransition: function (routerJsMethod, url) {
          assert.equal(routerJsMethod, 'handleURL');
          assert.equal(url, '/foo/bar?time=morphin');
        }
      });
      router.handleURL('/foo/bar?time=morphin#pink-power-ranger');
    };

    _proto['@test Router#triggerEvent allows actions to bubble when returning true'] = function testRouterTriggerEventAllowsActionsToBubbleWhenReturningTrue(assert) {
      assert.expect(2);
      var routeInfos = [{
        name: 'application',
        route: {
          actions: {
            loading: function () {
              assert.ok(false, 'loading not handled by application route');
            }
          }
        }
      }, {
        name: 'about',
        route: {
          actions: {
            loading: function () {
              assert.ok(true, 'loading handled by about route');
              return false;
            }
          }
        }
      }, {
        name: 'about.me',
        route: {
          actions: {
            loading: function () {
              assert.ok(true, 'loading handled by about.me route');
              return true;
            }
          }
        }
      }];
      (0, _router.triggerEvent)(routeInfos, false, ['loading']);
    };

    _proto['@test Router#triggerEvent ignores handlers that have not loaded yet'] = function testRouterTriggerEventIgnoresHandlersThatHaveNotLoadedYet(assert) {
      assert.expect(1);
      var routeInfos = [{
        name: 'about',
        route: {
          actions: {
            loading: function () {
              assert.ok(true, 'loading handled by about route');
            }
          }
        }
      }, {
        name: 'about.me',
        route: undefined
      }];
      (0, _router.triggerEvent)(routeInfos, false, ['loading']);
    };

    _proto['@test transitionTo should throw an error when called after owner is destroyed'] = function testTransitionToShouldThrowAnErrorWhenCalledAfterOwnerIsDestroyed() {
      var router = createRouter();
      (0, _internalTestHelpers.runDestroy)(router);
      router.currentRouteName = 'route-a';
      expectAssertion(function () {
        router.transitionTo('route-b');
      }, "A transition was attempted from 'route-a' to 'route-b' but the application instance has already been destroyed.");
      expectAssertion(function () {
        router.transitionTo('./route-b/1');
      }, "A transition was attempted from 'route-a' to './route-b/1' but the application instance has already been destroyed.");
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/routing/tests/utils_test", ["ember-babel", "@ember/-internals/routing/lib/utils", "internal-test-helpers"], function (_emberBabel, _utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Routing query parameter utils - normalizeControllerQueryParams',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test converts array style into verbose object style'] = function testConvertsArrayStyleIntoVerboseObjectStyle(assert) {
      var paramName = 'foo';
      var params = [paramName];
      var normalized = (0, _utils.normalizeControllerQueryParams)(params);
      assert.ok(normalized[paramName], 'turns the query param name into key');
      assert.equal(normalized[paramName].as, null, "includes a blank alias in 'as' key");
      assert.equal(normalized[paramName].scope, 'model', 'defaults scope to model');
    };

    _proto["@test converts object style [{foo: 'an_alias'}]"] = function testConvertsObjectStyleFooAn_alias(assert) {
      var paramName = 'foo';
      var params = [{
        foo: 'an_alias'
      }];
      var normalized = (0, _utils.normalizeControllerQueryParams)(params);
      assert.ok(normalized[paramName], 'retains the query param name as key');
      assert.equal(normalized[paramName].as, 'an_alias', "includes the provided alias in 'as' key");
      assert.equal(normalized[paramName].scope, 'model', 'defaults scope to model');
    };

    _proto["@test retains maximally verbose object style [{foo: {as: 'foo'}}]"] = function testRetainsMaximallyVerboseObjectStyleFooAsFoo(assert) {
      var paramName = 'foo';
      var params = [{
        foo: {
          as: 'an_alias'
        }
      }];
      var normalized = (0, _utils.normalizeControllerQueryParams)(params);
      assert.ok(normalized[paramName], 'retains the query param name as key');
      assert.equal(normalized[paramName].as, 'an_alias', "includes the provided alias in 'as' key");
      assert.equal(normalized[paramName].scope, 'model', 'defaults scope to model');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/array/any-test", ["ember-babel", "@ember/-internals/runtime/lib/mixins/array", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _array, _internalTestHelpers, _array2) {
  "use strict";

  var AnyTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(AnyTests, _AbstractTestCase);

    function AnyTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = AnyTests.prototype;

    _proto['@test any should should invoke callback on each item as long as you return false'] = function testAnyShouldShouldInvokeCallbackOnEachItemAsLongAsYouReturnFalse() {
      var obj = this.newObject();
      var ary = this.toArray(obj);
      var found = [];
      var result;
      result = obj.any(function (i) {
        found.push(i);
        return false;
      });
      this.assert.equal(result, false, 'return value of obj.any');
      this.assert.deepEqual(found, ary, 'items passed during any() should match');
    };

    _proto['@test any should stop invoking when you return true'] = function testAnyShouldStopInvokingWhenYouReturnTrue() {
      var obj = this.newObject();
      var ary = this.toArray(obj);
      var cnt = ary.length - 2;
      var exp = cnt;
      var found = [];
      var result;
      result = obj.any(function (i) {
        found.push(i);
        return --cnt <= 0;
      });
      this.assert.equal(result, true, 'return value of obj.any');
      this.assert.equal(found.length, exp, 'should invoke proper number of times');
      this.assert.deepEqual(found, ary.slice(0, -2), 'items passed during any() should match');
    };

    _proto['@test any should return true if any object matches the callback'] = function testAnyShouldReturnTrueIfAnyObjectMatchesTheCallback() {
      var obj = (0, _array.A)([0, 1, 2]);
      var result;
      result = obj.any(function (i) {
        return Boolean(i);
      });
      this.assert.equal(result, true, 'return value of obj.any');
    };

    _proto['@test any should produce correct results even if the matching element is undefined'] = function testAnyShouldProduceCorrectResultsEvenIfTheMatchingElementIsUndefined(assert) {
      var obj = (0, _array.A)([undefined]);
      var result;
      result = obj.any(function () {
        return true;
      });
      assert.equal(result, true, 'return value of obj.any');
    };

    return AnyTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array2.runArrayTests)('any', AnyTests);
});
enifed("@ember/-internals/runtime/tests/array/apply-test", ["ember-babel", "@ember/-internals/runtime/lib/mixins/array", "internal-test-helpers"], function (_emberBabel, _array, _internalTestHelpers) {
  "use strict";

  var ArrayPrototypeExtensionSelfReferenceTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(ArrayPrototypeExtensionSelfReferenceTests, _AbstractTestCase);

    function ArrayPrototypeExtensionSelfReferenceTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = ArrayPrototypeExtensionSelfReferenceTests.prototype;

    _proto['@test should not create non-Symbol, enumerable properties that refer to itself'] = function testShouldNotCreateNonSymbolEnumerablePropertiesThatReferToItself() {
      // Don't want to pollute Array.prototype so we make a fake / simple prototype
      function ThrowAwayArray() {} // Extend our throw-away prototype (like EXTEND_PROTOTYPES.Array would)


      _array.NativeArray.apply(ThrowAwayArray.prototype); // Create an instance to test


      var obj = new ThrowAwayArray(); // Make sure that no enumerable properties refer back to the object (creating a cyclic structure)

      for (var p in obj) {
        this.assert.notStrictEqual(obj[p], obj, ("Property \"" + p + "\" is an enumerable part of the prototype\n        so must not refer back to the original array.\n        Otherwise code that explores all properties,\n        such as jQuery.extend and other \"deep cloning\" functions,\n        will get stuck in an infinite loop.\n        ").replace(/\s+/g, ' '));
      }
    };

    return ArrayPrototypeExtensionSelfReferenceTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _internalTestHelpers.moduleFor)("NativeArray: apply", ArrayPrototypeExtensionSelfReferenceTests);
});
enifed("@ember/-internals/runtime/tests/array/compact-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _internalTestHelpers, _array) {
  "use strict";

  var CompactTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(CompactTests, _AbstractTestCase);

    function CompactTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = CompactTests.prototype;

    _proto['@test removes null and undefined values from enumerable'] = function testRemovesNullAndUndefinedValuesFromEnumerable() {
      var obj = this.newObject([null, 1, false, '', undefined, 0, null]);
      var ary = obj.compact();
      this.assert.deepEqual(ary, [1, false, '', 0]);
    };

    return CompactTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('compact', CompactTests);
});
enifed("@ember/-internals/runtime/tests/array/every-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/-internals/runtime/lib/system/object"], function (_emberBabel, _internalTestHelpers, _array, _object) {
  "use strict";

  var EveryTest =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(EveryTest, _AbstractTestCase);

    function EveryTest() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = EveryTest.prototype;

    _proto['@test every should should invoke callback on each item as long as you return true'] = function testEveryShouldShouldInvokeCallbackOnEachItemAsLongAsYouReturnTrue() {
      var obj = this.newObject();
      var ary = this.toArray(obj);
      var found = [];
      var result;
      result = obj.every(function (i) {
        found.push(i);
        return true;
      });
      this.assert.equal(result, true, 'return value of obj.every');
      this.assert.deepEqual(found, ary, 'items passed during every() should match');
    };

    _proto['@test every should stop invoking when you return false'] = function testEveryShouldStopInvokingWhenYouReturnFalse() {
      var obj = this.newObject();
      var ary = this.toArray(obj);
      var cnt = ary.length - 2;
      var exp = cnt;
      var found = [];
      var result;
      result = obj.every(function (i) {
        found.push(i);
        return --cnt > 0;
      });
      this.assert.equal(result, false, 'return value of obj.every');
      this.assert.equal(found.length, exp, 'should invoke proper number of times');
      this.assert.deepEqual(found, ary.slice(0, -2), 'items passed during every() should match');
    };

    return EveryTest;
  }(_internalTestHelpers.AbstractTestCase);

  var IsEveryTest =
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(IsEveryTest, _AbstractTestCase2);

    function IsEveryTest() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = IsEveryTest.prototype;

    _proto2['@test should return true of every property matches'] = function testShouldReturnTrueOfEveryPropertyMatches() {
      var obj = this.newObject([{
        foo: 'foo',
        bar: 'BAZ'
      }, _object.default.create({
        foo: 'foo',
        bar: 'bar'
      })]);
      this.assert.equal(obj.isEvery('foo', 'foo'), true, 'isEvery(foo)');
      this.assert.equal(obj.isEvery('bar', 'bar'), false, 'isEvery(bar)');
    };

    _proto2['@test should return true of every property is true'] = function testShouldReturnTrueOfEveryPropertyIsTrue() {
      var obj = this.newObject([{
        foo: 'foo',
        bar: true
      }, _object.default.create({
        foo: 'bar',
        bar: false
      })]); // different values - all eval to true

      this.assert.equal(obj.isEvery('foo'), true, 'isEvery(foo)');
      this.assert.equal(obj.isEvery('bar'), false, 'isEvery(bar)');
    };

    _proto2['@test should return true if every property matches null'] = function testShouldReturnTrueIfEveryPropertyMatchesNull() {
      var obj = this.newObject([{
        foo: null,
        bar: 'BAZ'
      }, _object.default.create({
        foo: null,
        bar: null
      })]);
      this.assert.equal(obj.isEvery('foo', null), true, "isEvery('foo', null)");
      this.assert.equal(obj.isEvery('bar', null), false, "isEvery('bar', null)");
    };

    _proto2['@test should return true if every property is undefined'] = function testShouldReturnTrueIfEveryPropertyIsUndefined() {
      var obj = this.newObject([{
        foo: undefined,
        bar: 'BAZ'
      }, _object.default.create({
        bar: undefined
      })]);
      this.assert.equal(obj.isEvery('foo', undefined), true, "isEvery('foo', undefined)");
      this.assert.equal(obj.isEvery('bar', undefined), false, "isEvery('bar', undefined)");
    };

    return IsEveryTest;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('every', EveryTest);
  (0, _array.runArrayTests)('isEvery', IsEveryTest);
});
enifed("@ember/-internals/runtime/tests/array/filter-test", ["ember-babel", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _object, _internalTestHelpers, _array) {
  "use strict";

  var FilterTest =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(FilterTest, _AbstractTestCase);

    function FilterTest() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = FilterTest.prototype;

    _proto['@test filter should invoke on each item'] = function testFilterShouldInvokeOnEachItem() {
      var obj = this.newObject();
      var ary = this.toArray(obj);
      var cnt = ary.length - 2;
      var found = [];
      var result; // return true on all but the last two

      result = obj.filter(function (i) {
        found.push(i);
        return --cnt >= 0;
      });
      this.assert.deepEqual(found, ary, 'should have invoked on each item');
      this.assert.deepEqual(result, ary.slice(0, -2), 'filtered array should exclude items');
    };

    return FilterTest;
  }(_internalTestHelpers.AbstractTestCase);

  var FilterByTest =
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(FilterByTest, _AbstractTestCase2);

    function FilterByTest() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = FilterByTest.prototype;

    _proto2['@test should filter based on object'] = function testShouldFilterBasedOnObject() {
      var obj, ary;
      ary = [{
        foo: 'foo',
        bar: 'BAZ'
      }, _object.default.create({
        foo: 'foo',
        bar: 'bar'
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.filterBy('foo', 'foo'), ary, 'filterBy(foo)');
      this.assert.deepEqual(obj.filterBy('bar', 'bar'), [ary[1]], 'filterBy(bar)');
    };

    _proto2['@test should include in result if property is true'] = function testShouldIncludeInResultIfPropertyIsTrue() {
      var obj, ary;
      ary = [{
        foo: 'foo',
        bar: true
      }, _object.default.create({
        foo: 'bar',
        bar: false
      })];
      obj = this.newObject(ary); // different values - all eval to true

      this.assert.deepEqual(obj.filterBy('foo'), ary, 'filterBy(foo)');
      this.assert.deepEqual(obj.filterBy('bar'), [ary[0]], 'filterBy(bar)');
    };

    _proto2['@test should filter on second argument if provided'] = function testShouldFilterOnSecondArgumentIfProvided() {
      var obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: 2
      }), {
        name: 'obj3',
        foo: 2
      }, _object.default.create({
        name: 'obj4',
        foo: 3
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.filterBy('foo', 3), [ary[0], ary[3]], "filterBy('foo', 3)')");
    };

    _proto2['@test should correctly filter null second argument'] = function testShouldCorrectlyFilterNullSecondArgument() {
      var obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: null
      }), {
        name: 'obj3',
        foo: null
      }, _object.default.create({
        name: 'obj4',
        foo: 3
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.filterBy('foo', null), [ary[1], ary[2]], "filterBy('foo', 3)')");
    };

    _proto2['@test should not return all objects on undefined second argument'] = function testShouldNotReturnAllObjectsOnUndefinedSecondArgument() {
      var obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: 2
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.filterBy('foo', undefined), [], "filterBy('foo', 3)')");
    };

    _proto2['@test should correctly filter explicit undefined second argument'] = function testShouldCorrectlyFilterExplicitUndefinedSecondArgument() {
      var obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: 3
      }), {
        name: 'obj3',
        foo: undefined
      }, _object.default.create({
        name: 'obj4',
        foo: undefined
      }), {
        name: 'obj5'
      }, _object.default.create({
        name: 'obj6'
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.filterBy('foo', undefined), ary.slice(2), "filterBy('foo', 3)')");
    };

    _proto2['@test should not match undefined properties without second argument'] = function testShouldNotMatchUndefinedPropertiesWithoutSecondArgument() {
      var obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: 3
      }), {
        name: 'obj3',
        foo: undefined
      }, _object.default.create({
        name: 'obj4',
        foo: undefined
      }), {
        name: 'obj5'
      }, _object.default.create({
        name: 'obj6'
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.filterBy('foo'), ary.slice(0, 2), "filterBy('foo', 3)')");
    };

    return FilterByTest;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('filter', FilterTest);
  (0, _array.runArrayTests)('filter', FilterByTest);
});
enifed("@ember/-internals/runtime/tests/array/find-test", ["ember-babel", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _object, _internalTestHelpers, _array) {
  "use strict";

  var FindTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(FindTests, _AbstractTestCase);

    function FindTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = FindTests.prototype;

    _proto['@test find should invoke callback on each item as long as you return false'] = function testFindShouldInvokeCallbackOnEachItemAsLongAsYouReturnFalse() {
      var obj = this.newObject();
      var ary = this.toArray(obj);
      var found = [];
      var result;
      result = obj.find(function (i) {
        found.push(i);
        return false;
      });
      this.assert.equal(result, undefined, 'return value of obj.find');
      this.assert.deepEqual(found, ary, 'items passed during find() should match');
    };

    _proto['@test every should stop invoking when you return true'] = function testEveryShouldStopInvokingWhenYouReturnTrue() {
      var obj = this.newObject();
      var ary = this.toArray(obj);
      var cnt = ary.length - 2;
      var exp = cnt;
      var found = [];
      var result;
      result = obj.find(function (i) {
        found.push(i);
        return --cnt >= 0;
      });
      this.assert.equal(result, ary[exp - 1], 'return value of obj.find');
      this.assert.equal(found.length, exp, 'should invoke proper number of times');
      this.assert.deepEqual(found, ary.slice(0, -2), 'items passed during find() should match');
    };

    return FindTests;
  }(_internalTestHelpers.AbstractTestCase);

  var FindByTests =
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(FindByTests, _AbstractTestCase2);

    function FindByTests() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = FindByTests.prototype;

    _proto2['@test should return first object of property matches'] = function testShouldReturnFirstObjectOfPropertyMatches() {
      var ary, obj;
      ary = [{
        foo: 'foo',
        bar: 'BAZ'
      }, _object.default.create({
        foo: 'foo',
        bar: 'bar'
      })];
      obj = this.newObject(ary);
      this.assert.equal(obj.findBy('foo', 'foo'), ary[0], 'findBy(foo)');
      this.assert.equal(obj.findBy('bar', 'bar'), ary[1], 'findBy(bar)');
    };

    _proto2['@test should return first object with truthy prop'] = function testShouldReturnFirstObjectWithTruthyProp() {
      var ary, obj;
      ary = [{
        foo: 'foo',
        bar: false
      }, _object.default.create({
        foo: 'bar',
        bar: true
      })];
      obj = this.newObject(ary); // different values - all eval to true

      this.assert.equal(obj.findBy('foo'), ary[0], 'findBy(foo)');
      this.assert.equal(obj.findBy('bar'), ary[1], 'findBy(bar)');
    };

    _proto2['@test should return first null property match'] = function testShouldReturnFirstNullPropertyMatch() {
      var ary, obj;
      ary = [{
        foo: null,
        bar: 'BAZ'
      }, _object.default.create({
        foo: null,
        bar: null
      })];
      obj = this.newObject(ary);
      this.assert.equal(obj.findBy('foo', null), ary[0], "findBy('foo', null)");
      this.assert.equal(obj.findBy('bar', null), ary[1], "findBy('bar', null)");
    };

    _proto2['@test should return first undefined property match'] = function testShouldReturnFirstUndefinedPropertyMatch() {
      var ary, obj;
      ary = [{
        foo: undefined,
        bar: 'BAZ'
      }, _object.default.create({})];
      obj = this.newObject(ary);
      this.assert.equal(obj.findBy('foo', undefined), ary[0], "findBy('foo', undefined)");
      this.assert.equal(obj.findBy('bar', undefined), ary[1], "findBy('bar', undefined)");
    };

    return FindByTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('find', FindTests);
  (0, _array.runArrayTests)('findBy', FindByTests);
});
enifed("@ember/-internals/runtime/tests/array/firstObject-test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _metal, _internalTestHelpers, _array) {
  "use strict";

  var FirstObjectTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(FirstObjectTests, _AbstractTestCase);

    function FirstObjectTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = FirstObjectTests.prototype;

    _proto['@test returns first item in enumerable'] = function testReturnsFirstItemInEnumerable() {
      var obj = this.newObject();
      this.assert.equal((0, _metal.get)(obj, 'firstObject'), this.toArray(obj)[0]);
    };

    _proto['@test returns undefined if enumerable is empty'] = function testReturnsUndefinedIfEnumerableIsEmpty() {
      var obj = this.newObject([]);
      this.assert.equal((0, _metal.get)(obj, 'firstObject'), undefined);
    };

    _proto['@test can not be set'] = function testCanNotBeSet() {
      var obj = this.newObject([]);
      this.assert.equal((0, _metal.get)(obj, 'firstObject'), this.toArray(obj)[0]);
      this.assert.throws(function () {
        (0, _metal.set)(obj, 'firstObject', 'foo!');
      }, /Cannot set read-only property "firstObject" on object/);
    };

    return FirstObjectTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('firstObject', FirstObjectTests);
});
enifed("@ember/-internals/runtime/tests/array/forEach-test", ["ember-babel", "@ember/-internals/utils", "@ember/-internals/metal", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _utils, _metal, _internalTestHelpers, _array) {
  "use strict";

  var ForEachTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(ForEachTests, _AbstractTestCase);

    function ForEachTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = ForEachTests.prototype;

    _proto['@test forEach should iterate over list'] = function testForEachShouldIterateOverList() {
      var obj = this.newObject();
      var ary = this.toArray(obj);
      var found = [];
      obj.forEach(function (i) {
        return found.push(i);
      });
      this.assert.deepEqual(found, ary, 'items passed during forEach should match');
    };

    _proto['@test forEach should iterate over list after mutation'] = function testForEachShouldIterateOverListAfterMutation() {
      if ((0, _metal.get)(this, 'canTestMutation')) {
        this.assert.expect(0);
        return;
      }

      var obj = this.newObject();
      var ary = this.toArray(obj);
      var found = [];
      obj.forEach(function (i) {
        return found.push(i);
      });
      this.assert.deepEqual(found, ary, 'items passed during forEach should match');
      this.mutate(obj);
      ary = this.toArray(obj);
      found = [];
      obj.forEach(function (i) {
        return found.push(i);
      });
      this.assert.deepEqual(found, ary, 'items passed during forEach should match');
    };

    _proto['@test 2nd target parameter'] = function test2ndTargetParameter() {
      var _this = this;

      var obj = this.newObject();
      var target = this;
      obj.forEach(function () {// ES6TODO: When transpiled we will end up with "use strict" which disables automatically binding to the global context.
        // Therefore, the following test can never pass in strict mode unless we modify the `map` function implementation to
        // use `Ember.lookup` if target is not specified.
        //
        // equal(guidFor(this), guidFor(global), 'should pass the global object as this if no context');
      });
      obj.forEach(function () {
        _this.assert.equal((0, _utils.guidFor)(_this), (0, _utils.guidFor)(target), 'should pass target as this if context');
      }, target);
    };

    _proto['@test callback params'] = function testCallbackParams() {
      var _this2 = this;

      var obj = this.newObject();
      var ary = this.toArray(obj);
      var loc = 0;
      obj.forEach(function (item, idx, enumerable) {
        _this2.assert.equal(item, ary[loc], 'item param');

        _this2.assert.equal(idx, loc, 'idx param');

        _this2.assert.equal((0, _utils.guidFor)(enumerable), (0, _utils.guidFor)(obj), 'enumerable param');

        loc++;
      });
    };

    return ForEachTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('forEach', ForEachTests);
});
enifed("@ember/-internals/runtime/tests/array/includes-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _internalTestHelpers, _array) {
  "use strict";

  var IncludesTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(IncludesTests, _AbstractTestCase);

    function IncludesTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = IncludesTests.prototype;

    _proto['@test includes returns correct value if startAt is positive'] = function testIncludesReturnsCorrectValueIfStartAtIsPositive() {
      var data = (0, _array.newFixture)(3);
      var obj = this.newObject(data);
      this.assert.equal(obj.includes(data[1], 1), true, 'should return true if included');
      this.assert.equal(obj.includes(data[0], 1), false, 'should return false if not included');
    };

    _proto['@test includes returns correct value if startAt is negative'] = function testIncludesReturnsCorrectValueIfStartAtIsNegative() {
      var data = (0, _array.newFixture)(3);
      var obj = this.newObject(data);
      this.assert.equal(obj.includes(data[1], -2), true, 'should return true if included');
      this.assert.equal(obj.includes(data[0], -2), false, 'should return false if not included');
    };

    _proto['@test includes returns true if startAt + length is still negative'] = function testIncludesReturnsTrueIfStartAtLengthIsStillNegative() {
      var data = (0, _array.newFixture)(1);
      var obj = this.newObject(data);
      this.assert.equal(obj.includes(data[0], -2), true, 'should return true if included');
      this.assert.equal(obj.includes((0, _array.newFixture)(1), -2), false, 'should return false if not included');
    };

    _proto['@test includes returns false if startAt out of bounds'] = function testIncludesReturnsFalseIfStartAtOutOfBounds() {
      var data = (0, _array.newFixture)(1);
      var obj = this.newObject(data);
      this.assert.equal(obj.includes(data[0], 2), false, 'should return false if startAt >= length');
      this.assert.equal(obj.includes((0, _array.newFixture)(1), 2), false, 'should return false if startAt >= length');
    };

    return IncludesTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('includes', IncludesTests);
});
enifed("@ember/-internals/runtime/tests/array/indexOf-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _internalTestHelpers, _array) {
  "use strict";

  var IndexOfTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(IndexOfTests, _AbstractTestCase);

    function IndexOfTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = IndexOfTests.prototype;

    _proto['@test should return index of object'] = function testShouldReturnIndexOfObject() {
      var expected = (0, _array.newFixture)(3);
      var obj = this.newObject(expected);
      var len = 3;

      for (var idx = 0; idx < len; idx++) {
        this.assert.equal(obj.indexOf(expected[idx]), idx, "obj.indexOf(" + expected[idx] + ") should match idx");
      }
    };

    _proto['@test should return -1 when requesting object not in index'] = function testShouldReturn1WhenRequestingObjectNotInIndex() {
      var obj = this.newObject((0, _array.newFixture)(3));
      var foo = {};
      this.assert.equal(obj.indexOf(foo), -1, 'obj.indexOf(foo) should be < 0');
    };

    return IndexOfTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('indexOf', IndexOfTests);
});
enifed("@ember/-internals/runtime/tests/array/invoke-test", ["ember-babel", "@ember/-internals/runtime/index", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _index, _internalTestHelpers, _array) {
  "use strict";

  var InvokeTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(InvokeTests, _AbstractTestCase);

    function InvokeTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = InvokeTests.prototype;

    _proto['@test invoke should call on each object that implements'] = function testInvokeShouldCallOnEachObjectThatImplements() {
      var cnt, ary, obj;

      function F(amt) {
        cnt += amt === undefined ? 1 : amt;
      }

      cnt = 0;
      ary = [{
        foo: F
      }, _index.Object.create({
        foo: F
      }), // NOTE: does not impl foo - invoke should just skip
      _index.Object.create({
        bar: F
      }), {
        foo: F
      }];
      obj = this.newObject(ary);
      obj.invoke('foo');
      this.assert.equal(cnt, 3, 'should have invoked 3 times');
      cnt = 0;
      obj.invoke('foo', 2);
      this.assert.equal(cnt, 6, 'should have invoked 3 times, passing param');
    };

    _proto['@test invoke should return an array containing the results of each invoked method'] = function testInvokeShouldReturnAnArrayContainingTheResultsOfEachInvokedMethod(assert) {
      var obj = this.newObject([{
        foo: function () {
          return 'one';
        }
      }, {}, // intentionally not including `foo` method
      {
        foo: function () {
          return 'two';
        }
      }]);
      var result = obj.invoke('foo');
      assert.deepEqual(result, ['one', undefined, 'two']);
    };

    _proto['@test invoke should return an extended array (aka Ember.A)'] = function testInvokeShouldReturnAnExtendedArrayAkaEmberA(assert) {
      var obj = this.newObject([{
        foo: function () {}
      }, {
        foo: function () {}
      }]);
      var result = obj.invoke('foo');
      assert.ok(_index.NativeArray.detect(result), 'NativeArray has been applied');
    };

    return InvokeTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('invoke', InvokeTests);
});
enifed("@ember/-internals/runtime/tests/array/isAny-test", ["ember-babel", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _object, _internalTestHelpers, _array) {
  "use strict";

  var IsAnyTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(IsAnyTests, _AbstractTestCase);

    function IsAnyTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = IsAnyTests.prototype;

    _proto['@test should return true of any property matches'] = function testShouldReturnTrueOfAnyPropertyMatches() {
      var obj = this.newObject([{
        foo: 'foo',
        bar: 'BAZ'
      }, _object.default.create({
        foo: 'foo',
        bar: 'bar'
      })]);
      this.assert.equal(obj.isAny('foo', 'foo'), true, 'isAny(foo)');
      this.assert.equal(obj.isAny('bar', 'bar'), true, 'isAny(bar)');
      this.assert.equal(obj.isAny('bar', 'BIFF'), false, 'isAny(BIFF)');
    };

    _proto['@test should return true of any property is true'] = function testShouldReturnTrueOfAnyPropertyIsTrue() {
      var obj = this.newObject([{
        foo: 'foo',
        bar: true
      }, _object.default.create({
        foo: 'bar',
        bar: false
      })]); // different values - all eval to true

      this.assert.equal(obj.isAny('foo'), true, 'isAny(foo)');
      this.assert.equal(obj.isAny('bar'), true, 'isAny(bar)');
      this.assert.equal(obj.isAny('BIFF'), false, 'isAny(biff)');
    };

    _proto['@test should return true if any property matches null'] = function testShouldReturnTrueIfAnyPropertyMatchesNull() {
      var obj = this.newObject([{
        foo: null,
        bar: 'bar'
      }, _object.default.create({
        foo: 'foo',
        bar: null
      })]);
      this.assert.equal(obj.isAny('foo', null), true, "isAny('foo', null)");
      this.assert.equal(obj.isAny('bar', null), true, "isAny('bar', null)");
    };

    _proto['@test should return true if any property is undefined'] = function testShouldReturnTrueIfAnyPropertyIsUndefined() {
      var obj = this.newObject([{
        foo: undefined,
        bar: 'bar'
      }, _object.default.create({
        foo: 'foo'
      })]);
      this.assert.equal(obj.isAny('foo', undefined), true, "isAny('foo', undefined)");
      this.assert.equal(obj.isAny('bar', undefined), true, "isAny('bar', undefined)");
    };

    _proto['@test should not match undefined properties without second argument'] = function testShouldNotMatchUndefinedPropertiesWithoutSecondArgument() {
      var obj = this.newObject([{
        foo: undefined
      }, _object.default.create({})]);
      this.assert.equal(obj.isAny('foo'), false, "isAny('foo', undefined)");
    };

    return IsAnyTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('isAny', IsAnyTests);
});
enifed("@ember/-internals/runtime/tests/array/lastIndexOf-test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _metal, _internalTestHelpers, _array) {
  "use strict";

  var LastIndexOfTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(LastIndexOfTests, _AbstractTestCase);

    function LastIndexOfTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = LastIndexOfTests.prototype;

    _proto["@test should return index of object's last occurrence"] = function testShouldReturnIndexOfObjectSLastOccurrence() {
      var expected = (0, _array.newFixture)(3);
      var obj = this.newObject(expected);
      var len = 3;

      for (var idx = 0; idx < len; idx++) {
        this.assert.equal(obj.lastIndexOf(expected[idx]), idx, "obj.lastIndexOf(" + expected[idx] + ") should match idx");
      }
    };

    _proto["@test should return index of object's last occurrence even startAt search location is equal to length"] = function testShouldReturnIndexOfObjectSLastOccurrenceEvenStartAtSearchLocationIsEqualToLength() {
      var expected = (0, _array.newFixture)(3);
      var obj = this.newObject(expected);
      var len = 3;

      for (var idx = 0; idx < len; idx++) {
        this.assert.equal(obj.lastIndexOf(expected[idx], len), idx, "obj.lastIndexOfs(" + expected[idx] + ") should match idx");
      }
    };

    _proto["@test should return index of object's last occurrence even startAt search location is greater than length"] = function testShouldReturnIndexOfObjectSLastOccurrenceEvenStartAtSearchLocationIsGreaterThanLength() {
      var expected = (0, _array.newFixture)(3);
      var obj = this.newObject(expected);
      var len = 3;

      for (var idx = 0; idx < len; idx++) {
        this.assert.equal(obj.lastIndexOf(expected[idx], len + 1), idx, "obj.lastIndexOf(" + expected[idx] + ") should match idx");
      }
    };

    _proto['@test should return -1 when no match is found'] = function testShouldReturn1WhenNoMatchIsFound() {
      var obj = this.newObject((0, _array.newFixture)(3));
      var foo = {};
      this.assert.equal(obj.lastIndexOf(foo), -1, 'obj.lastIndexOf(foo) should be -1');
    };

    _proto['@test should return -1 when no match is found even startAt search location is equal to length'] = function testShouldReturn1WhenNoMatchIsFoundEvenStartAtSearchLocationIsEqualToLength() {
      var obj = this.newObject((0, _array.newFixture)(3));
      var foo = {};
      this.assert.equal(obj.lastIndexOf(foo, (0, _metal.get)(obj, 'length')), -1, 'obj.lastIndexOf(foo) should be -1');
    };

    _proto['@test should return -1 when no match is found even startAt search location is greater than length'] = function testShouldReturn1WhenNoMatchIsFoundEvenStartAtSearchLocationIsGreaterThanLength() {
      var obj = this.newObject((0, _array.newFixture)(3));
      var foo = {};
      this.assert.equal(obj.lastIndexOf(foo, (0, _metal.get)(obj, 'length') + 1), -1, 'obj.lastIndexOf(foo) should be -1');
    };

    return LastIndexOfTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('lastIndexOf', LastIndexOfTests);
});
enifed("@ember/-internals/runtime/tests/array/lastObject-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _array, _metal) {
  "use strict";

  var LastObjectTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(LastObjectTests, _AbstractTestCase);

    function LastObjectTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = LastObjectTests.prototype;

    _proto['@test returns last item in enumerable'] = function testReturnsLastItemInEnumerable() {
      var obj = this.newObject();
      var ary = this.toArray(obj);
      this.assert.equal((0, _metal.get)(obj, 'lastObject'), ary[ary.length - 1]);
    };

    _proto['@test returns undefined if enumerable is empty'] = function testReturnsUndefinedIfEnumerableIsEmpty() {
      var obj = this.newObject([]);
      this.assert.equal((0, _metal.get)(obj, 'lastObject'), undefined);
    };

    _proto['@test can not be set'] = function testCanNotBeSet() {
      var obj = this.newObject();
      var ary = this.toArray(obj);
      this.assert.equal((0, _metal.get)(obj, 'lastObject'), ary[ary.length - 1]);
      this.assert.throws(function () {
        (0, _metal.set)(obj, 'lastObject', 'foo!');
      }, /Cannot set read-only property "lastObject" on object/);
    };

    return LastObjectTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('lastObject', LastObjectTests);
});
enifed("@ember/-internals/runtime/tests/array/map-test", ["ember-babel", "@ember/-internals/utils", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/-internals/metal"], function (_emberBabel, _utils, _internalTestHelpers, _array, _metal) {
  "use strict";

  var mapFunc = function (item) {
    return item ? item.toString() : null;
  };

  var MapTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(MapTests, _AbstractTestCase);

    function MapTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = MapTests.prototype;

    _proto['@test map should iterate over list'] = function testMapShouldIterateOverList() {
      var obj = this.newObject();
      var ary = this.toArray(obj).map(mapFunc);
      var found = [];
      found = obj.map(mapFunc);
      this.assert.deepEqual(found, ary, 'mapped arrays should match');
    };

    _proto['@test map should iterate over list after mutation'] = function testMapShouldIterateOverListAfterMutation() {
      if ((0, _metal.get)(this, 'canTestMutation')) {
        this.assert.expect(0);
        return;
      }

      var obj = this.newObject();
      var ary = this.toArray(obj).map(mapFunc);
      var found;
      found = obj.map(mapFunc);
      this.assert.deepEqual(found, ary, 'items passed during forEach should match');
      this.mutate(obj);
      ary = this.toArray(obj).map(mapFunc);
      found = obj.map(mapFunc);
      this.assert.deepEqual(found, ary, 'items passed during forEach should match');
    };

    _proto['@test 2nd target parameter'] = function test2ndTargetParameter() {
      var _this = this;

      var obj = this.newObject();
      var target = this;
      obj.map(function () {// ES6TODO: When transpiled we will end up with "use strict" which disables automatically binding to the global context.
        // Therefore, the following test can never pass in strict mode unless we modify the `map` function implementation to
        // use `Ember.lookup` if target is not specified.
        //
        // equal(guidFor(this), guidFor(global), 'should pass the global object as this if no context');
      });
      obj.map(function () {
        _this.assert.equal((0, _utils.guidFor)(_this), (0, _utils.guidFor)(target), 'should pass target as this if context');
      }, target);
    };

    _proto['@test callback params'] = function testCallbackParams() {
      var _this2 = this;

      var obj = this.newObject();
      var ary = this.toArray(obj);
      var loc = 0;
      obj.map(function (item, idx, enumerable) {
        _this2.assert.equal(item, ary[loc], 'item param');

        _this2.assert.equal(idx, loc, 'idx param');

        _this2.assert.equal((0, _utils.guidFor)(enumerable), (0, _utils.guidFor)(obj), 'enumerable param');

        loc++;
      });
    };

    return MapTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('map', MapTests);
});
enifed("@ember/-internals/runtime/tests/array/mapBy-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _internalTestHelpers, _array) {
  "use strict";

  var MapByTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(MapByTests, _AbstractTestCase);

    function MapByTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = MapByTests.prototype;

    _proto['@test get value of each property'] = function testGetValueOfEachProperty() {
      var obj = this.newObject([{
        a: 1
      }, {
        a: 2
      }]);
      this.assert.equal(obj.mapBy('a').join(''), '12');
    };

    _proto['@test should work also through getEach alias'] = function testShouldWorkAlsoThroughGetEachAlias() {
      var obj = this.newObject([{
        a: 1
      }, {
        a: 2
      }]);
      this.assert.equal(obj.getEach('a').join(''), '12');
    };

    return MapByTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('mapBy', MapByTests);
});
enifed("@ember/-internals/runtime/tests/array/objectAt-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _internalTestHelpers, _array) {
  "use strict";

  var ObjectAtTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(ObjectAtTests, _AbstractTestCase);

    function ObjectAtTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = ObjectAtTests.prototype;

    _proto['@test should return object at specified index'] = function testShouldReturnObjectAtSpecifiedIndex() {
      var expected = (0, _array.newFixture)(3);
      var obj = this.newObject(expected);
      var len = expected.length;

      for (var idx = 0; idx < len; idx++) {
        this.assert.equal(obj.objectAt(idx), expected[idx], "obj.objectAt(" + idx + ") should match");
      }
    };

    _proto['@test should return undefined when requesting objects beyond index'] = function testShouldReturnUndefinedWhenRequestingObjectsBeyondIndex() {
      var obj;
      obj = this.newObject((0, _array.newFixture)(3));
      this.assert.equal(obj.objectAt(obj, 5), undefined, 'should return undefined for obj.objectAt(5) when len = 3');
      obj = this.newObject([]);
      this.assert.equal(obj.objectAt(obj, 0), undefined, 'should return undefined for obj.objectAt(0) when len = 0');
    };

    return ObjectAtTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('objectAt', ObjectAtTests);
});
enifed("@ember/-internals/runtime/tests/array/reduce-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _internalTestHelpers, _array) {
  "use strict";

  var ReduceTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(ReduceTests, _AbstractTestCase);

    function ReduceTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = ReduceTests.prototype;

    _proto['@test collects a summary value from an enumeration'] = function testCollectsASummaryValueFromAnEnumeration() {
      var obj = this.newObject([1, 2, 3]);
      var res = obj.reduce(function (previousValue, item) {
        return previousValue + item;
      }, 0);
      this.assert.equal(res, 6);
    };

    _proto['@test passes index of item to callback'] = function testPassesIndexOfItemToCallback() {
      var obj = this.newObject([1, 2, 3]);
      var res = obj.reduce(function (previousValue, item, index) {
        return previousValue + index;
      }, 0);
      this.assert.equal(res, 3);
    };

    _proto['@test passes enumerable object to callback'] = function testPassesEnumerableObjectToCallback() {
      var obj = this.newObject([1, 2, 3]);
      var res = obj.reduce(function (previousValue, item, index, enumerable) {
        return enumerable;
      }, 0);
      this.assert.equal(res, obj);
    };

    return ReduceTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('reduce', ReduceTests);
});
enifed("@ember/-internals/runtime/tests/array/reject-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/-internals/runtime/lib/system/object"], function (_emberBabel, _internalTestHelpers, _array, _object) {
  "use strict";

  var RejectTest =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(RejectTest, _AbstractTestCase);

    function RejectTest() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = RejectTest.prototype;

    _proto['@test should reject any item that does not meet the condition'] = function testShouldRejectAnyItemThatDoesNotMeetTheCondition() {
      var obj = this.newObject([1, 2, 3, 4]);
      var result;
      result = obj.reject(function (i) {
        return i < 3;
      });
      this.assert.deepEqual(result, [3, 4], 'reject the correct items');
    };

    _proto['@test should be the inverse of filter'] = function testShouldBeTheInverseOfFilter() {
      var obj = this.newObject([1, 2, 3, 4]);

      var isEven = function (i) {
        return i % 2 === 0;
      };

      var filtered, rejected;
      filtered = obj.filter(isEven);
      rejected = obj.reject(isEven);
      this.assert.deepEqual(filtered, [2, 4], 'filtered evens');
      this.assert.deepEqual(rejected, [1, 3], 'rejected evens');
    };

    return RejectTest;
  }(_internalTestHelpers.AbstractTestCase);

  var RejectByTest =
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(RejectByTest, _AbstractTestCase2);

    function RejectByTest() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = RejectByTest.prototype;

    _proto2['@test should reject based on object'] = function testShouldRejectBasedOnObject() {
      var obj, ary;
      ary = [{
        foo: 'foo',
        bar: 'BAZ'
      }, _object.default.create({
        foo: 'foo',
        bar: 'bar'
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.rejectBy('foo', 'foo'), [], 'rejectBy(foo)');
      this.assert.deepEqual(obj.rejectBy('bar', 'bar'), [ary[0]], 'rejectBy(bar)');
    };

    _proto2['@test should include in result if property is false'] = function testShouldIncludeInResultIfPropertyIsFalse() {
      var obj, ary;
      ary = [{
        foo: false,
        bar: true
      }, _object.default.create({
        foo: false,
        bar: false
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.rejectBy('foo'), ary, 'rejectBy(foo)');
      this.assert.deepEqual(obj.rejectBy('bar'), [ary[1]], 'rejectBy(bar)');
    };

    _proto2['@test should reject on second argument if provided'] = function testShouldRejectOnSecondArgumentIfProvided() {
      var obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: 2
      }), {
        name: 'obj3',
        foo: 2
      }, _object.default.create({
        name: 'obj4',
        foo: 3
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.rejectBy('foo', 3), [ary[1], ary[2]], "rejectBy('foo', 3)')");
    };

    _proto2['@test should correctly reject null second argument'] = function testShouldCorrectlyRejectNullSecondArgument() {
      var obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: null
      }), {
        name: 'obj3',
        foo: null
      }, _object.default.create({
        name: 'obj4',
        foo: 3
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.rejectBy('foo', null), [ary[0], ary[3]], "rejectBy('foo', null)')");
    };

    _proto2['@test should correctly reject undefined second argument'] = function testShouldCorrectlyRejectUndefinedSecondArgument() {
      var obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: 2
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.rejectBy('bar', undefined), [], "rejectBy('bar', undefined)')");
    };

    _proto2['@test should correctly reject explicit undefined second argument'] = function testShouldCorrectlyRejectExplicitUndefinedSecondArgument() {
      var obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: 3
      }), {
        name: 'obj3',
        foo: undefined
      }, _object.default.create({
        name: 'obj4',
        foo: undefined
      }), {
        name: 'obj5'
      }, _object.default.create({
        name: 'obj6'
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.rejectBy('foo', undefined), ary.slice(0, 2), "rejectBy('foo', undefined)')");
    };

    _proto2['@test should match undefined, null, or false properties without second argument'] = function testShouldMatchUndefinedNullOrFalsePropertiesWithoutSecondArgument() {
      var obj, ary;
      ary = [{
        name: 'obj1',
        foo: 3
      }, _object.default.create({
        name: 'obj2',
        foo: 3
      }), {
        name: 'obj3',
        foo: undefined
      }, _object.default.create({
        name: 'obj4',
        foo: undefined
      }), {
        name: 'obj5'
      }, _object.default.create({
        name: 'obj6'
      }), {
        name: 'obj7',
        foo: null
      }, _object.default.create({
        name: 'obj8',
        foo: null
      }), {
        name: 'obj9',
        foo: false
      }, _object.default.create({
        name: 'obj10',
        foo: false
      })];
      obj = this.newObject(ary);
      this.assert.deepEqual(obj.rejectBy('foo'), ary.slice(2), "rejectBy('foo')')");
    };

    return RejectByTest;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('reject', RejectTest);
  (0, _array.runArrayTests)('rejectBy', RejectByTest);
});
enifed("@ember/-internals/runtime/tests/array/sortBy-test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _metal, _internalTestHelpers, _array) {
  "use strict";

  var SortByTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(SortByTests, _AbstractTestCase);

    function SortByTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = SortByTests.prototype;

    _proto['@test sort by value of property'] = function testSortByValueOfProperty() {
      var obj = this.newObject([{
        a: 2
      }, {
        a: 1
      }]);
      var sorted = obj.sortBy('a');
      this.assert.equal((0, _metal.get)(sorted[0], 'a'), 1);
      this.assert.equal((0, _metal.get)(sorted[1], 'a'), 2);
    };

    _proto['@test supports multiple propertyNames'] = function testSupportsMultiplePropertyNames() {
      var obj = this.newObject([{
        a: 1,
        b: 2
      }, {
        a: 1,
        b: 1
      }]);
      var sorted = obj.sortBy('a', 'b');
      this.assert.equal((0, _metal.get)(sorted[0], 'b'), 1);
      this.assert.equal((0, _metal.get)(sorted[1], 'b'), 2);
    };

    return SortByTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('sortBy', SortByTests);
});
enifed("@ember/-internals/runtime/tests/array/toArray-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _internalTestHelpers, _array) {
  "use strict";

  var ToArrayTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(ToArrayTests, _AbstractTestCase);

    function ToArrayTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = ToArrayTests.prototype;

    _proto['@test toArray should convert to an array'] = function testToArrayShouldConvertToAnArray() {
      var obj = this.newObject();
      this.assert.deepEqual(obj.toArray(), this.toArray(obj));
    };

    return ToArrayTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('toArray', ToArrayTests);
});
enifed("@ember/-internals/runtime/tests/array/uniq-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _internalTestHelpers, _array) {
  "use strict";

  var UniqTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(UniqTests, _AbstractTestCase);

    function UniqTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = UniqTests.prototype;

    _proto['@test should return new instance with duplicates removed'] = function testShouldReturnNewInstanceWithDuplicatesRemoved() {
      var before, after, obj, ret;
      after = (0, _array.newFixture)(3);
      before = [after[0], after[1], after[2], after[1], after[0]];
      obj = this.newObject(before);
      before = obj.toArray(); // in case of set before will be different...

      ret = obj.uniq();
      this.assert.deepEqual(this.toArray(ret), after, 'should have removed item');
      this.assert.deepEqual(this.toArray(obj), before, 'should not have changed original');
    };

    _proto['@test should return duplicate of same content if no duplicates found'] = function testShouldReturnDuplicateOfSameContentIfNoDuplicatesFound() {
      var item, obj, ret;
      obj = this.newObject((0, _array.newFixture)(3));
      ret = obj.uniq(item);
      this.assert.ok(ret !== obj, 'should not be same object');
      this.assert.deepEqual(this.toArray(ret), this.toArray(obj), 'should be the same content');
    };

    return UniqTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('uniq', UniqTests);
});
enifed("@ember/-internals/runtime/tests/array/uniqBy-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _internalTestHelpers, _array) {
  "use strict";

  var UniqByTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(UniqByTests, _AbstractTestCase);

    function UniqByTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = UniqByTests.prototype;

    _proto['@test should return new instance with duplicates removed'] = function testShouldReturnNewInstanceWithDuplicatesRemoved() {
      var numbers = this.newObject([{
        id: 1,
        value: 'one'
      }, {
        id: 2,
        value: 'two'
      }, {
        id: 1,
        value: 'one'
      }]);
      this.assert.deepEqual(numbers.uniqBy('id'), [{
        id: 1,
        value: 'one'
      }, {
        id: 2,
        value: 'two'
      }]);
    };

    _proto['@test supports function as key'] = function testSupportsFunctionAsKey() {
      var _this = this,
          _arguments = arguments;

      var numbers = this.newObject([{
        id: 1,
        value: 'boom'
      }, {
        id: 2,
        value: 'boom'
      }, {
        id: 1,
        value: 'doom'
      }]);

      var keyFunction = function (val) {
        _this.assert.equal(_arguments.length, 1);

        return val.value;
      };

      this.assert.deepEqual(numbers.uniqBy(keyFunction), [{
        id: 1,
        value: 'boom'
      }, {
        id: 1,
        value: 'doom'
      }]);
    };

    return UniqByTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('uniqBy', UniqByTests);
});
enifed("@ember/-internals/runtime/tests/array/without-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _internalTestHelpers, _array) {
  "use strict";

  var WithoutTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(WithoutTests, _AbstractTestCase);

    function WithoutTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = WithoutTests.prototype;

    _proto['@test should return new instance with item removed'] = function testShouldReturnNewInstanceWithItemRemoved() {
      var before, after, obj, ret;
      before = (0, _array.newFixture)(3);
      after = [before[0], before[2]];
      obj = this.newObject(before);
      ret = obj.without(before[1]);
      this.assert.deepEqual(this.toArray(ret), after, 'should have removed item');
      this.assert.deepEqual(this.toArray(obj), before, 'should not have changed original');
    };

    _proto['@test should remove NaN value'] = function testShouldRemoveNaNValue() {
      var before, after, obj, ret;
      before = [].concat((0, _array.newFixture)(2), [NaN]);
      after = [before[0], before[1]];
      obj = this.newObject(before);
      ret = obj.without(NaN);
      this.assert.deepEqual(this.toArray(ret), after, 'should have removed item');
    };

    _proto['@test should return same instance if object not found'] = function testShouldReturnSameInstanceIfObjectNotFound() {
      var item, obj, ret;
      item = (0, _array.newFixture)(1)[0];
      obj = this.newObject((0, _array.newFixture)(3));
      ret = obj.without(item);
      this.assert.equal(ret, obj, 'should be same instance');
    };

    return WithoutTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('without', WithoutTests);
});
enifed("@ember/-internals/runtime/tests/copyable-array/copy-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _internalTestHelpers, _array) {
  "use strict";

  var CopyTest =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(CopyTest, _AbstractTestCase);

    function CopyTest() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = CopyTest.prototype;

    _proto['@test should return an equivalent copy'] = function testShouldReturnAnEquivalentCopy() {
      var obj = this.newObject();
      var copy = obj.copy();
      this.assert.ok(this.isEqual(obj, copy), 'old object and new object should be equivalent');
    };

    return CopyTest;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('copy', CopyTest, 'CopyableNativeArray', 'CopyableArray');
});
enifed("@ember/-internals/runtime/tests/core/compare_test", ["ember-babel", "@ember/-internals/runtime/lib/type-of", "@ember/-internals/runtime/lib/system/object", "@ember/-internals/runtime/lib/compare", "@ember/-internals/runtime/lib/mixins/comparable", "internal-test-helpers"], function (_emberBabel, _typeOf, _object, _compare, _comparable, _internalTestHelpers) {
  "use strict";

  var data = [];

  var Comp = _object.default.extend(_comparable.default);

  Comp.reopenClass({
    compare: function (obj) {
      return obj.get('val');
    }
  });
  (0, _internalTestHelpers.moduleFor)('Ember.compare()',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      data[0] = null;
      data[1] = false;
      data[2] = true;
      data[3] = -12;
      data[4] = 3.5;
      data[5] = 'a string';
      data[6] = 'another string';
      data[7] = 'last string';
      data[8] = [1, 2];
      data[9] = [1, 2, 3];
      data[10] = [1, 3];
      data[11] = {
        a: 'hash'
      };
      data[12] = _object.default.create();

      data[13] = function (a) {
        return a;
      };

      data[14] = new Date('2012/01/01');
      data[15] = new Date('2012/06/06');
    };

    _proto['@test ordering should work'] = function testOrderingShouldWork(assert) {
      var suspect, comparable, failureMessage, suspectIndex, comparableIndex;

      for (suspectIndex = 0; suspectIndex < data.length; suspectIndex++) {
        suspect = data[suspectIndex];
        assert.equal((0, _compare.default)(suspect, suspect), 0, suspectIndex + ' should equal itself');

        for (comparableIndex = suspectIndex + 1; comparableIndex < data.length; comparableIndex++) {
          comparable = data[comparableIndex];
          failureMessage = 'data[' + suspectIndex + '] (' + (0, _typeOf.typeOf)(suspect) + ') should be smaller than data[' + comparableIndex + '] (' + (0, _typeOf.typeOf)(comparable) + ')';
          assert.equal((0, _compare.default)(suspect, comparable), -1, failureMessage);
        }
      }
    };

    _proto['@test comparables should return values in the range of -1, 0, 1'] = function testComparablesShouldReturnValuesInTheRangeOf101(assert) {
      var negOne = Comp.create({
        val: -1
      });
      var zero = Comp.create({
        val: 0
      });
      var one = Comp.create({
        val: 1
      });
      assert.equal((0, _compare.default)(negOne, 'a'), -1, 'First item comparable - returns -1 (not negated)');
      assert.equal((0, _compare.default)(zero, 'b'), 0, 'First item comparable - returns  0 (not negated)');
      assert.equal((0, _compare.default)(one, 'c'), 1, 'First item comparable - returns  1 (not negated)');
      assert.equal((0, _compare.default)('a', negOne), 1, 'Second item comparable - returns -1 (negated)');
      assert.equal((0, _compare.default)('b', zero), 0, 'Second item comparable - returns  0 (negated)');
      assert.equal((0, _compare.default)('c', one), -1, 'Second item comparable - returns  1 (negated)');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/core/copy_test", ["ember-babel", "@ember/-internals/runtime/lib/copy", "internal-test-helpers"], function (_emberBabel, _copy, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember Copy Method',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Ember.copy null'] = function testEmberCopyNull(assert) {
      var obj = {
        field: null
      };
      var copied = null;
      expectDeprecation(function () {
        copied = (0, _copy.default)(obj, true);
      }, 'Use ember-copy addon instead of copy method and Copyable mixin.');
      assert.equal(copied.field, null, 'null should still be null');
    };

    _proto['@test Ember.copy date'] = function testEmberCopyDate(assert) {
      var date = new Date(2014, 7, 22);
      var dateCopy = null;
      expectDeprecation(function () {
        dateCopy = (0, _copy.default)(date);
      }, 'Use ember-copy addon instead of copy method and Copyable mixin.');
      assert.equal(date.getTime(), dateCopy.getTime(), 'dates should be equivalent');
    };

    _proto['@test Ember.copy null prototype object'] = function testEmberCopyNullPrototypeObject(assert) {
      var obj = Object.create(null);
      obj.foo = 'bar';
      var copied = null;
      expectDeprecation(function () {
        copied = (0, _copy.default)(obj);
      }, 'Use ember-copy addon instead of copy method and Copyable mixin.');
      assert.equal(copied.foo, 'bar', 'bar should still be bar');
    };

    _proto['@test Ember.copy Array'] = function testEmberCopyArray(assert) {
      var array = [1, null, new Date(2015, 9, 9), 'four'];
      var arrayCopy = null;
      expectDeprecation(function () {
        arrayCopy = (0, _copy.default)(array);
      }, 'Use ember-copy addon instead of copy method and Copyable mixin.');
      assert.deepEqual(array, arrayCopy, 'array content cloned successfully in new array');
    };

    _proto['@test Ember.copy cycle detection'] = function testEmberCopyCycleDetection(assert) {
      var obj = {
        foo: {
          bar: 'bar'
        }
      };
      obj.foo.foo = obj.foo;
      var cycleCopy = null;
      expectDeprecation(function () {
        cycleCopy = (0, _copy.default)(obj, true);
      }, 'Use ember-copy addon instead of copy method and Copyable mixin.');
      assert.equal(cycleCopy.foo.bar, 'bar');
      assert.notEqual(cycleCopy.foo.foo, obj.foo.foo);
      assert.strictEqual(cycleCopy.foo.foo, cycleCopy.foo.foo);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/core/isEqual_test", ["ember-babel", "@ember/-internals/runtime/lib/is-equal", "internal-test-helpers"], function (_emberBabel, _isEqual, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('isEqual',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test undefined and null'] = function testUndefinedAndNull(assert) {
      assert.ok((0, _isEqual.default)(undefined, undefined), 'undefined is equal to undefined');
      assert.ok(!(0, _isEqual.default)(undefined, null), 'undefined is not equal to null');
      assert.ok((0, _isEqual.default)(null, null), 'null is equal to null');
      assert.ok(!(0, _isEqual.default)(null, undefined), 'null is not equal to undefined');
    };

    _proto['@test strings should be equal'] = function testStringsShouldBeEqual(assert) {
      assert.ok(!(0, _isEqual.default)('Hello', 'Hi'), 'different Strings are unequal');
      assert.ok((0, _isEqual.default)('Hello', 'Hello'), 'same Strings are equal');
    };

    _proto['@test numericals should be equal'] = function testNumericalsShouldBeEqual(assert) {
      assert.ok((0, _isEqual.default)(24, 24), 'same numbers are equal');
      assert.ok(!(0, _isEqual.default)(24, 21), 'different numbers are inequal');
    };

    _proto['@test dates should be equal'] = function testDatesShouldBeEqual(assert) {
      assert.ok((0, _isEqual.default)(new Date(1985, 7, 22), new Date(1985, 7, 22)), 'same dates are equal');
      assert.ok(!(0, _isEqual.default)(new Date(2014, 7, 22), new Date(1985, 7, 22)), 'different dates are not equal');
    };

    _proto['@test array should be equal'] = function testArrayShouldBeEqual(assert) {
      // NOTE: We don't test for array contents -- that would be too expensive.
      assert.ok(!(0, _isEqual.default)([1, 2], [1, 2]), 'two array instances with the same values should not be equal');
      assert.ok(!(0, _isEqual.default)([1, 2], [1]), 'two array instances with different values should not be equal');
    };

    _proto['@test first object implements isEqual should use it'] = function testFirstObjectImplementsIsEqualShouldUseIt(assert) {
      assert.ok((0, _isEqual.default)({
        isEqual: function () {
          return true;
        }
      }, null), 'should return true always');
      var obj = {
        isEqual: function () {
          return false;
        }
      };
      assert.equal((0, _isEqual.default)(obj, obj), false, 'should return false because isEqual returns false');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/core/is_array_test", ["ember-babel", "@ember/-internals/runtime/lib/mixins/array", "@ember/-internals/runtime/lib/system/array_proxy", "@ember/-internals/runtime/lib/system/object", "@ember/-internals/browser-environment", "internal-test-helpers"], function (_emberBabel, _array, _array_proxy, _object, _browserEnvironment, _internalTestHelpers) {
  "use strict";

  var global = void 0;
  (0, _internalTestHelpers.moduleFor)('Ember Type Checking',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Ember.isArray'] = function testEmberIsArray(assert) {
      var numarray = [1, 2, 3];
      var number = 23;
      var strarray = ['Hello', 'Hi'];
      var string = 'Hello';
      var object = {};
      var length = {
        length: 12
      };
      var strangeLength = {
        length: 'yes'
      };

      var fn = function () {};

      var arrayProxy = _array_proxy.default.create({
        content: (0, _array.A)()
      });

      assert.equal((0, _array.isArray)(numarray), true, '[1,2,3]');
      assert.equal((0, _array.isArray)(number), false, '23');
      assert.equal((0, _array.isArray)(strarray), true, '["Hello", "Hi"]');
      assert.equal((0, _array.isArray)(string), false, '"Hello"');
      assert.equal((0, _array.isArray)(object), false, '{}');
      assert.equal((0, _array.isArray)(length), true, '{ length: 12 }');
      assert.equal((0, _array.isArray)(strangeLength), false, '{ length: "yes" }');
      assert.equal((0, _array.isArray)(global), false, 'global');
      assert.equal((0, _array.isArray)(fn), false, 'function() {}');
      assert.equal((0, _array.isArray)(arrayProxy), true, '[]');
    };

    _proto['@test Ember.isArray does not trigger proxy assertion when probing for length GH#16495'] = function testEmberIsArrayDoesNotTriggerProxyAssertionWhenProbingForLengthGH16495(assert) {
      var instance = _object.default.extend({
        // intentionally returning non-null / non-undefined
        unknownProperty: function () {
          return false;
        }
      }).create();

      assert.equal((0, _array.isArray)(instance), false);
    };

    _proto['@test Ember.isArray(fileList)'] = function testEmberIsArrayFileList(assert) {
      if (_browserEnvironment.window && typeof _browserEnvironment.window.FileList === 'function') {
        var fileListElement = document.createElement('input');
        fileListElement.type = 'file';
        var fileList = fileListElement.files;
        assert.equal((0, _array.isArray)(fileList), false, 'fileList');
      } else {
        assert.ok(true, 'FileList is not present on window');
      }
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/core/is_empty_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/array_proxy", "@ember/-internals/runtime/lib/mixins/array", "internal-test-helpers"], function (_emberBabel, _metal, _array_proxy, _array, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.isEmpty',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Ember.isEmpty'] = function testEmberIsEmpty(assert) {
      var arrayProxy = _array_proxy.default.create({
        content: (0, _array.A)()
      });

      assert.equal(true, (0, _metal.isEmpty)(arrayProxy), 'for an ArrayProxy that has empty content');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/core/type_of_test", ["ember-babel", "@ember/-internals/runtime/lib/type-of", "@ember/-internals/runtime/lib/system/object", "@ember/-internals/browser-environment", "internal-test-helpers"], function (_emberBabel, _typeOf, _object, _browserEnvironment, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember Type Checking',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Ember.typeOf'] = function testEmberTypeOf(assert) {
      var MockedDate = function () {};

      MockedDate.prototype = new Date();
      var mockedDate = new MockedDate();
      var date = new Date();
      var error = new Error('boum');
      var object = {
        a: 'b'
      };
      var a = null;
      var arr = [1, 2, 3];
      var obj = {};

      var instance = _object.default.create({
        method: function () {}
      });

      assert.equal((0, _typeOf.typeOf)(), 'undefined', 'undefined');
      assert.equal((0, _typeOf.typeOf)(null), 'null', 'null');
      assert.equal((0, _typeOf.typeOf)('Cyril'), 'string', 'Cyril');
      assert.equal((0, _typeOf.typeOf)(101), 'number', '101');
      assert.equal((0, _typeOf.typeOf)(true), 'boolean', 'true');
      assert.equal((0, _typeOf.typeOf)([1, 2, 90]), 'array', '[1,2,90]');
      assert.equal((0, _typeOf.typeOf)(/abc/), 'regexp', '/abc/');
      assert.equal((0, _typeOf.typeOf)(date), 'date', 'new Date()');
      assert.equal((0, _typeOf.typeOf)(mockedDate), 'date', 'mocked date');
      assert.equal((0, _typeOf.typeOf)(error), 'error', 'error');
      assert.equal((0, _typeOf.typeOf)(object), 'object', 'object');
      assert.equal((0, _typeOf.typeOf)(undefined), 'undefined', 'item of type undefined');
      assert.equal((0, _typeOf.typeOf)(a), 'null', 'item of type null');
      assert.equal((0, _typeOf.typeOf)(arr), 'array', 'item of type array');
      assert.equal((0, _typeOf.typeOf)(obj), 'object', 'item of type object');
      assert.equal((0, _typeOf.typeOf)(instance), 'instance', 'item of type instance');
      assert.equal((0, _typeOf.typeOf)(instance.method), 'function', 'item of type function');
      assert.equal((0, _typeOf.typeOf)(_object.default.extend()), 'class', 'item of type class');
      assert.equal((0, _typeOf.typeOf)(new Error()), 'error', 'item of type error');
    };

    _proto['@test Ember.typeOf(fileList)'] = function testEmberTypeOfFileList(assert) {
      if (_browserEnvironment.window && typeof _browserEnvironment.window.FileList === 'function') {
        var fileListElement = document.createElement('input');
        fileListElement.type = 'file';
        var fileList = fileListElement.files;
        assert.equal((0, _typeOf.typeOf)(fileList), 'filelist', 'item of type filelist');
      } else {
        assert.ok(true, 'FileList is not present on window');
      }
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/ext/function_test", ["ember-babel", "@ember/-internals/environment", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/object", "@ember/-internals/runtime/lib/mixins/evented", "internal-test-helpers", "@ember/deprecated-features"], function (_emberBabel, _environment, _metal, _object, _evented, _internalTestHelpers, _deprecatedFeatures) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('Function.prototype.observes() helper',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test global observer helper takes multiple params'] =
    /*#__PURE__*/
    function () {
      var _testGlobalObserverHelperTakesMultipleParams = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var MyMixin, obj;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(!_deprecatedFeatures.FUNCTION_PROTOTYPE_EXTENSIONS || !_environment.ENV.EXTEND_PROTOTYPES.Function)) {
                _context.next = 3;
                break;
              }

              assert.ok('undefined' === typeof Function.prototype.observes, 'Function.prototype helper disabled');
              return _context.abrupt("return");

            case 3:
              expectDeprecation(function () {
                MyMixin = _metal.Mixin.create({
                  count: 0,
                  foo: function () {
                    (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                  }.observes('bar', 'baz')
                });
              }, /Function prototype extensions have been deprecated, please migrate from function\(\){}.observes\('foo'\) to observer\('foo', function\(\) {}\)/);
              obj = (0, _metal.mixin)({}, MyMixin);
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer immediately');
              (0, _metal.set)(obj, 'bar', 'BAZ');
              _context.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              (0, _metal.set)(obj, 'baz', 'BAZ');
              _context.next = 12;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 12:
              assert.equal((0, _metal.get)(obj, 'count'), 2, 'should invoke observer after change');

            case 13:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function testGlobalObserverHelperTakesMultipleParams(_x) {
        return _testGlobalObserverHelperTakesMultipleParams.apply(this, arguments);
      }

      return testGlobalObserverHelperTakesMultipleParams;
    }();

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Function.prototype.on() helper',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test sets up an event listener, and can trigger the function on multiple events'] = function testSetsUpAnEventListenerAndCanTriggerTheFunctionOnMultipleEvents(assert) {
      if (!_deprecatedFeatures.FUNCTION_PROTOTYPE_EXTENSIONS || !_environment.ENV.EXTEND_PROTOTYPES.Function) {
        assert.ok('undefined' === typeof Function.prototype.on, 'Function.prototype helper disabled');
        return;
      }

      var MyMixin;
      expectDeprecation(function () {
        MyMixin = _metal.Mixin.create({
          count: 0,
          foo: function () {
            (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
          }.on('bar', 'baz')
        });
      }, /Function prototype extensions have been deprecated, please migrate from function\(\){}.on\('foo'\) to on\('foo', function\(\) {}\)/);
      var obj = (0, _metal.mixin)({}, _evented.default, MyMixin);
      assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke listener immediately');
      obj.trigger('bar');
      obj.trigger('baz');
      assert.equal((0, _metal.get)(obj, 'count'), 2, 'should invoke listeners when events trigger');
    };

    _proto2['@test can be chained with observes'] =
    /*#__PURE__*/
    function () {
      var _testCanBeChainedWithObserves = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        var MyMixin, obj;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!(!_deprecatedFeatures.FUNCTION_PROTOTYPE_EXTENSIONS || !_environment.ENV.EXTEND_PROTOTYPES.Function)) {
                _context2.next = 3;
                break;
              }

              assert.ok('Function.prototype helper disabled');
              return _context2.abrupt("return");

            case 3:
              expectDeprecation(function () {
                MyMixin = _metal.Mixin.create({
                  count: 0,
                  bay: 'bay',
                  foo: function () {
                    (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                  }.observes('bay').on('bar')
                });
              });
              obj = (0, _metal.mixin)({}, _evented.default, MyMixin);
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke listener immediately');
              (0, _metal.set)(obj, 'bay', 'BAY');
              obj.trigger('bar');
              _context2.next = 10;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 10:
              assert.equal((0, _metal.get)(obj, 'count'), 2, 'should invoke observer and listener');

            case 11:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));

      function testCanBeChainedWithObserves(_x2) {
        return _testCanBeChainedWithObserves.apply(this, arguments);
      }

      return testCanBeChainedWithObserves;
    }();

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Function.prototype.property() helper',
  /*#__PURE__*/
  function (_AbstractTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class3, _AbstractTestCase3);

    function _class3() {
      return _AbstractTestCase3.apply(this, arguments) || this;
    }

    var _proto3 = _class3.prototype;

    _proto3['@test sets up a ComputedProperty'] = function testSetsUpAComputedProperty(assert) {
      if (!_deprecatedFeatures.FUNCTION_PROTOTYPE_EXTENSIONS || !_environment.ENV.EXTEND_PROTOTYPES.Function) {
        assert.ok('undefined' === typeof Function.prototype.property, 'Function.prototype helper disabled');
        return;
      }

      var MyClass;
      expectDeprecation(function () {
        MyClass = _object.default.extend({
          firstName: null,
          lastName: null,
          fullName: function () {
            return (0, _metal.get)(this, 'firstName') + ' ' + (0, _metal.get)(this, 'lastName');
          }.property('firstName', 'lastName')
        });
      }, /Function prototype extensions have been deprecated, please migrate from function\(\){}.property\('bar'\) to computed\('bar', function\(\) {}\)/);
      var obj = MyClass.create({
        firstName: 'Fred',
        lastName: 'Flinstone'
      });
      assert.equal((0, _metal.get)(obj, 'fullName'), 'Fred Flinstone', 'should return the computed value');
      (0, _metal.set)(obj, 'firstName', 'Wilma');
      assert.equal((0, _metal.get)(obj, 'fullName'), 'Wilma Flinstone', 'should return the new computed value');
      (0, _metal.set)(obj, 'lastName', '');
      assert.equal((0, _metal.get)(obj, 'fullName'), 'Wilma ', 'should return the new computed value');
    };

    return _class3;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/ext/rsvp_test", ["ember-babel", "@ember/runloop", "@ember/-internals/error-handling", "@ember/-internals/runtime/lib/ext/rsvp", "@ember/debug", "internal-test-helpers"], function (_emberBabel, _runloop, _errorHandling, _rsvp, _debug, _internalTestHelpers) {
  "use strict";

  var ORIGINAL_ONERROR = (0, _errorHandling.getOnerror)();
  (0, _internalTestHelpers.moduleFor)('Ember.RSVP',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.afterEach = function afterEach() {
      (0, _errorHandling.setOnerror)(ORIGINAL_ONERROR);
    };

    _proto['@test Ensure that errors thrown from within a promise are sent to the console'] = function testEnsureThatErrorsThrownFromWithinAPromiseAreSentToTheConsole(assert) {
      var error = new Error('Error thrown in a promise for testing purposes.');

      try {
        (0, _runloop.run)(function () {
          new _rsvp.default.Promise(function () {
            throw error;
          });
        });
        assert.ok(false, 'expected assertion to be thrown');
      } catch (e) {
        assert.equal(e, error, 'error was re-thrown');
      }
    };

    _proto['@test TransitionAborted errors are not re-thrown'] = function testTransitionAbortedErrorsAreNotReThrown(assert) {
      assert.expect(1);
      var fakeTransitionAbort = {
        name: 'TransitionAborted'
      };
      (0, _runloop.run)(_rsvp.default, 'reject', fakeTransitionAbort);
      assert.ok(true, 'did not throw an error when dealing with TransitionAborted');
    };

    _proto['@test Can reject with non-Error object'] = function testCanRejectWithNonErrorObject(assert) {
      var wasEmberTesting = (0, _debug.isTesting)();
      (0, _debug.setTesting)(false);
      assert.expect(1);

      try {
        (0, _runloop.run)(_rsvp.default, 'reject', 'foo');
      } catch (e) {
        assert.equal(e, 'foo', 'should throw with rejection message');
      } finally {
        (0, _debug.setTesting)(wasEmberTesting);
      }
    };

    _proto['@test Can reject with no arguments'] = function testCanRejectWithNoArguments(assert) {
      var wasEmberTesting = (0, _debug.isTesting)();
      (0, _debug.setTesting)(false);
      assert.expect(1);

      try {
        (0, _runloop.run)(_rsvp.default, 'reject');
      } catch (e) {
        assert.ok(false, 'should not throw');
      } finally {
        (0, _debug.setTesting)(wasEmberTesting);
      }

      assert.ok(true);
    };

    _proto['@test rejections like jqXHR which have errorThrown property work'] = function testRejectionsLikeJqXHRWhichHaveErrorThrownPropertyWork(assert) {
      assert.expect(2);
      var wasEmberTesting = (0, _debug.isTesting)();
      var wasOnError = (0, _errorHandling.getOnerror)();

      try {
        (0, _debug.setTesting)(false);
        (0, _errorHandling.setOnerror)(function (error) {
          assert.equal(error, actualError, 'expected the real error on the jqXHR');
          assert.equal(error.__reason_with_error_thrown__, jqXHR, 'also retains a helpful reference to the rejection reason');
        });
        var actualError = new Error('OMG what really happened');
        var jqXHR = {
          errorThrown: actualError
        };
        (0, _runloop.run)(_rsvp.default, 'reject', jqXHR);
      } finally {
        (0, _errorHandling.setOnerror)(wasOnError);
        (0, _debug.setTesting)(wasEmberTesting);
      }
    };

    _proto['@test rejections where the errorThrown is a string should wrap the sting in an error object'] = function testRejectionsWhereTheErrorThrownIsAStringShouldWrapTheStingInAnErrorObject(assert) {
      assert.expect(2);
      var wasEmberTesting = (0, _debug.isTesting)();
      var wasOnError = (0, _errorHandling.getOnerror)();

      try {
        (0, _debug.setTesting)(false);
        (0, _errorHandling.setOnerror)(function (error) {
          assert.equal(error.message, actualError, 'expected the real error on the jqXHR');
          assert.equal(error.__reason_with_error_thrown__, jqXHR, 'also retains a helpful reference to the rejection reason');
        });
        var actualError = 'OMG what really happened';
        var jqXHR = {
          errorThrown: actualError
        };
        (0, _runloop.run)(_rsvp.default, 'reject', jqXHR);
      } finally {
        (0, _errorHandling.setOnerror)(wasOnError);
        (0, _debug.setTesting)(wasEmberTesting);
      }
    };

    _proto['@test rejections can be serialized to JSON'] = function testRejectionsCanBeSerializedToJSON(assert) {
      assert.expect(2);
      var wasEmberTesting = (0, _debug.isTesting)();
      var wasOnError = (0, _errorHandling.getOnerror)();

      try {
        (0, _debug.setTesting)(false);
        (0, _errorHandling.setOnerror)(function (error) {
          assert.equal(error.message, 'a fail');
          assert.ok(JSON.stringify(error), 'Error can be serialized');
        });
        var jqXHR = {
          errorThrown: new Error('a fail')
        };
        (0, _runloop.run)(_rsvp.default, 'reject', jqXHR);
      } finally {
        (0, _errorHandling.setOnerror)(wasOnError);
        (0, _debug.setTesting)(wasEmberTesting);
      }
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  var reason = 'i failed';

  function ajax() {
    return new _rsvp.default.Promise(function (resolve) {
      setTimeout(resolve, 0); // fake true / foreign async
    });
  }

  (0, _internalTestHelpers.moduleFor)('Ember.test: rejection assertions',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test unambigiously unhandled rejection'] = function testUnambigiouslyUnhandledRejection(assert) {
      assert.throws(function () {
        (0, _runloop.run)(function () {
          _rsvp.default.Promise.reject(reason);
        }); // something is funky, we should likely assert
      }, reason);
    };

    _proto2['@test sync handled'] = function testSyncHandled(assert) {
      (0, _runloop.run)(function () {
        _rsvp.default.Promise.reject(reason).catch(function () {});
      }); // handled, we shouldn't need to assert.

      assert.ok(true, 'reached end of test');
    };

    _proto2['@test handled within the same micro-task (via Ember.RVP.Promise)'] = function testHandledWithinTheSameMicroTaskViaEmberRVPPromise(assert) {
      (0, _runloop.run)(function () {
        var rejection = _rsvp.default.Promise.reject(reason);

        _rsvp.default.Promise.resolve(1).then(function () {
          return rejection.catch(function () {});
        });
      }); // handled, we shouldn't need to assert.

      assert.ok(true, 'reached end of test');
    };

    _proto2['@test handled within the same micro-task (via direct run-loop)'] = function testHandledWithinTheSameMicroTaskViaDirectRunLoop(assert) {
      (0, _runloop.run)(function () {
        var rejection = _rsvp.default.Promise.reject(reason);

        (0, _runloop.schedule)('afterRender', function () {
          return rejection.catch(function () {});
        });
      }); // handled, we shouldn't need to assert.

      assert.ok(true, 'reached end of test');
    };

    _proto2['@test handled in the next microTask queue flush (next)'] = function testHandledInTheNextMicroTaskQueueFlushNext(assert) {
      assert.expect(2);
      var done = assert.async();
      assert.throws(function () {
        (0, _runloop.run)(function () {
          var rejection = _rsvp.default.Promise.reject(reason);

          (0, _runloop.next)(function () {
            rejection.catch(function () {});
            assert.ok(true, 'reached end of test');
            done();
          });
        });
      }, reason); // a promise rejection survived a full flush of the run-loop without being handled
      // this is very likely an issue.
    };

    _proto2['@test handled in the same microTask Queue flush do to data locality'] = function testHandledInTheSameMicroTaskQueueFlushDoToDataLocality(assert) {
      // an ambiguous scenario, this may or may not assert
      // it depends on the locality of `user#1`
      var store = {
        find: function () {
          return _rsvp.default.Promise.resolve(1);
        }
      };
      (0, _runloop.run)(function () {
        var rejection = _rsvp.default.Promise.reject(reason);

        store.find('user', 1).then(function () {
          return rejection.catch(function () {});
        });
      });
      assert.ok(true, 'reached end of test');
    };

    _proto2['@test handled in a different microTask Queue flush do to data locality'] = function testHandledInADifferentMicroTaskQueueFlushDoToDataLocality(assert) {
      var done = assert.async(); // an ambiguous scenario, this may or may not assert
      // it depends on the locality of `user#1`

      var store = {
        find: function () {
          return ajax();
        }
      };
      assert.throws(function () {
        (0, _runloop.run)(function () {
          var rejection = _rsvp.default.Promise.reject(reason);

          store.find('user', 1).then(function () {
            rejection.catch(function () {});
            assert.ok(true, 'reached end of test');
            done();
          });
        });
      }, reason);
    };

    _proto2['@test handled in the next microTask queue flush (ajax example)'] = function testHandledInTheNextMicroTaskQueueFlushAjaxExample(assert) {
      var done = assert.async();
      assert.throws(function () {
        (0, _runloop.run)(function () {
          var rejection = _rsvp.default.Promise.reject(reason);

          ajax().then(function () {
            rejection.catch(function () {});
            assert.ok(true, 'reached end of test');
            done();
          });
        });
      }, reason);
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/helpers/array", ["exports", "ember-babel", "@ember/-internals/runtime/lib/system/array_proxy", "@ember/-internals/runtime/lib/mixins/array", "@ember/-internals/utils", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/object", "@ember/-internals/runtime/lib/mixins/copyable", "internal-test-helpers"], function (_exports, _emberBabel, _array_proxy, _array, _utils, _metal, _object, _copyable, _internalTestHelpers) {
  "use strict";

  _exports.newFixture = newFixture;
  _exports.newObjectsFixture = newObjectsFixture;
  _exports.runArrayTests = runArrayTests;

  function newFixture(cnt) {
    var ret = [];

    while (--cnt >= 0) {
      ret.push((0, _utils.generateGuid)());
    }

    return ret;
  }

  function newObjectsFixture(cnt) {
    var ret = [];
    var item;

    while (--cnt >= 0) {
      item = {};
      (0, _utils.guidFor)(item);
      ret.push(item);
    }

    return ret;
  }

  var ArrayTestsObserverClass = _object.default.extend({
    init: function () {
      this._super.apply(this, arguments);

      this.isEnabled = true;
      this.reset();
    },
    reset: function () {
      this._keys = {};
      this._values = {};
      this._before = null;
      this._after = null;
      return this;
    },
    observe: function (obj) {
      if (obj.addObserver) {
        for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          keys[_key - 1] = arguments[_key];
        }

        var loc = keys.length;

        while (--loc >= 0) {
          obj.addObserver(keys[loc], this, 'propertyDidChange');
        }
      } else {
        this.isEnabled = false;
      }

      return this;
    },
    observeArray: function (obj) {
      (0, _metal.addArrayObserver)(obj, this);
      return this;
    },
    stopObserveArray: function (obj) {
      (0, _metal.removeArrayObserver)(obj, this);
      return this;
    },
    propertyDidChange: function (target, key, value) {
      if (this._keys[key] === undefined) {
        this._keys[key] = 0;
      }

      this._keys[key]++;
      this._values[key] = value;
    },
    arrayWillChange: function () {
      this.assert.equal(this._before, null, 'should only call once');
      this._before = Array.prototype.slice.call(arguments);
    },
    arrayDidChange: function () {
      this.assert.equal(this._after, null, 'should only call once');
      this._after = Array.prototype.slice.call(arguments);
    },
    validate: function (key, value) {
      if (!this.isEnabled) {
        return true;
      }

      if (!this._keys[key]) {
        return false;
      }

      if (arguments.length > 1) {
        return this._values[key] === value;
      } else {
        return true;
      }
    },
    timesCalled: function (key) {
      return this._keys[key] || 0;
    }
  });

  var AbstractArrayHelper =
  /*#__PURE__*/
  function () {
    function AbstractArrayHelper() {}

    var _proto = AbstractArrayHelper.prototype;

    _proto.beforeEach = function beforeEach(assert) {
      this.assert = assert;
    };

    _proto.newObject = function newObject(ary) {
      return ary ? ary.slice() : newFixture(3);
    };

    _proto.toArray = function toArray(obj) {
      return obj.slice();
    };

    _proto.newObserver = function newObserver() {
      var ret = ArrayTestsObserverClass.create({
        assert: this.assert
      });

      if (arguments.length > 0) {
        ret.observe.apply(ret, arguments);
      }

      return ret;
    };

    return AbstractArrayHelper;
  }();

  var NativeArrayHelpers =
  /*#__PURE__*/
  function (_AbstractArrayHelper) {
    (0, _emberBabel.inheritsLoose)(NativeArrayHelpers, _AbstractArrayHelper);

    function NativeArrayHelpers() {
      return _AbstractArrayHelper.apply(this, arguments) || this;
    }

    var _proto2 = NativeArrayHelpers.prototype;

    _proto2.newObject = function newObject(ary) {
      return (0, _array.A)(_AbstractArrayHelper.prototype.newObject.call(this, ary));
    };

    _proto2.mutate = function mutate(obj) {
      obj.pushObject(obj.length + 1);
    };

    return NativeArrayHelpers;
  }(AbstractArrayHelper);

  var CopyableNativeArray =
  /*#__PURE__*/
  function (_AbstractArrayHelper2) {
    (0, _emberBabel.inheritsLoose)(CopyableNativeArray, _AbstractArrayHelper2);

    function CopyableNativeArray() {
      return _AbstractArrayHelper2.apply(this, arguments) || this;
    }

    var _proto3 = CopyableNativeArray.prototype;

    _proto3.newObject = function newObject() {
      return (0, _array.A)([(0, _utils.generateGuid)()]);
    };

    _proto3.isEqual = function isEqual(a, b) {
      if (!(a instanceof Array)) {
        return false;
      }

      if (!(b instanceof Array)) {
        return false;
      }

      if (a.length !== b.length) {
        return false;
      }

      return a[0] === b[0];
    };

    return CopyableNativeArray;
  }(AbstractArrayHelper);

  var CopyableArray =
  /*#__PURE__*/
  function (_AbstractArrayHelper3) {
    (0, _emberBabel.inheritsLoose)(CopyableArray, _AbstractArrayHelper3);

    function CopyableArray() {
      return _AbstractArrayHelper3.apply(this, arguments) || this;
    }

    var _proto4 = CopyableArray.prototype;

    _proto4.newObject = function newObject() {
      return CopyableObject.create();
    };

    _proto4.isEqual = function isEqual(a, b) {
      if (!(a instanceof CopyableObject) || !(b instanceof CopyableObject)) {
        return false;
      }

      return (0, _metal.get)(a, 'id') === (0, _metal.get)(b, 'id');
    };

    return CopyableArray;
  }(AbstractArrayHelper);

  var ArrayProxyHelpers =
  /*#__PURE__*/
  function (_AbstractArrayHelper4) {
    (0, _emberBabel.inheritsLoose)(ArrayProxyHelpers, _AbstractArrayHelper4);

    function ArrayProxyHelpers() {
      return _AbstractArrayHelper4.apply(this, arguments) || this;
    }

    var _proto5 = ArrayProxyHelpers.prototype;

    _proto5.newObject = function newObject(ary) {
      return _array_proxy.default.create({
        content: (0, _array.A)(_AbstractArrayHelper4.prototype.newObject.call(this, ary))
      });
    };

    _proto5.mutate = function mutate(obj) {
      obj.pushObject((0, _metal.get)(obj, 'length') + 1);
    };

    _proto5.toArray = function toArray(obj) {
      return obj.toArray ? obj.toArray() : obj.slice();
    };

    return ArrayProxyHelpers;
  }(AbstractArrayHelper);
  /*
    Implement a basic fake mutable array.  This validates that any non-native
    enumerable can impl this API.
  */


  var TestArray = _object.default.extend(_array.default, {
    _content: null,
    init: function () {
      this._content = this._content || [];
    },
    // some methods to modify the array so we can test changes.  Note that
    // arrays can be modified even if they don't implement MutableArray.  The
    // MutableArray is just a standard API for mutation but not required.
    addObject: function (obj) {
      var idx = this._content.length;
      (0, _metal.arrayContentWillChange)(this, idx, 0, 1);

      this._content.push(obj);

      (0, _metal.arrayContentDidChange)(this, idx, 0, 1);
    },
    removeFirst: function () {
      (0, _metal.arrayContentWillChange)(this, 0, 1, 0);

      this._content.shift();

      (0, _metal.arrayContentDidChange)(this, 0, 1, 0);
    },
    objectAt: function (idx) {
      return this._content[idx];
    },
    length: (0, _metal.computed)(function () {
      return this._content.length;
    })
  });
  /*
    Implement a basic fake mutable array.  This validates that any non-native
    enumerable can impl this API.
  */


  var TestMutableArray = _object.default.extend(_array.MutableArray, {
    _content: null,
    init: function () {
      var ary = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this._content = (0, _array.A)(ary);
    },
    replace: function (idx, amt, objects) {
      var args = objects ? objects.slice() : [];
      var removeAmt = amt;
      var addAmt = args.length;
      (0, _metal.arrayContentWillChange)(this, idx, removeAmt, addAmt);
      args.unshift(amt);
      args.unshift(idx);

      this._content.splice.apply(this._content, args);

      (0, _metal.arrayContentDidChange)(this, idx, removeAmt, addAmt);
      return this;
    },
    objectAt: function (idx) {
      return this._content[idx];
    },
    length: (0, _metal.computed)(function () {
      return this._content.length;
    }),
    slice: function () {
      return this._content.slice();
    }
  });

  var CopyableObject = _object.default.extend(_copyable.default, {
    id: null,
    init: function () {
      this._super.apply(this, arguments);

      (0, _metal.set)(this, 'id', (0, _utils.generateGuid)());
    },
    copy: function () {
      var ret = CopyableObject.create();
      (0, _metal.set)(ret, 'id', (0, _metal.get)(this, 'id'));
      return ret;
    }
  });

  var MutableArrayHelpers =
  /*#__PURE__*/
  function (_NativeArrayHelpers) {
    (0, _emberBabel.inheritsLoose)(MutableArrayHelpers, _NativeArrayHelpers);

    function MutableArrayHelpers() {
      return _NativeArrayHelpers.apply(this, arguments) || this;
    }

    var _proto6 = MutableArrayHelpers.prototype;

    _proto6.newObject = function newObject(ary) {
      return TestMutableArray.create(_NativeArrayHelpers.prototype.newObject.call(this, ary));
    } // allows for testing of the basic enumerable after an internal mutation
    ;

    _proto6.mutate = function mutate(obj) {
      obj.addObject(this.getFixture(1)[0]);
    };

    return MutableArrayHelpers;
  }(NativeArrayHelpers);

  var EmberArrayHelpers =
  /*#__PURE__*/
  function (_MutableArrayHelpers) {
    (0, _emberBabel.inheritsLoose)(EmberArrayHelpers, _MutableArrayHelpers);

    function EmberArrayHelpers() {
      return _MutableArrayHelpers.apply(this, arguments) || this;
    }

    var _proto7 = EmberArrayHelpers.prototype;

    _proto7.newObject = function newObject(ary) {
      return TestArray.create(_MutableArrayHelpers.prototype.newObject.call(this, ary));
    };

    return EmberArrayHelpers;
  }(MutableArrayHelpers);

  function runArrayTests(name, Tests) {
    for (var _len2 = arguments.length, types = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      types[_key2 - 2] = arguments[_key2];
    }

    if (types.length > 0) {
      types.forEach(function (type) {
        switch (type) {
          case 'ArrayProxy':
            (0, _internalTestHelpers.moduleFor)("ArrayProxy: " + name, Tests, ArrayProxyHelpers);
            break;

          case 'EmberArray':
            (0, _internalTestHelpers.moduleFor)("EmberArray: " + name, Tests, EmberArrayHelpers);
            break;

          case 'MutableArray':
            (0, _internalTestHelpers.moduleFor)("MutableArray: " + name, Tests, EmberArrayHelpers);
            break;

          case 'CopyableArray':
            (0, _internalTestHelpers.moduleFor)("CopyableArray: " + name, Tests, CopyableArray);
            break;

          case 'CopyableNativeArray':
            (0, _internalTestHelpers.moduleFor)("CopyableNativeArray: " + name, Tests, CopyableNativeArray);
            break;

          case 'NativeArray':
            (0, _internalTestHelpers.moduleFor)("NativeArray: " + name, Tests, EmberArrayHelpers);
            break;
        }
      });
    } else {
      (0, _internalTestHelpers.moduleFor)("ArrayProxy: " + name, Tests, ArrayProxyHelpers);
      (0, _internalTestHelpers.moduleFor)("EmberArray: " + name, Tests, EmberArrayHelpers);
      (0, _internalTestHelpers.moduleFor)("MutableArray: " + name, Tests, MutableArrayHelpers);
      (0, _internalTestHelpers.moduleFor)("NativeArray: " + name, Tests, NativeArrayHelpers);
    }
  }
});
enifed("@ember/-internals/runtime/tests/inject_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers"], function (_emberBabel, _metal, _object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('inject',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test attempting to inject a nonexistent container key should error'] = function testAttemptingToInjectANonexistentContainerKeyShouldError() {
      var owner = (0, _internalTestHelpers.buildOwner)();

      var AnObject = _object.default.extend({
        foo: (0, _metal.inject)('bar', 'baz')
      });

      owner.register('foo:main', AnObject);
      expectAssertion(function () {
        owner.lookup('foo:main');
      }, /Attempting to inject an unknown injection: 'bar:baz'/);
    };

    _proto['@test factories should return a list of lazy injection full names'] = function testFactoriesShouldReturnAListOfLazyInjectionFullNames(assert) {
      if (true
      /* DEBUG */
      ) {
          var AnObject = _object.default.extend({
            foo: (0, _metal.inject)('foo', 'bar'),
            bar: (0, _metal.inject)('quux')
          });

          assert.deepEqual(AnObject._lazyInjections(), {
            foo: {
              specifier: 'foo:bar',
              source: undefined,
              namespace: undefined
            },
            bar: {
              specifier: 'quux:bar',
              source: undefined,
              namespace: undefined
            }
          }, 'should return injected container keys');
        } else {
        assert.expect(0);
      }
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/legacy_1x/mixins/observable/chained_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/object", "@ember/-internals/runtime/lib/mixins/array", "internal-test-helpers"], function (_emberBabel, _metal, _object, _array, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * changed obj.set() and obj.get() to Ember.set() and Ember.get()
    * changed obj.addObserver() to addObserver()
  */
  (0, _internalTestHelpers.moduleFor)('Ember.Observable - Observing with @each',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test chained observers on enumerable properties are triggered when the observed property of any item changes'] =
    /*#__PURE__*/
    function () {
      var _testChainedObserversOnEnumerablePropertiesAreTriggeredWhenTheObservedPropertyOfAnyItemChanges = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var family, momma, child1, child2, child3, child4, observerFiredCount, i;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              family = _object.default.create({
                momma: null
              });
              momma = _object.default.create({
                children: []
              });
              child1 = _object.default.create({
                name: 'Bartholomew'
              });
              child2 = _object.default.create({
                name: 'Agnes'
              });
              child3 = _object.default.create({
                name: 'Dan'
              });
              child4 = _object.default.create({
                name: 'Nancy'
              });
              (0, _metal.set)(family, 'momma', momma);
              (0, _metal.set)(momma, 'children', (0, _array.A)([child1, child2, child3]));
              observerFiredCount = 0;
              (0, _metal.addObserver)(family, 'momma.children.@each.name', this, function () {
                observerFiredCount++;
              });
              observerFiredCount = 0;
              i = 0;

            case 12:
              if (!(i < momma.children.length)) {
                _context.next = 19;
                break;
              }

              momma.children[i].set('name', 'Juan');
              _context.next = 16;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 16:
              i++;
              _context.next = 12;
              break;

            case 19:
              assert.equal(observerFiredCount, 3, 'observer fired after changing child names');
              observerFiredCount = 0;
              (0, _metal.get)(momma, 'children').pushObject(child4);
              _context.next = 24;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 24:
              assert.equal(observerFiredCount, 1, 'observer fired after adding a new item');
              observerFiredCount = 0;
              (0, _metal.set)(child4, 'name', 'Herbert');
              _context.next = 29;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 29:
              assert.equal(observerFiredCount, 1, 'observer fired after changing property on new object');
              (0, _metal.set)(momma, 'children', []);
              _context.next = 33;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 33:
              observerFiredCount = 0;
              (0, _metal.set)(child1, 'name', 'Hanna');
              _context.next = 37;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 37:
              assert.equal(observerFiredCount, 0, 'observer did not fire after removing changing property on a removed object');

            case 38:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testChainedObserversOnEnumerablePropertiesAreTriggeredWhenTheObservedPropertyOfAnyItemChanges(_x) {
        return _testChainedObserversOnEnumerablePropertiesAreTriggeredWhenTheObservedPropertyOfAnyItemChanges.apply(this, arguments);
      }

      return testChainedObserversOnEnumerablePropertiesAreTriggeredWhenTheObservedPropertyOfAnyItemChanges;
    }();

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/legacy_1x/mixins/observable/observable_test", ["ember-babel", "@ember/-internals/environment", "@ember/runloop", "@ember/-internals/metal", "@ember/string", "@ember/-internals/runtime/lib/system/object", "@ember/-internals/runtime/lib/mixins/observable", "@ember/-internals/runtime/lib/mixins/array", "internal-test-helpers"], function (_emberBabel, _environment, _runloop, _metal, _string, _object, _observable, _array, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * Added ObservableObject which applies the Ember.Observable mixin.
    * Changed reference to Ember.T_FUNCTION to 'function'
    * Changed all references to sc_super to this._super(...arguments)
    * Changed Ember.objectForPropertyPath() to Ember.getPath()
    * Removed allPropertiesDidChange test - no longer supported
    * Changed test that uses 'ObjectE' as path to 'objectE' to reflect new
      rule on using capital letters for property paths.
    * Removed test passing context to addObserver.  context param is no longer
      supported.
    * removed test in observer around line 862 that expected key/value to be
      the last item in the chained path.  Should be root and chained path
  
  */
  // ========================================================================
  // Ember.Observable Tests
  // ========================================================================
  var object, ObjectC, ObjectD, objectA, objectB, lookup;

  var ObservableObject = _object.default.extend(_observable.default);

  var originalLookup = _environment.context.lookup; // ..........................................................
  // GET()
  //

  (0, _internalTestHelpers.moduleFor)('object.get()',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      object = ObservableObject.extend(_observable.default, {
        computed: (0, _metal.computed)(function () {
          return 'value';
        }),
        method: function () {
          return 'value';
        },
        unknownProperty: function (key) {
          this.lastUnknownProperty = key;
          return 'unknown';
        }
      }).create({
        normal: 'value',
        numberVal: 24,
        toggleVal: true,
        nullProperty: null
      });
    };

    _proto['@test should get normal properties'] = function testShouldGetNormalProperties(assert) {
      assert.equal(object.get('normal'), 'value');
    };

    _proto['@test should call computed properties and return their result'] = function testShouldCallComputedPropertiesAndReturnTheirResult(assert) {
      assert.equal(object.get('computed'), 'value');
    };

    _proto['@test should return the function for a non-computed property'] = function testShouldReturnTheFunctionForANonComputedProperty(assert) {
      var value = object.get('method');
      assert.equal(typeof value, 'function');
    };

    _proto['@test should return null when property value is null'] = function testShouldReturnNullWhenPropertyValueIsNull(assert) {
      assert.equal(object.get('nullProperty'), null);
    };

    _proto['@test should call unknownProperty when value is undefined'] = function testShouldCallUnknownPropertyWhenValueIsUndefined(assert) {
      assert.equal(object.get('unknown'), 'unknown');
      assert.equal(object.lastUnknownProperty, 'unknown');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // Ember.GET()
  //

  (0, _internalTestHelpers.moduleFor)('Ember.get()',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2.beforeEach = function beforeEach() {
      objectA = ObservableObject.extend({
        computed: (0, _metal.computed)(function () {
          return 'value';
        }),
        method: function () {
          return 'value';
        },
        unknownProperty: function (key) {
          this.lastUnknownProperty = key;
          return 'unknown';
        }
      }).create({
        normal: 'value',
        numberVal: 24,
        toggleVal: true,
        nullProperty: null
      });
      objectB = {
        normal: 'value',
        nullProperty: null
      };
    };

    _proto2['@test should get normal properties on Ember.Observable'] = function testShouldGetNormalPropertiesOnEmberObservable(assert) {
      assert.equal((0, _metal.get)(objectA, 'normal'), 'value');
    };

    _proto2['@test should call computed properties on Ember.Observable and return their result'] = function testShouldCallComputedPropertiesOnEmberObservableAndReturnTheirResult(assert) {
      assert.equal((0, _metal.get)(objectA, 'computed'), 'value');
    };

    _proto2['@test should return the function for a non-computed property on Ember.Observable'] = function testShouldReturnTheFunctionForANonComputedPropertyOnEmberObservable(assert) {
      var value = (0, _metal.get)(objectA, 'method');
      assert.equal(typeof value, 'function');
    };

    _proto2['@test should return null when property value is null on Ember.Observable'] = function testShouldReturnNullWhenPropertyValueIsNullOnEmberObservable(assert) {
      assert.equal((0, _metal.get)(objectA, 'nullProperty'), null);
    };

    _proto2['@test should call unknownProperty when value is undefined on Ember.Observable'] = function testShouldCallUnknownPropertyWhenValueIsUndefinedOnEmberObservable(assert) {
      assert.equal((0, _metal.get)(objectA, 'unknown'), 'unknown');
      assert.equal(objectA.lastUnknownProperty, 'unknown');
    };

    _proto2['@test should get normal properties on standard objects'] = function testShouldGetNormalPropertiesOnStandardObjects(assert) {
      assert.equal((0, _metal.get)(objectB, 'normal'), 'value');
    };

    _proto2['@test should return null when property is null on standard objects'] = function testShouldReturnNullWhenPropertyIsNullOnStandardObjects(assert) {
      assert.equal((0, _metal.get)(objectB, 'nullProperty'), null);
    };

    _proto2['@test raise if the provided object is undefined'] = function testRaiseIfTheProvidedObjectIsUndefined() {
      expectAssertion(function () {
        (0, _metal.get)(undefined, 'key');
      }, /Cannot call get with 'key' on an undefined object/i);
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Ember.get() with paths',
  /*#__PURE__*/
  function (_AbstractTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class3, _AbstractTestCase3);

    function _class3() {
      return _AbstractTestCase3.apply(this, arguments) || this;
    }

    var _proto3 = _class3.prototype;

    _proto3['@test should return a property at a given path relative to the passed object'] = function testShouldReturnAPropertyAtAGivenPathRelativeToThePassedObject(assert) {
      var foo = ObservableObject.create({
        bar: ObservableObject.extend({
          baz: (0, _metal.computed)(function () {
            return 'blargh';
          })
        }).create()
      });
      assert.equal((0, _metal.get)(foo, 'bar.baz'), 'blargh');
    };

    _proto3['@test should return a property at a given path relative to the passed object - JavaScript hash'] = function testShouldReturnAPropertyAtAGivenPathRelativeToThePassedObjectJavaScriptHash(assert) {
      var foo = {
        bar: {
          baz: 'blargh'
        }
      };
      assert.equal((0, _metal.get)(foo, 'bar.baz'), 'blargh');
    };

    return _class3;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // SET()
  //

  (0, _internalTestHelpers.moduleFor)('object.set()',
  /*#__PURE__*/
  function (_AbstractTestCase4) {
    (0, _emberBabel.inheritsLoose)(_class4, _AbstractTestCase4);

    function _class4() {
      return _AbstractTestCase4.apply(this, arguments) || this;
    }

    var _proto4 = _class4.prototype;

    _proto4.beforeEach = function beforeEach() {
      object = ObservableObject.extend({
        computed: (0, _metal.computed)({
          get: function () {
            return this._computed;
          },
          set: function (key, value) {
            this._computed = value;
            return this._computed;
          }
        }),
        method: function (key, value) {
          if (value !== undefined) {
            this._method = value;
          }

          return this._method;
        },
        unknownProperty: function () {
          return this._unknown;
        },
        setUnknownProperty: function (key, value) {
          this._unknown = value;
          return this._unknown;
        },
        // normal property
        normal: 'value',
        // computed property
        _computed: 'computed',
        // method, but not a property
        _method: 'method',
        // null property
        nullProperty: null,
        // unknown property
        _unknown: 'unknown'
      }).create();
    };

    _proto4['@test should change normal properties and return the value'] = function testShouldChangeNormalPropertiesAndReturnTheValue(assert) {
      var ret = object.set('normal', 'changed');
      assert.equal(object.get('normal'), 'changed');
      assert.equal(ret, 'changed');
    };

    _proto4['@test should call computed properties passing value and return the value'] = function testShouldCallComputedPropertiesPassingValueAndReturnTheValue(assert) {
      var ret = object.set('computed', 'changed');
      assert.equal(object.get('_computed'), 'changed');
      assert.equal(ret, 'changed');
    };

    _proto4['@test should change normal properties when passing undefined'] = function testShouldChangeNormalPropertiesWhenPassingUndefined(assert) {
      var ret = object.set('normal', undefined);
      assert.equal(object.get('normal'), undefined);
      assert.equal(ret, undefined);
    };

    _proto4['@test should replace the function for a non-computed property and return the value'] = function testShouldReplaceTheFunctionForANonComputedPropertyAndReturnTheValue(assert) {
      var ret = object.set('method', 'changed');
      assert.equal(object.get('_method'), 'method'); // make sure this was NOT run

      assert.ok(typeof object.get('method') !== 'function');
      assert.equal(ret, 'changed');
    };

    _proto4['@test should replace prover when property value is null'] = function testShouldReplaceProverWhenPropertyValueIsNull(assert) {
      var ret = object.set('nullProperty', 'changed');
      assert.equal(object.get('nullProperty'), 'changed');
      assert.equal(ret, 'changed');
    };

    _proto4['@test should call unknownProperty with value when property is undefined'] = function testShouldCallUnknownPropertyWithValueWhenPropertyIsUndefined(assert) {
      var ret = object.set('unknown', 'changed');
      assert.equal(object.get('_unknown'), 'changed');
      assert.equal(ret, 'changed');
    };

    return _class4;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // COMPUTED PROPERTIES
  //

  (0, _internalTestHelpers.moduleFor)('Computed properties',
  /*#__PURE__*/
  function (_AbstractTestCase5) {
    (0, _emberBabel.inheritsLoose)(_class5, _AbstractTestCase5);

    function _class5() {
      return _AbstractTestCase5.apply(this, arguments) || this;
    }

    var _proto5 = _class5.prototype;

    _proto5.beforeEach = function beforeEach() {
      lookup = _environment.context.lookup = {};
      expectDeprecation(function () {
        object = ObservableObject.extend({
          computed: (0, _metal.computed)({
            get: function () {
              this.computedCalls.push('getter-called');
              return 'computed';
            },
            set: function (key, value) {
              this.computedCalls.push(value);
            }
          }).volatile(),
          computedCached: (0, _metal.computed)({
            get: function () {
              this.computedCachedCalls.push('getter-called');
              return 'computedCached';
            },
            set: function (key, value) {
              this.computedCachedCalls.push(value);
            }
          }),
          dependent: (0, _metal.computed)('changer', {
            get: function () {
              this.dependentCalls.push('getter-called');
              return 'dependent';
            },
            set: function (key, value) {
              this.dependentCalls.push(value);
            }
          }).volatile(),
          dependentFront: (0, _metal.computed)('changer', {
            get: function () {
              this.dependentFrontCalls.push('getter-called');
              return 'dependentFront';
            },
            set: function (key, value) {
              this.dependentFrontCalls.push(value);
            }
          }).volatile(),
          dependentCached: (0, _metal.computed)('changer', {
            get: function () {
              this.dependentCachedCalls.push('getter-called!');
              return 'dependentCached';
            },
            set: function (key, value) {
              this.dependentCachedCalls.push(value);
            }
          }),
          inc: (0, _metal.computed)('changer', function () {
            return this.incCallCount++;
          }),
          nestedInc: (0, _metal.computed)('inc', function () {
            (0, _metal.get)(this, 'inc');
            return this.nestedIncCallCount++;
          }),
          isOn: (0, _metal.computed)('state', {
            get: function () {
              return this.get('state') === 'on';
            },
            set: function () {
              this.set('state', 'on');
              return this.get('state') === 'on';
            }
          }).volatile(),
          isOff: (0, _metal.computed)('state', {
            get: function () {
              return this.get('state') === 'off';
            },
            set: function () {
              this.set('state', 'off');
              return this.get('state') === 'off';
            }
          }).volatile()
        }).create({
          computedCalls: [],
          computedCachedCalls: [],
          changer: 'foo',
          dependentCalls: [],
          dependentFrontCalls: [],
          dependentCachedCalls: [],
          incCallCount: 0,
          nestedIncCallCount: 0,
          state: 'on'
        });
      });
    };

    _proto5.afterEach = function afterEach() {
      _environment.context.lookup = originalLookup;
    };

    _proto5['@test getting values should call function return value'] = function testGettingValuesShouldCallFunctionReturnValue(assert) {
      // get each property twice. Verify return.
      var keys = (0, _string.w)('computed computedCached dependent dependentFront dependentCached');
      keys.forEach(function (key) {
        assert.equal(object.get(key), key, "Try #1: object.get(" + key + ") should run function");
        assert.equal(object.get(key), key, "Try #2: object.get(" + key + ") should run function");
      }); // verify each call count.  cached should only be called once

      (0, _string.w)('computedCalls dependentFrontCalls dependentCalls').forEach(function (key) {
        assert.equal(object[key].length, 2, "non-cached property " + key + " should be called 2x");
      });
      (0, _string.w)('computedCachedCalls dependentCachedCalls').forEach(function (key) {
        assert.equal(object[key].length, 1, "non-cached property " + key + " should be called 1x");
      });
    };

    _proto5['@test setting values should call function return value'] = function testSettingValuesShouldCallFunctionReturnValue(assert) {
      // get each property twice. Verify return.
      var keys = (0, _string.w)('computed dependent dependentFront computedCached dependentCached');
      var values = (0, _string.w)('value1 value2');
      keys.forEach(function (key) {
        assert.equal(object.set(key, values[0]), values[0], "Try #1: object.set(" + key + ", " + values[0] + ") should run function");
        assert.equal(object.set(key, values[1]), values[1], "Try #2: object.set(" + key + ", " + values[1] + ") should run function");
        assert.equal(object.set(key, values[1]), values[1], "Try #3: object.set(" + key + ", " + values[1] + ") should not run function since it is setting same value as before");
      }); // verify each call count.  cached should only be called once

      keys.forEach(function (key) {
        var calls = object[key + 'Calls'];
        var idx, expectedLength; // Cached properties first check their cached value before setting the
        // property. Other properties blindly call set.

        expectedLength = 3;
        assert.equal(calls.length, expectedLength, "set(" + key + ") should be called the right amount of times");

        for (idx = 0; idx < 2; idx++) {
          assert.equal(calls[idx], values[idx], "call #" + (idx + 1) + " to set(" + key + ") should have passed value " + values[idx]);
        }
      });
    };

    _proto5['@test notify change should clear cache'] = function testNotifyChangeShouldClearCache(assert) {
      // call get several times to collect call count
      object.get('computedCached'); // should run func

      object.get('computedCached'); // should not run func

      object.notifyPropertyChange('computedCached');
      object.get('computedCached'); // should run again

      assert.equal(object.computedCachedCalls.length, 2, 'should have invoked method 2x');
    };

    _proto5['@test change dependent should clear cache'] = function testChangeDependentShouldClearCache(assert) {
      // call get several times to collect call count
      var ret1 = object.get('inc'); // should run func

      assert.equal(object.get('inc'), ret1, 'multiple calls should not run cached prop');
      object.set('changer', 'bar');
      assert.equal(object.get('inc'), ret1 + 1, 'should increment after dependent key changes'); // should run again
    };

    _proto5['@test just notifying change of dependent should clear cache'] = function testJustNotifyingChangeOfDependentShouldClearCache(assert) {
      // call get several times to collect call count
      var ret1 = object.get('inc'); // should run func

      assert.equal(object.get('inc'), ret1, 'multiple calls should not run cached prop');
      object.notifyPropertyChange('changer');
      assert.equal(object.get('inc'), ret1 + 1, 'should increment after dependent key changes'); // should run again
    };

    _proto5['@test changing dependent should clear nested cache'] = function testChangingDependentShouldClearNestedCache(assert) {
      // call get several times to collect call count
      var ret1 = object.get('nestedInc'); // should run func

      assert.equal(object.get('nestedInc'), ret1, 'multiple calls should not run cached prop');
      object.set('changer', 'bar');
      assert.equal(object.get('nestedInc'), ret1 + 1, 'should increment after dependent key changes'); // should run again
    };

    _proto5['@test just notifying change of dependent should clear nested cache'] = function testJustNotifyingChangeOfDependentShouldClearNestedCache(assert) {
      // call get several times to collect call count
      var ret1 = object.get('nestedInc'); // should run func

      assert.equal(object.get('nestedInc'), ret1, 'multiple calls should not run cached prop');
      object.notifyPropertyChange('changer');
      assert.equal(object.get('nestedInc'), ret1 + 1, 'should increment after dependent key changes'); // should run again
    } // This verifies a specific bug encountered where observers for computed
    // properties would fire before their prop caches were cleared.
    ;

    _proto5['@test change dependent should clear cache when observers of dependent are called'] = function testChangeDependentShouldClearCacheWhenObserversOfDependentAreCalled(assert) {
      // call get several times to collect call count
      var ret1 = object.get('inc'); // should run func

      assert.equal(object.get('inc'), ret1, 'multiple calls should not run cached prop'); // add observer to verify change...

      object.addObserver('inc', this, function () {
        assert.equal(object.get('inc'), ret1 + 1, 'should increment after dependent key changes'); // should run again
      }); // now run

      object.set('changer', 'bar');
    };

    _proto5['@test setting one of two computed properties that depend on a third property should clear the kvo cache'] = function testSettingOneOfTwoComputedPropertiesThatDependOnAThirdPropertyShouldClearTheKvoCache(assert) {
      // we have to call set twice to fill up the cache
      object.set('isOff', true);
      object.set('isOn', true); // setting isOff to true should clear the kvo cache

      object.set('isOff', true);
      assert.equal(object.get('isOff'), true, 'object.isOff should be true');
      assert.equal(object.get('isOn'), false, 'object.isOn should be false');
    };

    _proto5['@test dependent keys should be able to be specified as property paths'] = function testDependentKeysShouldBeAbleToBeSpecifiedAsPropertyPaths(assert) {
      var depObj = ObservableObject.extend({
        menuPrice: (0, _metal.computed)('menu.price', function () {
          return this.get('menu.price');
        })
      }).create({
        menu: ObservableObject.create({
          price: 5
        })
      });
      assert.equal(depObj.get('menuPrice'), 5, 'precond - initial value returns 5');
      depObj.set('menu.price', 6);
      assert.equal(depObj.get('menuPrice'), 6, 'cache is properly invalidated after nested property changes');
    };

    _proto5['@test cacheable nested dependent keys should clear after their dependencies update'] = function testCacheableNestedDependentKeysShouldClearAfterTheirDependenciesUpdate(assert) {
      assert.ok(true);
      var DepObj;
      (0, _runloop.run)(function () {
        lookup.DepObj = DepObj = ObservableObject.extend({
          price: (0, _metal.computed)('restaurant.menu.price', function () {
            return this.get('restaurant.menu.price');
          })
        }).create({
          restaurant: ObservableObject.create({
            menu: ObservableObject.create({
              price: 5
            })
          })
        });
      });
      assert.equal(DepObj.get('price'), 5, 'precond - computed property is correct');
      (0, _runloop.run)(function () {
        DepObj.set('restaurant.menu.price', 10);
      });
      assert.equal(DepObj.get('price'), 10, 'cacheable computed properties are invalidated even if no run loop occurred');
      (0, _runloop.run)(function () {
        DepObj.set('restaurant.menu.price', 20);
      });
      assert.equal(DepObj.get('price'), 20, 'cacheable computed properties are invalidated after a second get before a run loop');
      assert.equal(DepObj.get('price'), 20, 'precond - computed properties remain correct after a run loop');
      (0, _runloop.run)(function () {
        DepObj.set('restaurant.menu', ObservableObject.create({
          price: 15
        }));
      });
      assert.equal(DepObj.get('price'), 15, 'cacheable computed properties are invalidated after a middle property changes');
      (0, _runloop.run)(function () {
        DepObj.set('restaurant.menu', ObservableObject.create({
          price: 25
        }));
      });
      assert.equal(DepObj.get('price'), 25, 'cacheable computed properties are invalidated after a middle property changes again, before a run loop');
    };

    return _class5;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // OBSERVABLE OBJECTS
  //

  (0, _internalTestHelpers.moduleFor)('Observable objects & object properties ',
  /*#__PURE__*/
  function (_AbstractTestCase6) {
    (0, _emberBabel.inheritsLoose)(_class6, _AbstractTestCase6);

    function _class6() {
      return _AbstractTestCase6.apply(this, arguments) || this;
    }

    var _proto6 = _class6.prototype;

    _proto6.beforeEach = function beforeEach() {
      object = ObservableObject.extend({
        getEach: function () {
          var keys = ['normal', 'abnormal'];
          var ret = [];

          for (var idx = 0; idx < keys.length; idx++) {
            ret[ret.length] = this.get(keys[idx]);
          }

          return ret;
        },
        newObserver: function () {
          this.abnormal = 'changedValueObserved';
        },
        testObserver: (0, _metal.observer)('normal', function () {
          this.abnormal = 'removedObserver';
        }),
        testArrayObserver: (0, _metal.observer)('normalArray.[]', function () {
          this.abnormal = 'notifiedObserver';
        })
      }).create({
        normal: 'value',
        abnormal: 'zeroValue',
        numberVal: 24,
        toggleVal: true,
        observedProperty: 'beingWatched',
        testRemove: 'observerToBeRemoved',
        normalArray: (0, _array.A)([1, 2, 3, 4, 5])
      });
    };

    _proto6['@test incrementProperty and decrementProperty'] = function testIncrementPropertyAndDecrementProperty(assert) {
      var newValue = object.incrementProperty('numberVal');
      assert.equal(25, newValue, 'numerical value incremented');
      object.numberVal = 24;
      newValue = object.decrementProperty('numberVal');
      assert.equal(23, newValue, 'numerical value decremented');
      object.numberVal = 25;
      newValue = object.incrementProperty('numberVal', 5);
      assert.equal(30, newValue, 'numerical value incremented by specified increment');
      object.numberVal = 25;
      newValue = object.incrementProperty('numberVal', -5);
      assert.equal(20, newValue, 'minus numerical value incremented by specified increment');
      object.numberVal = 25;
      newValue = object.incrementProperty('numberVal', 0);
      assert.equal(25, newValue, 'zero numerical value incremented by specified increment');
      expectAssertion(function () {
        newValue = object.incrementProperty('numberVal', 0 - void 0); // Increment by NaN
      }, /Must pass a numeric value to incrementProperty/i);
      expectAssertion(function () {
        newValue = object.incrementProperty('numberVal', 'Ember'); // Increment by non-numeric String
      }, /Must pass a numeric value to incrementProperty/i);
      expectAssertion(function () {
        newValue = object.incrementProperty('numberVal', 1 / 0); // Increment by Infinity
      }, /Must pass a numeric value to incrementProperty/i);
      assert.equal(25, newValue, 'Attempting to increment by non-numeric values should not increment value');
      object.numberVal = 25;
      newValue = object.decrementProperty('numberVal', 5);
      assert.equal(20, newValue, 'numerical value decremented by specified increment');
      object.numberVal = 25;
      newValue = object.decrementProperty('numberVal', -5);
      assert.equal(30, newValue, 'minus numerical value decremented by specified increment');
      object.numberVal = 25;
      newValue = object.decrementProperty('numberVal', 0);
      assert.equal(25, newValue, 'zero numerical value decremented by specified increment');
      expectAssertion(function () {
        newValue = object.decrementProperty('numberVal', 0 - void 0); // Decrement by NaN
      }, /Must pass a numeric value to decrementProperty/i);
      expectAssertion(function () {
        newValue = object.decrementProperty('numberVal', 'Ember'); // Decrement by non-numeric String
      }, /Must pass a numeric value to decrementProperty/i);
      expectAssertion(function () {
        newValue = object.decrementProperty('numberVal', 1 / 0); // Decrement by Infinity
      }, /Must pass a numeric value to decrementProperty/i);
      assert.equal(25, newValue, 'Attempting to decrement by non-numeric values should not decrement value');
    };

    _proto6['@test toggle function, should be boolean'] = function testToggleFunctionShouldBeBoolean(assert) {
      assert.equal(object.toggleProperty('toggleVal', true, false), object.get('toggleVal'));
      assert.equal(object.toggleProperty('toggleVal', true, false), object.get('toggleVal'));
      assert.equal(object.toggleProperty('toggleVal', undefined, undefined), object.get('toggleVal'));
    };

    _proto6['@test should notify array observer when array changes'] =
    /*#__PURE__*/
    function () {
      var _testShouldNotifyArrayObserverWhenArrayChanges = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              (0, _metal.get)(object, 'normalArray').replace(0, 0, [6]);
              _context.next = 3;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 3:
              assert.equal(object.abnormal, 'notifiedObserver', 'observer should be notified');

            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function testShouldNotifyArrayObserverWhenArrayChanges(_x) {
        return _testShouldNotifyArrayObserverWhenArrayChanges.apply(this, arguments);
      }

      return testShouldNotifyArrayObserverWhenArrayChanges;
    }();

    return _class6;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('object.addObserver()',
  /*#__PURE__*/
  function (_AbstractTestCase7) {
    (0, _emberBabel.inheritsLoose)(_class7, _AbstractTestCase7);

    function _class7() {
      return _AbstractTestCase7.apply(this, arguments) || this;
    }

    var _proto7 = _class7.prototype;

    _proto7.beforeEach = function beforeEach() {
      ObjectC = ObservableObject.create({
        objectE: ObservableObject.create({
          propertyVal: 'chainedProperty'
        }),
        normal: 'value',
        normal1: 'zeroValue',
        normal2: 'dependentValue',
        incrementor: 10,
        action: function () {
          this.normal1 = 'newZeroValue';
        },
        observeOnceAction: function () {
          this.incrementor = this.incrementor + 1;
        },
        chainedObserver: function () {
          this.normal2 = 'chainedPropertyObserved';
        }
      });
    };

    _proto7['@test should register an observer for a property'] =
    /*#__PURE__*/
    function () {
      var _testShouldRegisterAnObserverForAProperty = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              ObjectC.addObserver('normal', ObjectC, 'action');
              ObjectC.set('normal', 'newValue');
              _context2.next = 4;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 4:
              assert.equal(ObjectC.normal1, 'newZeroValue');

            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));

      function testShouldRegisterAnObserverForAProperty(_x2) {
        return _testShouldRegisterAnObserverForAProperty.apply(this, arguments);
      }

      return testShouldRegisterAnObserverForAProperty;
    }();

    _proto7['@test should register an observer for a property - Special case of chained property'] =
    /*#__PURE__*/
    function () {
      var _testShouldRegisterAnObserverForAPropertySpecialCaseOfChainedProperty = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(assert) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              ObjectC.addObserver('objectE.propertyVal', ObjectC, 'chainedObserver');
              ObjectC.objectE.set('propertyVal', 'chainedPropertyValue');
              _context3.next = 4;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 4:
              assert.equal('chainedPropertyObserved', ObjectC.normal2);
              ObjectC.normal2 = 'dependentValue';
              ObjectC.set('objectE', '');
              _context3.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              assert.equal('chainedPropertyObserved', ObjectC.normal2);

            case 10:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));

      function testShouldRegisterAnObserverForAPropertySpecialCaseOfChainedProperty(_x3) {
        return _testShouldRegisterAnObserverForAPropertySpecialCaseOfChainedProperty.apply(this, arguments);
      }

      return testShouldRegisterAnObserverForAPropertySpecialCaseOfChainedProperty;
    }();

    return _class7;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('object.removeObserver()',
  /*#__PURE__*/
  function (_AbstractTestCase8) {
    (0, _emberBabel.inheritsLoose)(_class8, _AbstractTestCase8);

    function _class8() {
      return _AbstractTestCase8.apply(this, arguments) || this;
    }

    var _proto8 = _class8.prototype;

    _proto8.beforeEach = function beforeEach() {
      ObjectD = ObservableObject.create({
        objectF: ObservableObject.create({
          propertyVal: 'chainedProperty'
        }),
        normal: 'value',
        normal1: 'zeroValue',
        normal2: 'dependentValue',
        ArrayKeys: ['normal', 'normal1'],
        addAction: function () {
          this.normal1 = 'newZeroValue';
        },
        removeAction: function () {
          this.normal2 = 'newDependentValue';
        },
        removeChainedObserver: function () {
          this.normal2 = 'chainedPropertyObserved';
        },
        observableValue: 'hello world',
        observer1: function () {// Just an observer
        },
        observer2: function () {
          this.removeObserver('observableValue', null, 'observer1');
          this.removeObserver('observableValue', null, 'observer2');
          this.hasObserverFor('observableValue'); // Tickle 'getMembers()'

          this.removeObserver('observableValue', null, 'observer3');
        },
        observer3: function () {// Just an observer
        }
      });
    };

    _proto8['@test should unregister an observer for a property'] =
    /*#__PURE__*/
    function () {
      var _testShouldUnregisterAnObserverForAProperty = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(assert) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              ObjectD.addObserver('normal', ObjectD, 'addAction');
              ObjectD.set('normal', 'newValue');
              _context4.next = 4;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 4:
              assert.equal(ObjectD.normal1, 'newZeroValue');
              ObjectD.set('normal1', 'zeroValue');
              _context4.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              ObjectD.removeObserver('normal', ObjectD, 'addAction');
              ObjectD.set('normal', 'newValue');
              assert.equal(ObjectD.normal1, 'zeroValue');

            case 11:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));

      function testShouldUnregisterAnObserverForAProperty(_x4) {
        return _testShouldUnregisterAnObserverForAProperty.apply(this, arguments);
      }

      return testShouldUnregisterAnObserverForAProperty;
    }();

    _proto8["@test should unregister an observer for a property - special case when key has a '.' in it."] =
    /*#__PURE__*/
    function () {
      var _testShouldUnregisterAnObserverForAPropertySpecialCaseWhenKeyHasAInIt = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(assert) {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              ObjectD.addObserver('objectF.propertyVal', ObjectD, 'removeChainedObserver');
              ObjectD.objectF.set('propertyVal', 'chainedPropertyValue');
              _context5.next = 4;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 4:
              ObjectD.removeObserver('objectF.propertyVal', ObjectD, 'removeChainedObserver');
              ObjectD.normal2 = 'dependentValue';
              ObjectD.objectF.set('propertyVal', 'removedPropertyValue');
              _context5.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              assert.equal('dependentValue', ObjectD.normal2);
              ObjectD.set('objectF', '');
              _context5.next = 13;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 13:
              assert.equal('dependentValue', ObjectD.normal2);

            case 14:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }));

      function testShouldUnregisterAnObserverForAPropertySpecialCaseWhenKeyHasAInIt(_x5) {
        return _testShouldUnregisterAnObserverForAPropertySpecialCaseWhenKeyHasAInIt.apply(this, arguments);
      }

      return testShouldUnregisterAnObserverForAPropertySpecialCaseWhenKeyHasAInIt;
    }();

    _proto8['@test removing an observer inside of an observer shouldnt cause any problems'] =
    /*#__PURE__*/
    function () {
      var _testRemovingAnObserverInsideOfAnObserverShouldnTCauseAnyProblems = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(assert) {
        var encounteredError;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              // The observable system should be protected against clients removing
              // observers in the middle of observer notification.
              encounteredError = false;
              _context6.prev = 1;
              ObjectD.addObserver('observableValue', null, 'observer1');
              ObjectD.addObserver('observableValue', null, 'observer2');
              ObjectD.addObserver('observableValue', null, 'observer3');
              ObjectD.set('observableValue', 'hi world');
              _context6.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              _context6.next = 13;
              break;

            case 10:
              _context6.prev = 10;
              _context6.t0 = _context6["catch"](1);
              encounteredError = true;

            case 13:
              assert.equal(encounteredError, false);

            case 14:
            case "end":
              return _context6.stop();
          }
        }, _callee6, null, [[1, 10]]);
      }));

      function testRemovingAnObserverInsideOfAnObserverShouldnTCauseAnyProblems(_x6) {
        return _testRemovingAnObserverInsideOfAnObserverShouldnTCauseAnyProblems.apply(this, arguments);
      }

      return testRemovingAnObserverInsideOfAnObserverShouldnTCauseAnyProblems;
    }();

    return _class8;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/legacy_1x/mixins/observable/propertyChanges_test", ["ember-babel", "@ember/-internals/runtime/lib/system/object", "@ember/-internals/runtime/lib/mixins/observable", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _object, _observable, _metal, _internalTestHelpers) {
  "use strict";

  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * Create ObservableObject which includes Ember.Observable
    * Remove test that tests internal _kvo_changeLevel property.  This is an
      implementation detail.
    * Remove test for allPropertiesDidChange
    * Removed star observer test.  no longer supported
    * Removed property revision test.  no longer supported
  */
  // ========================================================================
  // Ember.Observable Tests
  // ========================================================================
  var ObservableObject = _object.default.extend(_observable.default);

  var ObjectA;

  if (!false
  /* EMBER_METAL_TRACKED_PROPERTIES */
  ) {
      (0, _internalTestHelpers.moduleFor)('object.propertyChanges',
      /*#__PURE__*/
      function (_AbstractTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

        function _class() {
          return _AbstractTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto.beforeEach = function beforeEach() {
          ObjectA = ObservableObject.extend({
            action: (0, _metal.observer)('foo', function () {
              this.set('prop', 'changedPropValue');
            }),
            notifyAction: (0, _metal.observer)('newFoo', function () {
              this.set('newProp', 'changedNewPropValue');
            }),
            notifyAllAction: (0, _metal.observer)('prop', function () {
              this.set('newFoo', 'changedNewFooValue');
            }),
            starObserver: function (target, key) {
              this.starProp = key;
            }
          }).create({
            starProp: null,
            foo: 'fooValue',
            prop: 'propValue',
            newFoo: 'newFooValue',
            newProp: 'newPropValue'
          });
        };

        _proto['@test should observe the changes within the nested begin / end property changes'] = function testShouldObserveTheChangesWithinTheNestedBeginEndPropertyChanges(assert) {
          //start the outer nest
          ObjectA.beginPropertyChanges(); // Inner nest

          ObjectA.beginPropertyChanges();
          ObjectA.set('foo', 'changeFooValue');
          assert.equal(ObjectA.prop, 'propValue');
          ObjectA.endPropertyChanges(); //end inner nest

          ObjectA.set('prop', 'changePropValue');
          assert.equal(ObjectA.newFoo, 'newFooValue'); //close the outer nest

          ObjectA.endPropertyChanges();
          assert.equal(ObjectA.prop, 'changedPropValue');
          assert.equal(ObjectA.newFoo, 'changedNewFooValue');
        };

        _proto['@test should observe the changes within the begin and end property changes'] = function testShouldObserveTheChangesWithinTheBeginAndEndPropertyChanges(assert) {
          ObjectA.beginPropertyChanges();
          ObjectA.set('foo', 'changeFooValue');
          assert.equal(ObjectA.prop, 'propValue');
          ObjectA.endPropertyChanges();
          assert.equal(ObjectA.prop, 'changedPropValue');
        };

        _proto['@test should indicate that the property of an object has just changed'] = function testShouldIndicateThatThePropertyOfAnObjectHasJustChanged(assert) {
          //change the value of foo.
          ObjectA.set('foo', 'changeFooValue'); // Indicate the subscribers of foo that the value has just changed

          ObjectA.notifyPropertyChange('foo', null); // Values of prop has just changed

          assert.equal(ObjectA.prop, 'changedPropValue');
        };

        _proto['@test should notify that the property of an object has changed'] = function testShouldNotifyThatThePropertyOfAnObjectHasChanged(assert) {
          // Notify to its subscriber that the values of 'newFoo' will be changed. In this
          // case the observer is "newProp". Therefore this will call the notifyAction function
          // and value of "newProp" will be changed.
          ObjectA.notifyPropertyChange('newFoo', 'fooValue'); //value of newProp changed.

          assert.equal(ObjectA.newProp, 'changedNewPropValue');
        };

        _proto['@test should invalidate function property cache when notifyPropertyChange is called'] = function testShouldInvalidateFunctionPropertyCacheWhenNotifyPropertyChangeIsCalled(assert) {
          var a;
          expectDeprecation(function () {
            a = ObservableObject.extend({
              b: (0, _metal.computed)({
                get: function () {
                  return this._b;
                },
                set: function (key, value) {
                  this._b = value;
                  return this;
                }
              }).volatile()
            }).create({
              _b: null
            });
          }, /Setting a computed property as volatile has been deprecated/);
          a.set('b', 'foo');
          assert.equal(a.get('b'), 'foo', 'should have set the correct value for property b');
          a._b = 'bar';
          a.notifyPropertyChange('b');
          a.set('b', 'foo');
          assert.equal(a.get('b'), 'foo', 'should have invalidated the cache so that the newly set value is actually set');
        };

        return _class;
      }(_internalTestHelpers.AbstractTestCase));
    }
});
enifed("@ember/-internals/runtime/tests/legacy_1x/system/object/base_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers"], function (_emberBabel, _metal, _object, _internalTestHelpers) {
  "use strict";

  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * Changed get(obj, ) and set(obj, ) to Ember.get() and Ember.set()
    * Removed obj.instanceOf() and obj.kindOf() tests.  use obj instanceof Foo
      instead
    * Removed respondsTo() and tryToPerform() tests.  Can be brought back in a
      utils package.
    * Removed destroy() test.  You can impl yourself but not built in
    * Changed Class.subclassOf() test to Class.detect()
    * Remove broken test for 'superclass' property.
    * Removed obj.didChangeFor()
  */
  // ========================================================================
  // EmberObject Base Tests
  // ========================================================================
  var obj, obj1; // global variables

  (0, _internalTestHelpers.moduleFor)('A new EmberObject instance',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      obj = _object.default.create({
        foo: 'bar',
        total: 12345,
        aMethodThatExists: function () {},
        aMethodThatReturnsTrue: function () {
          return true;
        },
        aMethodThatReturnsFoobar: function () {
          return 'Foobar';
        },
        aMethodThatReturnsFalse: function () {
          return false;
        }
      });
    };

    _proto.afterEach = function afterEach() {
      obj = undefined;
    };

    _proto['@test Should return its properties when requested using EmberObject#get'] = function testShouldReturnItsPropertiesWhenRequestedUsingEmberObjectGet(assert) {
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar');
      assert.equal((0, _metal.get)(obj, 'total'), 12345);
    };

    _proto['@test Should allow changing of those properties by calling EmberObject#set'] = function testShouldAllowChangingOfThosePropertiesByCallingEmberObjectSet(assert) {
      assert.equal((0, _metal.get)(obj, 'foo'), 'bar');
      assert.equal((0, _metal.get)(obj, 'total'), 12345);
      (0, _metal.set)(obj, 'foo', 'Chunky Bacon');
      (0, _metal.set)(obj, 'total', 12);
      assert.equal((0, _metal.get)(obj, 'foo'), 'Chunky Bacon');
      assert.equal((0, _metal.get)(obj, 'total'), 12);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('EmberObject superclass and subclasses',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2.beforeEach = function beforeEach() {
      obj = _object.default.extend({
        method1: function () {
          return 'hello';
        }
      });
      obj1 = obj.extend();
    };

    _proto2.afterEach = function afterEach() {
      obj = undefined;
      obj1 = undefined;
    };

    _proto2['@test Checking the detect() function on an object and its subclass'] = function testCheckingTheDetectFunctionOnAnObjectAndItsSubclass(assert) {
      assert.equal(obj.detect(obj1), true);
      assert.equal(obj1.detect(obj), false);
    };

    _proto2['@test Checking the detectInstance() function on an object and its subclass'] = function testCheckingTheDetectInstanceFunctionOnAnObjectAndItsSubclass(assert) {
      assert.ok(_object.default.detectInstance(obj.create()));
      assert.ok(obj.detectInstance(obj.create()));
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/legacy_1x/system/object/concatenated_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers"], function (_emberBabel, _metal, _object, _internalTestHelpers) {
  "use strict";

  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * changed get(obj, ) and set(obj, ) to Ember.get() and Ember.set()
    * converted uses of obj.isEqual() to use deepEqual() test since isEqual is not
      always defined
  */
  function K() {
    return this;
  }

  var klass;
  (0, _internalTestHelpers.moduleFor)('EmberObject Concatenated Properties',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      klass = _object.default.extend({
        concatenatedProperties: ['values', 'functions'],
        values: ['a', 'b', 'c'],
        functions: [K]
      });
    };

    _proto['@test concatenates instances'] = function testConcatenatesInstances(assert) {
      var obj = klass.create({
        values: ['d', 'e', 'f']
      });
      var values = (0, _metal.get)(obj, 'values');
      var expected = ['a', 'b', 'c', 'd', 'e', 'f'];
      assert.deepEqual(values, expected, "should concatenate values property (expected: " + expected + ", got: " + values + ")");
    };

    _proto['@test concatenates subclasses'] = function testConcatenatesSubclasses(assert) {
      var subKlass = klass.extend({
        values: ['d', 'e', 'f']
      });
      var obj = subKlass.create();
      var values = (0, _metal.get)(obj, 'values');
      var expected = ['a', 'b', 'c', 'd', 'e', 'f'];
      assert.deepEqual(values, expected, "should concatenate values property (expected: " + expected + ", got: " + values + ")");
    };

    _proto['@test concatenates reopen'] = function testConcatenatesReopen(assert) {
      klass.reopen({
        values: ['d', 'e', 'f']
      });
      var obj = klass.create();
      var values = (0, _metal.get)(obj, 'values');
      var expected = ['a', 'b', 'c', 'd', 'e', 'f'];
      assert.deepEqual(values, expected, "should concatenate values property (expected: " + expected + ", got: " + values + ")");
    };

    _proto['@test concatenates mixin'] = function testConcatenatesMixin(assert) {
      var mixin = {
        values: ['d', 'e']
      };
      var subKlass = klass.extend(mixin, {
        values: ['f']
      });
      var obj = subKlass.create();
      var values = (0, _metal.get)(obj, 'values');
      var expected = ['a', 'b', 'c', 'd', 'e', 'f'];
      assert.deepEqual(values, expected, "should concatenate values property (expected: " + expected + ", got: " + values + ")");
    };

    _proto['@test concatenates reopen, subclass, and instance'] = function testConcatenatesReopenSubclassAndInstance(assert) {
      klass.reopen({
        values: ['d']
      });
      var subKlass = klass.extend({
        values: ['e']
      });
      var obj = subKlass.create({
        values: ['f']
      });
      var values = (0, _metal.get)(obj, 'values');
      var expected = ['a', 'b', 'c', 'd', 'e', 'f'];
      assert.deepEqual(values, expected, "should concatenate values property (expected: " + expected + ", got: " + values + ")");
    };

    _proto['@test concatenates subclasses when the values are functions'] = function testConcatenatesSubclassesWhenTheValuesAreFunctions(assert) {
      var subKlass = klass.extend({
        functions: K
      });
      var obj = subKlass.create();
      var values = (0, _metal.get)(obj, 'functions');
      var expected = [K, K];
      assert.deepEqual(values, expected, "should concatenate functions property (expected: " + expected + ", got: " + values + ")");
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/mixins/array_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/object", "@ember/-internals/runtime/lib/mixins/array", "internal-test-helpers"], function (_emberBabel, _metal, _object, _array, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  /*
    Implement a basic fake mutable array.  This validates that any non-native
    enumerable can impl this API.
  */
  var TestArray = _object.default.extend(_array.default, {
    _content: null,
    init: function () {
      this._content = this._content || [];
    },
    // some methods to modify the array so we can test changes.  Note that
    // arrays can be modified even if they don't implement MutableArray.  The
    // MutableArray is just a standard API for mutation but not required.
    addObject: function (obj) {
      var idx = this._content.length;
      (0, _metal.arrayContentWillChange)(this, idx, 0, 1);

      this._content.push(obj);

      (0, _metal.arrayContentDidChange)(this, idx, 0, 1);
    },
    removeFirst: function () {
      (0, _metal.arrayContentWillChange)(this, 0, 1, 0);

      this._content.shift();

      (0, _metal.arrayContentDidChange)(this, 0, 1, 0);
    },
    objectAt: function (idx) {
      return this._content[idx];
    },
    length: (0, _metal.computed)(function () {
      return this._content.length;
    })
  });

  (0, _internalTestHelpers.moduleFor)('Ember.Array',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test the return value of slice has Ember.Array applied'] = function testTheReturnValueOfSliceHasEmberArrayApplied(assert) {
      var x = _object.default.extend(_array.default).create({
        length: 0
      });

      var y = x.slice(1);
      assert.equal(_array.default.detect(y), true, 'mixin should be applied');
    };

    _proto['@test slice supports negative index arguments'] = function testSliceSupportsNegativeIndexArguments(assert) {
      var testArray = TestArray.create({
        _content: [1, 2, 3, 4]
      });
      assert.deepEqual(testArray.slice(-2), [3, 4], 'slice(-2)');
      assert.deepEqual(testArray.slice(-2, -1), [3], 'slice(-2, -1');
      assert.deepEqual(testArray.slice(-2, -2), [], 'slice(-2, -2)');
      assert.deepEqual(testArray.slice(-1, -2), [], 'slice(-1, -2)');
      assert.deepEqual(testArray.slice(-4, 1), [1], 'slice(-4, 1)');
      assert.deepEqual(testArray.slice(-4, 5), [1, 2, 3, 4], 'slice(-4, 5)');
      assert.deepEqual(testArray.slice(-4), [1, 2, 3, 4], 'slice(-4)');
      assert.deepEqual(testArray.slice(0, -1), [1, 2, 3], 'slice(0, -1)');
      assert.deepEqual(testArray.slice(0, -4), [], 'slice(0, -4)');
      assert.deepEqual(testArray.slice(0, -3), [1], 'slice(0, -3)');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // CONTENT DID CHANGE
  //

  var DummyArray = _object.default.extend(_array.default, {
    length: 0,
    objectAt: function (idx) {
      return 'ITEM-' + idx;
    }
  });

  var obj, observer; // ..........................................................
  // NOTIFY ARRAY OBSERVERS
  //

  (0, _internalTestHelpers.moduleFor)('mixins/array/arrayContent[Will|Did]Change',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test should notify observers of []'] =
    /*#__PURE__*/
    function () {
      var _testShouldNotifyObserversOf = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              obj = DummyArray.extend({
                enumerablePropertyDidChange: (0, _metal.observer)('[]', function () {
                  this._count++;
                })
              }).create({
                _count: 0
              });
              assert.equal(obj._count, 0, 'should not have invoked yet');
              (0, _metal.arrayContentWillChange)(obj, 0, 1, 1);
              (0, _metal.arrayContentDidChange)(obj, 0, 1, 1);
              _context.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              assert.equal(obj._count, 1, 'should have invoked');

            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function testShouldNotifyObserversOf(_x) {
        return _testShouldNotifyObserversOf.apply(this, arguments);
      }

      return testShouldNotifyObserversOf;
    }();

    return _class2;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // NOTIFY CHANGES TO LENGTH
  //

  (0, _internalTestHelpers.moduleFor)('notify observers of length',
  /*#__PURE__*/
  function (_AbstractTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class3, _AbstractTestCase3);

    function _class3() {
      return _AbstractTestCase3.apply(this, arguments) || this;
    }

    var _proto3 = _class3.prototype;

    _proto3.beforeEach = function beforeEach(assert) {
      obj = DummyArray.extend({
        lengthDidChange: (0, _metal.observer)('length', function () {
          this._after++;
        })
      }).create({
        _after: 0
      });
      assert.equal(obj._after, 0, 'should not have fired yet');
    };

    _proto3.afterEach = function afterEach() {
      obj = null;
    };

    _proto3['@test should notify observers when call with no params'] =
    /*#__PURE__*/
    function () {
      var _testShouldNotifyObserversWhenCallWithNoParams = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              (0, _metal.arrayContentWillChange)(obj);
              _context2.next = 3;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 3:
              assert.equal(obj._after, 0);
              (0, _metal.arrayContentDidChange)(obj);
              _context2.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              assert.equal(obj._after, 1);

            case 8:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));

      function testShouldNotifyObserversWhenCallWithNoParams(_x2) {
        return _testShouldNotifyObserversWhenCallWithNoParams.apply(this, arguments);
      }

      return testShouldNotifyObserversWhenCallWithNoParams;
    }() // API variation that included items only
    ;

    _proto3['@test should not notify when passed lengths are same'] =
    /*#__PURE__*/
    function () {
      var _testShouldNotNotifyWhenPassedLengthsAreSame = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(assert) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              (0, _metal.arrayContentWillChange)(obj, 0, 1, 1);
              _context3.next = 3;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 3:
              assert.equal(obj._after, 0);
              (0, _metal.arrayContentDidChange)(obj, 0, 1, 1);
              _context3.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              assert.equal(obj._after, 0);

            case 8:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));

      function testShouldNotNotifyWhenPassedLengthsAreSame(_x3) {
        return _testShouldNotNotifyWhenPassedLengthsAreSame.apply(this, arguments);
      }

      return testShouldNotNotifyWhenPassedLengthsAreSame;
    }();

    _proto3['@test should notify when passed lengths are different'] =
    /*#__PURE__*/
    function () {
      var _testShouldNotifyWhenPassedLengthsAreDifferent = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(assert) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              (0, _metal.arrayContentWillChange)(obj, 0, 1, 2);
              _context4.next = 3;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 3:
              assert.equal(obj._after, 0);
              (0, _metal.arrayContentDidChange)(obj, 0, 1, 2);
              _context4.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              assert.equal(obj._after, 1);

            case 8:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));

      function testShouldNotifyWhenPassedLengthsAreDifferent(_x4) {
        return _testShouldNotifyWhenPassedLengthsAreDifferent.apply(this, arguments);
      }

      return testShouldNotifyWhenPassedLengthsAreDifferent;
    }();

    return _class3;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // NOTIFY ARRAY OBSERVER
  //

  (0, _internalTestHelpers.moduleFor)('notify array observers',
  /*#__PURE__*/
  function (_AbstractTestCase4) {
    (0, _emberBabel.inheritsLoose)(_class4, _AbstractTestCase4);

    function _class4() {
      return _AbstractTestCase4.apply(this, arguments) || this;
    }

    var _proto4 = _class4.prototype;

    _proto4.beforeEach = function beforeEach(assert) {
      obj = DummyArray.create();
      observer = _object.default.extend({
        arrayWillChange: function () {
          assert.equal(this._before, null); // should only call once

          this._before = Array.prototype.slice.call(arguments);
        },
        arrayDidChange: function () {
          assert.equal(this._after, null); // should only call once

          this._after = Array.prototype.slice.call(arguments);
        }
      }).create({
        _before: null,
        _after: null
      });
      (0, _metal.addArrayObserver)(obj, observer);
    };

    _proto4.afterEach = function afterEach() {
      obj = observer = null;
    };

    _proto4['@test should notify array observers when called with no params'] = function testShouldNotifyArrayObserversWhenCalledWithNoParams(assert) {
      (0, _metal.arrayContentWillChange)(obj);
      assert.deepEqual(observer._before, [obj, 0, -1, -1]);
      (0, _metal.arrayContentDidChange)(obj);
      assert.deepEqual(observer._after, [obj, 0, -1, -1]);
    } // API variation that included items only
    ;

    _proto4['@test should notify when called with same length items'] = function testShouldNotifyWhenCalledWithSameLengthItems(assert) {
      (0, _metal.arrayContentWillChange)(obj, 0, 1, 1);
      assert.deepEqual(observer._before, [obj, 0, 1, 1]);
      (0, _metal.arrayContentDidChange)(obj, 0, 1, 1);
      assert.deepEqual(observer._after, [obj, 0, 1, 1]);
    };

    _proto4['@test should notify when called with diff length items'] = function testShouldNotifyWhenCalledWithDiffLengthItems(assert) {
      (0, _metal.arrayContentWillChange)(obj, 0, 2, 1);
      assert.deepEqual(observer._before, [obj, 0, 2, 1]);
      (0, _metal.arrayContentDidChange)(obj, 0, 2, 1);
      assert.deepEqual(observer._after, [obj, 0, 2, 1]);
    };

    _proto4['@test removing array observer should disable'] = function testRemovingArrayObserverShouldDisable(assert) {
      (0, _metal.removeArrayObserver)(obj, observer);
      (0, _metal.arrayContentWillChange)(obj);
      assert.deepEqual(observer._before, null);
      (0, _metal.arrayContentDidChange)(obj);
      assert.deepEqual(observer._after, null);
    };

    return _class4;
  }(_internalTestHelpers.AbstractTestCase)); // ..........................................................
  // @each
  //

  var ary;
  (0, _internalTestHelpers.moduleFor)('EmberArray.@each support',
  /*#__PURE__*/
  function (_AbstractTestCase5) {
    (0, _emberBabel.inheritsLoose)(_class5, _AbstractTestCase5);

    function _class5() {
      return _AbstractTestCase5.apply(this, arguments) || this;
    }

    var _proto5 = _class5.prototype;

    _proto5.beforeEach = function beforeEach() {
      ary = TestArray.create({
        _content: [{
          isDone: true,
          desc: 'Todo 1'
        }, {
          isDone: false,
          desc: 'Todo 2'
        }, {
          isDone: true,
          desc: 'Todo 3'
        }, {
          isDone: false,
          desc: 'Todo 4'
        }]
      });
    };

    _proto5.afterEach = function afterEach() {
      ary = null;
    };

    _proto5['@test adding an object should notify (@each.isDone)'] =
    /*#__PURE__*/
    function () {
      var _testAddingAnObjectShouldNotifyEachIsDone = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(assert) {
        var called, observerObject;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              called = 0;
              observerObject = _object.default.create({
                wasCalled: function () {
                  called++;
                }
              });
              (0, _metal.addObserver)(ary, '@each.isDone', observerObject, 'wasCalled');
              ary.addObject(_object.default.create({
                desc: 'foo',
                isDone: false
              }));
              _context5.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              assert.equal(called, 1, 'calls observer when object is pushed');

            case 7:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }));

      function testAddingAnObjectShouldNotifyEachIsDone(_x5) {
        return _testAddingAnObjectShouldNotifyEachIsDone.apply(this, arguments);
      }

      return testAddingAnObjectShouldNotifyEachIsDone;
    }();

    _proto5['@test using @each to observe arrays that does not return objects raise error'] =
    /*#__PURE__*/
    function () {
      var _testUsingEachToObserveArraysThatDoesNotReturnObjectsRaiseError = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(assert) {
        var called, observerObject;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              called = 0;
              observerObject = _object.default.create({
                wasCalled: function () {
                  called++;
                }
              });
              ary = TestArray.create({
                objectAt: function (idx) {
                  return (0, _metal.get)(this._content[idx], 'desc');
                }
              });
              ary.addObject({
                desc: 'foo',
                isDone: false
              });
              assert.throwsAssertion(function () {
                (0, _metal.addObserver)(ary, '@each.isDone', observerObject, 'wasCalled');
              }, /When using @each to observe the array/);
              _context6.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              assert.equal(called, 0, 'not calls observer when object is pushed');

            case 8:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));

      function testUsingEachToObserveArraysThatDoesNotReturnObjectsRaiseError(_x6) {
        return _testUsingEachToObserveArraysThatDoesNotReturnObjectsRaiseError.apply(this, arguments);
      }

      return testUsingEachToObserveArraysThatDoesNotReturnObjectsRaiseError;
    }();

    _proto5['@test `objectAt` returns correct object'] = function testObjectAtReturnsCorrectObject(assert) {
      var arr = ['first', 'second', 'third', 'fourth'];
      assert.equal((0, _metal.objectAt)(arr, 2), 'third');
      assert.equal((0, _metal.objectAt)(arr, 4), undefined);
    };

    _proto5['@test should be clear caches for computed properties that have dependent keys on arrays that are changed after object initialization'] = function testShouldBeClearCachesForComputedPropertiesThatHaveDependentKeysOnArraysThatAreChangedAfterObjectInitialization(assert) {
      var obj = _object.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'resources', (0, _array.A)());
        },
        common: (0, _metal.computed)('resources.@each.common', function () {
          return (0, _metal.get)((0, _metal.objectAt)((0, _metal.get)(this, 'resources'), 0), 'common');
        })
      }).create();

      (0, _metal.get)(obj, 'resources').pushObject(_object.default.create({
        common: 'HI!'
      }));
      assert.equal('HI!', (0, _metal.get)(obj, 'common'));
      (0, _metal.set)((0, _metal.objectAt)((0, _metal.get)(obj, 'resources'), 0), 'common', 'BYE!');
      assert.equal('BYE!', (0, _metal.get)(obj, 'common'));
    };

    _proto5['@test observers that contain @each in the path should fire only once the first time they are accessed'] =
    /*#__PURE__*/
    function () {
      var _testObserversThatContainEachInThePathShouldFireOnlyOnceTheFirstTimeTheyAreAccessed = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(assert) {
        var count, obj;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              count = 0;
              obj = _object.default.extend({
                init: function () {
                  this._super.apply(this, arguments); // Observer does not fire on init


                  (0, _metal.set)(this, 'resources', (0, _array.A)());
                },
                commonDidChange: (0, _metal.observer)('resources.@each.common', function () {
                  return count++;
                })
              }).create(); // Observer fires first time when new object is added

              (0, _metal.get)(obj, 'resources').pushObject(_object.default.create({
                common: 'HI!'
              }));
              _context7.next = 5;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 5:
              // Observer fires second time when property on an object is changed
              (0, _metal.set)((0, _metal.objectAt)((0, _metal.get)(obj, 'resources'), 0), 'common', 'BYE!');
              _context7.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              assert.equal(count, 2, 'observers should be called twice');

            case 9:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      }));

      function testObserversThatContainEachInThePathShouldFireOnlyOnceTheFirstTimeTheyAreAccessed(_x7) {
        return _testObserversThatContainEachInThePathShouldFireOnlyOnceTheFirstTimeTheyAreAccessed.apply(this, arguments);
      }

      return testObserversThatContainEachInThePathShouldFireOnlyOnceTheFirstTimeTheyAreAccessed;
    }();

    return _class5;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/mixins/comparable_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/object", "@ember/-internals/runtime/lib/compare", "@ember/-internals/runtime/lib/mixins/comparable", "internal-test-helpers"], function (_emberBabel, _metal, _object, _compare, _comparable, _internalTestHelpers) {
  "use strict";

  var Rectangle = _object.default.extend(_comparable.default, {
    length: 0,
    width: 0,
    area: function () {
      return (0, _metal.get)(this, 'length') * (0, _metal.get)(this, 'width');
    },
    compare: function (a, b) {
      return (0, _compare.default)(a.area(), b.area());
    }
  });

  var r1, r2;
  (0, _internalTestHelpers.moduleFor)('Comparable',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      r1 = Rectangle.create({
        length: 6,
        width: 12
      });
      r2 = Rectangle.create({
        length: 6,
        width: 13
      });
    };

    _proto['@test should be comparable and return the correct result'] = function testShouldBeComparableAndReturnTheCorrectResult(assert) {
      assert.equal(_comparable.default.detect(r1), true);
      assert.equal((0, _compare.default)(r1, r1), 0);
      assert.equal((0, _compare.default)(r1, r2), -1);
      assert.equal((0, _compare.default)(r2, r1), 1);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/mixins/container_proxy_test", ["ember-babel", "@ember/-internals/owner", "@ember/-internals/container", "@ember/-internals/runtime/lib/mixins/container_proxy", "@ember/-internals/runtime/lib/system/object", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _owner, _container, _container_proxy, _object, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('@ember/-internals/runtime/mixins/container_proxy',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      this.Owner = _object.default.extend(_container_proxy.default);
      this.instance = this.Owner.create();
      this.registry = new _container.Registry();
      this.instance.__container__ = new _container.Container(this.registry, {
        owner: this.instance
      });
    };

    _proto['@test provides ownerInjection helper method'] = function testProvidesOwnerInjectionHelperMethod(assert) {
      var result = this.instance.ownerInjection();
      assert.equal(result[_owner.OWNER], this.instance, 'returns an object with the OWNER symbol');
    };

    _proto['@test actions queue completes before destruction'] = function testActionsQueueCompletesBeforeDestruction(assert) {
      var _this = this;

      assert.expect(1);
      this.registry.register('service:auth', _object.default.extend({
        willDestroy: function () {
          assert.ok((0, _owner.getOwner)(this).lookup('service:auth'), 'can still lookup');
        }
      }));
      var service = this.instance.lookup('service:auth');
      (0, _runloop.run)(function () {
        (0, _runloop.schedule)('actions', service, 'destroy');

        _this.instance.destroy();
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/mixins/enumerable_test", ["ember-babel", "@ember/-internals/runtime/lib/mixins/enumerable", "@ember/-internals/runtime/lib/system/array_proxy", "@ember/-internals/runtime/lib/mixins/array", "internal-test-helpers"], function (_emberBabel, _enumerable, _array_proxy, _array, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Enumerable',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test should be mixed into A()'] = function testShouldBeMixedIntoA(assert) {
      assert.ok(_enumerable.default.detect((0, _array.A)()));
    };

    _proto['@test should be mixed into ArrayProxy'] = function testShouldBeMixedIntoArrayProxy(assert) {
      assert.ok(_enumerable.default.detect(_array_proxy.default.create()));
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/mixins/evented_test", ["ember-babel", "@ember/-internals/runtime/lib/mixins/evented", "@ember/-internals/runtime/lib/system/core_object", "internal-test-helpers"], function (_emberBabel, _evented, _core_object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.Evented',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test works properly on proxy-ish objects'] = function testWorksProperlyOnProxyIshObjects(assert) {
      var eventedProxyObj = _core_object.default.extend(_evented.default, {
        unknownProperty: function () {
          return true;
        }
      }).create();

      var noop = function () {};

      eventedProxyObj.on('foo', noop);
      eventedProxyObj.off('foo', noop);
      assert.ok(true, 'An assertion was triggered');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/mixins/mutable_enumerable_test", ["ember-babel", "@ember/-internals/runtime/lib/mixins/mutable_enumerable", "@ember/-internals/runtime/lib/system/array_proxy", "@ember/-internals/runtime/lib/mixins/array", "internal-test-helpers"], function (_emberBabel, _mutable_enumerable, _array_proxy, _array, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('MutableEnumerable',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test should be mixed into A()'] = function testShouldBeMixedIntoA(assert) {
      assert.ok(_mutable_enumerable.default.detect((0, _array.A)()));
    };

    _proto['@test should be mixed into ArrayProxy'] = function testShouldBeMixedIntoArrayProxy(assert) {
      assert.ok(_mutable_enumerable.default.detect(_array_proxy.default.create()));
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/mixins/observable_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers"], function (_emberBabel, _metal, _object, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('mixins/observable',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test should be able to use getProperties to get a POJO of provided keys'] = function testShouldBeAbleToUseGetPropertiesToGetAPOJOOfProvidedKeys(assert) {
      var obj = _object.default.create({
        firstName: 'Steve',
        lastName: 'Jobs',
        companyName: 'Apple, Inc.'
      });

      var pojo = obj.getProperties('firstName', 'lastName');
      assert.equal('Steve', pojo.firstName);
      assert.equal('Jobs', pojo.lastName);
    };

    _proto['@test should be able to use getProperties with array parameter to get a POJO of provided keys'] = function testShouldBeAbleToUseGetPropertiesWithArrayParameterToGetAPOJOOfProvidedKeys(assert) {
      var obj = _object.default.create({
        firstName: 'Steve',
        lastName: 'Jobs',
        companyName: 'Apple, Inc.'
      });

      var pojo = obj.getProperties(['firstName', 'lastName']);
      assert.equal('Steve', pojo.firstName);
      assert.equal('Jobs', pojo.lastName);
    };

    _proto['@test should be able to use setProperties to set multiple properties at once'] = function testShouldBeAbleToUseSetPropertiesToSetMultiplePropertiesAtOnce(assert) {
      var obj = _object.default.create({
        firstName: 'Steve',
        lastName: 'Jobs',
        companyName: 'Apple, Inc.'
      });

      obj.setProperties({
        firstName: 'Tim',
        lastName: 'Cook'
      });
      assert.equal('Tim', obj.get('firstName'));
      assert.equal('Cook', obj.get('lastName'));
    };

    _proto['@test calling setProperties completes safely despite exceptions'] =
    /*#__PURE__*/
    function () {
      var _testCallingSetPropertiesCompletesSafelyDespiteExceptions = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var exc, obj, firstNameChangedCount;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              exc = new Error('Something unexpected happened!');
              obj = _object.default.extend({
                companyName: (0, _metal.computed)({
                  get: function () {
                    return 'Apple, Inc.';
                  },
                  set: function () {
                    throw exc;
                  }
                })
              }).create({
                firstName: 'Steve',
                lastName: 'Jobs'
              });
              firstNameChangedCount = 0;
              (0, _metal.addObserver)(obj, 'firstName', function () {
                return firstNameChangedCount++;
              });
              _context.prev = 4;
              obj.setProperties({
                firstName: 'Tim',
                lastName: 'Cook',
                companyName: 'Fruit Co., Inc.'
              });
              _context.next = 12;
              break;

            case 8:
              _context.prev = 8;
              _context.t0 = _context["catch"](4);

              if (!(_context.t0 !== exc)) {
                _context.next = 12;
                break;
              }

              throw _context.t0;

            case 12:
              _context.next = 14;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 14:
              assert.equal(firstNameChangedCount, 1, 'firstName should have fired once');

            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[4, 8]]);
      }));

      function testCallingSetPropertiesCompletesSafelyDespiteExceptions(_x) {
        return _testCallingSetPropertiesCompletesSafelyDespiteExceptions.apply(this, arguments);
      }

      return testCallingSetPropertiesCompletesSafelyDespiteExceptions;
    }();

    _proto['@test should be able to retrieve cached values of computed properties without invoking the computed property'] = function testShouldBeAbleToRetrieveCachedValuesOfComputedPropertiesWithoutInvokingTheComputedProperty(assert) {
      var obj = _object.default.extend({
        foo: (0, _metal.computed)(function () {
          return 'foo';
        })
      }).create({
        bar: 'bar'
      });

      assert.equal(obj.cacheFor('foo'), undefined, 'should return undefined if no value has been cached');
      (0, _metal.get)(obj, 'foo');
      assert.equal((0, _metal.get)(obj, 'foo'), 'foo', 'precond - should cache the value');
      assert.equal(obj.cacheFor('foo'), 'foo', 'should return the cached value after it is invoked');
      assert.equal(obj.cacheFor('bar'), undefined, 'returns undefined if the value is not a computed property');
    };

    _proto['@test incrementProperty should work even if value is number in string'] = function testIncrementPropertyShouldWorkEvenIfValueIsNumberInString(assert) {
      var obj = _object.default.create({
        age: '24'
      });

      obj.incrementProperty('age');
      assert.equal(25, obj.get('age'));
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/mixins/promise_proxy_test", ["ember-babel", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/object_proxy", "@ember/-internals/runtime/lib/mixins/promise_proxy", "@ember/-internals/runtime/lib/ext/rsvp", "rsvp", "internal-test-helpers"], function (_emberBabel, _runloop, _metal, _object_proxy, _promise_proxy, _rsvp, RSVP, _internalTestHelpers) {
  "use strict";

  var ObjectPromiseProxy;
  (0, _internalTestHelpers.moduleFor)('Ember.PromiseProxy - ObjectProxy',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      ObjectPromiseProxy = _object_proxy.default.extend(_promise_proxy.default);
    };

    _proto.afterEach = function afterEach() {
      RSVP.on('error', _rsvp.onerrorDefault);
    };

    _proto['@test present on ember namespace'] = function testPresentOnEmberNamespace(assert) {
      assert.ok(_promise_proxy.default, 'expected PromiseProxyMixin to exist');
    };

    _proto['@test no promise, invoking then should raise'] = function testNoPromiseInvokingThenShouldRaise(assert) {
      var proxy = ObjectPromiseProxy.create();
      assert.throws(function () {
        proxy.then(function () {
          return this;
        }, function () {
          return this;
        });
      }, new RegExp("PromiseProxy's promise must be set"));
    };

    _proto['@test fulfillment'] = function testFulfillment(assert) {
      var value = {
        firstName: 'stef',
        lastName: 'penner'
      };
      var deferred = RSVP.defer();
      var proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      var didFulfillCount = 0;
      var didRejectCount = 0;
      proxy.then(function () {
        return didFulfillCount++;
      }, function () {
        return didRejectCount++;
      });
      assert.equal((0, _metal.get)(proxy, 'content'), undefined, 'expects the proxy to have no content');
      assert.equal((0, _metal.get)(proxy, 'reason'), undefined, 'expects the proxy to have no reason');
      assert.equal((0, _metal.get)(proxy, 'isPending'), true, 'expects the proxy to indicate that it is loading');
      assert.equal((0, _metal.get)(proxy, 'isSettled'), false, 'expects the proxy to indicate that it is not settled');
      assert.equal((0, _metal.get)(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
      assert.equal((0, _metal.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
      assert.equal(didFulfillCount, 0, 'should not yet have been fulfilled');
      assert.equal(didRejectCount, 0, 'should not yet have been rejected');
      (0, _runloop.run)(deferred, 'resolve', value);
      assert.equal(didFulfillCount, 1, 'should have been fulfilled');
      assert.equal(didRejectCount, 0, 'should not have been rejected');
      assert.equal((0, _metal.get)(proxy, 'content'), value, 'expects the proxy to have content');
      assert.equal((0, _metal.get)(proxy, 'reason'), undefined, 'expects the proxy to still have no reason');
      assert.equal((0, _metal.get)(proxy, 'isPending'), false, 'expects the proxy to indicate that it is no longer loading');
      assert.equal((0, _metal.get)(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
      assert.equal((0, _metal.get)(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
      assert.equal((0, _metal.get)(proxy, 'isFulfilled'), true, 'expects the proxy to indicate that it is fulfilled');
      (0, _runloop.run)(deferred, 'resolve', value);
      assert.equal(didFulfillCount, 1, 'should still have been only fulfilled once');
      assert.equal(didRejectCount, 0, 'should still not have been rejected');
      (0, _runloop.run)(deferred, 'reject', value);
      assert.equal(didFulfillCount, 1, 'should still have been only fulfilled once');
      assert.equal(didRejectCount, 0, 'should still not have been rejected');
      assert.equal((0, _metal.get)(proxy, 'content'), value, 'expects the proxy to have still have same content');
      assert.equal((0, _metal.get)(proxy, 'reason'), undefined, 'expects the proxy still to have no reason');
      assert.equal((0, _metal.get)(proxy, 'isPending'), false, 'expects the proxy to indicate that it is no longer loading');
      assert.equal((0, _metal.get)(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
      assert.equal((0, _metal.get)(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
      assert.equal((0, _metal.get)(proxy, 'isFulfilled'), true, 'expects the proxy to indicate that it is fulfilled'); // rest of the promise semantics are tested in directly in RSVP
    };

    _proto['@test rejection'] = function testRejection(assert) {
      var reason = new Error('failure');
      var deferred = RSVP.defer();
      var proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      var didFulfillCount = 0;
      var didRejectCount = 0;
      proxy.then(function () {
        return didFulfillCount++;
      }, function () {
        return didRejectCount++;
      });
      assert.equal((0, _metal.get)(proxy, 'content'), undefined, 'expects the proxy to have no content');
      assert.equal((0, _metal.get)(proxy, 'reason'), undefined, 'expects the proxy to have no reason');
      assert.equal((0, _metal.get)(proxy, 'isPending'), true, 'expects the proxy to indicate that it is loading');
      assert.equal((0, _metal.get)(proxy, 'isSettled'), false, 'expects the proxy to indicate that it is not settled');
      assert.equal((0, _metal.get)(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
      assert.equal((0, _metal.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
      assert.equal(didFulfillCount, 0, 'should not yet have been fulfilled');
      assert.equal(didRejectCount, 0, 'should not yet have been rejected');
      (0, _runloop.run)(deferred, 'reject', reason);
      assert.equal(didFulfillCount, 0, 'should not yet have been fulfilled');
      assert.equal(didRejectCount, 1, 'should have been rejected');
      assert.equal((0, _metal.get)(proxy, 'content'), undefined, 'expects the proxy to have no content');
      assert.equal((0, _metal.get)(proxy, 'reason'), reason, 'expects the proxy to have a reason');
      assert.equal((0, _metal.get)(proxy, 'isPending'), false, 'expects the proxy to indicate that it is not longer loading');
      assert.equal((0, _metal.get)(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
      assert.equal((0, _metal.get)(proxy, 'isRejected'), true, 'expects the proxy to indicate that it is  rejected');
      assert.equal((0, _metal.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
      (0, _runloop.run)(deferred, 'reject', reason);
      assert.equal(didFulfillCount, 0, 'should stll not yet have been fulfilled');
      assert.equal(didRejectCount, 1, 'should still remain rejected');
      (0, _runloop.run)(deferred, 'resolve', 1);
      assert.equal(didFulfillCount, 0, 'should stll not yet have been fulfilled');
      assert.equal(didRejectCount, 1, 'should still remain rejected');
      assert.equal((0, _metal.get)(proxy, 'content'), undefined, 'expects the proxy to have no content');
      assert.equal((0, _metal.get)(proxy, 'reason'), reason, 'expects the proxy to have a reason');
      assert.equal((0, _metal.get)(proxy, 'isPending'), false, 'expects the proxy to indicate that it is not longer loading');
      assert.equal((0, _metal.get)(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
      assert.equal((0, _metal.get)(proxy, 'isRejected'), true, 'expects the proxy to indicate that it is  rejected');
      assert.equal((0, _metal.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
    } // https://github.com/emberjs/ember.js/issues/15694
    ;

    _proto['@test rejection without specifying reason'] = function testRejectionWithoutSpecifyingReason(assert) {
      var deferred = RSVP.defer();
      var proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      var didFulfillCount = 0;
      var didRejectCount = 0;
      proxy.then(function () {
        return didFulfillCount++;
      }, function () {
        return didRejectCount++;
      });
      assert.equal((0, _metal.get)(proxy, 'content'), undefined, 'expects the proxy to have no content');
      assert.equal((0, _metal.get)(proxy, 'reason'), undefined, 'expects the proxy to have no reason');
      assert.equal((0, _metal.get)(proxy, 'isPending'), true, 'expects the proxy to indicate that it is loading');
      assert.equal((0, _metal.get)(proxy, 'isSettled'), false, 'expects the proxy to indicate that it is not settled');
      assert.equal((0, _metal.get)(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
      assert.equal((0, _metal.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
      assert.equal(didFulfillCount, 0, 'should not yet have been fulfilled');
      assert.equal(didRejectCount, 0, 'should not yet have been rejected');
      (0, _runloop.run)(deferred, 'reject');
      assert.equal(didFulfillCount, 0, 'should not yet have been fulfilled');
      assert.equal(didRejectCount, 1, 'should have been rejected');
      assert.equal((0, _metal.get)(proxy, 'content'), undefined, 'expects the proxy to have no content');
      assert.equal((0, _metal.get)(proxy, 'reason'), undefined, 'expects the proxy to have a reason');
      assert.equal((0, _metal.get)(proxy, 'isPending'), false, 'expects the proxy to indicate that it is not longer loading');
      assert.equal((0, _metal.get)(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
      assert.equal((0, _metal.get)(proxy, 'isRejected'), true, 'expects the proxy to indicate that it is  rejected');
      assert.equal((0, _metal.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
    };

    _proto["@test unhandled rejects still propagate to RSVP.on('error', ...) "] = function testUnhandledRejectsStillPropagateToRSVPOnError(assert) {
      assert.expect(1);
      RSVP.on('error', onerror);
      RSVP.off('error', _rsvp.onerrorDefault);
      var expectedReason = new Error('failure');
      var deferred = RSVP.defer();
      var proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      proxy.get('promise');

      function onerror(reason) {
        assert.equal(reason, expectedReason, 'expected reason');
      }

      RSVP.on('error', onerror);
      RSVP.off('error', _rsvp.onerrorDefault);
      (0, _runloop.run)(deferred, 'reject', expectedReason);
      RSVP.on('error', _rsvp.onerrorDefault);
      RSVP.off('error', onerror);
      (0, _runloop.run)(deferred, 'reject', expectedReason);
      RSVP.on('error', _rsvp.onerrorDefault);
      RSVP.off('error', onerror);
    };

    _proto['@test should work with promise inheritance'] = function testShouldWorkWithPromiseInheritance(assert) {
      var PromiseSubclass =
      /*#__PURE__*/
      function (_RSVP$Promise) {
        (0, _emberBabel.inheritsLoose)(PromiseSubclass, _RSVP$Promise);

        function PromiseSubclass() {
          return _RSVP$Promise.apply(this, arguments) || this;
        }

        return PromiseSubclass;
      }(RSVP.Promise);

      var proxy = ObjectPromiseProxy.create({
        promise: new PromiseSubclass(function () {})
      });
      assert.ok(proxy.then() instanceof PromiseSubclass, 'promise proxy respected inheritance');
    };

    _proto['@test should reset isFulfilled and isRejected when promise is reset'] = function testShouldResetIsFulfilledAndIsRejectedWhenPromiseIsReset(assert) {
      var deferred = _rsvp.default.defer();

      var proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      assert.equal((0, _metal.get)(proxy, 'isPending'), true, 'expects the proxy to indicate that it is loading');
      assert.equal((0, _metal.get)(proxy, 'isSettled'), false, 'expects the proxy to indicate that it is not settled');
      assert.equal((0, _metal.get)(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
      assert.equal((0, _metal.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
      (0, _runloop.run)(deferred, 'resolve');
      assert.equal((0, _metal.get)(proxy, 'isPending'), false, 'expects the proxy to indicate that it is no longer loading');
      assert.equal((0, _metal.get)(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
      assert.equal((0, _metal.get)(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
      assert.equal((0, _metal.get)(proxy, 'isFulfilled'), true, 'expects the proxy to indicate that it is fulfilled');

      var anotherDeferred = _rsvp.default.defer();

      proxy.set('promise', anotherDeferred.promise);
      assert.equal((0, _metal.get)(proxy, 'isPending'), true, 'expects the proxy to indicate that it is loading');
      assert.equal((0, _metal.get)(proxy, 'isSettled'), false, 'expects the proxy to indicate that it is not settled');
      assert.equal((0, _metal.get)(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
      assert.equal((0, _metal.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
      (0, _runloop.run)(anotherDeferred, 'reject');
      assert.equal((0, _metal.get)(proxy, 'isPending'), false, 'expects the proxy to indicate that it is not longer loading');
      assert.equal((0, _metal.get)(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
      assert.equal((0, _metal.get)(proxy, 'isRejected'), true, 'expects the proxy to indicate that it is  rejected');
      assert.equal((0, _metal.get)(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
    };

    _proto['@test should have content when isFulfilled is set'] = function testShouldHaveContentWhenIsFulfilledIsSet(assert) {
      var deferred = _rsvp.default.defer();

      var proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      proxy.addObserver('isFulfilled', function () {
        return assert.equal((0, _metal.get)(proxy, 'content'), true);
      });
      (0, _runloop.run)(deferred, 'resolve', true);
    };

    _proto['@test should have reason when isRejected is set'] = function testShouldHaveReasonWhenIsRejectedIsSet(assert) {
      var error = new Error('Y U REJECT?!?');

      var deferred = _rsvp.default.defer();

      var proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      proxy.addObserver('isRejected', function () {
        return assert.equal((0, _metal.get)(proxy, 'reason'), error);
      });

      try {
        (0, _runloop.run)(deferred, 'reject', error);
      } catch (e) {
        assert.equal(e, error);
      }
    };

    _proto['@test should not error if promise is resolved after proxy has been destroyed'] = function testShouldNotErrorIfPromiseIsResolvedAfterProxyHasBeenDestroyed(assert) {
      var deferred = _rsvp.default.defer();

      var proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      proxy.then(function () {}, function () {});
      (0, _runloop.run)(proxy, 'destroy');
      (0, _runloop.run)(deferred, 'resolve', true);
      assert.ok(true, 'resolving the promise after the proxy has been destroyed does not raise an error');
    };

    _proto['@test should not error if promise is rejected after proxy has been destroyed'] = function testShouldNotErrorIfPromiseIsRejectedAfterProxyHasBeenDestroyed(assert) {
      var deferred = _rsvp.default.defer();

      var proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      proxy.then(function () {}, function () {});
      (0, _runloop.run)(proxy, 'destroy');
      (0, _runloop.run)(deferred, 'reject', 'some reason');
      assert.ok(true, 'rejecting the promise after the proxy has been destroyed does not raise an error');
    };

    _proto['@test promise chain is not broken if promised is resolved after proxy has been destroyed'] = function testPromiseChainIsNotBrokenIfPromisedIsResolvedAfterProxyHasBeenDestroyed(assert) {
      var deferred = _rsvp.default.defer();

      var expectedValue = {};
      var receivedValue;
      var didResolveCount = 0;
      var proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      proxy.then(function (value) {
        receivedValue = value;
        didResolveCount++;
      }, function () {});
      (0, _runloop.run)(proxy, 'destroy');
      (0, _runloop.run)(deferred, 'resolve', expectedValue);
      assert.equal(didResolveCount, 1, 'callback called');
      assert.equal(receivedValue, expectedValue, 'passed value is the value the promise was resolved with');
    };

    _proto['@test promise chain is not broken if promised is rejected after proxy has been destroyed'] = function testPromiseChainIsNotBrokenIfPromisedIsRejectedAfterProxyHasBeenDestroyed(assert) {
      var deferred = _rsvp.default.defer();

      var expectedReason = 'some reason';
      var receivedReason;
      var didRejectCount = 0;
      var proxy = ObjectPromiseProxy.create({
        promise: deferred.promise
      });
      proxy.then(function () {}, function (reason) {
        receivedReason = reason;
        didRejectCount++;
      });
      (0, _runloop.run)(proxy, 'destroy');
      (0, _runloop.run)(deferred, 'reject', expectedReason);
      assert.equal(didRejectCount, 1, 'callback called');
      assert.equal(receivedReason, expectedReason, 'passed reason is the reason the promise was rejected for');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/mixins/target_action_support_test", ["ember-babel", "@ember/-internals/environment", "@ember/-internals/runtime/lib/system/object", "@ember/-internals/runtime/lib/mixins/target_action_support", "internal-test-helpers"], function (_emberBabel, _environment, _object, _target_action_support, _internalTestHelpers) {
  "use strict";

  var originalLookup = _environment.context.lookup;
  var lookup;
  (0, _internalTestHelpers.moduleFor)('TargetActionSupport',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      _environment.context.lookup = lookup = {};
    };

    _proto.afterEach = function afterEach() {
      _environment.context.lookup = originalLookup;
    };

    _proto['@test it should return false if no target or action are specified'] = function testItShouldReturnFalseIfNoTargetOrActionAreSpecified(assert) {
      assert.expect(1);

      var obj = _object.default.extend(_target_action_support.default).create();

      assert.ok(false === obj.triggerAction(), 'no target or action was specified');
    };

    _proto['@test it should support actions specified as strings'] = function testItShouldSupportActionsSpecifiedAsStrings(assert) {
      assert.expect(2);

      var obj = _object.default.extend(_target_action_support.default).create({
        target: _object.default.create({
          anEvent: function () {
            assert.ok(true, 'anEvent method was called');
          }
        }),
        action: 'anEvent'
      });

      assert.ok(true === obj.triggerAction(), 'a valid target and action were specified');
    };

    _proto['@test it should invoke the send() method on objects that implement it'] = function testItShouldInvokeTheSendMethodOnObjectsThatImplementIt(assert) {
      assert.expect(3);

      var obj = _object.default.extend(_target_action_support.default).create({
        target: _object.default.create({
          send: function (evt, context) {
            assert.equal(evt, 'anEvent', 'send() method was invoked with correct event name');
            assert.equal(context, obj, 'send() method was invoked with correct context');
          }
        }),
        action: 'anEvent'
      });

      assert.ok(true === obj.triggerAction(), 'a valid target and action were specified');
    };

    _proto['@test it should find targets specified using a property path'] = function testItShouldFindTargetsSpecifiedUsingAPropertyPath(assert) {
      assert.expect(2);
      var Test = {};
      lookup.Test = Test;
      Test.targetObj = _object.default.create({
        anEvent: function () {
          assert.ok(true, 'anEvent method was called on global object');
        }
      });

      var myObj = _object.default.extend(_target_action_support.default).create({
        target: 'Test.targetObj',
        action: 'anEvent'
      });

      assert.ok(true === myObj.triggerAction(), 'a valid target and action were specified');
    };

    _proto['@test it should use an actionContext object specified as a property on the object'] = function testItShouldUseAnActionContextObjectSpecifiedAsAPropertyOnTheObject(assert) {
      assert.expect(2);

      var obj = _object.default.extend(_target_action_support.default).create({
        action: 'anEvent',
        actionContext: {},
        target: _object.default.create({
          anEvent: function (ctx) {
            assert.ok(obj.actionContext === ctx, 'anEvent method was called with the expected context');
          }
        })
      });

      assert.ok(true === obj.triggerAction(), 'a valid target and action were specified');
    };

    _proto['@test it should find an actionContext specified as a property path'] = function testItShouldFindAnActionContextSpecifiedAsAPropertyPath(assert) {
      assert.expect(2);
      var Test = {};
      lookup.Test = Test;
      Test.aContext = {};

      var obj = _object.default.extend(_target_action_support.default).create({
        action: 'anEvent',
        actionContext: 'Test.aContext',
        target: _object.default.create({
          anEvent: function (ctx) {
            assert.ok(Test.aContext === ctx, 'anEvent method was called with the expected context');
          }
        })
      });

      assert.ok(true === obj.triggerAction(), 'a valid target and action were specified');
    };

    _proto['@test it should use the target specified in the argument'] = function testItShouldUseTheTargetSpecifiedInTheArgument(assert) {
      assert.expect(2);

      var targetObj = _object.default.create({
        anEvent: function () {
          assert.ok(true, 'anEvent method was called');
        }
      });

      var obj = _object.default.extend(_target_action_support.default).create({
        action: 'anEvent'
      });

      assert.ok(true === obj.triggerAction({
        target: targetObj
      }), 'a valid target and action were specified');
    };

    _proto['@test it should use the action specified in the argument'] = function testItShouldUseTheActionSpecifiedInTheArgument(assert) {
      assert.expect(2);

      var obj = _object.default.extend(_target_action_support.default).create({
        target: _object.default.create({
          anEvent: function () {
            assert.ok(true, 'anEvent method was called');
          }
        })
      });

      assert.ok(true === obj.triggerAction({
        action: 'anEvent'
      }), 'a valid target and action were specified');
    };

    _proto['@test it should use the actionContext specified in the argument'] = function testItShouldUseTheActionContextSpecifiedInTheArgument(assert) {
      assert.expect(2);
      var context = {};

      var obj = _object.default.extend(_target_action_support.default).create({
        target: _object.default.create({
          anEvent: function (ctx) {
            assert.ok(context === ctx, 'anEvent method was called with the expected context');
          }
        }),
        action: 'anEvent'
      });

      assert.ok(true === obj.triggerAction({
        actionContext: context
      }), 'a valid target and action were specified');
    };

    _proto['@test it should allow multiple arguments from actionContext'] = function testItShouldAllowMultipleArgumentsFromActionContext(assert) {
      assert.expect(3);
      var param1 = 'someParam';
      var param2 = 'someOtherParam';

      var obj = _object.default.extend(_target_action_support.default).create({
        target: _object.default.create({
          anEvent: function (first, second) {
            assert.ok(first === param1, 'anEvent method was called with the expected first argument');
            assert.ok(second === param2, 'anEvent method was called with the expected second argument');
          }
        }),
        action: 'anEvent'
      });

      assert.ok(true === obj.triggerAction({
        actionContext: [param1, param2]
      }), 'a valid target and action were specified');
    };

    _proto['@test it should use a null value specified in the actionContext argument'] = function testItShouldUseANullValueSpecifiedInTheActionContextArgument(assert) {
      assert.expect(2);

      var obj = _object.default.extend(_target_action_support.default).create({
        target: _object.default.create({
          anEvent: function (ctx) {
            assert.ok(null === ctx, 'anEvent method was called with the expected context (null)');
          }
        }),
        action: 'anEvent'
      });

      assert.ok(true === obj.triggerAction({
        actionContext: null
      }), 'a valid target and action were specified');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/mutable-array/addObject-test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _metal, _internalTestHelpers, _array) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var AddObjectTest =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(AddObjectTest, _AbstractTestCase);

    function AddObjectTest() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = AddObjectTest.prototype;

    _proto['@test should return receiver'] = function testShouldReturnReceiver() {
      var before = (0, _array.newFixture)(3);
      var obj = this.newObject(before);
      this.assert.equal(obj.addObject(before[1]), obj, 'should return receiver');
    };

    _proto['@test [A,B].addObject(C) => [A,B,C] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABAddObjectCABCNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var before, item, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              before = (0, _array.newFixture)(2);
              item = (0, _array.newFixture)(1)[0];
              after = [before[0], before[1], item];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.addObject(item); // flush observers

              _context.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');

              if (observer.isEnabled) {
                this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
                this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
                this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
                this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
                this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
              }

            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testABAddObjectCABCNotify() {
        return _testABAddObjectCABCNotify.apply(this, arguments);
      }

      return testABAddObjectCABCNotify;
    }();

    _proto['@test [A,B,C].addObject(A) => [A,B,C] + NO notify'] =
    /*#__PURE__*/
    function () {
      var _testABCAddObjectAABCNONotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var before, after, item, obj, observer;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              before = (0, _array.newFixture)(3);
              after = before;
              item = before[0];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.addObject(item); // note: item in set
              // flush observers

              _context2.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');

              if (observer.isEnabled) {
                this.assert.equal(observer.validate('[]'), false, 'should NOT have notified []');
                this.assert.equal(observer.validate('@each'), false, 'should NOT have notified @each');
                this.assert.equal(observer.validate('length'), false, 'should NOT have notified length');
                this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
                this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
              }

            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testABCAddObjectAABCNONotify() {
        return _testABCAddObjectAABCNONotify.apply(this, arguments);
      }

      return testABCAddObjectAABCNONotify;
    }();

    return AddObjectTest;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('addObject', AddObjectTest, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
enifed("@ember/-internals/runtime/tests/mutable-array/clear-test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _metal, _internalTestHelpers, _array) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var ClearTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(ClearTests, _AbstractTestCase);

    function ClearTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = ClearTests.prototype;

    _proto['@test [].clear() => [] + notify'] =
    /*#__PURE__*/
    function () {
      var _testClearNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              before = [];
              after = [];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject'); // flush observers

              _context.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              this.assert.equal(obj.clear(), obj, 'return self');
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.validate('[]'), false, 'should NOT have notified [] once');
              this.assert.equal(observer.validate('@each'), false, 'should NOT have notified @each once');
              this.assert.equal(observer.validate('length'), false, 'should NOT have notified length once');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');

            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testClearNotify() {
        return _testClearNotify.apply(this, arguments);
      }

      return testClearNotify;
    }();

    _proto['@test [X].clear() => [] + notify'] =
    /*#__PURE__*/
    function () {
      var _testXClearNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var obj, before, after, observer;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              before = (0, _array.newFixture)(1);
              after = [];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              this.assert.equal(obj.clear(), obj, 'return self'); // flush observers

              _context2.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

            case 15:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testXClearNotify() {
        return _testXClearNotify.apply(this, arguments);
      }

      return testXClearNotify;
    }();

    return ClearTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('clear', ClearTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
enifed("@ember/-internals/runtime/tests/mutable-array/insertAt-test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _metal, _internalTestHelpers, _array) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var InsertAtTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(InsertAtTests, _AbstractTestCase);

    function InsertAtTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = InsertAtTests.prototype;

    _proto['@test [].insertAt(0, X) => [X] + notify'] =
    /*#__PURE__*/
    function () {
      var _testInsertAt0XXNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var after, obj, observer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              after = (0, _array.newFixture)(1);
              obj = this.newObject([]);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.insertAt(0, after[0]); // flush observers

              _context.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] did change once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each did change once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length did change once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject did change once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject did change once');

            case 14:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testInsertAt0XXNotify() {
        return _testInsertAt0XXNotify.apply(this, arguments);
      }

      return testInsertAt0XXNotify;
    }();

    _proto['@test [].insertAt(200,X) => OUT_OF_RANGE_EXCEPTION exception'] = function testInsertAt200XOUT_OF_RANGE_EXCEPTIONException() {
      var obj = this.newObject([]);
      var item = (0, _array.newFixture)(1)[0];
      expectAssertion(function () {
        return obj.insertAt(200, item);
      }, /`insertAt` index provided is out of range/);
    };

    _proto['@test [A].insertAt(0, X) => [X,A] + notify'] =
    /*#__PURE__*/
    function () {
      var _testAInsertAt0XXANotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var item, before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              item = (0, _array.newFixture)(1)[0];
              before = (0, _array.newFixture)(1);
              after = [item, before[0]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.insertAt(0, item); // flush observers

              _context2.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');

            case 16:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testAInsertAt0XXANotify() {
        return _testAInsertAt0XXANotify.apply(this, arguments);
      }

      return testAInsertAt0XXANotify;
    }();

    _proto['@test [A].insertAt(1, X) => [A,X] + notify'] =
    /*#__PURE__*/
    function () {
      var _testAInsertAt1XAXNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var item, before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              item = (0, _array.newFixture)(1)[0];
              before = (0, _array.newFixture)(1);
              after = [before[0], item];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.insertAt(1, item); // flush observers

              _context3.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');

            case 16:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function testAInsertAt1XAXNotify() {
        return _testAInsertAt1XAXNotify.apply(this, arguments);
      }

      return testAInsertAt1XAXNotify;
    }();

    _proto['@test [A].insertAt(200,X) => OUT_OF_RANGE exception'] = function testAInsertAt200XOUT_OF_RANGEException() {
      var obj = this.newObject((0, _array.newFixture)(1));
      var that = this;
      this.assert.throws(function () {
        return obj.insertAt(200, that.newFixture(1)[0]);
      }, Error);
    };

    _proto['@test [A,B,C].insertAt(0,X) => [X,A,B,C] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCInsertAt0XXABCNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        var item, before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              item = (0, _array.newFixture)(1)[0];
              before = (0, _array.newFixture)(3);
              after = [item, before[0], before[1], before[2]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.insertAt(0, item);
              _context4.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');

            case 16:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));

      function testABCInsertAt0XXABCNotify() {
        return _testABCInsertAt0XXABCNotify.apply(this, arguments);
      }

      return testABCInsertAt0XXABCNotify;
    }();

    _proto['@test [A,B,C].insertAt(1,X) => [A,X,B,C] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCInsertAt1XAXBCNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        var item, before, after, obj, observer, objectAtCalls, objectAt;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              item = (0, _array.newFixture)(1)[0];
              before = (0, _array.newFixture)(3);
              after = [before[0], item, before[1], before[2]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              objectAtCalls = [];
              objectAt = obj.objectAt;

              obj.objectAt = function (ix) {
                objectAtCalls.push(ix);
                return objectAt.call(obj, ix);
              };

              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              objectAtCalls.splice(0, objectAtCalls.length);
              obj.insertAt(1, item); // flush observers

              _context5.next = 13;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 13:
              this.assert.deepEqual(objectAtCalls, [], 'objectAt is not called when only inserting items');
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');

            case 21:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));

      function testABCInsertAt1XAXBCNotify() {
        return _testABCInsertAt1XAXBCNotify.apply(this, arguments);
      }

      return testABCInsertAt1XAXBCNotify;
    }();

    _proto['@test [A,B,C].insertAt(3,X) => [A,B,C,X] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCInsertAt3XABCXNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6() {
        var item, before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              item = (0, _array.newFixture)(1)[0];
              before = (0, _array.newFixture)(3);
              after = [before[0], before[1], before[2], item];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.insertAt(3, item); // flush observers

              _context6.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');

            case 16:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));

      function testABCInsertAt3XABCXNotify() {
        return _testABCInsertAt3XABCXNotify.apply(this, arguments);
      }

      return testABCInsertAt3XABCXNotify;
    }();

    return InsertAtTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('instertAt', InsertAtTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
enifed("@ember/-internals/runtime/tests/mutable-array/popObject-test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _metal, _internalTestHelpers, _array) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var PopObjectTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(PopObjectTests, _AbstractTestCase);

    function PopObjectTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = PopObjectTests.prototype;

    _proto['@test [].popObject() => [] + returns undefined + NO notify'] =
    /*#__PURE__*/
    function () {
      var _testPopObjectReturnsUndefinedNONotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var obj, observer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              obj = this.newObject([]);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              this.assert.equal(obj.popObject(), undefined, 'popObject results'); // flush observers

              _context.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              this.assert.deepEqual(this.toArray(obj), [], 'post item results');
              this.assert.equal(observer.validate('[]'), false, 'should NOT have notified []');
              this.assert.equal(observer.validate('@each'), false, 'should NOT have notified @each');
              this.assert.equal(observer.validate('length'), false, 'should NOT have notified length');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');

            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testPopObjectReturnsUndefinedNONotify() {
        return _testPopObjectReturnsUndefinedNONotify.apply(this, arguments);
      }

      return testPopObjectReturnsUndefinedNONotify;
    }();

    _proto['@test [X].popObject() => [] + notify'] =
    /*#__PURE__*/
    function () {
      var _testXPopObjectNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var before, after, obj, observer, ret;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              before = (0, _array.newFixture)(1);
              after = [];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              ret = obj.popObject(); // flush observers

              _context2.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.equal(ret, before[0], 'return object');
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

            case 16:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testXPopObjectNotify() {
        return _testXPopObjectNotify.apply(this, arguments);
      }

      return testXPopObjectNotify;
    }();

    _proto['@test [A,B,C].popObject() => [A,B] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCPopObjectABNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var before, after, obj, observer, ret;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              before = (0, _array.newFixture)(3);
              after = [before[0], before[1]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              ret = obj.popObject(); // flush observers

              _context3.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.equal(ret, before[2], 'return object');
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');

            case 16:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function testABCPopObjectABNotify() {
        return _testABCPopObjectABNotify.apply(this, arguments);
      }

      return testABCPopObjectABNotify;
    }();

    return PopObjectTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('popObject', PopObjectTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
enifed("@ember/-internals/runtime/tests/mutable-array/pushObject-test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _metal, _internalTestHelpers, _array) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var PushObjectTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(PushObjectTests, _AbstractTestCase);

    function PushObjectTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = PushObjectTests.prototype;

    _proto['@test returns pushed object'] = function testReturnsPushedObject() {
      var exp = (0, _array.newFixture)(1)[0];
      var obj = this.newObject([]);
      this.assert.equal(obj.pushObject(exp), exp, 'should return pushed object');
    };

    _proto['@test [].pushObject(X) => [X] + notify'] =
    /*#__PURE__*/
    function () {
      var _testPushObjectXXNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              before = [];
              after = (0, _array.newFixture)(1);
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.pushObject(after[0]); // flush observers

              _context.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testPushObjectXXNotify() {
        return _testPushObjectXXNotify.apply(this, arguments);
      }

      return testPushObjectXXNotify;
    }();

    _proto['@test [A,B,C].pushObject(X) => [A,B,C,X] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCPushObjectXABCXNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var before, item, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              before = (0, _array.newFixture)(3);
              item = (0, _array.newFixture)(1)[0];
              after = [before[0], before[1], before[2], item];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.pushObject(item); // flush observers

              _context2.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');

            case 16:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testABCPushObjectXABCXNotify() {
        return _testABCPushObjectXABCXNotify.apply(this, arguments);
      }

      return testABCPushObjectXABCXNotify;
    }();

    _proto['@test [A,B,C,C].pushObject(A) => [A,B,C,C] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCCPushObjectAABCCNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var before, item, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              before = (0, _array.newFixture)(3);
              item = before[2]; // note same object as current tail. should end up twice

              after = [before[0], before[1], before[2], item];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.pushObject(item); // flush observers

              _context3.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
              this.assert.equal(observer.validate('lastObject'), true, 'should have notified lastObject');

            case 16:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function testABCCPushObjectAABCCNotify() {
        return _testABCCPushObjectAABCCNotify.apply(this, arguments);
      }

      return testABCCPushObjectAABCCNotify;
    }();

    return PushObjectTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('pushObject', PushObjectTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
enifed("@ember/-internals/runtime/tests/mutable-array/pushObjects-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _internalTestHelpers, _array) {
  "use strict";

  var PushObjectsTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(PushObjectsTests, _AbstractTestCase);

    function PushObjectsTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = PushObjectsTests.prototype;

    _proto['@test should raise exception if not Ember.Enumerable is passed to pushObjects'] = function testShouldRaiseExceptionIfNotEmberEnumerableIsPassedToPushObjects() {
      var obj = this.newObject([]);
      expectAssertion(function () {
        return obj.pushObjects('string');
      });
    };

    return PushObjectsTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('pushObjects', PushObjectsTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
enifed("@ember/-internals/runtime/tests/mutable-array/removeAt-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/-internals/runtime/lib/mixins/array", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _array, _array2, _metal) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var RemoveAtTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(RemoveAtTests, _AbstractTestCase);

    function RemoveAtTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = RemoveAtTests.prototype;

    _proto['@test removeAt([X], 0) => [] + notify'] =
    /*#__PURE__*/
    function () {
      var _testRemoveAtX0Notify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              before = (0, _array.newFixture)(1);
              after = [];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              this.assert.equal((0, _array2.removeAt)(obj, 0), obj, 'return self'); // flush observers

              _context.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testRemoveAtX0Notify() {
        return _testRemoveAtX0Notify.apply(this, arguments);
      }

      return testRemoveAtX0Notify;
    }();

    _proto['@test removeAt([], 200) => OUT_OF_RANGE_EXCEPTION exception'] = function testRemoveAt200OUT_OF_RANGE_EXCEPTIONException() {
      var obj = this.newObject([]);
      expectAssertion(function () {
        return (0, _array2.removeAt)(obj, 200);
      }, /`removeAt` index provided is out of range/);
    };

    _proto['@test removeAt([A,B], 0) => [B] + notify'] =
    /*#__PURE__*/
    function () {
      var _testRemoveAtAB0BNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              before = (0, _array.newFixture)(2);
              after = [before[1]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              this.assert.equal((0, _array2.removeAt)(obj, 0), obj, 'return self'); // flush observers

              _context2.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');

            case 15:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testRemoveAtAB0BNotify() {
        return _testRemoveAtAB0BNotify.apply(this, arguments);
      }

      return testRemoveAtAB0BNotify;
    }();

    _proto['@test removeAt([A,B], 1) => [A] + notify'] =
    /*#__PURE__*/
    function () {
      var _testRemoveAtAB1ANotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              before = (0, _array.newFixture)(2);
              after = [before[0]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              this.assert.equal((0, _array2.removeAt)(obj, 1), obj, 'return self'); // flush observers

              _context3.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');

            case 15:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function testRemoveAtAB1ANotify() {
        return _testRemoveAtAB1ANotify.apply(this, arguments);
      }

      return testRemoveAtAB1ANotify;
    }();

    _proto['@test removeAt([A,B,C], 1) => [A,C] + notify'] =
    /*#__PURE__*/
    function () {
      var _testRemoveAtABC1ACNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              before = (0, _array.newFixture)(3);
              after = [before[0], before[2]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              this.assert.equal((0, _array2.removeAt)(obj, 1), obj, 'return self'); // flush observers

              _context4.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');

            case 15:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));

      function testRemoveAtABC1ACNotify() {
        return _testRemoveAtABC1ACNotify.apply(this, arguments);
      }

      return testRemoveAtABC1ACNotify;
    }();

    _proto['@test removeAt([A,B,C,D], 1,2) => [A,D] + notify'] =
    /*#__PURE__*/
    function () {
      var _testRemoveAtABCD12ADNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              before = (0, _array.newFixture)(4);
              after = [before[0], before[3]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              this.assert.equal((0, _array2.removeAt)(obj, 1, 2), obj, 'return self'); // flush observers

              _context5.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');

            case 15:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));

      function testRemoveAtABCD12ADNotify() {
        return _testRemoveAtABCD12ADNotify.apply(this, arguments);
      }

      return testRemoveAtABCD12ADNotify;
    }();

    _proto['@test [A,B,C,D].removeAt(1,2) => [A,D] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCDRemoveAt12ADNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6() {
        var obj, before, after, observer;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              before = (0, _array.newFixture)(4);
              after = [before[0], before[3]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              this.assert.equal(obj.removeAt(1, 2), obj, 'return self'); // flush observers

              _context6.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');

            case 15:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));

      function testABCDRemoveAt12ADNotify() {
        return _testABCDRemoveAt12ADNotify.apply(this, arguments);
      }

      return testABCDRemoveAt12ADNotify;
    }();

    return RemoveAtTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('removeAt', RemoveAtTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
enifed("@ember/-internals/runtime/tests/mutable-array/removeObject-test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _metal, _internalTestHelpers, _array) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var RemoveObjectTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(RemoveObjectTests, _AbstractTestCase);

    function RemoveObjectTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = RemoveObjectTests.prototype;

    _proto['@test should return receiver'] = function testShouldReturnReceiver() {
      var before = (0, _array.newFixture)(3);
      var obj = this.newObject(before);
      this.assert.equal(obj.removeObject(before[1]), obj, 'should return receiver');
    };

    _proto['@test [A,B,C].removeObject(B) => [A,C] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCRemoveObjectBACNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              before = (0, _array.newFixture)(3);
              after = [before[0], before[2]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.removeObject(before[1]); // flush observers

              _context.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');

              if (observer.isEnabled) {
                this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
                this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
                this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
                this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
                this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
              }

            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testABCRemoveObjectBACNotify() {
        return _testABCRemoveObjectBACNotify.apply(this, arguments);
      }

      return testABCRemoveObjectBACNotify;
    }();

    _proto['@test [A,B,C].removeObject(D) => [A,B,C]'] =
    /*#__PURE__*/
    function () {
      var _testABCRemoveObjectDABC = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var before, after, item, obj, observer;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              before = (0, _array.newFixture)(3);
              after = before;
              item = (0, _array.newFixture)(1)[0];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.removeObject(item); // note: item not in set
              // flush observers

              _context2.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');

              if (observer.isEnabled) {
                this.assert.equal(observer.validate('[]'), false, 'should NOT have notified []');
                this.assert.equal(observer.validate('@each'), false, 'should NOT have notified @each');
                this.assert.equal(observer.validate('length'), false, 'should NOT have notified length');
                this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
                this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
              }

            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testABCRemoveObjectDABC() {
        return _testABCRemoveObjectDABC.apply(this, arguments);
      }

      return testABCRemoveObjectDABC;
    }();

    return RemoveObjectTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('removeObject', RemoveObjectTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
enifed("@ember/-internals/runtime/tests/mutable-array/removeObjects-test", ["ember-babel", "@ember/-internals/metal", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/-internals/runtime/lib/mixins/array"], function (_emberBabel, _metal, _internalTestHelpers, _array, _array2) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var RemoveObjectsTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(RemoveObjectsTests, _AbstractTestCase);

    function RemoveObjectsTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = RemoveObjectsTests.prototype;

    _proto['@test should return receiver'] = function testShouldReturnReceiver() {
      var before = (0, _array2.A)((0, _array.newFixture)(3));
      var obj = before;
      this.assert.equal(obj.removeObjects(before[1]), obj, 'should return receiver');
    };

    _proto['@test [A,B,C].removeObjects([B]) => [A,C] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCRemoveObjectsBACNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              before = (0, _array2.A)((0, _array.newFixture)(3));
              after = [before[0], before[2]];
              obj = before;
              observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject'); // Prime the cache

              obj.removeObjects([before[1]]); // flush observers

              _context.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');

              if (observer.isEnabled) {
                this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
                this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
                this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
                this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
              }

            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testABCRemoveObjectsBACNotify() {
        return _testABCRemoveObjectsBACNotify.apply(this, arguments);
      }

      return testABCRemoveObjectsBACNotify;
    }();

    _proto['@test [{A},{B},{C}].removeObjects([{B}]) => [{A},{C}] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCRemoveObjectsBACNotify2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              before = (0, _array2.A)((0, _array.newObjectsFixture)(3));
              after = [before[0], before[2]];
              obj = before;
              observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject'); // Prime the cache

              obj.removeObjects([before[1]]); // flush observers

              _context2.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');

              if (observer.isEnabled) {
                this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
                this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
                this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
                this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
              }

            case 11:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testABCRemoveObjectsBACNotify() {
        return _testABCRemoveObjectsBACNotify2.apply(this, arguments);
      }

      return testABCRemoveObjectsBACNotify;
    }();

    _proto['@test [A,B,C].removeObjects([A,B]) => [C] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCRemoveObjectsABCNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              before = (0, _array2.A)((0, _array.newFixture)(3));
              after = [before[2]];
              obj = before;
              observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject'); // Prime the cache

              obj.removeObjects([before[0], before[1]]); // flush observers

              _context3.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');

              if (observer.isEnabled) {
                this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
                this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
                this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject');
                this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
              }

            case 11:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function testABCRemoveObjectsABCNotify() {
        return _testABCRemoveObjectsABCNotify.apply(this, arguments);
      }

      return testABCRemoveObjectsABCNotify;
    }();

    _proto['@test [{A},{B},{C}].removeObjects([{A},{B}]) => [{C}] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCRemoveObjectsABCNotify2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              before = (0, _array2.A)((0, _array.newObjectsFixture)(3));
              after = [before[2]];
              obj = before;
              observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject'); // Prime the cache

              obj.removeObjects([before[0], before[1]]); // flush observers

              _context4.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');

              if (observer.isEnabled) {
                this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
                this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
                this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject');
                this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
              }

            case 11:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));

      function testABCRemoveObjectsABCNotify() {
        return _testABCRemoveObjectsABCNotify2.apply(this, arguments);
      }

      return testABCRemoveObjectsABCNotify;
    }();

    _proto['@test [A,B,C].removeObjects([A,B,C]) => [] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCRemoveObjectsABCNotify3 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              before = (0, _array2.A)((0, _array.newFixture)(3));
              after = [];
              obj = before;
              observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject'); // Prime the cache

              obj.removeObjects([before[0], before[1], before[2]]); // flush observers

              _context5.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');

              if (observer.isEnabled) {
                this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
                this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
                this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject');
                this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject');
              }

            case 11:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));

      function testABCRemoveObjectsABCNotify() {
        return _testABCRemoveObjectsABCNotify3.apply(this, arguments);
      }

      return testABCRemoveObjectsABCNotify;
    }();

    _proto['@test [{A},{B},{C}].removeObjects([{A},{B},{C}]) => [] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCRemoveObjectsABCNotify4 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              before = (0, _array2.A)((0, _array.newObjectsFixture)(3));
              after = [];
              obj = before;
              observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject'); // Prime the cache

              obj.removeObjects(before); // flush observers

              _context6.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');

              if (observer.isEnabled) {
                this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
                this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
                this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject');
                this.assert.equal(observer.validate('lastObject'), 1, 'should have notified lastObject');
              }

            case 11:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));

      function testABCRemoveObjectsABCNotify() {
        return _testABCRemoveObjectsABCNotify4.apply(this, arguments);
      }

      return testABCRemoveObjectsABCNotify;
    }();

    _proto['@test [A,B,C].removeObjects([D]) => [A,B,C]'] =
    /*#__PURE__*/
    function () {
      var _testABCRemoveObjectsDABC = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7() {
        var before, after, item, obj, observer;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              before = (0, _array2.A)((0, _array.newFixture)(3));
              after = before;
              item = (0, _array.newFixture)(1)[0];
              obj = before;
              observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject'); // Prime the cache

              obj.removeObjects([item]); // Note: item not in set
              // flush observers

              _context7.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');

              if (observer.isEnabled) {
                this.assert.equal(observer.validate('[]'), false, 'should NOT have notified []');
                this.assert.equal(observer.validate('length'), false, 'should NOT have notified length');
                this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
                this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
              }

            case 12:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));

      function testABCRemoveObjectsDABC() {
        return _testABCRemoveObjectsDABC.apply(this, arguments);
      }

      return testABCRemoveObjectsDABC;
    }();

    return RemoveObjectsTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('removeObjects', RemoveObjectsTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
enifed("@ember/-internals/runtime/tests/mutable-array/replace-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _internalTestHelpers, _array) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var ReplaceTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(ReplaceTests, _AbstractTestCase);

    function ReplaceTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = ReplaceTests.prototype;

    _proto["@test [].replace(0,0,'X') => ['X'] + notify"] =
    /*#__PURE__*/
    function () {
      var _testReplace00XXNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var exp, obj, observer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              exp = (0, _array.newFixture)(1);
              obj = this.newObject([]);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.replace(0, 0, exp); // flush observers

              _context.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              this.assert.deepEqual(this.toArray(obj), exp, 'post item results');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

            case 13:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testReplace00XXNotify() {
        return _testReplace00XXNotify.apply(this, arguments);
      }

      return testReplace00XXNotify;
    }();

    _proto['@test [].replace(0,0,"X") => ["X"] + avoid calling objectAt and notifying fistObject/lastObject when not in cache'] =
    /*#__PURE__*/
    function () {
      var _testReplace00XXAvoidCallingObjectAtAndNotifyingFistObjectLastObjectWhenNotInCache = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var obj, exp, observer, called;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              called = 0;
              exp = (0, _array.newFixture)(1);
              obj = this.newObject([]);

              obj.objectAt = function () {
                called++;
              };

              observer = this.newObserver(obj, 'firstObject', 'lastObject');
              obj.replace(0, 0, exp); // flush observers

              _context2.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.equal(called, 0, 'should NOT have called objectAt upon replace when firstObject/lastObject are not cached');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject since not cached');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject since not cached');

            case 11:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testReplace00XXAvoidCallingObjectAtAndNotifyingFistObjectLastObjectWhenNotInCache() {
        return _testReplace00XXAvoidCallingObjectAtAndNotifyingFistObjectLastObjectWhenNotInCache.apply(this, arguments);
      }

      return testReplace00XXAvoidCallingObjectAtAndNotifyingFistObjectLastObjectWhenNotInCache;
    }();

    _proto['@test [A,B,C,D].replace(1,2,X) => [A,X,D] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCDReplace12XAXDNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var before, replace, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              before = (0, _array.newFixture)(4);
              replace = (0, _array.newFixture)(1);
              after = [before[0], replace[0], before[3]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.replace(1, 2, replace); // flush observers

              _context3.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');

            case 15:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function testABCDReplace12XAXDNotify() {
        return _testABCDReplace12XAXDNotify.apply(this, arguments);
      }

      return testABCDReplace12XAXDNotify;
    }();

    _proto['@test [A,B,C,D].replace(1,2,[X,Y]) => [A,X,Y,D] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCDReplace12XYAXYDNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        var before, replace, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              before = (0, _array.newFixture)(4);
              replace = (0, _array.newFixture)(2);
              after = [before[0], replace[0], replace[1], before[3]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.replace(1, 2, replace); // flush observers

              _context4.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.validate('length'), false, 'should NOT have notified length');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');

            case 15:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));

      function testABCDReplace12XYAXYDNotify() {
        return _testABCDReplace12XYAXYDNotify.apply(this, arguments);
      }

      return testABCDReplace12XYAXYDNotify;
    }();

    _proto['@test [A,B].replace(1,0,[X,Y]) => [A,X,Y,B] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABReplace10XYAXYBNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5() {
        var before, replace, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              before = (0, _array.newFixture)(2);
              replace = (0, _array.newFixture)(2);
              after = [before[0], replace[0], replace[1], before[1]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.replace(1, 0, replace); // flush observers

              _context5.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');

            case 15:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));

      function testABReplace10XYAXYBNotify() {
        return _testABReplace10XYAXYBNotify.apply(this, arguments);
      }

      return testABReplace10XYAXYBNotify;
    }();

    _proto['@test [A,B,C,D].replace(2,2) => [A,B] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCDReplace22ABNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              before = (0, _array.newFixture)(4);
              after = [before[0], before[1]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.replace(2, 2); // flush observers

              _context6.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');

            case 14:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));

      function testABCDReplace22ABNotify() {
        return _testABCDReplace22ABNotify.apply(this, arguments);
      }

      return testABCDReplace22ABNotify;
    }();

    _proto['@test [A,B,C,D].replace(-1,1) => [A,B,C] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCDReplace11ABCNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              before = (0, _array.newFixture)(4);
              after = [before[0], before[1], before[2]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.replace(-1, 1); // flush observers

              _context7.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');

            case 14:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));

      function testABCDReplace11ABCNotify() {
        return _testABCDReplace11ABCNotify.apply(this, arguments);
      }

      return testABCDReplace11ABCNotify;
    }();

    _proto['@test Adding object should notify array observer'] =
    /*#__PURE__*/
    function () {
      var _testAddingObjectShouldNotifyArrayObserver = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8() {
        var fixtures, obj, observer, item;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              fixtures = (0, _array.newFixture)(4);
              obj = this.newObject(fixtures);
              observer = this.newObserver(obj).observeArray(obj);
              item = (0, _array.newFixture)(1)[0];
              obj.replace(2, 2, [item]); // flush observers

              _context8.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              this.assert.deepEqual(observer._before, [obj, 2, 2, 1], 'before');
              this.assert.deepEqual(observer._after, [obj, 2, 2, 1], 'after');

            case 9:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));

      function testAddingObjectShouldNotifyArrayObserver() {
        return _testAddingObjectShouldNotifyArrayObserver.apply(this, arguments);
      }

      return testAddingObjectShouldNotifyArrayObserver;
    }();

    return ReplaceTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('replace', ReplaceTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
enifed("@ember/-internals/runtime/tests/mutable-array/reverseObjects-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _array, _metal) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var ReverseObjectsTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(ReverseObjectsTests, _AbstractTestCase);

    function ReverseObjectsTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = ReverseObjectsTests.prototype;

    _proto['@test [A,B,C].reverseObjects() => [] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCReverseObjectsNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              before = (0, _array.newFixture)(3);
              after = [before[2], before[1], before[0]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              this.assert.equal(obj.reverseObjects(), obj, 'return self'); // flush observers

              _context.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 0, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testABCReverseObjectsNotify() {
        return _testABCReverseObjectsNotify.apply(this, arguments);
      }

      return testABCReverseObjectsNotify;
    }();

    return ReverseObjectsTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('reverseObjects', ReverseObjectsTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
enifed("@ember/-internals/runtime/tests/mutable-array/setObjects-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _array, _metal) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var SetObjectsTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(SetObjectsTests, _AbstractTestCase);

    function SetObjectsTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = SetObjectsTests.prototype;

    _proto['@test [A,B,C].setObjects([]) = > [] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCSetObjectsNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              before = (0, _array.newFixture)(3);
              after = [];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              this.assert.equal(obj.setObjects(after), obj, 'return self'); // flush observers

              _context.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testABCSetObjectsNotify() {
        return _testABCSetObjectsNotify.apply(this, arguments);
      }

      return testABCSetObjectsNotify;
    }();

    _proto['@test [A,B,C].setObjects([D, E, F, G]) = > [D, E, F, G] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCSetObjectsDEFGDEFGNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              before = (0, _array.newFixture)(3);
              after = (0, _array.newFixture)(4);
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              this.assert.equal(obj.setObjects(after), obj, 'return self'); // flush observers

              _context2.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

            case 15:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testABCSetObjectsDEFGDEFGNotify() {
        return _testABCSetObjectsDEFGDEFGNotify.apply(this, arguments);
      }

      return testABCSetObjectsDEFGDEFGNotify;
    }();

    return SetObjectsTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('setObjects', SetObjectsTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
enifed("@ember/-internals/runtime/tests/mutable-array/shiftObject-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/runtime/tests/helpers/array", "@ember/-internals/metal"], function (_emberBabel, _internalTestHelpers, _array, _metal) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var ShiftObjectTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(ShiftObjectTests, _AbstractTestCase);

    function ShiftObjectTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = ShiftObjectTests.prototype;

    _proto['@test [].shiftObject() => [] + returns undefined + NO notify'] =
    /*#__PURE__*/
    function () {
      var _testShiftObjectReturnsUndefinedNONotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              before = [];
              after = [];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              this.assert.equal(obj.shiftObject(), undefined); // flush observers

              _context.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.validate('[]', undefined, 1), false, 'should NOT have notified [] once');
              this.assert.equal(observer.validate('@each', undefined, 1), false, 'should NOT have notified @each once');
              this.assert.equal(observer.validate('length', undefined, 1), false, 'should NOT have notified length once');
              this.assert.equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');

            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testShiftObjectReturnsUndefinedNONotify() {
        return _testShiftObjectReturnsUndefinedNONotify.apply(this, arguments);
      }

      return testShiftObjectReturnsUndefinedNONotify;
    }();

    _proto['@test [X].shiftObject() => [] + notify'] =
    /*#__PURE__*/
    function () {
      var _testXShiftObjectNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              before = (0, _array.newFixture)(1);
              after = [];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              this.assert.equal(obj.shiftObject(), before[0], 'should return object'); // flush observers

              _context2.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

            case 15:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testXShiftObjectNotify() {
        return _testXShiftObjectNotify.apply(this, arguments);
      }

      return testXShiftObjectNotify;
    }();

    _proto['@test [A,B,C].shiftObject() => [B,C] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCShiftObjectBCNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var before, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              before = (0, _array.newFixture)(3);
              after = [before[1], before[2]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              this.assert.equal(obj.shiftObject(), before[0], 'should return object'); // flush observers

              _context3.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');

            case 15:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function testABCShiftObjectBCNotify() {
        return _testABCShiftObjectBCNotify.apply(this, arguments);
      }

      return testABCShiftObjectBCNotify;
    }();

    return ShiftObjectTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('shiftObject', ShiftObjectTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
enifed("@ember/-internals/runtime/tests/mutable-array/unshiftObject-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _internalTestHelpers, _metal, _array) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var UnshiftObjectTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(UnshiftObjectTests, _AbstractTestCase);

    function UnshiftObjectTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = UnshiftObjectTests.prototype;

    _proto['@test returns unshifted object'] = function testReturnsUnshiftedObject() {
      var obj = this.newObject([]);
      var item = (0, _array.newFixture)(1)[0];
      this.assert.equal(obj.unshiftObject(item), item, 'should return unshifted object');
    };

    _proto['@test [].unshiftObject(X) => [X] + notify'] =
    /*#__PURE__*/
    function () {
      var _testUnshiftObjectXXNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var before, item, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              before = [];
              item = (0, _array.newFixture)(1)[0];
              after = [item];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.unshiftObject(item); // flush observers

              _context.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

            case 16:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testUnshiftObjectXXNotify() {
        return _testUnshiftObjectXXNotify.apply(this, arguments);
      }

      return testUnshiftObjectXXNotify;
    }();

    _proto['@test [A,B,C].unshiftObject(X) => [X,A,B,C] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCUnshiftObjectXXABCNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var before, item, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              before = (0, _array.newFixture)(3);
              item = (0, _array.newFixture)(1)[0];
              after = [item, before[0], before[1], before[2]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.unshiftObject(item); // flush observers

              _context2.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');

            case 16:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testABCUnshiftObjectXXABCNotify() {
        return _testABCUnshiftObjectXXABCNotify.apply(this, arguments);
      }

      return testABCUnshiftObjectXXABCNotify;
    }();

    _proto['@test [A,B,C].unshiftObject(A) => [A,A,B,C] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCUnshiftObjectAAABCNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var before, item, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              before = (0, _array.newFixture)(3);
              item = before[0]; // note same object as current head. should end up twice

              after = [item, before[0], before[1], before[2]];
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.unshiftObject(item); // flush observers

              _context3.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.validate('firstObject'), true, 'should have notified firstObject');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');

            case 16:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function testABCUnshiftObjectAAABCNotify() {
        return _testABCUnshiftObjectAAABCNotify.apply(this, arguments);
      }

      return testABCUnshiftObjectAAABCNotify;
    }();

    return UnshiftObjectTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('unshiftObject', UnshiftObjectTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
enifed("@ember/-internals/runtime/tests/mutable-array/unshiftObjects-test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/-internals/runtime/tests/helpers/array"], function (_emberBabel, _internalTestHelpers, _metal, _array) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var UnshiftObjectsTests =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(UnshiftObjectsTests, _AbstractTestCase);

    function UnshiftObjectsTests() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = UnshiftObjectsTests.prototype;

    _proto['@test returns receiver'] = function testReturnsReceiver() {
      var obj = this.newObject([]);
      var items = (0, _array.newFixture)(3);
      this.assert.equal(obj.unshiftObjects(items), obj, 'should return receiver');
    };

    _proto['@test [].unshiftObjects([A,B,C]) => [A,B,C] + notify'] =
    /*#__PURE__*/
    function () {
      var _testUnshiftObjectsABCABCNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var before, items, obj, observer;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              before = [];
              items = (0, _array.newFixture)(3);
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.unshiftObjects(items); // flush observers

              _context.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              this.assert.deepEqual(this.toArray(obj), items, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), items.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testUnshiftObjectsABCABCNotify() {
        return _testUnshiftObjectsABCABCNotify.apply(this, arguments);
      }

      return testUnshiftObjectsABCABCNotify;
    }();

    _proto['@test [A,B,C].unshiftObjects([X,Y]) => [X,Y,A,B,C] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCUnshiftObjectsXYXYABCNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var before, items, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              before = (0, _array.newFixture)(3);
              items = (0, _array.newFixture)(2);
              after = items.concat(before);
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.unshiftObjects(items); // flush observers

              _context2.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');

            case 16:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testABCUnshiftObjectsXYXYABCNotify() {
        return _testABCUnshiftObjectsXYXYABCNotify.apply(this, arguments);
      }

      return testABCUnshiftObjectsXYXYABCNotify;
    }();

    _proto['@test [A,B,C].unshiftObjects([A,B]) => [A,B,A,B,C] + notify'] =
    /*#__PURE__*/
    function () {
      var _testABCUnshiftObjectsABABABCNotify = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var before, items, after, obj, observer;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              before = (0, _array.newFixture)(3);
              items = [before[0], before[1]]; // note same object as current head. should end up twice

              after = items.concat(before);
              obj = this.newObject(before);
              observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
              obj.getProperties('firstObject', 'lastObject');
              /* Prime the cache */

              obj.unshiftObjects(items); // flush observers

              _context3.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assert.deepEqual(this.toArray(obj), after, 'post item results');
              this.assert.equal((0, _metal.get)(obj, 'length'), after.length, 'length');
              this.assert.equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
              this.assert.equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
              this.assert.equal(observer.timesCalled('length'), 1, 'should have notified length once');
              this.assert.equal(observer.validate('firstObject'), true, 'should NOT have notified firstObject');
              this.assert.equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');

            case 16:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function testABCUnshiftObjectsABABABCNotify() {
        return _testABCUnshiftObjectsABABABCNotify.apply(this, arguments);
      }

      return testABCUnshiftObjectsABABABCNotify;
    }();

    return UnshiftObjectsTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _array.runArrayTests)('unshiftObjects', UnshiftObjectsTests, 'MutableArray', 'NativeArray', 'ArrayProxy');
});
enifed("@ember/-internals/runtime/tests/system/array_proxy/arranged_content_test", ["ember-babel", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/array_proxy", "@ember/-internals/runtime/lib/mixins/array", "internal-test-helpers"], function (_emberBabel, _runloop, _metal, _array_proxy, _array, _internalTestHelpers) {
  "use strict";

  var array;
  (0, _internalTestHelpers.moduleFor)('ArrayProxy - arrangedContent',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      (0, _runloop.run)(function () {
        array = _array_proxy.default.extend({
          arrangedContent: (0, _metal.computed)('content.[]', function () {
            var content = this.get('content');
            return content && (0, _array.A)(content.slice().sort(function (a, b) {
              if (a == null) {
                a = -1;
              }

              if (b == null) {
                b = -1;
              }

              return b - a;
            }));
          })
        }).create({
          content: (0, _array.A)([1, 2, 4, 5])
        });
      });
    };

    _proto.afterEach = function afterEach() {
      (0, _runloop.run)(function () {
        return array.destroy();
      });
    };

    _proto['@test compact - returns arrangedContent without nulls and undefined'] = function testCompactReturnsArrangedContentWithoutNullsAndUndefined(assert) {
      (0, _runloop.run)(function () {
        return array.set('content', (0, _array.A)([1, 3, null, 2, undefined]));
      });
      assert.deepEqual(array.compact(), [3, 2, 1]);
    };

    _proto['@test indexOf - returns index of object in arrangedContent'] = function testIndexOfReturnsIndexOfObjectInArrangedContent(assert) {
      assert.equal(array.indexOf(4), 1, 'returns arranged index');
    };

    _proto['@test lastIndexOf - returns last index of object in arrangedContent'] = function testLastIndexOfReturnsLastIndexOfObjectInArrangedContent(assert) {
      array.get('content').pushObject(4);
      assert.equal(array.lastIndexOf(4), 2, 'returns last arranged index');
    };

    _proto['@test objectAt - returns object at index in arrangedContent'] = function testObjectAtReturnsObjectAtIndexInArrangedContent(assert) {
      assert.equal((0, _metal.objectAt)(array, 1), 4, 'returns object at index');
    } // Not sure if we need a specific test for it, since it's internal
    ;

    _proto['@test objectAtContent - returns object at index in arrangedContent'] = function testObjectAtContentReturnsObjectAtIndexInArrangedContent(assert) {
      assert.equal(array.objectAtContent(1), 4, 'returns object at index');
    };

    _proto['@test objectsAt - returns objects at indices in arrangedContent'] = function testObjectsAtReturnsObjectsAtIndicesInArrangedContent(assert) {
      assert.deepEqual(array.objectsAt([0, 2, 4]), [5, 2, undefined], 'returns objects at indices');
    };

    _proto['@test replace - mutating an arranged ArrayProxy is not allowed'] = function testReplaceMutatingAnArrangedArrayProxyIsNotAllowed() {
      expectAssertion(function () {
        array.replace(0, 0, [3]);
      }, /Mutating an arranged ArrayProxy is not allowed/);
    };

    _proto['@test replaceContent - does a standard array replace on content'] = function testReplaceContentDoesAStandardArrayReplaceOnContent(assert) {
      (0, _runloop.run)(function () {
        return array.replaceContent(1, 2, [3]);
      });
      assert.deepEqual(array.get('content'), [1, 3, 5]);
    };

    _proto['@test slice - returns a slice of the arrangedContent'] = function testSliceReturnsASliceOfTheArrangedContent(assert) {
      assert.deepEqual(array.slice(1, 3), [4, 2], 'returns sliced arrangedContent');
    };

    _proto['@test toArray - returns copy of arrangedContent'] = function testToArrayReturnsCopyOfArrangedContent(assert) {
      assert.deepEqual(array.toArray(), [5, 4, 2, 1]);
    };

    _proto['@test without - returns arrangedContent without object'] = function testWithoutReturnsArrangedContentWithoutObject(assert) {
      assert.deepEqual(array.without(2), [5, 4, 1], 'returns arranged without object');
    };

    _proto['@test lastObject - returns last arranged object'] = function testLastObjectReturnsLastArrangedObject(assert) {
      assert.equal(array.get('lastObject'), 1, 'returns last arranged object');
    };

    _proto['@test firstObject - returns first arranged object'] = function testFirstObjectReturnsFirstArrangedObject(assert) {
      assert.equal(array.get('firstObject'), 5, 'returns first arranged object');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('ArrayProxy - arrangedContent matching content',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2.beforeEach = function beforeEach() {
      (0, _runloop.run)(function () {
        array = _array_proxy.default.create({
          content: (0, _array.A)([1, 2, 4, 5])
        });
      });
    };

    _proto2.afterEach = function afterEach() {
      (0, _runloop.run)(function () {
        array.destroy();
      });
    };

    _proto2['@test insertAt - inserts object at specified index'] = function testInsertAtInsertsObjectAtSpecifiedIndex(assert) {
      (0, _runloop.run)(function () {
        array.insertAt(2, 3);
      });
      assert.deepEqual(array.get('content'), [1, 2, 3, 4, 5]);
    };

    _proto2['@test replace - does a standard array replace'] = function testReplaceDoesAStandardArrayReplace(assert) {
      (0, _runloop.run)(function () {
        array.replace(1, 2, [3]);
      });
      assert.deepEqual(array.get('content'), [1, 3, 5]);
    };

    _proto2['@test reverseObjects - reverses content'] = function testReverseObjectsReversesContent(assert) {
      (0, _runloop.run)(function () {
        array.reverseObjects();
      });
      assert.deepEqual(array.get('content'), [5, 4, 2, 1]);
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('ArrayProxy - arrangedContent with transforms',
  /*#__PURE__*/
  function (_AbstractTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class3, _AbstractTestCase3);

    function _class3() {
      return _AbstractTestCase3.apply(this, arguments) || this;
    }

    var _proto3 = _class3.prototype;

    _proto3.beforeEach = function beforeEach() {
      (0, _runloop.run)(function () {
        array = _array_proxy.default.extend({
          arrangedContent: (0, _metal.computed)('content.[]', function () {
            var content = this.get('content');
            return content && (0, _array.A)(content.slice().sort(function (a, b) {
              if (a == null) {
                a = -1;
              }

              if (b == null) {
                b = -1;
              }

              return b - a;
            }));
          }),
          objectAtContent: function (idx) {
            var obj = (0, _metal.objectAt)(this.get('arrangedContent'), idx);
            return obj && obj.toString();
          }
        }).create({
          content: (0, _array.A)([1, 2, 4, 5])
        });
      });
    };

    _proto3.afterEach = function afterEach() {
      (0, _runloop.run)(function () {
        array.destroy();
      });
    };

    _proto3['@test indexOf - returns index of object in arrangedContent'] = function testIndexOfReturnsIndexOfObjectInArrangedContent(assert) {
      assert.equal(array.indexOf('4'), 1, 'returns arranged index');
    };

    _proto3['@test lastIndexOf - returns last index of object in arrangedContent'] = function testLastIndexOfReturnsLastIndexOfObjectInArrangedContent(assert) {
      array.get('content').pushObject(4);
      assert.equal(array.lastIndexOf('4'), 2, 'returns last arranged index');
    };

    _proto3['@test objectAt - returns object at index in arrangedContent'] = function testObjectAtReturnsObjectAtIndexInArrangedContent(assert) {
      assert.equal((0, _metal.objectAt)(array, 1), '4', 'returns object at index');
    } // Not sure if we need a specific test for it, since it's internal
    ;

    _proto3['@test objectAtContent - returns object at index in arrangedContent'] = function testObjectAtContentReturnsObjectAtIndexInArrangedContent(assert) {
      assert.equal(array.objectAtContent(1), '4', 'returns object at index');
    };

    _proto3['@test objectsAt - returns objects at indices in arrangedContent'] = function testObjectsAtReturnsObjectsAtIndicesInArrangedContent(assert) {
      assert.deepEqual(array.objectsAt([0, 2, 4]), ['5', '2', undefined], 'returns objects at indices');
    };

    _proto3['@test slice - returns a slice of the arrangedContent'] = function testSliceReturnsASliceOfTheArrangedContent(assert) {
      assert.deepEqual(array.slice(1, 3), ['4', '2'], 'returns sliced arrangedContent');
    };

    _proto3['@test toArray - returns copy of arrangedContent'] = function testToArrayReturnsCopyOfArrangedContent(assert) {
      assert.deepEqual(array.toArray(), ['5', '4', '2', '1']);
    };

    _proto3['@test without - returns arrangedContent without object'] = function testWithoutReturnsArrangedContentWithoutObject(assert) {
      assert.deepEqual(array.without('2'), ['5', '4', '1'], 'returns arranged without object');
    };

    _proto3['@test lastObject - returns last arranged object'] = function testLastObjectReturnsLastArrangedObject(assert) {
      assert.equal(array.get('lastObject'), '1', 'returns last arranged object');
    };

    _proto3['@test firstObject - returns first arranged object'] = function testFirstObjectReturnsFirstArrangedObject(assert) {
      assert.equal(array.get('firstObject'), '5', 'returns first arranged object');
    };

    return _class3;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('ArrayProxy - with transforms',
  /*#__PURE__*/
  function (_AbstractTestCase4) {
    (0, _emberBabel.inheritsLoose)(_class4, _AbstractTestCase4);

    function _class4() {
      return _AbstractTestCase4.apply(this, arguments) || this;
    }

    var _proto4 = _class4.prototype;

    _proto4.beforeEach = function beforeEach() {
      (0, _runloop.run)(function () {
        array = _array_proxy.default.extend({
          objectAtContent: function (idx) {
            var obj = (0, _metal.objectAt)(this.get('arrangedContent'), idx);
            return obj && obj.toString();
          }
        }).create({
          content: (0, _array.A)([1, 2, 4, 5])
        });
      });
    };

    _proto4.afterEach = function afterEach() {
      (0, _runloop.run)(function () {
        array.destroy();
      });
    };

    _proto4['@test popObject - removes last object in arrangedContent'] = function testPopObjectRemovesLastObjectInArrangedContent(assert) {
      var popped = array.popObject();
      assert.equal(popped, '5', 'returns last object');
      assert.deepEqual(array.toArray(), ['1', '2', '4'], 'removes from content');
    };

    _proto4['@test removeObject - removes object from content'] = function testRemoveObjectRemovesObjectFromContent(assert) {
      array.removeObject('2');
      assert.deepEqual(array.toArray(), ['1', '4', '5']);
    };

    _proto4['@test removeObjects - removes objects from content'] = function testRemoveObjectsRemovesObjectsFromContent(assert) {
      array.removeObjects(['2', '4', '6']);
      assert.deepEqual(array.toArray(), ['1', '5']);
    };

    _proto4['@test shiftObject - removes from start of arrangedContent'] = function testShiftObjectRemovesFromStartOfArrangedContent(assert) {
      var shifted = array.shiftObject();
      assert.equal(shifted, '1', 'returns first object');
      assert.deepEqual(array.toArray(), ['2', '4', '5'], 'removes object from content');
    };

    return _class4;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/array_proxy/array_observer_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/array_proxy", "@ember/-internals/runtime/lib/mixins/array", "internal-test-helpers"], function (_emberBabel, _metal, _array_proxy, _array, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ArrayProxy - array observers',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test mutating content'] = function testMutatingContent(assert) {
      assert.expect(4);
      var content = (0, _array.A)(['x', 'y', 'z']);

      var proxy = _array_proxy.default.create({
        content: content
      });

      proxy.addArrayObserver({
        arrayWillChange: function (proxy, startIndex, removeCount, addCount) {
          assert.deepEqual([startIndex, removeCount, addCount], [1, 1, 3]);
          assert.deepEqual(proxy.toArray(), ['x', 'y', 'z']);
        },
        arrayDidChange: function (proxy, startIndex, removeCount, addCount) {
          assert.deepEqual([startIndex, removeCount, addCount], [1, 1, 3]);
          assert.deepEqual(proxy.toArray(), ['x', 'a', 'b', 'c', 'z']);
        }
      });
      proxy.toArray();
      content.replace(1, 1, ['a', 'b', 'c']);
    };

    _proto['@test assigning content'] = function testAssigningContent(assert) {
      assert.expect(4);
      var content = (0, _array.A)(['x', 'y', 'z']);

      var proxy = _array_proxy.default.create({
        content: content
      });

      proxy.addArrayObserver({
        arrayWillChange: function (proxy, startIndex, removeCount, addCount) {
          assert.deepEqual([startIndex, removeCount, addCount], [0, 3, 5]);
          assert.deepEqual(proxy.toArray(), ['x', 'y', 'z']);
        },
        arrayDidChange: function (proxy, startIndex, removeCount, addCount) {
          assert.deepEqual([startIndex, removeCount, addCount], [0, 3, 5]);
          assert.deepEqual(proxy.toArray(), ['a', 'b', 'c', 'd', 'e']);
        }
      });
      proxy.toArray();
      (0, _metal.set)(proxy, 'content', (0, _array.A)(['a', 'b', 'c', 'd', 'e']));
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/array_proxy/content_change_test", ["ember-babel", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/array_proxy", "@ember/-internals/runtime/lib/mixins/array", "internal-test-helpers"], function (_emberBabel, _runloop, _metal, _array_proxy, _array, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ArrayProxy - content change',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto["@test The ArrayProxy doesn't explode when assigned a destroyed object"] = function testTheArrayProxyDoesnTExplodeWhenAssignedADestroyedObject(assert) {
      var proxy1 = _array_proxy.default.create();

      var proxy2 = _array_proxy.default.create();

      (0, _runloop.run)(function () {
        return proxy1.destroy();
      });
      (0, _metal.set)(proxy2, 'content', proxy1);
      assert.ok(true, 'No exception was raised');
    };

    _proto['@test should update if content changes while change events are deferred'] = function testShouldUpdateIfContentChangesWhileChangeEventsAreDeferred(assert) {
      var proxy = _array_proxy.default.create();

      assert.deepEqual(proxy.toArray(), []);
      (0, _metal.changeProperties)(function () {
        proxy.set('content', (0, _array.A)([1, 2, 3]));
        assert.deepEqual(proxy.toArray(), [1, 2, 3]);
      });
    };

    _proto['@test objectAt recomputes the object cache correctly'] = function testObjectAtRecomputesTheObjectCacheCorrectly(assert) {
      var indexes = [];

      var proxy = _array_proxy.default.extend({
        objectAtContent: function (index) {
          indexes.push(index);
          return this.content[index];
        }
      }).create({
        content: (0, _array.A)([1, 2, 3, 4, 5])
      });

      assert.deepEqual(indexes, []);
      assert.deepEqual(proxy.objectAt(0), 1);
      assert.deepEqual(indexes, [0, 1, 2, 3, 4]);
      indexes.length = 0;
      proxy.set('content', (0, _array.A)([1, 2, 3]));
      assert.deepEqual(proxy.objectAt(0), 1);
      assert.deepEqual(indexes, [0, 1, 2]);
      indexes.length = 0;
      proxy.content.replace(2, 0, [4, 5]);
      assert.deepEqual(proxy.objectAt(0), 1);
      assert.deepEqual(proxy.objectAt(1), 2);
      assert.deepEqual(indexes, []);
      assert.deepEqual(proxy.objectAt(2), 4);
      assert.deepEqual(indexes, [2, 3, 4]);
    };

    _proto['@test negative indexes are handled correctly'] = function testNegativeIndexesAreHandledCorrectly(assert) {
      var indexes = [];

      var proxy = _array_proxy.default.extend({
        objectAtContent: function (index) {
          indexes.push(index);
          return this.content[index];
        }
      }).create({
        content: (0, _array.A)([1, 2, 3, 4, 5])
      });

      assert.deepEqual(proxy.toArray(), [1, 2, 3, 4, 5]);
      indexes.length = 0;
      proxy.content.replace(-1, 0, [7]);
      proxy.content.replace(-2, 0, [6]);
      assert.deepEqual(proxy.toArray(), [1, 2, 3, 4, 6, 7, 5]);
      assert.deepEqual(indexes, [4, 5, 6]);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/array_proxy/length_test", ["ember-babel", "@ember/-internals/runtime/lib/system/array_proxy", "@ember/-internals/runtime/lib/system/object", "@ember/-internals/metal", "@ember/object/computed", "@ember/-internals/runtime/lib/mixins/array", "internal-test-helpers"], function (_emberBabel, _array_proxy, _object, _metal, _computed, _array, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('Ember.ArrayProxy - content change (length)',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test should update length for null content'] = function testShouldUpdateLengthForNullContent(assert) {
      var proxy = _array_proxy.default.create({
        content: (0, _array.A)([1, 2, 3])
      });

      assert.equal(proxy.get('length'), 3, 'precond - length is 3');
      proxy.set('content', null);
      assert.equal(proxy.get('length'), 0, 'length updates');
    };

    _proto['@test should update length for null content when there is a computed property watching length'] = function testShouldUpdateLengthForNullContentWhenThereIsAComputedPropertyWatchingLength(assert) {
      var proxy = _array_proxy.default.extend({
        isEmpty: (0, _computed.not)('length')
      }).create({
        content: (0, _array.A)([1, 2, 3])
      });

      assert.equal(proxy.get('length'), 3, 'precond - length is 3'); // Consume computed property that depends on length

      proxy.get('isEmpty'); // update content

      proxy.set('content', null);
      assert.equal(proxy.get('length'), 0, 'length updates');
    };

    _proto['@test getting length does not recompute the object cache'] = function testGettingLengthDoesNotRecomputeTheObjectCache(assert) {
      var indexes = [];

      var proxy = _array_proxy.default.extend({
        objectAtContent: function (index) {
          indexes.push(index);
          return this.content[index];
        }
      }).create({
        content: (0, _array.A)([1, 2, 3, 4, 5])
      });

      assert.equal((0, _metal.get)(proxy, 'length'), 5);
      assert.deepEqual(indexes, []);
      indexes.length = 0;
      proxy.set('content', (0, _array.A)([6, 7, 8]));
      assert.equal((0, _metal.get)(proxy, 'length'), 3);
      assert.deepEqual(indexes, []);
      indexes.length = 0;
      proxy.content.replace(1, 0, [1, 2, 3]);
      assert.equal((0, _metal.get)(proxy, 'length'), 6);
      assert.deepEqual(indexes, []);
    };

    _proto['@test accessing length after content set to null'] = function testAccessingLengthAfterContentSetToNull(assert) {
      var obj = _array_proxy.default.create({
        content: ['foo', 'bar']
      });

      assert.equal(obj.length, 2, 'precond');
      (0, _metal.set)(obj, 'content', null);
      assert.equal(obj.length, 0, 'length is 0 without content');
      assert.deepEqual(obj.content, null, 'content was updated');
    };

    _proto['@test accessing length after content set to null in willDestroy'] = function testAccessingLengthAfterContentSetToNullInWillDestroy(assert) {
      var obj = _array_proxy.default.extend({
        willDestroy: function () {
          this.set('content', null);

          this._super.apply(this, arguments);
        }
      }).create({
        content: ['foo', 'bar']
      });

      assert.equal(obj.length, 2, 'precond');
      (0, _internalTestHelpers.runTask)(function () {
        return obj.destroy();
      });
      assert.equal(obj.length, 0, 'length is 0 without content');
      assert.deepEqual(obj.content, null, 'content was updated');
    };

    _proto['@test setting length to 0'] = function testSettingLengthTo0(assert) {
      var obj = _array_proxy.default.create({
        content: ['foo', 'bar']
      });

      assert.equal(obj.length, 2, 'precond');
      (0, _metal.set)(obj, 'length', 0);
      assert.equal(obj.length, 0, 'length was updated');
      assert.deepEqual(obj.content, [], 'content length was truncated');
    };

    _proto['@test setting length to smaller value'] = function testSettingLengthToSmallerValue(assert) {
      var obj = _array_proxy.default.create({
        content: ['foo', 'bar']
      });

      assert.equal(obj.length, 2, 'precond');
      (0, _metal.set)(obj, 'length', 1);
      assert.equal(obj.length, 1, 'length was updated');
      assert.deepEqual(obj.content, ['foo'], 'content length was truncated');
    };

    _proto['@test setting length to larger value'] = function testSettingLengthToLargerValue(assert) {
      var obj = _array_proxy.default.create({
        content: ['foo', 'bar']
      });

      assert.equal(obj.length, 2, 'precond');
      (0, _metal.set)(obj, 'length', 3);
      assert.equal(obj.length, 3, 'length was updated');
      assert.deepEqual(obj.content, ['foo', 'bar', undefined], 'content length was updated');
    };

    _proto['@test setting length after content set to null'] = function testSettingLengthAfterContentSetToNull(assert) {
      var obj = _array_proxy.default.create({
        content: ['foo', 'bar']
      });

      assert.equal(obj.length, 2, 'precond');
      (0, _metal.set)(obj, 'content', null);
      assert.equal(obj.length, 0, 'length was updated');
      (0, _metal.set)(obj, 'length', 0);
      assert.equal(obj.length, 0, 'length is still updated');
    };

    _proto['@test setting length to greater than zero'] = function testSettingLengthToGreaterThanZero(assert) {
      var obj = _array_proxy.default.create({
        content: ['foo', 'bar']
      });

      assert.equal(obj.length, 2, 'precond');
      (0, _metal.set)(obj, 'length', 1);
      assert.equal(obj.length, 1, 'length was updated');
      assert.deepEqual(obj.content, ['foo'], 'content length was truncated');
    };

    _proto['@test array proxy + aliasedProperty complex test'] =
    /*#__PURE__*/
    function () {
      var _testArrayProxyAliasedPropertyComplexTest = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var aCalled, bCalled, cCalled, dCalled, eCalled, obj;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              aCalled = bCalled = cCalled = dCalled = eCalled = 0;
              obj = _object.default.extend({
                colors: (0, _computed.oneWay)('model'),
                length: (0, _computed.oneWay)('colors.length'),
                a: (0, _metal.observer)('length', function () {
                  return aCalled++;
                }),
                b: (0, _metal.observer)('colors.length', function () {
                  return bCalled++;
                }),
                c: (0, _metal.observer)('colors.content.length', function () {
                  return cCalled++;
                }),
                d: (0, _metal.observer)('colors.[]', function () {
                  return dCalled++;
                }),
                e: (0, _metal.observer)('colors.content.[]', function () {
                  return eCalled++;
                })
              }).create();
              obj.set('model', _array_proxy.default.create({
                content: (0, _array.A)(['red', 'yellow', 'blue'])
              })); // bootstrap aliases

              obj.length;
              _context.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              assert.equal(obj.get('colors.content.length'), 3);
              assert.equal(obj.get('colors.length'), 3);
              assert.equal(obj.get('length'), 3);
              assert.equal(aCalled, 1, 'expected observer `length` to be called ONCE');
              assert.equal(bCalled, 1, 'expected observer `colors.length` to be called ONCE');
              assert.equal(cCalled, 1, 'expected observer `colors.content.length` to be called ONCE');
              assert.equal(dCalled, 1, 'expected observer `colors.[]` to be called ONCE');
              assert.equal(eCalled, 1, 'expected observer `colors.content.[]` to be called ONCE');
              obj.get('colors').pushObjects(['green', 'red']);
              _context.next = 17;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 17:
              assert.equal(obj.get('colors.content.length'), 5);
              assert.equal(obj.get('colors.length'), 5);
              assert.equal(obj.get('length'), 5);
              assert.equal(aCalled, 2, 'expected observer `length` to be called TWICE');
              assert.equal(bCalled, 2, 'expected observer `colors.length` to be called TWICE');
              assert.equal(cCalled, 2, 'expected observer `colors.content.length` to be called TWICE');
              assert.equal(dCalled, 2, 'expected observer `colors.[]` to be called TWICE');
              assert.equal(eCalled, 2, 'expected observer `colors.content.[]` to be called TWICE');

            case 25:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function testArrayProxyAliasedPropertyComplexTest(_x) {
        return _testArrayProxyAliasedPropertyComplexTest.apply(this, arguments);
      }

      return testArrayProxyAliasedPropertyComplexTest;
    }();

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/array_proxy/watching_and_listening_test", ["ember-babel", "@ember/-internals/meta", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/array_proxy", "@ember/-internals/runtime/lib/mixins/array", "internal-test-helpers"], function (_emberBabel, _meta, _metal, _array_proxy, _array, _internalTestHelpers) {
  "use strict";

  function sortedListenersFor(obj, eventName) {
    var listeners = (0, _meta.peekMeta)(obj).matchingListeners(eventName) || [];
    var keys = [];

    for (var i = 0; i < listeners.length; i += 3) {
      keys.push(listeners[i + 1]);
    }

    return keys.sort();
  }

  (0, _internalTestHelpers.moduleFor)('ArrayProxy - watching and listening',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto["@test setting 'content' adds listeners correctly"] = function (assert) {
      var content = (0, _array.A)();

      var proxy = _array_proxy.default.create();

      assert.deepEqual(sortedListenersFor(content, '@array:before'), []);
      assert.deepEqual(sortedListenersFor(content, '@array:change'), []);
      proxy.set('content', content);
      assert.deepEqual(sortedListenersFor(content, '@array:before'), ['_arrangedContentArrayWillChange']);
      assert.deepEqual(sortedListenersFor(content, '@array:change'), ['_arrangedContentArrayDidChange']);
    };

    _proto["@test changing 'content' adds and removes listeners correctly"] = function (assert) {
      var content1 = (0, _array.A)();
      var content2 = (0, _array.A)();

      var proxy = _array_proxy.default.create({
        content: content1
      });

      assert.deepEqual(sortedListenersFor(content1, '@array:before'), ['_arrangedContentArrayWillChange']);
      assert.deepEqual(sortedListenersFor(content1, '@array:change'), ['_arrangedContentArrayDidChange']);
      proxy.set('content', content2);
      assert.deepEqual(sortedListenersFor(content1, '@array:before'), []);
      assert.deepEqual(sortedListenersFor(content1, '@array:change'), []);
      assert.deepEqual(sortedListenersFor(content2, '@array:before'), ['_arrangedContentArrayWillChange']);
      assert.deepEqual(sortedListenersFor(content2, '@array:change'), ['_arrangedContentArrayDidChange']);
    };

    _proto["@test regression test for https://github.com/emberjs/ember.js/issues/12475"] = function (assert) {
      if (false
      /* EMBER_METAL_TRACKED_PROPERTIES */
      ) {
          // Test is primarily about watching values, which is not necessary anymore
          return assert.expect(0);
        }

      var item1a = {
        id: 1
      };
      var item1b = {
        id: 2
      };
      var item1c = {
        id: 3
      };
      var content1 = (0, _array.A)([item1a, item1b, item1c]);

      var proxy = _array_proxy.default.create({
        content: content1
      });

      var obj = {
        proxy: proxy
      };
      (0, _metal.defineProperty)(obj, 'ids', (0, _metal.computed)('proxy.@each.id', function () {
        return (0, _metal.get)(this, 'proxy').mapBy('id');
      })); // These manually added observers are to simulate the observers added by the
      // rendering process in a template like:
      //
      // {{#each items as |item|}}
      //   {{item.id}}
      // {{/each}}

      (0, _metal.addObserver)(item1a, 'id', function () {});
      (0, _metal.addObserver)(item1b, 'id', function () {});
      (0, _metal.addObserver)(item1c, 'id', function () {}); // The EachProxy has not yet been consumed. Only the manually added
      // observers are watching.

      assert.equal((0, _metal.watcherCount)(item1a, 'id'), 1);
      assert.equal((0, _metal.watcherCount)(item1b, 'id'), 1);
      assert.equal((0, _metal.watcherCount)(item1c, 'id'), 1); // Consume the each proxy. This causes the EachProxy to add two observers
      // per item: one for "before" events and one for "after" events.

      assert.deepEqual((0, _metal.get)(obj, 'ids'), [1, 2, 3]); // For each item, the two each proxy observers and one manual added observer
      // are watching.

      assert.equal((0, _metal.watcherCount)(item1a, 'id'), 2);
      assert.equal((0, _metal.watcherCount)(item1b, 'id'), 2);
      assert.equal((0, _metal.watcherCount)(item1c, 'id'), 2); // This should be a no-op because observers do not fire if the value
      // 1. is an object and 2. is the same as the old value.

      proxy.set('content', content1);
      assert.equal((0, _metal.watcherCount)(item1a, 'id'), 2);
      assert.equal((0, _metal.watcherCount)(item1b, 'id'), 2);
      assert.equal((0, _metal.watcherCount)(item1c, 'id'), 2); // This is repeated to catch the regression. It should still be a no-op.

      proxy.set('content', content1);
      assert.equal((0, _metal.watcherCount)(item1a, 'id'), 2);
      assert.equal((0, _metal.watcherCount)(item1b, 'id'), 2);
      assert.equal((0, _metal.watcherCount)(item1c, 'id'), 2); // Set the content to a new array with completely different items and
      // repeat the process.

      var item2a = {
        id: 4
      };
      var item2b = {
        id: 5
      };
      var item2c = {
        id: 6
      };
      var content2 = (0, _array.A)([item2a, item2b, item2c]);
      (0, _metal.addObserver)(item2a, 'id', function () {});
      (0, _metal.addObserver)(item2b, 'id', function () {});
      (0, _metal.addObserver)(item2c, 'id', function () {});
      proxy.set('content', content2);
      assert.deepEqual((0, _metal.get)(obj, 'ids'), [4, 5, 6]);
      assert.equal((0, _metal.watcherCount)(item2a, 'id'), 2);
      assert.equal((0, _metal.watcherCount)(item2b, 'id'), 2);
      assert.equal((0, _metal.watcherCount)(item2c, 'id'), 2); // Ensure that the observers added by the EachProxy on all items in the
      // first content array have been torn down.

      assert.equal((0, _metal.watcherCount)(item1a, 'id'), 1);
      assert.equal((0, _metal.watcherCount)(item1b, 'id'), 1);
      assert.equal((0, _metal.watcherCount)(item1c, 'id'), 1);
      proxy.set('content', content2);
      assert.equal((0, _metal.watcherCount)(item2a, 'id'), 2);
      assert.equal((0, _metal.watcherCount)(item2b, 'id'), 2);
      assert.equal((0, _metal.watcherCount)(item2c, 'id'), 2);
      proxy.set('content', content2);
      assert.equal((0, _metal.watcherCount)(item2a, 'id'), 2);
      assert.equal((0, _metal.watcherCount)(item2b, 'id'), 2);
      assert.equal((0, _metal.watcherCount)(item2c, 'id'), 2);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/core_object_test", ["ember-babel", "@ember/-internals/owner", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/core_object", "internal-test-helpers"], function (_emberBabel, _owner, _metal, _core_object, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('Ember.CoreObject',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test throws an error with new (one arg)'] = function testThrowsAnErrorWithNewOneArg() {
      expectAssertion(function () {
        new _core_object.default({
          firstName: 'Stef',
          lastName: 'Penner'
        });
      }, /You may have either used `new` instead of `.create\(\)`/);
    };

    _proto['@test throws an error with new (> 1 arg)'] = function testThrowsAnErrorWithNew1Arg() {
      expectAssertion(function () {
        new _core_object.default({
          firstName: 'Stef',
          lastName: 'Penner'
        }, {
          other: 'name'
        });
      }, /You may have either used `new` instead of `.create\(\)`/);
    };

    _proto['@test toString should be not be added as a property when calling toString()'] = function testToStringShouldBeNotBeAddedAsAPropertyWhenCallingToString(assert) {
      var obj = _core_object.default.create({
        firstName: 'Foo',
        lastName: 'Bar'
      });

      obj.toString();
      assert.notOk(obj.hasOwnProperty('toString'), 'Calling toString() should not create a toString class property');
    };

    _proto['@test should not trigger proxy assertion when retrieving a proxy with (GH#16263)'] = function testShouldNotTriggerProxyAssertionWhenRetrievingAProxyWithGH16263(assert) {
      var someProxyishThing = _core_object.default.extend({
        unknownProperty: function () {
          return true;
        }
      }).create();

      var obj = _core_object.default.create({
        someProxyishThing: someProxyishThing
      });

      var proxy = (0, _metal.get)(obj, 'someProxyishThing');
      assert.equal((0, _metal.get)(proxy, 'lolol'), true, 'should be able to get data from a proxy');
    };

    _proto['@test should not trigger proxy assertion when retrieving a re-registered proxy (GH#16610)'] = function testShouldNotTriggerProxyAssertionWhenRetrievingAReRegisteredProxyGH16610(assert) {
      var owner = (0, _internalTestHelpers.buildOwner)();

      var someProxyishThing = _core_object.default.extend({
        unknownProperty: function () {
          return true;
        }
      }).create(); // emulates ember-engines's process of registering services provided
      // by the host app down to the engine


      owner.register('thing:one', someProxyishThing, {
        instantiate: false
      });
      assert.equal(owner.lookup('thing:one'), someProxyishThing);
    };

    _proto['@test should not trigger proxy assertion when probing for a "symbol"'] = function testShouldNotTriggerProxyAssertionWhenProbingForASymbol(assert) {
      var proxy = _core_object.default.extend({
        unknownProperty: function () {
          return true;
        }
      }).create();

      assert.equal((0, _metal.get)(proxy, 'lolol'), true, 'should be able to get data from a proxy'); // should not trigger an assertion

      (0, _owner.getOwner)(proxy);
    };

    _proto['@test can use getOwner in a proxy init GH#16484'] = function testCanUseGetOwnerInAProxyInitGH16484(assert) {
      var owner = {};
      var options = {};
      (0, _owner.setOwner)(options, owner);

      _core_object.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          var localOwner = (0, _owner.getOwner)(this);
          assert.equal(localOwner, owner, 'should be able to `getOwner` in init');
        },
        unknownProperty: function () {
          return undefined;
        }
      }).create(options);
    };

    _proto['@test observed properties are enumerable when set GH#14594'] =
    /*#__PURE__*/
    function () {
      var _testObservedPropertiesAreEnumerableWhenSetGH = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var callCount, Test, test;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              callCount = 0;
              Test = _core_object.default.extend({
                myProp: null,
                anotherProp: undefined,
                didChangeMyProp: (0, _metal.observer)('myProp', function () {
                  callCount++;
                })
              });
              test = Test.create();
              (0, _metal.set)(test, 'id', '3');
              (0, _metal.set)(test, 'myProp', {
                id: 1
              });
              assert.deepEqual(Object.keys(test).sort(), ['id', 'myProp']);
              (0, _metal.set)(test, 'anotherProp', 'nice');
              assert.deepEqual(Object.keys(test).sort(), ['anotherProp', 'id', 'myProp']);
              _context.next = 10;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 10:
              assert.equal(callCount, 1);

            case 11:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function testObservedPropertiesAreEnumerableWhenSetGH14594(_x) {
        return _testObservedPropertiesAreEnumerableWhenSetGH.apply(this, arguments);
      }

      return testObservedPropertiesAreEnumerableWhenSetGH14594;
    }();

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/namespace/base_test", ["ember-babel", "@ember/-internals/environment", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/utils", "@ember/-internals/runtime/lib/system/object", "@ember/-internals/runtime/lib/system/namespace", "internal-test-helpers"], function (_emberBabel, _environment, _runloop, _metal, _utils, _object, _namespace, _internalTestHelpers) {
  "use strict";

  var originalLookup = _environment.context.lookup;
  var lookup;
  (0, _internalTestHelpers.moduleFor)('Namespace',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      (0, _metal.setNamespaceSearchDisabled)(false);
      lookup = _environment.context.lookup = {};
    };

    _proto.afterEach = function afterEach() {
      (0, _metal.setNamespaceSearchDisabled)(false);

      for (var prop in lookup) {
        if (lookup[prop]) {
          (0, _runloop.run)(lookup[prop], 'destroy');
        }
      }

      _environment.context.lookup = originalLookup;
    };

    _proto['@test Namespace should be a subclass of EmberObject'] = function testNamespaceShouldBeASubclassOfEmberObject(assert) {
      assert.ok(_object.default.detect(_namespace.default));
    };

    _proto['@test Namespace should be duck typed'] = function testNamespaceShouldBeDuckTyped(assert) {
      var namespace = _namespace.default.create();

      try {
        assert.ok((0, _metal.get)(namespace, 'isNamespace'), 'isNamespace property is true');
      } finally {
        (0, _runloop.run)(namespace, 'destroy');
      }
    };

    _proto['@test Namespace is found and named'] = function testNamespaceIsFoundAndNamed(assert) {
      var nsA = lookup.NamespaceA = _namespace.default.create();

      assert.equal(nsA.toString(), 'NamespaceA', 'namespaces should have a name if they are on lookup');

      var nsB = lookup.NamespaceB = _namespace.default.create();

      assert.equal(nsB.toString(), 'NamespaceB', 'namespaces work if created after the first namespace processing pass');
    };

    _proto['@test Classes under an Namespace are properly named'] = function testClassesUnderAnNamespaceAreProperlyNamed(assert) {
      var nsA = lookup.NamespaceA = _namespace.default.create();

      nsA.Foo = _object.default.extend();
      assert.equal(nsA.Foo.toString(), 'NamespaceA.Foo', 'Classes pick up their parent namespace');
      nsA.Bar = _object.default.extend();
      assert.equal(nsA.Bar.toString(), 'NamespaceA.Bar', 'New Classes get the naming treatment too');

      var nsB = lookup.NamespaceB = _namespace.default.create();

      nsB.Foo = _object.default.extend();
      assert.equal(nsB.Foo.toString(), 'NamespaceB.Foo', 'Classes in new namespaces get the naming treatment');
    } //test("Classes under Ember are properly named", function() {
    //  // ES6TODO: This test does not work reliably when running independent package build with Broccoli config.
    //  Ember.TestObject = EmberObject.extend({});
    //  equal(Ember.TestObject.toString(), "Ember.TestObject", "class under Ember is given a string representation");
    //});
    ;

    _proto['@test Lowercase namespaces are no longer supported'] = function testLowercaseNamespacesAreNoLongerSupported(assert) {
      var nsC = lookup.namespaceC = _namespace.default.create();

      assert.equal(nsC.toString(), (0, _utils.guidFor)(nsC));
    };

    _proto['@test A namespace can be assigned a custom name'] = function testANamespaceCanBeAssignedACustomName(assert) {
      var nsA = _namespace.default.create({
        name: 'NamespaceA'
      });

      try {
        var nsB = lookup.NamespaceB = _namespace.default.create({
          name: 'CustomNamespaceB'
        });

        nsA.Foo = _object.default.extend();
        nsB.Foo = _object.default.extend();
        assert.equal(nsA.Foo.toString(), 'NamespaceA.Foo', "The namespace's name is used when the namespace is not in the lookup object");
        assert.equal(nsB.Foo.toString(), 'CustomNamespaceB.Foo', "The namespace's name is used when the namespace is in the lookup object");
      } finally {
        (0, _runloop.run)(nsA, 'destroy');
      }
    };

    _proto['@test Calling namespace.nameClasses() eagerly names all classes'] = function testCallingNamespaceNameClassesEagerlyNamesAllClasses(assert) {
      (0, _metal.setNamespaceSearchDisabled)(true);

      var namespace = lookup.NS = _namespace.default.create();

      namespace.ClassA = _object.default.extend();
      namespace.ClassB = _object.default.extend();

      _namespace.default.processAll();

      assert.equal(namespace.ClassA.toString(), 'NS.ClassA');
      assert.equal(namespace.ClassB.toString(), 'NS.ClassB');
    };

    _proto['@test A namespace can be looked up by its name'] = function testANamespaceCanBeLookedUpByItsName(assert) {
      var NS = lookup.NS = _namespace.default.create();

      var UI = lookup.UI = _namespace.default.create();

      var CF = lookup.CF = _namespace.default.create();

      assert.equal(_namespace.default.byName('NS'), NS);
      assert.equal(_namespace.default.byName('UI'), UI);
      assert.equal(_namespace.default.byName('CF'), CF);
    };

    _proto['@test A nested namespace can be looked up by its name'] = function testANestedNamespaceCanBeLookedUpByItsName(assert) {
      var UI = lookup.UI = _namespace.default.create();

      UI.Nav = _namespace.default.create();
      assert.equal(_namespace.default.byName('UI.Nav'), UI.Nav);
      (0, _runloop.run)(UI.Nav, 'destroy');
    };

    _proto['@test Destroying a namespace before caching lookup removes it from the list of namespaces'] = function testDestroyingANamespaceBeforeCachingLookupRemovesItFromTheListOfNamespaces(assert) {
      var CF = lookup.CF = _namespace.default.create();

      (0, _runloop.run)(CF, 'destroy');
      assert.equal(_namespace.default.byName('CF'), undefined, 'namespace can not be found after destroyed');
    };

    _proto['@test Destroying a namespace after looking up removes it from the list of namespaces'] = function testDestroyingANamespaceAfterLookingUpRemovesItFromTheListOfNamespaces(assert) {
      var CF = lookup.CF = _namespace.default.create();

      assert.equal(_namespace.default.byName('CF'), CF, 'precondition - namespace can be looked up by name');
      (0, _runloop.run)(CF, 'destroy');
      assert.equal(_namespace.default.byName('CF'), undefined, 'namespace can not be found after destroyed');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/native_array/a_test", ["ember-babel", "@ember/-internals/runtime/lib/mixins/array", "internal-test-helpers"], function (_emberBabel, _array, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.A',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Ember.A'] = function testEmberA(assert) {
      assert.deepEqual((0, _array.A)([1, 2]), [1, 2], 'array values were not be modified');
      assert.deepEqual((0, _array.A)(), [], 'returned an array with no arguments');
      assert.deepEqual((0, _array.A)(null), [], 'returned an array with a null argument');
      assert.ok(_array.default.detect((0, _array.A)()), 'returned an ember array');
      assert.ok(_array.default.detect((0, _array.A)([1, 2])), 'returned an ember array');
    };

    _proto['@test new Ember.A'] = function testNewEmberA(assert) {
      expectAssertion(function () {
        assert.deepEqual(new _array.A([1, 2]), [1, 2], 'array values were not be modified');
        assert.deepEqual(new _array.A(), [], 'returned an array with no arguments');
        assert.deepEqual(new _array.A(null), [], 'returned an array with a null argument');
        assert.ok(_array.default.detect(new _array.A()), 'returned an ember array');
        assert.ok(_array.default.detect(new _array.A([1, 2])), 'returned an ember array');
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/native_array/replace_test", ["ember-babel", "@ember/-internals/runtime/lib/mixins/array", "internal-test-helpers"], function (_emberBabel, _array, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('NativeArray.replace',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test raises assertion if third argument is not an array'] = function testRaisesAssertionIfThirdArgumentIsNotAnArray() {
      expectAssertion(function () {
        (0, _array.A)([1, 2, 3]).replace(1, 1, '');
      }, 'The third argument to replace needs to be an array.');
    };

    _proto['@test it does not raise an assertion if third parameter is not passed'] = function testItDoesNotRaiseAnAssertionIfThirdParameterIsNotPassed(assert) {
      assert.deepEqual((0, _array.A)([1, 2, 3]).replace(1, 2), (0, _array.A)([1]), 'no assertion raised');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/object/computed_test", ["ember-babel", "@ember/-internals/metal", "@ember/object/computed", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers"], function (_emberBabel, _metal, _computed, _object, _internalTestHelpers) {
  "use strict";

  function K() {
    return this;
  }

  function testWithDefault(assert, expect, x, y, z) {
    assert.equal((0, _metal.get)(x, y), expect);
    assert.equal((0, _metal.getWithDefault)(x, y, z), expect);
    assert.equal(x.getWithDefault(y, z), expect);
  }

  (0, _internalTestHelpers.moduleFor)('EmberObject computed property',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test computed property on instance'] = function testComputedPropertyOnInstance(assert) {
      var MyClass = _object.default.extend({
        foo: (0, _metal.computed)(function () {
          return 'FOO';
        })
      });

      testWithDefault(assert, 'FOO', MyClass.create(), 'foo');
    };

    _proto['@test computed property on subclass'] = function testComputedPropertyOnSubclass(assert) {
      var MyClass = _object.default.extend({
        foo: (0, _metal.computed)(function () {
          return 'FOO';
        })
      });

      var Subclass = MyClass.extend({
        foo: (0, _metal.computed)(function () {
          return 'BAR';
        })
      });
      testWithDefault(assert, 'BAR', Subclass.create(), 'foo');
    };

    _proto['@test replacing computed property with regular val'] = function testReplacingComputedPropertyWithRegularVal(assert) {
      var MyClass = _object.default.extend({
        foo: (0, _metal.computed)(function () {
          return 'FOO';
        })
      });

      var Subclass = MyClass.extend({
        foo: 'BAR'
      });
      testWithDefault(assert, 'BAR', Subclass.create(), 'foo');
    };

    _proto['@test complex depndent keys'] = function testComplexDepndentKeys(assert) {
      var MyClass = _object.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'bar', {
            baz: 'BIFF'
          });
        },
        count: 0,
        foo: (0, _metal.computed)('bar.baz', function () {
          (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
          return (0, _metal.get)((0, _metal.get)(this, 'bar'), 'baz') + ' ' + (0, _metal.get)(this, 'count');
        })
      });

      var Subclass = MyClass.extend({
        count: 20
      });
      var obj1 = MyClass.create();
      var obj2 = Subclass.create();
      testWithDefault(assert, 'BIFF 1', obj1, 'foo');
      testWithDefault(assert, 'BIFF 21', obj2, 'foo');
      (0, _metal.set)((0, _metal.get)(obj1, 'bar'), 'baz', 'BLARG');
      testWithDefault(assert, 'BLARG 2', obj1, 'foo');
      testWithDefault(assert, 'BIFF 21', obj2, 'foo');
      (0, _metal.set)((0, _metal.get)(obj2, 'bar'), 'baz', 'BOOM');
      testWithDefault(assert, 'BLARG 2', obj1, 'foo');
      testWithDefault(assert, 'BOOM 22', obj2, 'foo');
    };

    _proto['@test complex dependent keys changing complex dependent keys'] = function testComplexDependentKeysChangingComplexDependentKeys(assert) {
      var MyClass = _object.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'bar', {
            baz: 'BIFF'
          });
        },
        count: 0,
        foo: (0, _metal.computed)('bar.baz', function () {
          (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
          return (0, _metal.get)((0, _metal.get)(this, 'bar'), 'baz') + ' ' + (0, _metal.get)(this, 'count');
        })
      });

      var Subclass = MyClass.extend({
        init: function () {
          this._super.apply(this, arguments);

          (0, _metal.set)(this, 'bar2', {
            baz: 'BIFF2'
          });
        },
        count: 0,
        foo: (0, _metal.computed)('bar2.baz', function () {
          (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
          return (0, _metal.get)((0, _metal.get)(this, 'bar2'), 'baz') + ' ' + (0, _metal.get)(this, 'count');
        })
      });
      var obj2 = Subclass.create();
      testWithDefault(assert, 'BIFF2 1', obj2, 'foo');
      (0, _metal.set)((0, _metal.get)(obj2, 'bar'), 'baz', 'BLARG');
      testWithDefault(assert, 'BIFF2 1', obj2, 'foo'); // should not invalidate property

      (0, _metal.set)((0, _metal.get)(obj2, 'bar2'), 'baz', 'BLARG');
      testWithDefault(assert, 'BLARG 2', obj2, 'foo'); // should not invalidate property
    };

    _proto['@test can retrieve metadata for a computed property'] = function testCanRetrieveMetadataForAComputedProperty(assert) {
      var MyClass = _object.default.extend({
        computedProperty: (0, _metal.computed)(function () {}).meta({
          key: 'keyValue'
        })
      });

      assert.equal((0, _metal.get)(MyClass.metaForProperty('computedProperty'), 'key'), 'keyValue', 'metadata saved on the computed property can be retrieved');

      var ClassWithNoMetadata = _object.default.extend({
        computedProperty: (0, _metal.computed)(function () {}),
        staticProperty: 12
      });

      assert.equal(typeof ClassWithNoMetadata.metaForProperty('computedProperty'), 'object', 'returns empty hash if no metadata has been saved');
      expectAssertion(function () {
        ClassWithNoMetadata.metaForProperty('nonexistentProperty');
      }, "metaForProperty() could not find a computed property with key 'nonexistentProperty'.");
      expectAssertion(function () {
        ClassWithNoMetadata.metaForProperty('staticProperty');
      }, "metaForProperty() could not find a computed property with key 'staticProperty'.");
    };

    _proto['@test overriding a computed property with null removes it from eachComputedProperty iteration'] = function testOverridingAComputedPropertyWithNullRemovesItFromEachComputedPropertyIteration(assert) {
      var MyClass = _object.default.extend({
        foo: (0, _metal.computed)(function () {}),
        fooDidChange: (0, _metal.observer)('foo', function () {}),
        bar: (0, _metal.computed)(function () {})
      });

      var SubClass = MyClass.extend({
        foo: null
      });
      var list = [];
      SubClass.eachComputedProperty(function (name) {
        return list.push(name);
      });
      assert.deepEqual(list.sort(), ['bar'], 'overridding with null removes from eachComputedProperty listing');
    };

    _proto['@test can iterate over a list of computed properties for a class'] = function testCanIterateOverAListOfComputedPropertiesForAClass(assert) {
      var MyClass = _object.default.extend({
        foo: (0, _metal.computed)(function () {}),
        fooDidChange: (0, _metal.observer)('foo', function () {}),
        bar: (0, _metal.computed)(function () {}),
        qux: (0, _metal.alias)('foo')
      });

      var SubClass = MyClass.extend({
        baz: (0, _metal.computed)(function () {})
      });
      SubClass.reopen({
        bat: (0, _metal.computed)(function () {}).meta({
          iAmBat: true
        })
      });
      var list = [];
      MyClass.eachComputedProperty(function (name) {
        list.push(name);
      });
      assert.deepEqual(list.sort(), ['bar', 'foo', 'qux'], 'watched and unwatched computed properties are iterated');
      list = [];
      SubClass.eachComputedProperty(function (name, meta) {
        list.push(name);

        if (name === 'bat') {
          assert.deepEqual(meta, {
            iAmBat: true
          });
        } else {
          assert.deepEqual(meta, {});
        }
      });
      assert.deepEqual(list.sort(), ['bar', 'bat', 'baz', 'foo', 'qux'], 'all inherited properties are included');
    };

    _proto['@test list of properties updates when an additional property is added (such cache busting)'] = function testListOfPropertiesUpdatesWhenAnAdditionalPropertyIsAddedSuchCacheBusting(assert) {
      var MyClass = _object.default.extend({
        foo: (0, _metal.computed)(K),
        fooDidChange: (0, _metal.observer)('foo', function () {}),
        bar: (0, _metal.computed)(K)
      });

      var list = [];
      MyClass.eachComputedProperty(function (name) {
        list.push(name);
      });
      assert.deepEqual(list.sort(), ['bar', 'foo'].sort(), 'expected two computed properties');
      MyClass.reopen({
        baz: (0, _metal.computed)(K)
      });
      MyClass.create(); // force apply mixins

      list = [];
      MyClass.eachComputedProperty(function (name) {
        list.push(name);
      });
      assert.deepEqual(list.sort(), ['bar', 'foo', 'baz'].sort(), 'expected three computed properties');
      (0, _metal.defineProperty)(MyClass.prototype, 'qux', (0, _metal.computed)(K));
      list = [];
      MyClass.eachComputedProperty(function (name) {
        list.push(name);
      });
      assert.deepEqual(list.sort(), ['bar', 'foo', 'baz', 'qux'].sort(), 'expected four computed properties');
    };

    _proto['@test Calling _super in call outside the immediate function of a CP getter works'] = function testCalling_superInCallOutsideTheImmediateFunctionOfACPGetterWorks(assert) {
      function macro(callback) {
        return (0, _metal.computed)(function () {
          return callback.call(this);
        });
      }

      var MyClass = _object.default.extend({
        foo: (0, _metal.computed)(function () {
          return 'FOO';
        })
      });

      var SubClass = MyClass.extend({
        foo: macro(function () {
          return this._super();
        })
      });
      assert.ok((0, _metal.get)(SubClass.create(), 'foo'), 'FOO', 'super value is fetched');
    };

    _proto['@test Calling _super in apply outside the immediate function of a CP getter works'] = function testCalling_superInApplyOutsideTheImmediateFunctionOfACPGetterWorks(assert) {
      function macro(callback) {
        return (0, _metal.computed)(function () {
          return callback.apply(this);
        });
      }

      var MyClass = _object.default.extend({
        foo: (0, _metal.computed)(function () {
          return 'FOO';
        })
      });

      var SubClass = MyClass.extend({
        foo: macro(function () {
          return this._super();
        })
      });
      assert.ok((0, _metal.get)(SubClass.create(), 'foo'), 'FOO', 'super value is fetched');
    };

    _proto['@test observing computed.reads prop and overriding it in create() works'] = function testObservingComputedReadsPropAndOverridingItInCreateWorks(assert) {
      var Obj = _object.default.extend({
        name: (0, _computed.oneWay)('model.name'),
        nameDidChange: (0, _metal.observer)('name', function () {})
      });

      var obj1 = Obj.create({
        name: '1'
      });
      var obj2 = Obj.create({
        name: '2'
      });
      assert.equal(obj1.get('name'), '1');
      assert.equal(obj2.get('name'), '2');
    };

    _proto['@test can declare dependent keys with .property()'] = function testCanDeclareDependentKeysWithProperty(assert) {
      var Obj;
      expectDeprecation(function () {
        Obj = _object.default.extend({
          foo: (0, _metal.computed)(function () {
            return this.bar;
          }).property('bar')
        });
      }, /Setting dependency keys using the `.property\(\)` modifier has been deprecated/);
      var obj = Obj.create({
        bar: 1
      });
      assert.equal(obj.get('foo'), 1);
      obj.set('bar', 2);
      assert.equal(obj.get('foo'), 2);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/object/create_test", ["ember-babel", "@ember/-internals/owner", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers"], function (_emberBabel, _owner, _metal, _object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('EmberObject.create',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test simple properties are set'] = function testSimplePropertiesAreSet(assert) {
      var o = _object.default.create({
        ohai: 'there'
      });

      assert.equal(o.get('ohai'), 'there');
    };

    _proto['@test calls computed property setters'] = function testCallsComputedPropertySetters(assert) {
      var MyClass = _object.default.extend({
        foo: (0, _metal.computed)({
          get: function () {
            return "this is not the value you're looking for";
          },
          set: function (key, value) {
            return value;
          }
        })
      });

      var o = MyClass.create({
        foo: 'bar'
      });
      assert.equal(o.get('foo'), 'bar');
    };

    _proto['@test sets up mandatory setters for watched simple properties'] = function testSetsUpMandatorySettersForWatchedSimpleProperties(assert) {
      if (true
      /* DEBUG */
      ) {
          var MyClass = _object.default.extend({
            foo: null,
            bar: null,
            fooDidChange: (0, _metal.observer)('foo', function () {})
          });

          var o = MyClass.create({
            foo: 'bar',
            bar: 'baz'
          });
          assert.equal(o.get('foo'), 'bar');
          var descriptor = Object.getOwnPropertyDescriptor(o, 'foo');
          assert.ok(descriptor.set, 'Mandatory setter was setup');
          descriptor = Object.getOwnPropertyDescriptor(o, 'bar');
          assert.ok(!descriptor.set, 'Mandatory setter was not setup');
        } else {
        assert.expect(0);
      }
    };

    _proto['@test calls setUnknownProperty if defined'] = function testCallsSetUnknownPropertyIfDefined(assert) {
      var setUnknownPropertyCalled = false;

      var MyClass = _object.default.extend({
        setUnknownProperty: function ()
        /* key, value */
        {
          setUnknownPropertyCalled = true;
        }
      });

      MyClass.create({
        foo: 'bar'
      });
      assert.ok(setUnknownPropertyCalled, 'setUnknownProperty was called');
    };

    _proto['@test throws if you try to define a computed property'] = function testThrowsIfYouTryToDefineAComputedProperty() {
      expectAssertion(function () {
        _object.default.create({
          foo: (0, _metal.computed)(function () {})
        });
      }, 'EmberObject.create no longer supports defining computed properties. Define computed properties using extend() or reopen() before calling create().');
    };

    _proto['@test throws if you try to call _super in a method'] = function testThrowsIfYouTryToCall_superInAMethod() {
      expectAssertion(function () {
        _object.default.create({
          foo: function () {
            this._super.apply(this, arguments);
          }
        });
      }, 'EmberObject.create no longer supports defining methods that call _super.');
    };

    _proto["@test throws if you try to 'mixin' a definition"] = function testThrowsIfYouTryToMixinADefinition() {
      var myMixin = _metal.Mixin.create({
        adder: function (arg1, arg2) {
          return arg1 + arg2;
        }
      });

      expectAssertion(function () {
        _object.default.create(myMixin);
      }, 'EmberObject.create no longer supports mixing in other definitions, use .extend & .create separately instead.');
    };

    _proto['@test inherits properties from passed in EmberObject'] = function testInheritsPropertiesFromPassedInEmberObject(assert) {
      var baseObj = _object.default.create({
        foo: 'bar'
      });

      var secondaryObj = _object.default.create(baseObj);

      assert.equal(secondaryObj.foo, baseObj.foo, 'Em.O.create inherits properties from EmberObject parameter');
    };

    _proto['@test throws if you try to pass anything a string as a parameter'] = function testThrowsIfYouTryToPassAnythingAStringAsAParameter() {
      var expected = 'EmberObject.create only accepts objects.';
      expectAssertion(function () {
        return _object.default.create('some-string');
      }, expected);
    };

    _proto['@test EmberObject.create can take undefined as a parameter'] = function testEmberObjectCreateCanTakeUndefinedAsAParameter(assert) {
      var o = _object.default.create(undefined);

      assert.deepEqual(_object.default.create(), o);
    };

    _proto['@test can use getOwner in a proxy init GH#16484'] = function testCanUseGetOwnerInAProxyInitGH16484(assert) {
      var owner = {};
      var options = {};
      (0, _owner.setOwner)(options, owner);

      _object.default.extend({
        init: function () {
          this._super.apply(this, arguments);

          var localOwner = (0, _owner.getOwner)(this);
          assert.equal(localOwner, owner, 'should be able to `getOwner` in init');
        },
        unknownProperty: function () {
          return undefined;
        }
      }).create(options);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/object/destroy_test", ["ember-babel", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/meta", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers"], function (_emberBabel, _runloop, _metal, _meta, _object, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('@ember/-internals/runtime/system/object/destroy_test',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test should schedule objects to be destroyed at the end of the run loop'] = function testShouldScheduleObjectsToBeDestroyedAtTheEndOfTheRunLoop(assert) {
      var obj = _object.default.create();

      var meta;
      (0, _runloop.run)(function () {
        obj.destroy();
        meta = (0, _meta.peekMeta)(obj);
        assert.ok(meta, 'meta is not destroyed immediately');
        assert.ok((0, _metal.get)(obj, 'isDestroying'), 'object is marked as destroying immediately');
        assert.ok(!(0, _metal.get)(obj, 'isDestroyed'), 'object is not destroyed immediately');
      });
      meta = (0, _meta.peekMeta)(obj);
      assert.ok((0, _metal.get)(obj, 'isDestroyed'), 'object is destroyed after run loop finishes');
    } // MANDATORY_SETTER moves value to meta.values
    // a destroyed object removes meta but leaves the accessor
    // that looks it up
    ;

    _proto['@test should raise an exception when modifying watched properties on a destroyed object'] = function testShouldRaiseAnExceptionWhenModifyingWatchedPropertiesOnADestroyedObject(assert) {
      if (true
      /* DEBUG */
      ) {
          var obj = _object.default.extend({
            fooDidChange: (0, _metal.observer)('foo', function () {})
          }).create({
            foo: 'bar'
          });

          (0, _runloop.run)(function () {
            return obj.destroy();
          });
          assert.throws(function () {
            return (0, _metal.set)(obj, 'foo', 'baz');
          }, Error, 'raises an exception');
        } else {
        assert.expect(0);
      }
    };

    _proto['@test observers should not fire after an object has been destroyed'] =
    /*#__PURE__*/
    function () {
      var _testObserversShouldNotFireAfterAnObjectHasBeenDestroyed = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var count, obj;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              count = 0;
              obj = _object.default.extend({
                fooDidChange: (0, _metal.observer)('foo', function () {
                  count++;
                })
              }).create();
              obj.set('foo', 'bar');
              _context.next = 5;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 5:
              assert.equal(count, 1, 'observer was fired once');
              (0, _metal.beginPropertyChanges)();
              obj.set('foo', 'quux');
              obj.destroy();
              (0, _metal.endPropertyChanges)();
              _context.next = 12;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 12:
              assert.equal(count, 1, 'observer was not called after object was destroyed');

            case 13:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function testObserversShouldNotFireAfterAnObjectHasBeenDestroyed(_x) {
        return _testObserversShouldNotFireAfterAnObjectHasBeenDestroyed.apply(this, arguments);
      }

      return testObserversShouldNotFireAfterAnObjectHasBeenDestroyed;
    }();

    _proto['@test destroyed objects should not see each others changes during teardown but a long lived object should'] =
    /*#__PURE__*/
    function () {
      var _testDestroyedObjectsShouldNotSeeEachOthersChangesDuringTeardownButALongLivedObjectShould = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        var shouldChange, shouldNotChange, objs, A, B, C, LongLivedObject, obj;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              shouldChange = 0;
              shouldNotChange = 0;
              objs = {};
              A = _object.default.extend({
                objs: objs,
                isAlive: true,
                willDestroy: function () {
                  this.set('isAlive', false);
                },
                bDidChange: (0, _metal.observer)('objs.b.isAlive', function () {
                  shouldNotChange++;
                }),
                cDidChange: (0, _metal.observer)('objs.c.isAlive', function () {
                  shouldNotChange++;
                })
              });
              B = _object.default.extend({
                objs: objs,
                isAlive: true,
                willDestroy: function () {
                  this.set('isAlive', false);
                },
                aDidChange: (0, _metal.observer)('objs.a.isAlive', function () {
                  shouldNotChange++;
                }),
                cDidChange: (0, _metal.observer)('objs.c.isAlive', function () {
                  shouldNotChange++;
                })
              });
              C = _object.default.extend({
                objs: objs,
                isAlive: true,
                willDestroy: function () {
                  this.set('isAlive', false);
                },
                aDidChange: (0, _metal.observer)('objs.a.isAlive', function () {
                  shouldNotChange++;
                }),
                bDidChange: (0, _metal.observer)('objs.b.isAlive', function () {
                  shouldNotChange++;
                })
              });
              LongLivedObject = _object.default.extend({
                objs: objs,
                isAliveDidChange: (0, _metal.observer)('objs.a.isAlive', function () {
                  shouldChange++;
                })
              });
              objs.a = A.create();
              objs.b = B.create();
              objs.c = C.create();
              LongLivedObject.create();

              for (obj in objs) {
                objs[obj].destroy();
              }

              _context2.next = 14;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 14:
              assert.equal(shouldNotChange, 0, 'destroyed graph objs should not see change in willDestroy');
              assert.equal(shouldChange, 1, 'long lived should see change in willDestroy');

            case 16:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));

      function testDestroyedObjectsShouldNotSeeEachOthersChangesDuringTeardownButALongLivedObjectShould(_x2) {
        return _testDestroyedObjectsShouldNotSeeEachOthersChangesDuringTeardownButALongLivedObjectShould.apply(this, arguments);
      }

      return testDestroyedObjectsShouldNotSeeEachOthersChangesDuringTeardownButALongLivedObjectShould;
    }();

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/object/detectInstance_test", ["ember-babel", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers"], function (_emberBabel, _object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/object/detectInstance',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test detectInstance detects instances correctly'] = function testDetectInstanceDetectsInstancesCorrectly(assert) {
      var A = _object.default.extend();

      var B = A.extend();
      var C = A.extend();

      var o = _object.default.create();

      var a = A.create();
      var b = B.create();
      var c = C.create();
      assert.ok(_object.default.detectInstance(o), 'o is an instance of EmberObject');
      assert.ok(_object.default.detectInstance(a), 'a is an instance of EmberObject');
      assert.ok(_object.default.detectInstance(b), 'b is an instance of EmberObject');
      assert.ok(_object.default.detectInstance(c), 'c is an instance of EmberObject');
      assert.ok(!A.detectInstance(o), 'o is not an instance of A');
      assert.ok(A.detectInstance(a), 'a is an instance of A');
      assert.ok(A.detectInstance(b), 'b is an instance of A');
      assert.ok(A.detectInstance(c), 'c is an instance of A');
      assert.ok(!B.detectInstance(o), 'o is not an instance of B');
      assert.ok(!B.detectInstance(a), 'a is not an instance of B');
      assert.ok(B.detectInstance(b), 'b is an instance of B');
      assert.ok(!B.detectInstance(c), 'c is not an instance of B');
      assert.ok(!C.detectInstance(o), 'o is not an instance of C');
      assert.ok(!C.detectInstance(a), 'a is not an instance of C');
      assert.ok(!C.detectInstance(b), 'b is not an instance of C');
      assert.ok(C.detectInstance(c), 'c is an instance of C');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/object/detect_test", ["ember-babel", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers"], function (_emberBabel, _object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/object/detect',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test detect detects classes correctly'] = function testDetectDetectsClassesCorrectly(assert) {
      var A = _object.default.extend();

      var B = A.extend();
      var C = A.extend();
      assert.ok(_object.default.detect(_object.default), 'EmberObject is an EmberObject class');
      assert.ok(_object.default.detect(A), 'A is an EmberObject class');
      assert.ok(_object.default.detect(B), 'B is an EmberObject class');
      assert.ok(_object.default.detect(C), 'C is an EmberObject class');
      assert.ok(!A.detect(_object.default), 'EmberObject is not an A class');
      assert.ok(A.detect(A), 'A is an A class');
      assert.ok(A.detect(B), 'B is an A class');
      assert.ok(A.detect(C), 'C is an A class');
      assert.ok(!B.detect(_object.default), 'EmberObject is not a B class');
      assert.ok(!B.detect(A), 'A is not a B class');
      assert.ok(B.detect(B), 'B is a B class');
      assert.ok(!B.detect(C), 'C is not a B class');
      assert.ok(!C.detect(_object.default), 'EmberObject is not a C class');
      assert.ok(!C.detect(A), 'A is not a C class');
      assert.ok(!C.detect(B), 'B is not a C class');
      assert.ok(C.detect(C), 'C is a C class');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/object/es-compatibility-test", ["ember-babel", "@ember/-internals/runtime/lib/system/object", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _object, _metal, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('EmberObject ES Compatibility',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test extending an Ember.Object'] = function testExtendingAnEmberObject(assert) {
      var calls = [];

      var MyObject =
      /*#__PURE__*/
      function (_EmberObject) {
        (0, _emberBabel.inheritsLoose)(MyObject, _EmberObject);

        function MyObject() {
          var _this;

          calls.push('constructor');
          _this = _EmberObject.apply(this, arguments) || this;
          _this.postInitProperty = 'post-init-property';
          return _this;
        }

        var _proto2 = MyObject.prototype;

        _proto2.init = function init() {
          calls.push('init');

          _EmberObject.prototype.init.apply(this, arguments);

          this.initProperty = 'init-property';
        };

        return MyObject;
      }(_object.default);

      var myObject = MyObject.create({
        passedProperty: 'passed-property'
      });
      assert.deepEqual(calls, ['constructor', 'init'], 'constructor then init called (create)');
      assert.equal(myObject.postInitProperty, 'post-init-property', 'constructor property available on instance (create)');
      assert.equal(myObject.initProperty, 'init-property', 'init property available on instance (create)');
      assert.equal(myObject.passedProperty, 'passed-property', 'passed property available on instance (create)');
    };

    _proto['@test normal method super'] = function testNormalMethodSuper(assert) {
      var calls = [];

      var Foo = _object.default.extend({
        method: function () {
          calls.push('foo');
        }
      });

      var Bar = Foo.extend({
        method: function () {
          this._super();

          calls.push('bar');
        }
      });

      var Baz =
      /*#__PURE__*/
      function (_Bar) {
        (0, _emberBabel.inheritsLoose)(Baz, _Bar);

        function Baz() {
          return _Bar.apply(this, arguments) || this;
        }

        var _proto3 = Baz.prototype;

        _proto3.method = function method() {
          _Bar.prototype.method.call(this);

          calls.push('baz');
        };

        return Baz;
      }(Bar);

      var Qux = Baz.extend({
        method: function () {
          this._super();

          calls.push('qux');
        }
      });
      var Quux = Qux.extend({
        method: function () {
          this._super();

          calls.push('quux');
        }
      });

      var Corge =
      /*#__PURE__*/
      function (_Quux) {
        (0, _emberBabel.inheritsLoose)(Corge, _Quux);

        function Corge() {
          return _Quux.apply(this, arguments) || this;
        }

        var _proto4 = Corge.prototype;

        _proto4.method = function method() {
          _Quux.prototype.method.call(this);

          calls.push('corge');
        };

        return Corge;
      }(Quux);

      var callValues = ['foo', 'bar', 'baz', 'qux', 'quux', 'corge'];
      [Foo, Bar, Baz, Qux, Quux, Corge].forEach(function (Class, index) {
        calls = [];
        Class.create().method();
        assert.deepEqual(calls, callValues.slice(0, index + 1), 'chain of static methods called with super');
      });
    };

    _proto['@test static method super'] = function testStaticMethodSuper(assert) {
      var calls;

      var Foo = _object.default.extend();

      Foo.reopenClass({
        method: function () {
          calls.push('foo');
        }
      });
      var Bar = Foo.extend();
      Bar.reopenClass({
        method: function () {
          this._super();

          calls.push('bar');
        }
      });

      var Baz =
      /*#__PURE__*/
      function (_Bar2) {
        (0, _emberBabel.inheritsLoose)(Baz, _Bar2);

        function Baz() {
          return _Bar2.apply(this, arguments) || this;
        }

        Baz.method = function method() {
          _Bar2.method.call(this);

          calls.push('baz');
        };

        return Baz;
      }(Bar);

      var Qux = Baz.extend();
      Qux.reopenClass({
        method: function () {
          this._super();

          calls.push('qux');
        }
      });
      var Quux = Qux.extend();
      Quux.reopenClass({
        method: function () {
          this._super();

          calls.push('quux');
        }
      });

      var Corge =
      /*#__PURE__*/
      function (_Quux2) {
        (0, _emberBabel.inheritsLoose)(Corge, _Quux2);

        function Corge() {
          return _Quux2.apply(this, arguments) || this;
        }

        Corge.method = function method() {
          _Quux2.method.call(this);

          calls.push('corge');
        };

        return Corge;
      }(Quux);

      var callValues = ['foo', 'bar', 'baz', 'qux', 'quux', 'corge'];
      [Foo, Bar, Baz, Qux, Quux, Corge].forEach(function (Class, index) {
        calls = [];
        Class.method();
        assert.deepEqual(calls, callValues.slice(0, index + 1), 'chain of static methods called with super');
      });
    };

    _proto['@test using mixins'] = function testUsingMixins(assert) {
      var Mixin1 = _metal.Mixin.create({
        property1: 'data-1'
      });

      var Mixin2 = _metal.Mixin.create({
        property2: 'data-2'
      });

      var MyObject =
      /*#__PURE__*/
      function (_EmberObject$extend) {
        (0, _emberBabel.inheritsLoose)(MyObject, _EmberObject$extend);

        function MyObject() {
          return _EmberObject$extend.apply(this, arguments) || this;
        }

        return MyObject;
      }(_object.default.extend(Mixin1, Mixin2));

      var myObject = MyObject.create();
      assert.equal(myObject.property1, 'data-1', 'includes the first mixin');
      assert.equal(myObject.property2, 'data-2', 'includes the second mixin');
    };

    _proto['@test using instanceof'] = function testUsingInstanceof(assert) {
      var MyObject =
      /*#__PURE__*/
      function (_EmberObject2) {
        (0, _emberBabel.inheritsLoose)(MyObject, _EmberObject2);

        function MyObject() {
          return _EmberObject2.apply(this, arguments) || this;
        }

        return MyObject;
      }(_object.default);

      var myObject = MyObject.create();
      assert.ok(myObject instanceof MyObject);
      assert.ok(myObject instanceof _object.default);
    };

    _proto['@test using Ember.Object#detect'] = function testUsingEmberObjectDetect(assert) {
      var Parent = _object.default.extend();

      var Child =
      /*#__PURE__*/
      function (_Parent) {
        (0, _emberBabel.inheritsLoose)(Child, _Parent);

        function Child() {
          return _Parent.apply(this, arguments) || this;
        }

        return Child;
      }(Parent);

      var Grandchild = Child.extend();
      assert.ok(Parent.detect(Child), 'Parent.detect(Child)');
      assert.ok(Child.detect(Grandchild), 'Child.detect(Grandchild)');
    };

    _proto['@test extending an ES subclass of EmberObject'] = function testExtendingAnESSubclassOfEmberObject(assert) {
      var calls = [];

      var SubEmberObject =
      /*#__PURE__*/
      function (_EmberObject3) {
        (0, _emberBabel.inheritsLoose)(SubEmberObject, _EmberObject3);

        function SubEmberObject() {
          calls.push('constructor');
          return _EmberObject3.apply(this, arguments) || this;
        }

        var _proto5 = SubEmberObject.prototype;

        _proto5.init = function init() {
          calls.push('init');

          _EmberObject3.prototype.init.apply(this, arguments);
        };

        return SubEmberObject;
      }(_object.default);

      var MyObject =
      /*#__PURE__*/
      function (_SubEmberObject) {
        (0, _emberBabel.inheritsLoose)(MyObject, _SubEmberObject);

        function MyObject() {
          return _SubEmberObject.apply(this, arguments) || this;
        }

        return MyObject;
      }(SubEmberObject);

      MyObject.create();
      assert.deepEqual(calls, ['constructor', 'init'], 'constructor then init called (create)');
    };

    _proto['@test calling extend on an ES subclass of EmberObject'] = function testCallingExtendOnAnESSubclassOfEmberObject(assert) {
      var calls = [];

      var SubEmberObject =
      /*#__PURE__*/
      function (_EmberObject4) {
        (0, _emberBabel.inheritsLoose)(SubEmberObject, _EmberObject4);

        function SubEmberObject() {
          var _this2;

          calls.push('before constructor');
          _this2 = _EmberObject4.apply(this, arguments) || this;
          calls.push('after constructor');
          _this2.foo = 123;
          return _this2;
        }

        var _proto6 = SubEmberObject.prototype;

        _proto6.init = function init() {
          calls.push('init');

          _EmberObject4.prototype.init.apply(this, arguments);
        };

        return SubEmberObject;
      }(_object.default);

      var MyObject = SubEmberObject.extend({});
      MyObject.create();
      assert.deepEqual(calls, ['before constructor', 'after constructor', 'init'], 'constructor then init called (create)');
      var obj = MyObject.create({
        foo: 456,
        bar: 789
      });
      assert.equal(obj.foo, 456, 'sets class fields on instance correctly');
      assert.equal(obj.bar, 789, 'sets passed in properties on instance correctly');
    };

    _proto['@test calling metaForProperty on a native class works'] = function testCallingMetaForPropertyOnANativeClassWorks(assert) {
      assert.expect(0);

      var SubEmberObject =
      /*#__PURE__*/
      function (_EmberObject5) {
        (0, _emberBabel.inheritsLoose)(SubEmberObject, _EmberObject5);

        function SubEmberObject() {
          return _EmberObject5.apply(this, arguments) || this;
        }

        return SubEmberObject;
      }(_object.default);

      (0, _metal.defineProperty)(SubEmberObject.prototype, 'foo', (0, _metal.computed)('foo', {
        get: function () {
          return 'bar';
        }
      })); // able to get meta without throwing an error

      SubEmberObject.metaForProperty('foo');
    };

    _proto['@test observes / removeObserver on / removeListener interop'] = function testObservesRemoveObserverOnRemoveListenerInterop(assert) {
      var fooDidChangeBase = 0;
      var fooDidChangeA = 0;
      var fooDidChangeB = 0;
      var someEventBase = 0;
      var someEventA = 0;
      var someEventB = 0;

      var A =
      /*#__PURE__*/
      function (_EmberObject$extend2) {
        (0, _emberBabel.inheritsLoose)(A, _EmberObject$extend2);

        function A() {
          return _EmberObject$extend2.apply(this, arguments) || this;
        }

        var _proto7 = A.prototype;

        _proto7.init = function init() {
          _EmberObject$extend2.prototype.init.call(this);

          this.foo = 'bar';
        };

        _proto7.fooDidChange = function fooDidChange() {
          _EmberObject$extend2.prototype.fooDidChange.call(this);

          fooDidChangeA++;
        };

        _proto7.onSomeEvent = function onSomeEvent() {
          _EmberObject$extend2.prototype.onSomeEvent.call(this);

          someEventA++;
        };

        return A;
      }(_object.default.extend({
        fooDidChange: (0, _metal.observer)('foo', function () {
          fooDidChangeBase++;
        }),
        onSomeEvent: (0, _metal.on)('someEvent', function () {
          someEventBase++;
        })
      }));

      var B =
      /*#__PURE__*/
      function (_A) {
        (0, _emberBabel.inheritsLoose)(B, _A);

        function B() {
          return _A.apply(this, arguments) || this;
        }

        var _proto8 = B.prototype;

        _proto8.fooDidChange = function fooDidChange() {
          _A.prototype.fooDidChange.call(this);

          fooDidChangeB++;
        };

        _proto8.onSomeEvent = function onSomeEvent() {
          _A.prototype.onSomeEvent.call(this);

          someEventB++;
        };

        return B;
      }(A);

      (0, _metal.removeObserver)(B.prototype, 'foo', null, 'fooDidChange');
      (0, _metal.removeListener)(B.prototype, 'someEvent', null, 'onSomeEvent');
      assert.equal(fooDidChangeBase, 0);
      assert.equal(fooDidChangeA, 0);
      assert.equal(fooDidChangeB, 0);
      assert.equal(someEventBase, 0);
      assert.equal(someEventA, 0);
      assert.equal(someEventB, 0);
      var a = A.create();
      a.set('foo', 'something'); // TODO: Generator transpilation code doesn't play nice with class definitions/hoisting

      return (0, _internalTestHelpers.runLoopSettled)().then(
      /*#__PURE__*/
      _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var b;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              assert.equal(fooDidChangeBase, 1);
              assert.equal(fooDidChangeA, 1);
              assert.equal(fooDidChangeB, 0);
              (0, _metal.sendEvent)(a, 'someEvent');
              assert.equal(someEventBase, 1);
              assert.equal(someEventA, 1);
              assert.equal(someEventB, 0);
              b = B.create();
              b.set('foo', 'something');
              _context.next = 11;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 11:
              assert.equal(fooDidChangeBase, 1);
              assert.equal(fooDidChangeA, 1);
              assert.equal(fooDidChangeB, 0);
              (0, _metal.sendEvent)(b, 'someEvent');
              assert.equal(someEventBase, 1);
              assert.equal(someEventA, 1);
              assert.equal(someEventB, 0);

            case 18:
            case "end":
              return _context.stop();
          }
        }, _callee);
      })));
    };

    _proto['@test super and _super interop between old and new methods'] = function testSuperAnd_superInteropBetweenOldAndNewMethods(assert) {
      var calls = [];
      var changes = [];
      var events = [];
      var lastProps;

      var A =
      /*#__PURE__*/
      function (_EmberObject6) {
        (0, _emberBabel.inheritsLoose)(A, _EmberObject6);

        function A() {
          return _EmberObject6.apply(this, arguments) || this;
        }

        var _proto9 = A.prototype;

        _proto9.init = function init(props) {
          calls.push('A init');
          lastProps = props;
        };

        return A;
      }(_object.default);

      var Mixin1 = _metal.Mixin.create({
        init: function () {
          calls.push('Mixin1 init before _super');

          this._super.apply(this, arguments);

          calls.push('Mixin1 init after _super');
        }
      });

      var Mixin2 = _metal.Mixin.create({
        init: function () {
          calls.push('Mixin2 init before _super');

          this._super.apply(this, arguments);

          calls.push('Mixin2 init after _super');
        }
      });

      var B =
      /*#__PURE__*/
      function (_A$extend) {
        (0, _emberBabel.inheritsLoose)(B, _A$extend);

        function B() {
          return _A$extend.apply(this, arguments) || this;
        }

        var _proto10 = B.prototype;

        _proto10.init = function init() {
          calls.push('B init before super.init');

          _A$extend.prototype.init.apply(this, arguments);

          calls.push('B init after super.init');
        };

        _proto10.onSomeEvent = function onSomeEvent(evt) {
          events.push("B onSomeEvent " + evt);
        };

        _proto10.fullNameDidChange = function fullNameDidChange() {
          changes.push('B fullNameDidChange');
        };

        return B;
      }(A.extend(Mixin1, Mixin2)); // // define a CP


      (0, _metal.defineProperty)(B.prototype, 'full', (0, _metal.computed)('first', 'last', {
        get: function () {
          return this.first + ' ' + this.last;
        }
      })); // Only string observers are allowed for prototypes

      (0, _metal.addObserver)(B.prototype, 'full', null, 'fullNameDidChange'); // Only string listeners are allowed for prototypes

      (0, _metal.addListener)(B.prototype, 'someEvent', null, 'onSomeEvent');
      B.reopen({
        init: function () {
          calls.push('reopen init before _super');

          this._super.apply(this, arguments);

          calls.push('reopen init after _super');
        }
      });
      var C = B.extend({
        init: function () {
          calls.push('C init before _super');

          this._super.apply(this, arguments);

          calls.push('C init after _super');
        },
        onSomeEvent: function (evt) {
          calls.push('C onSomeEvent before _super');

          this._super(evt);

          calls.push('C onSomeEvent after _super');
        },
        fullNameDidChange: function () {
          calls.push('C fullNameDidChange before _super');

          this._super();

          calls.push('C fullNameDidChange after _super');
        }
      });

      var D =
      /*#__PURE__*/
      function (_C) {
        (0, _emberBabel.inheritsLoose)(D, _C);

        function D() {
          return _C.apply(this, arguments) || this;
        }

        var _proto11 = D.prototype;

        _proto11.init = function init() {
          calls.push('D init before super.init');

          _C.prototype.init.apply(this, arguments);

          calls.push('D init after super.init');
        };

        _proto11.onSomeEvent = function onSomeEvent(evt) {
          events.push('D onSomeEvent before super.onSomeEvent');

          _C.prototype.onSomeEvent.call(this, evt);

          events.push('D onSomeEvent after super.onSomeEvent');
        };

        _proto11.fullNameDidChange = function fullNameDidChange() {
          changes.push('D fullNameDidChange before super.fullNameDidChange');

          _C.prototype.fullNameDidChange.call(this);

          changes.push('D fullNameDidChange after super.fullNameDidChange');
        };

        _proto11.triggerSomeEvent = function triggerSomeEvent() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          (0, _metal.sendEvent)(this, 'someEvent', args);
        };

        return D;
      }(C);

      assert.deepEqual(calls, [], 'nothing has been called');
      assert.deepEqual(changes, [], 'full has not changed');
      assert.deepEqual(events, [], 'onSomeEvent has not been triggered');
      var d = D.create({
        first: 'Robert',
        last: 'Jackson'
      });
      assert.deepEqual(calls, ['D init before super.init', 'C init before _super', 'reopen init before _super', 'B init before super.init', 'Mixin2 init before _super', 'Mixin1 init before _super', 'A init', 'Mixin1 init after _super', 'Mixin2 init after _super', 'B init after super.init', 'reopen init after _super', 'C init after _super', 'D init after super.init']);
      assert.deepEqual(changes, [], 'full has not changed');
      assert.deepEqual(events, [], 'onSomeEvent has not been triggered');
      assert.deepEqual(lastProps, {
        first: 'Robert',
        last: 'Jackson'
      });
      assert.equal(d.full, 'Robert Jackson');
      d.setProperties({
        first: 'Kris',
        last: 'Selden'
      }); // TODO: Generator transpilation code doesn't play nice with class definitions/hoisting

      return (0, _internalTestHelpers.runLoopSettled)().then(function () {
        assert.deepEqual(changes, ['D fullNameDidChange before super.fullNameDidChange', 'B fullNameDidChange', 'D fullNameDidChange after super.fullNameDidChange']);
        assert.equal(d.full, 'Kris Selden');
        d.triggerSomeEvent('event arg');
        assert.deepEqual(events, ['D onSomeEvent before super.onSomeEvent', 'B onSomeEvent event arg', 'D onSomeEvent after super.onSomeEvent']);
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/object/events_test", ["ember-babel", "@ember/-internals/runtime/lib/system/object", "@ember/-internals/runtime/lib/mixins/evented", "internal-test-helpers"], function (_emberBabel, _object, _evented, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Object events',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test a listener can be added to an object'] = function testAListenerCanBeAddedToAnObject(assert) {
      var count = 0;

      var F = function () {
        count++;
      };

      var obj = _object.default.extend(_evented.default).create();

      obj.on('event!', F);
      obj.trigger('event!');
      assert.equal(count, 1, 'the event was triggered');
      obj.trigger('event!');
      assert.equal(count, 2, 'the event was triggered');
    };

    _proto['@test a listener can be added and removed automatically the first time it is triggered'] = function testAListenerCanBeAddedAndRemovedAutomaticallyTheFirstTimeItIsTriggered(assert) {
      var count = 0;

      var F = function () {
        count++;
      };

      var obj = _object.default.extend(_evented.default).create();

      obj.one('event!', F);
      obj.trigger('event!');
      assert.equal(count, 1, 'the event was triggered');
      obj.trigger('event!');
      assert.equal(count, 1, 'the event was not triggered again');
    };

    _proto['@test triggering an event can have arguments'] = function testTriggeringAnEventCanHaveArguments(assert) {
      var self, args;

      var obj = _object.default.extend(_evented.default).create();

      obj.on('event!', function () {
        args = [].slice.call(arguments);
        self = this;
      });
      obj.trigger('event!', 'foo', 'bar');
      assert.deepEqual(args, ['foo', 'bar']);
      assert.equal(self, obj);
    };

    _proto['@test a listener can be added and removed automatically and have arguments'] = function testAListenerCanBeAddedAndRemovedAutomaticallyAndHaveArguments(assert) {
      var self, args;
      var count = 0;

      var obj = _object.default.extend(_evented.default).create();

      obj.one('event!', function () {
        args = [].slice.call(arguments);
        self = this;
        count++;
      });
      obj.trigger('event!', 'foo', 'bar');
      assert.deepEqual(args, ['foo', 'bar']);
      assert.equal(self, obj);
      assert.equal(count, 1, 'the event is triggered once');
      obj.trigger('event!', 'baz', 'bat');
      assert.deepEqual(args, ['foo', 'bar']);
      assert.equal(count, 1, 'the event was not triggered again');
      assert.equal(self, obj);
    };

    _proto['@test binding an event can specify a different target'] = function testBindingAnEventCanSpecifyADifferentTarget(assert) {
      var self, args;

      var obj = _object.default.extend(_evented.default).create();

      var target = {};
      obj.on('event!', target, function () {
        args = [].slice.call(arguments);
        self = this;
      });
      obj.trigger('event!', 'foo', 'bar');
      assert.deepEqual(args, ['foo', 'bar']);
      assert.equal(self, target);
    };

    _proto['@test a listener registered with one can take method as string and can be added with different target'] = function testAListenerRegisteredWithOneCanTakeMethodAsStringAndCanBeAddedWithDifferentTarget(assert) {
      var count = 0;
      var target = {};

      target.fn = function () {
        count++;
      };

      var obj = _object.default.extend(_evented.default).create();

      obj.one('event!', target, 'fn');
      obj.trigger('event!');
      assert.equal(count, 1, 'the event was triggered');
      obj.trigger('event!');
      assert.equal(count, 1, 'the event was not triggered again');
    };

    _proto['@test a listener registered with one can be removed with off'] = function testAListenerRegisteredWithOneCanBeRemovedWithOff(assert) {
      var obj = _object.default.extend(_evented.default, {
        F: function () {}
      }).create();

      var F = function () {};

      obj.one('event!', F);
      obj.one('event!', obj, 'F');
      assert.equal(obj.has('event!'), true, 'has events');
      obj.off('event!', F);
      obj.off('event!', obj, 'F');
      assert.equal(obj.has('event!'), false, 'has no more events');
    };

    _proto['@test adding and removing listeners should be chainable'] = function testAddingAndRemovingListenersShouldBeChainable(assert) {
      var obj = _object.default.extend(_evented.default).create();

      var F = function () {};

      var ret = obj.on('event!', F);
      assert.equal(ret, obj, '#on returns self');
      ret = obj.off('event!', F);
      assert.equal(ret, obj, '#off returns self');
      ret = obj.one('event!', F);
      assert.equal(ret, obj, '#one returns self');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/object/extend_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers"], function (_emberBabel, _metal, _object, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('EmberObject.extend',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Basic extend'] = function testBasicExtend(assert) {
      var SomeClass = _object.default.extend({
        foo: 'BAR'
      });

      assert.ok(SomeClass.isClass, 'A class has isClass of true');
      var obj = SomeClass.create();
      assert.equal(obj.foo, 'BAR');
    };

    _proto['@test Sub-subclass'] = function testSubSubclass(assert) {
      var SomeClass = _object.default.extend({
        foo: 'BAR'
      });

      var AnotherClass = SomeClass.extend({
        bar: 'FOO'
      });
      var obj = AnotherClass.create();
      assert.equal(obj.foo, 'BAR');
      assert.equal(obj.bar, 'FOO');
    };

    _proto['@test Overriding a method several layers deep'] = function testOverridingAMethodSeveralLayersDeep(assert) {
      var SomeClass = _object.default.extend({
        fooCnt: 0,
        foo: function () {
          this.fooCnt++;
        },
        barCnt: 0,
        bar: function () {
          this.barCnt++;
        }
      });

      var AnotherClass = SomeClass.extend({
        barCnt: 0,
        bar: function () {
          this.barCnt++;

          this._super.apply(this, arguments);
        }
      });
      var FinalClass = AnotherClass.extend({
        fooCnt: 0,
        foo: function () {
          this.fooCnt++;

          this._super.apply(this, arguments);
        }
      });
      var obj = FinalClass.create();
      obj.foo();
      obj.bar();
      assert.equal(obj.fooCnt, 2, 'should invoke both');
      assert.equal(obj.barCnt, 2, 'should invoke both'); // Try overriding on create also

      obj = FinalClass.extend({
        foo: function () {
          this.fooCnt++;

          this._super.apply(this, arguments);
        }
      }).create();
      obj.foo();
      obj.bar();
      assert.equal(obj.fooCnt, 3, 'should invoke final as well');
      assert.equal(obj.barCnt, 2, 'should invoke both');
    };

    _proto['@test With concatenatedProperties'] = function testWithConcatenatedProperties(assert) {
      var SomeClass = _object.default.extend({
        things: 'foo',
        concatenatedProperties: ['things']
      });

      var AnotherClass = SomeClass.extend({
        things: 'bar'
      });
      var YetAnotherClass = SomeClass.extend({
        things: 'baz'
      });
      var some = SomeClass.create();
      var another = AnotherClass.create();
      var yetAnother = YetAnotherClass.create();
      assert.deepEqual(some.get('things'), ['foo'], 'base class should have just its value');
      assert.deepEqual(another.get('things'), ['foo', 'bar'], "subclass should have base class' and its own");
      assert.deepEqual(yetAnother.get('things'), ['foo', 'baz'], "subclass should have base class' and its own");
    };

    _proto['@test With concatenatedProperties class properties'] = function testWithConcatenatedPropertiesClassProperties(assert) {
      var SomeClass = _object.default.extend();

      SomeClass.reopenClass({
        concatenatedProperties: ['things'],
        things: 'foo'
      });
      var AnotherClass = SomeClass.extend();
      AnotherClass.reopenClass({
        things: 'bar'
      });
      var YetAnotherClass = SomeClass.extend();
      YetAnotherClass.reopenClass({
        things: 'baz'
      });
      var some = SomeClass.create();
      var another = AnotherClass.create();
      var yetAnother = YetAnotherClass.create();
      assert.deepEqual((0, _metal.get)(some.constructor, 'things'), ['foo'], 'base class should have just its value');
      assert.deepEqual((0, _metal.get)(another.constructor, 'things'), ['foo', 'bar'], "subclass should have base class' and its own");
      assert.deepEqual((0, _metal.get)(yetAnother.constructor, 'things'), ['foo', 'baz'], "subclass should have base class' and its own");
    };

    _proto['@test Overriding a computed property with an observer'] =
    /*#__PURE__*/
    function () {
      var _testOverridingAComputedPropertyWithAnObserver = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var Parent, seen, Child, child;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              Parent = _object.default.extend({
                foo: (0, _metal.computed)(function () {
                  return 'FOO';
                })
              });
              seen = [];
              Child = Parent.extend({
                foo: (0, _metal.observer)('bar', function () {
                  seen.push(this.get('bar'));
                })
              });
              child = Child.create({
                bar: 0
              });
              assert.deepEqual(seen, []);
              child.set('bar', 1);
              _context.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              assert.deepEqual(seen, [1]);
              child.set('bar', 2);
              _context.next = 12;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 12:
              assert.deepEqual(seen, [1, 2]);

            case 13:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function testOverridingAComputedPropertyWithAnObserver(_x) {
        return _testOverridingAComputedPropertyWithAnObserver.apply(this, arguments);
      }

      return testOverridingAComputedPropertyWithAnObserver;
    }();

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/object/framework_test", ["ember-babel", "@ember/-internals/owner", "@ember/-internals/runtime/index", "internal-test-helpers", "@ember/-internals/runtime/lib/system/core_object"], function (_emberBabel, _owner, _index, _internalTestHelpers, _core_object) {
  "use strict";

  if (true
  /* EMBER_FRAMEWORK_OBJECT_OWNER_ARGUMENT */
  ) {
      (0, _internalTestHelpers.moduleFor)('FrameworkObject',
      /*#__PURE__*/
      function (_AbstractRenderingTes) {
        (0, _emberBabel.inheritsLoose)(_class, _AbstractRenderingTes);

        function _class() {
          return _AbstractRenderingTes.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto['@test tunnels the owner through to the base constructor for framework classes'] = function testTunnelsTheOwnerThroughToTheBaseConstructorForFrameworkClasses(assert) {
          assert.expect(2);
          var testContext = this;

          var Model =
          /*#__PURE__*/
          function (_FrameworkObject) {
            (0, _emberBabel.inheritsLoose)(Model, _FrameworkObject);

            function Model(owner) {
              var _this;

              _this = _FrameworkObject.call(this, owner) || this;
              assert.equal((0, _owner.getOwner)((0, _emberBabel.assertThisInitialized)(_this)), testContext.owner, 'owner was assigned properly in the root constructor');
              assert.equal(owner, testContext.owner, 'owner was passed properly to the constructor');
              return _this;
            }

            return Model;
          }(_index.FrameworkObject);

          (0, _core_object.setFrameworkClass)(Model);
          this.owner.register('model:blah', Model);
          this.owner.factoryFor('model:blah').create();
        };

        return _class;
      }(_internalTestHelpers.AbstractRenderingTestCase));
    }
});
enifed("@ember/-internals/runtime/tests/system/object/observer_test", ["ember-babel", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers"], function (_emberBabel, _runloop, _metal, _object, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('EmberObject observer',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test observer on class'] =
    /*#__PURE__*/
    function () {
      var _testObserverOnClass = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var MyClass, obj;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              MyClass = _object.default.extend({
                count: 0,
                foo: (0, _metal.observer)('bar', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              });
              obj = MyClass.create();
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer immediately');
              (0, _metal.set)(obj, 'bar', 'BAZ');
              _context.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              assert.equal((0, _metal.get)(obj, 'count'), 1, 'should invoke observer after change');

            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function testObserverOnClass(_x) {
        return _testObserverOnClass.apply(this, arguments);
      }

      return testObserverOnClass;
    }();

    _proto['@test observer on subclass'] =
    /*#__PURE__*/
    function () {
      var _testObserverOnSubclass = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        var MyClass, Subclass, obj;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              MyClass = _object.default.extend({
                count: 0,
                foo: (0, _metal.observer)('bar', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              });
              Subclass = MyClass.extend({
                foo: (0, _metal.observer)('baz', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              });
              obj = Subclass.create();
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer immediately');
              (0, _metal.set)(obj, 'bar', 'BAZ');
              _context2.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer after change');
              (0, _metal.set)(obj, 'baz', 'BAZ');
              _context2.next = 11;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 11:
              assert.equal((0, _metal.get)(obj, 'count'), 1, 'should invoke observer after change');

            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));

      function testObserverOnSubclass(_x2) {
        return _testObserverOnSubclass.apply(this, arguments);
      }

      return testObserverOnSubclass;
    }();

    _proto['@test observer on instance'] =
    /*#__PURE__*/
    function () {
      var _testObserverOnInstance = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(assert) {
        var obj;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              obj = _object.default.extend({
                foo: (0, _metal.observer)('bar', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              }).create({
                count: 0
              });
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer immediately');
              (0, _metal.set)(obj, 'bar', 'BAZ');
              _context3.next = 5;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 5:
              assert.equal((0, _metal.get)(obj, 'count'), 1, 'should invoke observer after change');

            case 6:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));

      function testObserverOnInstance(_x3) {
        return _testObserverOnInstance.apply(this, arguments);
      }

      return testObserverOnInstance;
    }();

    _proto['@test observer on instance overriding class'] =
    /*#__PURE__*/
    function () {
      var _testObserverOnInstanceOverridingClass = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(assert) {
        var MyClass, obj;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              MyClass = _object.default.extend({
                count: 0,
                foo: (0, _metal.observer)('bar', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              });
              obj = MyClass.extend({
                foo: (0, _metal.observer)('baz', function () {
                  // <-- change property we observe
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              }).create();
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer immediately');
              (0, _metal.set)(obj, 'bar', 'BAZ');
              _context4.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer after change');
              (0, _metal.set)(obj, 'baz', 'BAZ');
              _context4.next = 10;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 10:
              assert.equal((0, _metal.get)(obj, 'count'), 1, 'should invoke observer after change');

            case 11:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));

      function testObserverOnInstanceOverridingClass(_x4) {
        return _testObserverOnInstanceOverridingClass.apply(this, arguments);
      }

      return testObserverOnInstanceOverridingClass;
    }();

    _proto['@test observer should not fire after being destroyed'] = function testObserverShouldNotFireAfterBeingDestroyed(assert) {
      var obj = _object.default.extend({
        count: 0,
        foo: (0, _metal.observer)('bar', function () {
          (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
        })
      }).create();

      assert.equal((0, _metal.get)(obj, 'count'), 0, 'precond - should not invoke observer immediately');
      (0, _runloop.run)(function () {
        return obj.destroy();
      });
      expectAssertion(function () {
        (0, _metal.set)(obj, 'bar', 'BAZ');
      }, "calling set on destroyed object: " + obj + ".bar = BAZ");
      assert.equal((0, _metal.get)(obj, 'count'), 0, 'should not invoke observer after change');
    } // ..........................................................
    // COMPLEX PROPERTIES
    //
    ;

    _proto['@test chain observer on class'] =
    /*#__PURE__*/
    function () {
      var _testChainObserverOnClass = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(assert) {
        var MyClass, obj1, obj2;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              MyClass = _object.default.extend({
                count: 0,
                foo: (0, _metal.observer)('bar.baz', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              });
              obj1 = MyClass.create({
                bar: {
                  baz: 'biff'
                }
              });
              obj2 = MyClass.create({
                bar: {
                  baz: 'biff2'
                }
              });
              assert.equal((0, _metal.get)(obj1, 'count'), 0, 'should not invoke yet');
              assert.equal((0, _metal.get)(obj2, 'count'), 0, 'should not invoke yet');
              (0, _metal.set)((0, _metal.get)(obj1, 'bar'), 'baz', 'BIFF1');
              _context5.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              assert.equal((0, _metal.get)(obj1, 'count'), 1, 'should invoke observer on obj1');
              assert.equal((0, _metal.get)(obj2, 'count'), 0, 'should not invoke yet');
              (0, _metal.set)((0, _metal.get)(obj2, 'bar'), 'baz', 'BIFF2');
              _context5.next = 13;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 13:
              assert.equal((0, _metal.get)(obj1, 'count'), 1, 'should not invoke again');
              assert.equal((0, _metal.get)(obj2, 'count'), 1, 'should invoke observer on obj2');

            case 15:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }));

      function testChainObserverOnClass(_x5) {
        return _testChainObserverOnClass.apply(this, arguments);
      }

      return testChainObserverOnClass;
    }();

    _proto['@test chain observer on class'] =
    /*#__PURE__*/
    function () {
      var _testChainObserverOnClass2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(assert) {
        var MyClass, obj1, obj2;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              MyClass = _object.default.extend({
                count: 0,
                foo: (0, _metal.observer)('bar.baz', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              });
              obj1 = MyClass.extend().create({
                bar: {
                  baz: 'biff'
                }
              });
              obj2 = MyClass.extend({
                foo: (0, _metal.observer)('bar2.baz', function () {
                  (0, _metal.set)(this, 'count', (0, _metal.get)(this, 'count') + 1);
                })
              }).create({
                bar: {
                  baz: 'biff2'
                },
                bar2: {
                  baz: 'biff3'
                }
              });
              assert.equal((0, _metal.get)(obj1, 'count'), 0, 'should not invoke yet');
              assert.equal((0, _metal.get)(obj2, 'count'), 0, 'should not invoke yet');
              (0, _metal.set)((0, _metal.get)(obj1, 'bar'), 'baz', 'BIFF1');
              _context6.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              assert.equal((0, _metal.get)(obj1, 'count'), 1, 'should invoke observer on obj1');
              assert.equal((0, _metal.get)(obj2, 'count'), 0, 'should not invoke yet');
              (0, _metal.set)((0, _metal.get)(obj2, 'bar'), 'baz', 'BIFF2');
              _context6.next = 13;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 13:
              assert.equal((0, _metal.get)(obj1, 'count'), 1, 'should not invoke again');
              assert.equal((0, _metal.get)(obj2, 'count'), 0, 'should not invoke yet');
              (0, _metal.set)((0, _metal.get)(obj2, 'bar2'), 'baz', 'BIFF3');
              _context6.next = 18;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 18:
              assert.equal((0, _metal.get)(obj1, 'count'), 1, 'should not invoke again');
              assert.equal((0, _metal.get)(obj2, 'count'), 1, 'should invoke observer on obj2');

            case 20:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));

      function testChainObserverOnClass(_x6) {
        return _testChainObserverOnClass2.apply(this, arguments);
      }

      return testChainObserverOnClass;
    }();

    _proto['@test chain observer on class that has a reference to an uninitialized object will finish chains that reference it'] =
    /*#__PURE__*/
    function () {
      var _testChainObserverOnClassThatHasAReferenceToAnUninitializedObjectWillFinishChainsThatReferenceIt = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(assert) {
        var changed, ChildClass, ParentClass, parent;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              changed = false;
              ChildClass = _object.default.extend({
                parent: null,
                parentOneTwoDidChange: (0, _metal.observer)('parent.one.two', function () {
                  changed = true;
                })
              });
              ParentClass = _object.default.extend({
                one: {
                  two: 'old'
                },
                init: function () {
                  this.child = ChildClass.create({
                    parent: this
                  });
                }
              });
              parent = ParentClass.create();
              assert.equal(changed, false, 'precond');
              (0, _metal.set)(parent, 'one.two', 'new');
              _context7.next = 8;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 8:
              assert.equal(changed, true, 'child should have been notified of change to path');
              (0, _metal.set)(parent, 'one', {
                two: 'newer'
              });
              _context7.next = 12;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 12:
              assert.equal(changed, true, 'child should have been notified of change to path');

            case 13:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      }));

      function testChainObserverOnClassThatHasAReferenceToAnUninitializedObjectWillFinishChainsThatReferenceIt(_x7) {
        return _testChainObserverOnClassThatHasAReferenceToAnUninitializedObjectWillFinishChainsThatReferenceIt.apply(this, arguments);
      }

      return testChainObserverOnClassThatHasAReferenceToAnUninitializedObjectWillFinishChainsThatReferenceIt;
    }();

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/object/reopenClass_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers"], function (_emberBabel, _metal, _object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/object/reopenClass',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test adds new properties to subclass'] = function testAddsNewPropertiesToSubclass(assert) {
      var Subclass = _object.default.extend();

      Subclass.reopenClass({
        foo: function () {
          return 'FOO';
        },
        bar: 'BAR'
      });
      assert.equal(Subclass.foo(), 'FOO', 'Adds method');
      assert.equal((0, _metal.get)(Subclass, 'bar'), 'BAR', 'Adds property');
    };

    _proto['@test class properties inherited by subclasses'] = function testClassPropertiesInheritedBySubclasses(assert) {
      var Subclass = _object.default.extend();

      Subclass.reopenClass({
        foo: function () {
          return 'FOO';
        },
        bar: 'BAR'
      });
      var SubSub = Subclass.extend();
      assert.equal(SubSub.foo(), 'FOO', 'Adds method');
      assert.equal((0, _metal.get)(SubSub, 'bar'), 'BAR', 'Adds property');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/object/reopen_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers"], function (_emberBabel, _metal, _object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/core_object/reopen',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test adds new properties to subclass instance'] = function testAddsNewPropertiesToSubclassInstance(assert) {
      var Subclass = _object.default.extend();

      Subclass.reopen({
        foo: function () {
          return 'FOO';
        },
        bar: 'BAR'
      });
      assert.equal(Subclass.create().foo(), 'FOO', 'Adds method');
      assert.equal((0, _metal.get)(Subclass.create(), 'bar'), 'BAR', 'Adds property');
    };

    _proto['@test reopened properties inherited by subclasses'] = function testReopenedPropertiesInheritedBySubclasses(assert) {
      var Subclass = _object.default.extend();

      var SubSub = Subclass.extend();
      Subclass.reopen({
        foo: function () {
          return 'FOO';
        },
        bar: 'BAR'
      });
      assert.equal(SubSub.create().foo(), 'FOO', 'Adds method');
      assert.equal((0, _metal.get)(SubSub.create(), 'bar'), 'BAR', 'Adds property');
    };

    _proto['@test allows reopening already instantiated classes'] = function testAllowsReopeningAlreadyInstantiatedClasses(assert) {
      var Subclass = _object.default.extend();

      Subclass.create();
      Subclass.reopen({
        trololol: true
      });
      assert.equal(Subclass.create().get('trololol'), true, 'reopen works');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/object/strict-mode-test", ["ember-babel", "@ember/-internals/runtime/lib/system/object", "internal-test-helpers"], function (_emberBabel, _object, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('strict mode tests',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test __superWrapper does not throw errors in strict mode'] = function test__superWrapperDoesNotThrowErrorsInStrictMode(assert) {
      var Foo = _object.default.extend({
        blah: function () {
          return 'foo';
        }
      });

      var Bar = Foo.extend({
        blah: function () {
          return 'bar';
        },
        callBlah: function () {
          var blah = this.blah;
          return blah();
        }
      });
      var bar = Bar.create();
      assert.equal(bar.callBlah(), 'bar', 'can call local function without call/apply');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/object/toString_test", ["ember-babel", "@ember/runloop", "@ember/-internals/utils", "@ember/-internals/environment", "@ember/-internals/runtime/lib/system/object", "@ember/-internals/runtime/lib/system/namespace", "internal-test-helpers"], function (_emberBabel, _runloop, _utils, _environment, _object, _namespace, _internalTestHelpers) {
  "use strict";

  var originalLookup = _environment.context.lookup;
  var lookup;
  (0, _internalTestHelpers.moduleFor)('system/object/toString',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      _environment.context.lookup = lookup = {};
    };

    _proto.afterEach = function afterEach() {
      _environment.context.lookup = originalLookup;
    };

    _proto['@test toString() returns the same value if called twice'] = function testToStringReturnsTheSameValueIfCalledTwice(assert) {
      var Foo = _namespace.default.create();

      Foo.toString = function () {
        return 'Foo';
      };

      Foo.Bar = _object.default.extend();
      assert.equal(Foo.Bar.toString(), 'Foo.Bar');
      assert.equal(Foo.Bar.toString(), 'Foo.Bar');
      var obj = Foo.Bar.create();
      assert.equal(obj.toString(), '<Foo.Bar:' + (0, _utils.guidFor)(obj) + '>');
      assert.equal(obj.toString(), '<Foo.Bar:' + (0, _utils.guidFor)(obj) + '>');
      assert.equal(Foo.Bar.toString(), 'Foo.Bar');
      (0, _runloop.run)(Foo, 'destroy');
    };

    _proto['@test toString on a class returns a useful value when nested in a namespace'] = function testToStringOnAClassReturnsAUsefulValueWhenNestedInANamespace(assert) {
      var obj;

      var Foo = _namespace.default.create();

      Foo.toString = function () {
        return 'Foo';
      };

      Foo.Bar = _object.default.extend();
      assert.equal(Foo.Bar.toString(), 'Foo.Bar');
      obj = Foo.Bar.create();
      assert.equal(obj.toString(), '<Foo.Bar:' + (0, _utils.guidFor)(obj) + '>');
      Foo.Baz = Foo.Bar.extend();
      assert.equal(Foo.Baz.toString(), 'Foo.Baz');
      obj = Foo.Baz.create();
      assert.equal(obj.toString(), '<Foo.Baz:' + (0, _utils.guidFor)(obj) + '>');
      obj = Foo.Bar.create();
      assert.equal(obj.toString(), '<Foo.Bar:' + (0, _utils.guidFor)(obj) + '>');
      (0, _runloop.run)(Foo, 'destroy');
    };

    _proto['@test toString on a namespace finds the namespace in lookup'] = function testToStringOnANamespaceFindsTheNamespaceInLookup(assert) {
      var Foo = lookup.Foo = _namespace.default.create();

      assert.equal(Foo.toString(), 'Foo');
      (0, _runloop.run)(Foo, 'destroy');
    };

    _proto['@test toString on a namespace finds the namespace in lookup'] = function testToStringOnANamespaceFindsTheNamespaceInLookup(assert) {
      var Foo = lookup.Foo = _namespace.default.create();

      var obj;
      Foo.Bar = _object.default.extend();
      assert.equal(Foo.Bar.toString(), 'Foo.Bar');
      obj = Foo.Bar.create();
      assert.equal(obj.toString(), '<Foo.Bar:' + (0, _utils.guidFor)(obj) + '>');
      (0, _runloop.run)(Foo, 'destroy');
    };

    _proto['@test toString on a namespace falls back to modulePrefix, if defined'] = function testToStringOnANamespaceFallsBackToModulePrefixIfDefined(assert) {
      var Foo = _namespace.default.create({
        modulePrefix: 'foo'
      });

      assert.equal(Foo.toString(), 'foo');
      (0, _runloop.run)(Foo, 'destroy');
    };

    _proto['@test toString includes toStringExtension if defined'] = function testToStringIncludesToStringExtensionIfDefined(assert) {
      var Foo = _object.default.extend({
        toStringExtension: function () {
          return 'fooey';
        }
      });

      var foo = Foo.create();

      var Bar = _object.default.extend({});

      var bar = Bar.create(); // simulate these classes being defined on a Namespace

      (0, _utils.setName)(Foo, 'Foo');
      (0, _utils.setName)(Bar, 'Bar');
      assert.equal(bar.toString(), '<Bar:' + (0, _utils.guidFor)(bar) + '>', 'does not include toStringExtension part');
      assert.equal(foo.toString(), '<Foo:' + (0, _utils.guidFor)(foo) + ':fooey>', 'Includes toStringExtension result');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/runtime/tests/system/object_proxy_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/utils", "@ember/-internals/runtime/lib/system/object_proxy", "internal-test-helpers"], function (_emberBabel, _metal, _utils, _object_proxy, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('ObjectProxy',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test should not proxy properties passed to create'] = function testShouldNotProxyPropertiesPassedToCreate(assert) {
      var Proxy = _object_proxy.default.extend({
        cp: (0, _metal.computed)({
          get: function () {
            return this._cp;
          },
          set: function (key, value) {
            this._cp = value;
            return this._cp;
          }
        })
      });

      var proxy = Proxy.create({
        prop: 'Foo',
        cp: 'Bar'
      });
      assert.equal((0, _metal.get)(proxy, 'prop'), 'Foo', 'should not have tried to proxy set');
      assert.equal(proxy._cp, 'Bar', 'should use CP setter');
    };

    _proto['@test should proxy properties to content'] = function testShouldProxyPropertiesToContent(assert) {
      var content = {
        firstName: 'Tom',
        lastName: 'Dale',
        unknownProperty: function (key) {
          return key + ' unknown';
        }
      };

      var proxy = _object_proxy.default.create();

      assert.equal((0, _metal.get)(proxy, 'firstName'), undefined, 'get on proxy without content should return undefined');
      expectAssertion(function () {
        (0, _metal.set)(proxy, 'firstName', 'Foo');
      }, /Cannot delegate set\('firstName', Foo\) to the 'content'/i);
      (0, _metal.set)(proxy, 'content', content);
      assert.equal((0, _metal.get)(proxy, 'firstName'), 'Tom', 'get on proxy with content should forward to content');
      assert.equal((0, _metal.get)(proxy, 'lastName'), 'Dale', 'get on proxy with content should forward to content');
      assert.equal((0, _metal.get)(proxy, 'foo'), 'foo unknown', 'get on proxy with content should forward to content');
      (0, _metal.set)(proxy, 'lastName', 'Huda');
      assert.equal((0, _metal.get)(content, 'lastName'), 'Huda', 'content should have new value from set on proxy');
      assert.equal((0, _metal.get)(proxy, 'lastName'), 'Huda', 'proxy should have new value from set on proxy');
      (0, _metal.set)(proxy, 'content', {
        firstName: 'Yehuda',
        lastName: 'Katz'
      });
      assert.equal((0, _metal.get)(proxy, 'firstName'), 'Yehuda', 'proxy should reflect updated content');
      assert.equal((0, _metal.get)(proxy, 'lastName'), 'Katz', 'proxy should reflect updated content');
    };

    _proto['@test getting proxied properties with Ember.get should work'] = function testGettingProxiedPropertiesWithEmberGetShouldWork(assert) {
      var proxy = _object_proxy.default.create({
        content: {
          foo: 'FOO'
        }
      });

      assert.equal((0, _metal.get)(proxy, 'foo'), 'FOO');
    };

    _proto["@test JSON.stringify doens't assert"] = function (assert) {
      var proxy = _object_proxy.default.create({
        content: {
          foo: 'FOO'
        }
      });

      assert.equal(JSON.stringify(proxy), JSON.stringify({
        content: {
          foo: 'FOO'
        }
      }));
    };

    _proto['@test calling a function on the proxy avoids the assertion'] = function testCallingAFunctionOnTheProxyAvoidsTheAssertion(assert) {
      if (true
      /* DEBUG */
      && _utils.HAS_NATIVE_PROXY) {
        var proxy = _object_proxy.default.extend({
          init: function () {
            if (!this.foobar) {
              this.foobar = function () {
                var content = (0, _metal.get)(this, 'content');
                return content.foobar.apply(content, []);
              };
            }
          }
        }).create({
          content: {
            foobar: function () {
              return 'xoxo';
            }
          }
        });

        assert.equal(proxy.foobar(), 'xoxo', 'should be able to use a function from a proxy');
      } else {
        assert.expect(0);
      }
    };

    _proto["@test setting a property on the proxy avoids the assertion"] = function (assert) {
      var proxy = _object_proxy.default.create({
        toJSON: undefined,
        content: {
          toJSON: function () {
            return 'hello';
          }
        }
      });

      assert.equal(JSON.stringify(proxy), JSON.stringify({
        content: 'hello'
      }));
    };

    _proto["@test setting a property on the proxy's prototype avoids the assertion"] = function (assert) {
      var proxy = _object_proxy.default.extend({
        toJSON: null
      }).create({
        content: {
          toJSON: function () {
            return 'hello';
          }
        }
      });

      assert.equal(JSON.stringify(proxy), JSON.stringify({
        content: 'hello'
      }));
    };

    _proto['@test getting proxied properties with [] should be an error'] = function testGettingProxiedPropertiesWithShouldBeAnError(assert) {
      if (true
      /* DEBUG */
      && _utils.HAS_NATIVE_PROXY) {
        var proxy = _object_proxy.default.create({
          content: {
            foo: 'FOO'
          }
        });

        expectAssertion(function () {
          return proxy.foo;
        }, /\.get\('foo'\)/);
      } else {
        assert.expect(0);
      }
    };

    _proto['@test should work with watched properties'] =
    /*#__PURE__*/
    function () {
      var _testShouldWorkWithWatchedProperties = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var content1, content2, count, last, Proxy, proxy;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              content1 = {
                firstName: 'Tom',
                lastName: 'Dale'
              };
              content2 = {
                firstName: 'Yehuda',
                lastName: 'Katz'
              };
              count = 0;
              Proxy = _object_proxy.default.extend({
                fullName: (0, _metal.computed)('firstName', 'lastName', function () {
                  var firstName = this.get('firstName');
                  var lastName = this.get('lastName');

                  if (firstName && lastName) {
                    return firstName + ' ' + lastName;
                  }

                  return firstName || lastName;
                })
              });
              proxy = Proxy.create();
              (0, _metal.addObserver)(proxy, 'fullName', function () {
                last = (0, _metal.get)(proxy, 'fullName');
              }); // We need separate observers for each property for async observers

              (0, _metal.addObserver)(proxy, 'firstName', function () {
                count++;
              });
              (0, _metal.addObserver)(proxy, 'lastName', function () {
                count++;
              }); // proxy without content returns undefined

              assert.equal((0, _metal.get)(proxy, 'fullName'), undefined); // setting content causes all watched properties to change

              (0, _metal.set)(proxy, 'content', content1);
              _context.next = 12;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 12:
              // both dependent keys changed
              assert.equal(count, 2);
              assert.equal(last, 'Tom Dale'); // setting property in content causes proxy property to change

              (0, _metal.set)(content1, 'lastName', 'Huda');
              _context.next = 17;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 17:
              assert.equal(count, 3);
              assert.equal(last, 'Tom Huda'); // replacing content causes all watched properties to change

              (0, _metal.set)(proxy, 'content', content2);
              _context.next = 22;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 22:
              // both dependent keys changed
              assert.equal(count, 5);
              assert.equal(last, 'Yehuda Katz');

              if (!false
              /* EMBER_METAL_TRACKED_PROPERTIES */
              ) {
                  // content1 is no longer watched
                  assert.ok(!(0, _metal.isWatching)(content1, 'firstName'), 'not watching firstName');
                  assert.ok(!(0, _metal.isWatching)(content1, 'lastName'), 'not watching lastName');
                } // setting property in new content


              (0, _metal.set)(content2, 'firstName', 'Tomhuda');
              _context.next = 28;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 28:
              assert.equal(last, 'Tomhuda Katz');
              assert.equal(count, 6); // setting property in proxy syncs with new content

              (0, _metal.set)(proxy, 'lastName', 'Katzdale');
              _context.next = 33;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 33:
              assert.equal(count, 7);
              assert.equal(last, 'Tomhuda Katzdale');
              assert.equal((0, _metal.get)(content2, 'firstName'), 'Tomhuda');
              assert.equal((0, _metal.get)(content2, 'lastName'), 'Katzdale');

            case 37:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function testShouldWorkWithWatchedProperties(_x) {
        return _testShouldWorkWithWatchedProperties.apply(this, arguments);
      }

      return testShouldWorkWithWatchedProperties;
    }();

    _proto['@test set and get should work with paths'] =
    /*#__PURE__*/
    function () {
      var _testSetAndGetShouldWorkWithPaths = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        var content, proxy, count;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              content = {
                foo: {
                  bar: 'baz'
                }
              };
              proxy = _object_proxy.default.create({
                content: content
              });
              count = 0;
              proxy.set('foo.bar', 'hello');
              assert.equal(proxy.get('foo.bar'), 'hello');
              assert.equal(proxy.get('content.foo.bar'), 'hello');
              proxy.addObserver('foo.bar', function () {
                count++;
              });
              proxy.set('foo.bar', 'bye');
              _context2.next = 10;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 10:
              assert.equal(count, 1);
              assert.equal(proxy.get('foo.bar'), 'bye');
              assert.equal(proxy.get('content.foo.bar'), 'bye');

            case 13:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));

      function testSetAndGetShouldWorkWithPaths(_x2) {
        return _testSetAndGetShouldWorkWithPaths.apply(this, arguments);
      }

      return testSetAndGetShouldWorkWithPaths;
    }();

    _proto['@test should transition between watched and unwatched strategies'] =
    /*#__PURE__*/
    function () {
      var _testShouldTransitionBetweenWatchedAndUnwatchedStrategies = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(assert) {
        var content, proxy, count, observer;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              observer = function _ref() {
                count++;
              };

              content = {
                foo: 'foo'
              };
              proxy = _object_proxy.default.create({
                content: content
              });
              count = 0;
              assert.equal((0, _metal.get)(proxy, 'foo'), 'foo');
              (0, _metal.set)(content, 'foo', 'bar');
              assert.equal((0, _metal.get)(proxy, 'foo'), 'bar');
              (0, _metal.set)(proxy, 'foo', 'foo');
              assert.equal((0, _metal.get)(content, 'foo'), 'foo');
              assert.equal((0, _metal.get)(proxy, 'foo'), 'foo');
              (0, _metal.addObserver)(proxy, 'foo', observer);
              assert.equal(count, 0);
              assert.equal((0, _metal.get)(proxy, 'foo'), 'foo');
              (0, _metal.set)(content, 'foo', 'bar');
              _context3.next = 16;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 16:
              assert.equal(count, 1);
              assert.equal((0, _metal.get)(proxy, 'foo'), 'bar');
              (0, _metal.set)(proxy, 'foo', 'foo');
              _context3.next = 21;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 21:
              assert.equal(count, 2);
              assert.equal((0, _metal.get)(content, 'foo'), 'foo');
              assert.equal((0, _metal.get)(proxy, 'foo'), 'foo');
              (0, _metal.removeObserver)(proxy, 'foo', observer);
              (0, _metal.set)(content, 'foo', 'bar');
              assert.equal((0, _metal.get)(proxy, 'foo'), 'bar');
              (0, _metal.set)(proxy, 'foo', 'foo');
              assert.equal((0, _metal.get)(content, 'foo'), 'foo');
              assert.equal((0, _metal.get)(proxy, 'foo'), 'foo');

            case 30:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));

      function testShouldTransitionBetweenWatchedAndUnwatchedStrategies(_x3) {
        return _testShouldTransitionBetweenWatchedAndUnwatchedStrategies.apply(this, arguments);
      }

      return testShouldTransitionBetweenWatchedAndUnwatchedStrategies;
    }();

    _proto['@test setting `undefined` to a proxied content property should override its existing value'] = function testSettingUndefinedToAProxiedContentPropertyShouldOverrideItsExistingValue(assert) {
      var proxyObject = _object_proxy.default.create({
        content: {
          prop: 'emberjs'
        }
      });

      (0, _metal.set)(proxyObject, 'prop', undefined);
      assert.equal((0, _metal.get)(proxyObject, 'prop'), undefined, 'sets the `undefined` value to the proxied content');
    };

    _proto['@test should not throw or deprecate when adding an observer to an ObjectProxy based class'] = function testShouldNotThrowOrDeprecateWhenAddingAnObserverToAnObjectProxyBasedClass(assert) {
      assert.expect(0);

      _object_proxy.default.extend({
        observe: (0, _metal.observer)('foo', function () {})
      }).create();
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/utils/tests/cache_test", ["ember-babel", "@ember/-internals/utils", "internal-test-helpers"], function (_emberBabel, _utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Cache',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test basic'] = function testBasic(assert) {
      var cache = new _utils.Cache(100, function (key) {
        return key.toUpperCase();
      });
      assert.equal(cache.get('foo'), 'FOO');
      assert.equal(cache.get('bar'), 'BAR');
      assert.equal(cache.get('foo'), 'FOO');
    };

    _proto['@test explicit sets'] = function testExplicitSets(assert) {
      var cache = new _utils.Cache(100, function (key) {
        return key.toUpperCase();
      });
      assert.equal(cache.get('foo'), 'FOO');
      assert.equal(cache.set('foo', 'FOO!!!'), 'FOO!!!');
      assert.equal(cache.get('foo'), 'FOO!!!');
      assert.strictEqual(cache.set('foo', undefined), undefined);
      assert.strictEqual(cache.get('foo'), undefined);
    };

    _proto['@test caches computation correctly'] = function testCachesComputationCorrectly(assert) {
      var count = 0;
      var cache = new _utils.Cache(100, function (key) {
        count++;
        return key.toUpperCase();
      });
      assert.equal(count, 0);
      cache.get('foo');
      assert.equal(count, 1);
      cache.get('bar');
      assert.equal(count, 2);
      cache.get('bar');
      assert.equal(count, 2);
      cache.get('foo');
      assert.equal(count, 2);
    };

    _proto['@test handles undefined value correctly'] = function testHandlesUndefinedValueCorrectly(assert) {
      var count = 0;
      var cache = new _utils.Cache(100, function () {
        count++;
      });
      assert.equal(count, 0);
      assert.strictEqual(cache.get('foo'), undefined);
      assert.equal(count, 1);
      assert.strictEqual(cache.get('bar'), undefined);
      assert.equal(count, 2);
      assert.strictEqual(cache.get('bar'), undefined);
      assert.equal(count, 2);
      assert.strictEqual(cache.get('foo'), undefined);
      assert.equal(count, 2);
    };

    _proto['@test continues working after reaching cache limit'] = function testContinuesWorkingAfterReachingCacheLimit(assert) {
      var cache = new _utils.Cache(3, function (key) {
        return key.toUpperCase();
      });
      cache.get('a');
      cache.get('b');
      cache.get('c');
      assert.equal(cache.get('d'), 'D');
      assert.equal(cache.get('a'), 'A');
      assert.equal(cache.get('b'), 'B');
      assert.equal(cache.get('c'), 'C');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/utils/tests/can_invoke_test", ["ember-babel", "@ember/-internals/utils", "internal-test-helpers"], function (_emberBabel, _utils, _internalTestHelpers) {
  "use strict";

  var obj;
  (0, _internalTestHelpers.moduleFor)('Ember.canInvoke',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      var _this;

      _this = _TestCase.call(this) || this;
      obj = {
        foobar: 'foobar',
        aMethodThatExists: function () {}
      };
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      obj = undefined;
    };

    _proto["@test should return false if the object doesn't exist"] = function testShouldReturnFalseIfTheObjectDoesnTExist(assert) {
      assert.equal((0, _utils.canInvoke)(undefined, 'aMethodThatDoesNotExist'), false);
    };

    _proto['@test should return true for falsy values that have methods'] = function testShouldReturnTrueForFalsyValuesThatHaveMethods(assert) {
      assert.equal((0, _utils.canInvoke)(false, 'valueOf'), true);
      assert.equal((0, _utils.canInvoke)('', 'charAt'), true);
      assert.equal((0, _utils.canInvoke)(0, 'toFixed'), true);
    };

    _proto['@test should return true if the method exists on the object'] = function testShouldReturnTrueIfTheMethodExistsOnTheObject(assert) {
      assert.equal((0, _utils.canInvoke)(obj, 'aMethodThatExists'), true);
    };

    _proto["@test should return false if the method doesn't exist on the object"] = function testShouldReturnFalseIfTheMethodDoesnTExistOnTheObject(assert) {
      assert.equal((0, _utils.canInvoke)(obj, 'aMethodThatDoesNotExist'), false);
    };

    _proto['@test should return false if the property exists on the object but is a non-function'] = function testShouldReturnFalseIfThePropertyExistsOnTheObjectButIsANonFunction(assert) {
      assert.equal((0, _utils.canInvoke)(obj, 'foobar'), false);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/utils/tests/checkHasSuper_test", ["ember-babel", "@ember/-internals/browser-environment", "@ember/-internals/utils", "internal-test-helpers"], function (_emberBabel, _browserEnvironment, _utils, _internalTestHelpers) {
  "use strict";

  // Only run this test on browsers that we are certain should have function
  // source available.  This allows the test suite to continue to pass on other
  // platforms that correctly (for them) fall back to the "always wrap" code.
  if (_browserEnvironment.isChrome || _browserEnvironment.isFirefox) {
    (0, _internalTestHelpers.moduleFor)('checkHasSuper',
    /*#__PURE__*/
    function (_TestCase) {
      (0, _emberBabel.inheritsLoose)(_class, _TestCase);

      function _class() {
        return _TestCase.apply(this, arguments) || this;
      }

      var _proto = _class.prototype;

      _proto['@test does not super wrap needlessly [GH #12462]'] = function testDoesNotSuperWrapNeedlesslyGH12462(assert) {
        assert.notOk((0, _utils.checkHasSuper)(function () {}), 'empty function does not have super');
      };

      return _class;
    }(_internalTestHelpers.AbstractTestCase));
  }
});
enifed("@ember/-internals/utils/tests/generate_guid_test", ["ember-babel", "@ember/-internals/utils", "internal-test-helpers"], function (_emberBabel, _utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.generateGuid',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Prefix'] = function testPrefix(assert) {
      var a = {};
      assert.ok((0, _utils.generateGuid)(a, 'tyrell').indexOf('tyrell') > -1, 'guid can be prefixed');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/utils/tests/guid_for_test", ["ember-babel", "@ember/-internals/utils", "internal-test-helpers"], function (_emberBabel, _utils, _internalTestHelpers) {
  "use strict";

  function sameGuid(assert, a, b, message) {
    assert.equal((0, _utils.guidFor)(a), (0, _utils.guidFor)(b), message);
  }

  function diffGuid(assert, a, b, message) {
    assert.ok((0, _utils.guidFor)(a) !== (0, _utils.guidFor)(b), message);
  }

  function nanGuid(assert, obj) {
    var type = typeof obj;
    assert.ok(isNaN(parseInt((0, _utils.guidFor)(obj), 0)), 'guids for ' + type + "don't parse to numbers");
  }

  (0, _internalTestHelpers.moduleFor)('guidFor',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Object'] = function testObject(assert) {
      var a = {};
      var b = {};
      sameGuid(assert, a, a, 'same object always yields same guid');
      diffGuid(assert, a, b, 'different objects yield different guids');
      nanGuid(assert, a);
    };

    _proto['@test strings'] = function testStrings(assert) {
      var a = 'string A';
      var aprime = 'string A';
      var b = 'String B';
      sameGuid(assert, a, a, 'same string always yields same guid');
      sameGuid(assert, a, aprime, 'identical strings always yield the same guid');
      diffGuid(assert, a, b, 'different strings yield different guids');
      nanGuid(assert, a);
    };

    _proto['@test numbers'] = function testNumbers(assert) {
      var a = 23;
      var aprime = 23;
      var b = 34;
      sameGuid(assert, a, a, 'same numbers always yields same guid');
      sameGuid(assert, a, aprime, 'identical numbers always yield the same guid');
      diffGuid(assert, a, b, 'different numbers yield different guids');
      nanGuid(assert, a);
    };

    _proto['@test symbols'] = function testSymbols(assert) {
      if (_utils.HAS_NATIVE_SYMBOL) {
        assert.ok(true, 'symbols are not supported on this browser');
        return;
      }

      var a = Symbol('a');
      var b = Symbol('b');
      sameGuid(assert, a, a, 'same symbols always yields same guid');
      diffGuid(assert, a, b, 'different symbols yield different guids');
      nanGuid(assert, a);
    };

    _proto['@test booleans'] = function testBooleans(assert) {
      var a = true;
      var aprime = true;
      var b = false;
      sameGuid(assert, a, a, 'same booleans always yields same guid');
      sameGuid(assert, a, aprime, 'identical booleans always yield the same guid');
      diffGuid(assert, a, b, 'different boolean yield different guids');
      nanGuid(assert, a);
      nanGuid(assert, b);
    };

    _proto['@test null and undefined'] = function testNullAndUndefined(assert) {
      var a = null;
      var aprime = null;
      var b;
      sameGuid(assert, a, a, 'null always returns the same guid');
      sameGuid(assert, b, b, 'undefined always returns the same guid');
      sameGuid(assert, a, aprime, 'different nulls return the same guid');
      diffGuid(assert, a, b, 'null and undefined return different guids');
      nanGuid(assert, a);
      nanGuid(assert, b);
    };

    _proto['@test arrays'] = function testArrays(assert) {
      var a = ['a', 'b', 'c'];
      var aprime = ['a', 'b', 'c'];
      var b = ['1', '2', '3'];
      sameGuid(assert, a, a, 'same instance always yields same guid');
      diffGuid(assert, a, aprime, 'identical arrays always yield the same guid');
      diffGuid(assert, a, b, 'different arrays yield different guids');
      nanGuid(assert, a);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/utils/tests/inspect_test", ["ember-babel", "@ember/-internals/utils", "internal-test-helpers"], function (_emberBabel, _utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.inspect',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test strings'] = function testStrings(assert) {
      assert.equal((0, _utils.inspect)('foo'), '"foo"');
    };

    _proto['@test numbers'] = function testNumbers(assert) {
      assert.equal((0, _utils.inspect)(2.6), '2.6');
    };

    _proto['@test null'] = function testNull(assert) {
      assert.equal((0, _utils.inspect)(null), 'null');
    };

    _proto['@test undefined'] = function testUndefined(assert) {
      assert.equal((0, _utils.inspect)(undefined), 'undefined');
    };

    _proto['@test true'] = function testTrue(assert) {
      assert.equal((0, _utils.inspect)(true), 'true');
    };

    _proto['@test false'] = function testFalse(assert) {
      assert.equal((0, _utils.inspect)(false), 'false');
    };

    _proto['@test object'] = function testObject(assert) {
      assert.equal((0, _utils.inspect)({}), '{ }');
      assert.equal((0, _utils.inspect)({
        foo: 'bar'
      }), '{ foo: "bar" }');
      var obj = {
        foo: function () {
          return this;
        }
      }; // IE 11 doesn't have function name

      if (obj.foo.name) {
        assert.equal((0, _utils.inspect)(obj), "{ foo: [Function:foo] }");
      } else {
        assert.equal((0, _utils.inspect)(obj), "{ foo: [Function] }");
      }
    };

    _proto['@test objects without a prototype'] = function testObjectsWithoutAPrototype(assert) {
      var prototypelessObj = Object.create(null);
      prototypelessObj.a = 1;
      prototypelessObj.b = [Object.create(null)];
      assert.equal((0, _utils.inspect)({
        foo: prototypelessObj
      }), '{ foo: { a: 1, b: [ { } ] } }');
    };

    _proto['@test array'] = function testArray(assert) {
      assert.equal((0, _utils.inspect)([1, 2, 3]), '[ 1, 2, 3 ]');
    };

    _proto['@test array list limit'] = function testArrayListLimit(assert) {
      var a = [];

      for (var i = 0; i < 120; i++) {
        a.push(1);
      }

      assert.equal((0, _utils.inspect)(a), "[ " + a.slice(0, 100).join(', ') + ", ... 20 more items ]");
    };

    _proto['@test object list limit'] = function testObjectListLimit(assert) {
      var obj = {};
      var pairs = [];

      for (var i = 0; i < 120; i++) {
        obj['key' + i] = i;
        pairs.push("key" + i + ": " + i);
      }

      assert.equal((0, _utils.inspect)(obj), "{ " + pairs.slice(0, 100).join(', ') + ", ... 20 more keys }");
    };

    _proto['@test depth limit'] = function testDepthLimit(assert) {
      assert.equal((0, _utils.inspect)([[[['here', {
        a: 1
      }, [1]]]]]), '[ [ [ [ "here", [Object], [Array] ] ] ] ]');
    };

    _proto['@test odd key'] = function testOddKey(assert) {
      var _inspect;

      assert.equal((0, _utils.inspect)((_inspect = {}, _inspect["Hello world!\nHow are you?"] = 1, _inspect)), '{ "Hello world!\\nHow are you?": 1 }');
    };

    _proto['@test node call'] = function testNodeCall(assert) {
      var obj = {
        a: 1
      };
      obj.inspect = _utils.inspect;
      var depth = 2;
      var options = {};
      assert.equal(obj.inspect(depth, options), obj);
    };

    _proto['@test cycle'] = function testCycle(assert) {
      var obj = {};
      obj.a = obj;
      var arr = [obj];
      arr.push(arr);
      assert.equal((0, _utils.inspect)(arr), '[ { a: [Circular] }, [Circular] ]');
    };

    _proto['@test custom toString'] = function testCustomToString(assert) {
      var Component =
      /*#__PURE__*/
      function () {
        function Component() {}

        Component.toString = function toString() {
          return '@ember/component';
        };

        var _proto2 = Component.prototype;

        _proto2.toString = function toString() {
          return "<" + this.constructor + ":ember234>";
        };

        return Component;
      }();

      assert.equal((0, _utils.inspect)([new Component(), Component]), '[ <@ember/component:ember234>, @ember/component ]');
    };

    _proto['@test regexp'] = function testRegexp(assert) {
      assert.equal((0, _utils.inspect)(/regexp/), '/regexp/');
    };

    _proto['@test date'] = function testDate(assert) {
      var inspected = (0, _utils.inspect)(new Date('Sat Apr 30 2011 13:24:11'));
      assert.ok(inspected.match(/Sat Apr 30/), 'The inspected date has its date');
      assert.ok(inspected.match(/2011/), 'The inspected date has its year');
      assert.ok(inspected.match(/13:24:11/), 'The inspected date has its time');
    };

    _proto['@test inspect outputs the toString() representation of Symbols'] = function testInspectOutputsTheToStringRepresentationOfSymbols(assert) {
      if (_utils.HAS_NATIVE_SYMBOL) {
        var symbol = Symbol('test');
        assert.equal((0, _utils.inspect)(symbol), 'Symbol(test)');
      } else {
        assert.expect(0);
      }
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/utils/tests/is_proxy_test", ["ember-babel", "@ember/-internals/utils", "internal-test-helpers"], function (_emberBabel, _utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('@ember/-internals/utils isProxy',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test basic'] = function testBasic(assert) {
      var proxy = {};
      (0, _utils.setProxy)(proxy);
      assert.equal((0, _utils.isProxy)(proxy), true);
      assert.equal((0, _utils.isProxy)({}), false);
      assert.equal((0, _utils.isProxy)(undefined), false);
      assert.equal((0, _utils.isProxy)(null), false);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/utils/tests/make_array_test", ["ember-babel", "@ember/-internals/utils", "internal-test-helpers"], function (_emberBabel, _utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.makeArray',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test undefined'] = function testUndefined(assert) {
      assert.deepEqual((0, _utils.makeArray)(), []);
      assert.deepEqual((0, _utils.makeArray)(undefined), []);
    };

    _proto['@test null'] = function testNull(assert) {
      assert.deepEqual((0, _utils.makeArray)(null), []);
    };

    _proto['@test string'] = function testString(assert) {
      assert.deepEqual((0, _utils.makeArray)('lindsay'), ['lindsay']);
    };

    _proto['@test number'] = function testNumber(assert) {
      assert.deepEqual((0, _utils.makeArray)(0), [0]);
      assert.deepEqual((0, _utils.makeArray)(1), [1]);
    };

    _proto['@test array'] = function testArray(assert) {
      assert.deepEqual((0, _utils.makeArray)([1, 2, 42]), [1, 2, 42]);
    };

    _proto['@test true'] = function testTrue(assert) {
      assert.deepEqual((0, _utils.makeArray)(true), [true]);
    };

    _proto['@test false'] = function testFalse(assert) {
      assert.deepEqual((0, _utils.makeArray)(false), [false]);
    };

    _proto['@test object'] = function testObject(assert) {
      assert.deepEqual((0, _utils.makeArray)({}), [{}]);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/utils/tests/to-string-test", ["ember-babel", "@ember/-internals/utils", "internal-test-helpers"], function (_emberBabel, _utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('@ember/-internals/utils toString',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto["@test toString uses an object's toString method when available"] = function (assert) {
      var obj = {
        toString: function () {
          return 'bob';
        }
      };
      assert.strictEqual((0, _utils.toString)(obj), 'bob');
    };

    _proto['@test toString falls back to Object.prototype.toString'] = function testToStringFallsBackToObjectPrototypeToString(assert) {
      var obj = Object.create(null);
      assert.strictEqual((0, _utils.toString)(obj), {}.toString());
    };

    _proto['@test toString does not fail when called on Arrays with objects without toString method'] = function testToStringDoesNotFailWhenCalledOnArraysWithObjectsWithoutToStringMethod(assert) {
      var obj = Object.create(null);
      var arr = [obj, 2];
      assert.strictEqual((0, _utils.toString)(arr), {}.toString() + ",2");
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/utils/tests/trackable-object-test", ["ember-babel", "@ember/-internals/utils", "internal-test-helpers"], function (_emberBabel, _utils, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('@ember/-internals/utils Trackable Object',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test classes'] = function testClasses(assert) {
      var Test = function Test() {};

      Test.prototype[_utils.EMBER_ARRAY] = true;
      var instance = new Test();
      assert.equal((0, _utils.isEmberArray)(instance), true);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/-internals/utils/tests/try_invoke_test", ["ember-babel", "@ember/-internals/utils", "internal-test-helpers"], function (_emberBabel, _utils, _internalTestHelpers) {
  "use strict";

  var obj;
  (0, _internalTestHelpers.moduleFor)('Ember.tryInvoke',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      var _this;

      _this = _TestCase.call(this) || this;
      obj = {
        aMethodThatExists: function () {
          return true;
        },
        aMethodThatTakesArguments: function (arg1, arg2) {
          return arg1 === arg2;
        }
      };
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      obj = undefined;
    };

    _proto["@test should return undefined when the object doesn't exist"] = function testShouldReturnUndefinedWhenTheObjectDoesnTExist(assert) {
      assert.equal((0, _utils.tryInvoke)(undefined, 'aMethodThatDoesNotExist'), undefined);
    };

    _proto["@test should return undefined when asked to perform a method that doesn't exist on the object"] = function testShouldReturnUndefinedWhenAskedToPerformAMethodThatDoesnTExistOnTheObject(assert) {
      assert.equal((0, _utils.tryInvoke)(obj, 'aMethodThatDoesNotExist'), undefined);
    };

    _proto['@test should return what the method returns when asked to perform a method that exists on the object'] = function testShouldReturnWhatTheMethodReturnsWhenAskedToPerformAMethodThatExistsOnTheObject(assert) {
      assert.equal((0, _utils.tryInvoke)(obj, 'aMethodThatExists'), true);
    };

    _proto['@test should return what the method returns when asked to perform a method that takes arguments and exists on the object'] = function testShouldReturnWhatTheMethodReturnsWhenAskedToPerformAMethodThatTakesArgumentsAndExistsOnTheObject(assert) {
      assert.equal((0, _utils.tryInvoke)(obj, 'aMethodThatTakesArguments', [true, true]), true);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/application/tests/application_instance_test", ["ember-babel", "@ember/engine", "@ember/application", "@ember/application/instance", "@ember/runloop", "@ember/-internals/container", "internal-test-helpers", "@ember/-internals/runtime", "@ember/debug"], function (_emberBabel, _engine, _application, _instance, _runloop, _container, _internalTestHelpers, _runtime, _debug) {
  "use strict";

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["-bucket-cache:main"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  var originalDebug = (0, _debug.getDebugFunction)('debug');

  var noop = function () {};

  var application, appInstance;
  (0, _internalTestHelpers.moduleFor)('ApplicationInstance',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      var _this;

      (0, _debug.setDebugFunction)('debug', noop);
      _this = _TestCase.call(this) || this;
      document.getElementById('qunit-fixture').innerHTML = "\n      <div id='one'><div id='one-child'>HI</div></div><div id='two'>HI</div>\n    ";
      application = (0, _runloop.run)(function () {
        return _application.default.create({
          rootElement: '#one',
          router: null
        });
      });
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _debug.setDebugFunction)('debug', originalDebug);

      if (appInstance) {
        (0, _runloop.run)(appInstance, 'destroy');
        appInstance = null;
      }

      if (application) {
        (0, _runloop.run)(application, 'destroy');
        application = null;
      }

      document.getElementById('qunit-fixture').innerHTML = '';
    };

    _proto['@test an application instance can be created based upon an application'] = function testAnApplicationInstanceCanBeCreatedBasedUponAnApplication(assert) {
      appInstance = (0, _runloop.run)(function () {
        return _instance.default.create({
          application: application
        });
      });
      assert.ok(appInstance, 'instance should be created');
      assert.equal(appInstance.application, application, 'application should be set to parent');
    };

    _proto['@test customEvents added to the application before setupEventDispatcher'] = function testCustomEventsAddedToTheApplicationBeforeSetupEventDispatcher(assert) {
      assert.expect(1);
      appInstance = (0, _runloop.run)(function () {
        return _instance.default.create({
          application: application
        });
      });
      appInstance.setupRegistry();
      application.customEvents = {
        awesome: 'sauce'
      };
      var eventDispatcher = appInstance.lookup('event_dispatcher:main');

      eventDispatcher.setup = function (events) {
        assert.equal(events.awesome, 'sauce');
      };

      appInstance.setupEventDispatcher();
    };

    _proto['@test customEvents added to the application before setupEventDispatcher'] = function testCustomEventsAddedToTheApplicationBeforeSetupEventDispatcher(assert) {
      assert.expect(1);
      appInstance = (0, _runloop.run)(function () {
        return _instance.default.create({
          application: application
        });
      });
      appInstance.setupRegistry();
      application.customEvents = {
        awesome: 'sauce'
      };
      var eventDispatcher = appInstance.lookup('event_dispatcher:main');

      eventDispatcher.setup = function (events) {
        assert.equal(events.awesome, 'sauce');
      };

      appInstance.setupEventDispatcher();
    };

    _proto['@test customEvents added to the application instance before setupEventDispatcher'] = function testCustomEventsAddedToTheApplicationInstanceBeforeSetupEventDispatcher(assert) {
      assert.expect(1);
      appInstance = (0, _runloop.run)(function () {
        return _instance.default.create({
          application: application
        });
      });
      appInstance.setupRegistry();
      appInstance.customEvents = {
        awesome: 'sauce'
      };
      var eventDispatcher = appInstance.lookup('event_dispatcher:main');

      eventDispatcher.setup = function (events) {
        assert.equal(events.awesome, 'sauce');
      };

      appInstance.setupEventDispatcher();
    };

    _proto['@test unregistering a factory clears all cached instances of that factory'] = function testUnregisteringAFactoryClearsAllCachedInstancesOfThatFactory(assert) {
      assert.expect(5);
      appInstance = (0, _runloop.run)(function () {
        return _instance.default.create({
          application: application
        });
      });
      var PostController1 = (0, _internalTestHelpers.factory)();
      var PostController2 = (0, _internalTestHelpers.factory)();
      appInstance.register('controller:post', PostController1);
      var postController1 = appInstance.lookup('controller:post');
      var postController1Factory = appInstance.factoryFor('controller:post');
      assert.ok(postController1 instanceof PostController1, 'precond - lookup creates instance');
      assert.equal(PostController1, postController1Factory.class, 'precond - factoryFor().class matches');
      appInstance.unregister('controller:post');
      appInstance.register('controller:post', PostController2);
      var postController2 = appInstance.lookup('controller:post');
      var postController2Factory = appInstance.factoryFor('controller:post');
      assert.ok(postController2 instanceof PostController2, 'lookup creates instance');
      assert.equal(PostController2, postController2Factory.class, 'factoryFor().class matches');
      assert.notStrictEqual(postController1, postController2, 'lookup creates a brand new instance, because the previous one was reset');
    };

    _proto['@skip unregistering a factory clears caches with source of that factory'] = function skipUnregisteringAFactoryClearsCachesWithSourceOfThatFactory(assert) {
      assert.expect(1);
      appInstance = (0, _runloop.run)(function () {
        return _instance.default.create({
          application: application
        });
      });
      var PostController1 = (0, _internalTestHelpers.factory)();
      var PostController2 = (0, _internalTestHelpers.factory)();
      appInstance.register('controller:post', PostController1);
      appInstance.lookup('controller:post');
      var postControllerLookupWithSource = appInstance.lookup('controller:post', {
        source: 'doesnt-even-matter'
      });
      appInstance.unregister('controller:post');
      appInstance.register('controller:post', PostController2); // The cache that is source-specific is not cleared

      assert.ok(postControllerLookupWithSource !== appInstance.lookup('controller:post', {
        source: 'doesnt-even-matter'
      }), 'lookup with source creates a new instance');
    };

    _proto['@test can build and boot a registered engine'] = function testCanBuildAndBootARegisteredEngine(assert) {
      assert.expect(11);

      var ChatEngine = _engine.default.extend();

      var chatEngineInstance;
      application.register('engine:chat', ChatEngine);
      (0, _runloop.run)(function () {
        appInstance = _instance.default.create({
          application: application
        });
        appInstance.setupRegistry();
        chatEngineInstance = appInstance.buildChildEngineInstance('chat');
      });
      return chatEngineInstance.boot().then(function () {
        assert.ok(true, 'boot successful');
        var registrations = ['route:basic', 'service:-routing', 'service:-glimmer-environment'];
        registrations.forEach(function (key) {
          assert.strictEqual(chatEngineInstance.resolveRegistration(key), appInstance.resolveRegistration(key), "Engine and parent app share registrations for '" + key + "'");
        });
        var singletons = ['router:main', (0, _container.privatize)(_templateObject()), '-view-registry:main', '-environment:main', 'service:-document', 'event_dispatcher:main'];
        var env = appInstance.lookup('-environment:main');
        singletons.push(env.isInteractive ? 'renderer:-dom' : 'renderer:-inert');
        singletons.forEach(function (key) {
          assert.strictEqual(chatEngineInstance.lookup(key), appInstance.lookup(key), "Engine and parent app share singleton '" + key + "'");
        });
      });
    };

    _proto['@test can build a registry via ApplicationInstance.setupRegistry() -- simulates ember-test-helpers'] = function testCanBuildARegistryViaApplicationInstanceSetupRegistrySimulatesEmberTestHelpers(assert) {
      var namespace = _runtime.Object.create({
        Resolver: {
          create: function () {}
        }
      });

      var registry = _application.default.buildRegistry(namespace);

      _instance.default.setupRegistry(registry);

      assert.equal(registry.resolve('service:-document'), document);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/application/tests/application_test", ["ember-babel", "ember/version", "@ember/-internals/environment", "@ember/-internals/metal", "@ember/debug", "@ember/-internals/routing", "@ember/-internals/views", "@ember/application", "@ember/controller", "@ember/-internals/runtime", "@ember/-internals/glimmer", "@ember/-internals/container", "@ember/polyfills", "internal-test-helpers", "@ember/runloop"], function (_emberBabel, _version, _environment, _metal, _debug, _routing, _views, _application, _controller, _runtime, _glimmer, _container, _polyfills, _internalTestHelpers, _runloop) {
  "use strict";

  function _templateObject5() {
    const data = _taggedTemplateLiteralLoose(["template-compiler:main"]);

    _templateObject5 = function () {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    const data = _taggedTemplateLiteralLoose(["template:components/-default"]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["-bucket-cache:main"]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["-bucket-cache:main"]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["-bucket-cache:main"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  (0, _internalTestHelpers.moduleFor)('Application, autobooting multiple apps',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.createSecondApplication = function createSecondApplication(options) {
      var myOptions = (0, _polyfills.assign)(this.applicationOptions, options);
      return this.secondApp = _application.default.create(myOptions);
    };

    _proto.teardown = function teardown() {
      var _this = this;

      _ApplicationTestCase.prototype.teardown.call(this);

      if (this.secondApp) {
        (0, _internalTestHelpers.runTask)(function () {
          return _this.secondApp.destroy();
        });
      }
    };

    _proto["@test you can make a new application in a non-overlapping element"] = function (assert) {
      var _this2 = this;

      var app = (0, _internalTestHelpers.runTask)(function () {
        return _this2.createSecondApplication({
          rootElement: '#two'
        });
      });
      (0, _internalTestHelpers.runTask)(function () {
        return app.destroy();
      });
      assert.ok(true, 'should not raise');
    };

    _proto["@test you cannot make a new application that is a parent of an existing application"] = function () {
      var _this3 = this;

      expectAssertion(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this3.createSecondApplication({
            rootElement: _this3.applicationOptions.rootElement
          });
        });
      });
    };

    _proto["@test you cannot make a new application that is a descendant of an existing application"] = function () {
      var _this4 = this;

      expectAssertion(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this4.createSecondApplication({
            rootElement: '#one-child'
          });
        });
      });
    };

    _proto["@test you cannot make a new application that is a duplicate of an existing application"] = function () {
      var _this5 = this;

      expectAssertion(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this5.createSecondApplication({
            rootElement: '#one'
          });
        });
      });
    };

    _proto["@test you cannot make two default applications without a rootElement error"] = function () {
      var _this6 = this;

      expectAssertion(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this6.createSecondApplication();
        });
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "fixture",
      get: function () {
        return "\n      <div id=\"one\">\n        <div id=\"one-child\">HI</div>\n      </div>\n      <div id=\"two\">HI</div>\n    ";
      }
    }, {
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_ApplicationTestCase.prototype.applicationOptions, {
          rootElement: '#one',
          router: null,
          autoboot: true
        });
      }
    }]);
    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application',
  /*#__PURE__*/
  function (_ApplicationTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase2);

    function _class2() {
      return _ApplicationTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2["@test builds a registry"] = function (assert) {
      var application = this.application;
      assert.strictEqual(application.resolveRegistration('application:main'), application, "application:main is registered");
      assert.deepEqual(application.registeredOptionsForType('component'), {
        singleton: false
      }, "optionsForType 'component'");
      assert.deepEqual(application.registeredOptionsForType('view'), {
        singleton: false
      }, "optionsForType 'view'");
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'controller:basic');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, '-view-registry:main');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'view', '_viewRegistry', '-view-registry:main');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'route', '_topLevelViewTemplate', 'template:-outlet');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'route:basic');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'event_dispatcher:main');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'router:main', 'namespace', 'application:main');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'view:-outlet', 'namespace', 'application:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'location:auto');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'location:hash');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'location:history');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'location:none');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'controller', 'target', 'router:main');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'controller', 'namespace', 'application:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, (0, _container.privatize)(_templateObject()));
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'router', '_bucketCache', (0, _container.privatize)(_templateObject2()));
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'route', '_bucketCache', (0, _container.privatize)(_templateObject3()));
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'route', '_router', 'router:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'component:-text-field');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'component:-checkbox');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'component:link-to');

      if (true
      /* EMBER_GLIMMER_ANGLE_BRACKET_BUILT_INS */
      ) {
          (0, _internalTestHelpers.verifyRegistration)(assert, application, 'component:textarea');
        } else {
        (0, _internalTestHelpers.verifyRegistration)(assert, application, 'component:-text-area');
      }

      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'service:-routing');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'service:-routing', 'router', 'router:main'); // DEBUGGING

      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'resolver-for-debugging:main');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'container-debug-adapter:main', 'resolver', 'resolver-for-debugging:main');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'data-adapter:main', 'containerDebugAdapter', 'container-debug-adapter:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'container-debug-adapter:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'component-lookup:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'service:-glimmer-environment');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'service:-dom-changes');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'service:-dom-tree-construction');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'service:-glimmer-environment', 'appendOperations', 'service:-dom-tree-construction');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'service:-glimmer-environment', 'updateOperations', 'service:-dom-changes');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'renderer', 'env', 'service:-glimmer-environment');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'view:-outlet');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'renderer:-dom');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'renderer:-inert');
      (0, _internalTestHelpers.verifyRegistration)(assert, application, (0, _container.privatize)(_templateObject4()));
      (0, _internalTestHelpers.verifyRegistration)(assert, application, 'template:-outlet');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'view:-outlet', 'template', 'template:-outlet');
      (0, _internalTestHelpers.verifyInjection)(assert, application, 'template', 'compiler', (0, _container.privatize)(_templateObject5()));
      assert.deepEqual(application.registeredOptionsForType('helper'), {
        instantiate: false
      }, "optionsForType 'helper'");
    };

    return _class2;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application, default resolver with autoboot',
  /*#__PURE__*/
  function (_DefaultResolverAppli) {
    (0, _emberBabel.inheritsLoose)(_class3, _DefaultResolverAppli);

    function _class3() {
      var _this7;

      _this7 = _DefaultResolverAppli.apply(this, arguments) || this;
      _this7.originalLookup = _environment.context.lookup;
      return _this7;
    }

    var _proto3 = _class3.prototype;

    _proto3.teardown = function teardown() {
      _environment.context.lookup = this.originalLookup;

      _DefaultResolverAppli.prototype.teardown.call(this);

      (0, _glimmer.setTemplates)({});
    };

    _proto3["@test acts like a namespace"] = function (assert) {
      var _this8 = this;

      this.application = (0, _internalTestHelpers.runTask)(function () {
        return _this8.createApplication();
      });

      var Foo = this.application.Foo = _runtime.Object.extend();

      assert.equal(Foo.toString(), 'TestApp.Foo', 'Classes pick up their parent namespace');
    };

    _proto3["@test can specify custom router"] = function (assert) {
      var _this9 = this;

      var MyRouter = _routing.Router.extend();

      (0, _internalTestHelpers.runTask)(function () {
        _this9.createApplication();

        _this9.application.Router = MyRouter;
      });
      assert.ok(this.application.__deprecatedInstance__.lookup('router:main') instanceof MyRouter, 'application resolved the correct router');
    };

    _proto3["@test Minimal Application initialized with just an application template"] = function () {
      var _this10 = this;

      this.setupFixture('<script type="text/x-handlebars">Hello World</script>');
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.createApplication();
      });
      this.assertInnerHTML('Hello World');
    };

    (0, _emberBabel.createClass)(_class3, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_DefaultResolverAppli.prototype.applicationOptions, {
          autoboot: true
        });
      }
    }]);
    return _class3;
  }(_internalTestHelpers.DefaultResolverApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application, autobooting',
  /*#__PURE__*/
  function (_AutobootApplicationT) {
    (0, _emberBabel.inheritsLoose)(_class4, _AutobootApplicationT);

    function _class4() {
      var _this11;

      _this11 = _AutobootApplicationT.apply(this, arguments) || this;
      _this11.originalLogVersion = _environment.ENV.LOG_VERSION;
      _this11.originalDebug = (0, _debug.getDebugFunction)('debug');
      _this11.originalWarn = (0, _debug.getDebugFunction)('warn');
      return _this11;
    }

    var _proto4 = _class4.prototype;

    _proto4.teardown = function teardown() {
      (0, _debug.setDebugFunction)('warn', this.originalWarn);
      (0, _debug.setDebugFunction)('debug', this.originalDebug);
      _environment.ENV.LOG_VERSION = this.originalLogVersion;

      _AutobootApplicationT.prototype.teardown.call(this);
    };

    _proto4["@test initialized application goes to initial route"] = function () {
      var _this12 = this;

      (0, _internalTestHelpers.runTask)(function () {
        _this12.createApplication();

        _this12.addTemplate('application', '{{outlet}}');

        _this12.addTemplate('index', '<h1>Hi from index</h1>');
      });
      this.assertText('Hi from index');
    };

    _proto4["@test ready hook is called before routing begins"] = function (assert) {
      var _this13 = this;

      assert.expect(2);
      (0, _internalTestHelpers.runTask)(function () {
        function registerRoute(application, name, callback) {
          var route = _routing.Route.extend({
            activate: callback
          });

          application.register('route:' + name, route);
        }

        var MyApplication = _application.default.extend({
          ready: function () {
            registerRoute(this, 'index', function () {
              assert.ok(true, 'last-minute route is activated');
            });
          }
        });

        var app = _this13.createApplication({}, MyApplication);

        registerRoute(app, 'application', function () {
          return assert.ok(true, 'normal route is activated');
        });
      });
    };

    _proto4["@test initialize application via initialize call"] = function (assert) {
      var _this14 = this;

      (0, _internalTestHelpers.runTask)(function () {
        return _this14.createApplication();
      }); // This is not a public way to access the container; we just
      // need to make some assertions about the created router

      var router = this.applicationInstance.lookup('router:main');
      assert.equal(router instanceof _routing.Router, true, 'Router was set from initialize call');
      assert.equal(router.location instanceof _routing.NoneLocation, true, 'Location was set from location implementation name');
    };

    _proto4["@test initialize application with stateManager via initialize call from Router class"] = function (assert) {
      var _this15 = this;

      (0, _internalTestHelpers.runTask)(function () {
        _this15.createApplication();

        _this15.addTemplate('application', '<h1>Hello!</h1>');
      }); // This is not a public way to access the container; we just
      // need to make some assertions about the created router

      var router = this.application.__deprecatedInstance__.lookup('router:main');

      assert.equal(router instanceof _routing.Router, true, 'Router was set from initialize call');
      this.assertText('Hello!');
    };

    _proto4["@test Application Controller backs the appplication template"] = function () {
      var _this16 = this;

      (0, _internalTestHelpers.runTask)(function () {
        _this16.createApplication();

        _this16.addTemplate('application', '<h1>{{greeting}}</h1>');

        _this16.add('controller:application', _controller.default.extend({
          greeting: 'Hello!'
        }));
      });
      this.assertText('Hello!');
    };

    _proto4["@test enable log of libraries with an ENV var"] = function (assert) {
      var _this17 = this;

      if (EmberDev && EmberDev.runningProdBuild) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }

      var messages = [];
      _environment.ENV.LOG_VERSION = true;
      (0, _debug.setDebugFunction)('debug', function (message) {
        return messages.push(message);
      });

      _metal.libraries.register('my-lib', '2.0.0a');

      (0, _internalTestHelpers.runTask)(function () {
        return _this17.createApplication();
      });
      assert.equal(messages[1], 'Ember  : ' + _version.default);

      if (_views.jQueryDisabled) {
        assert.equal(messages[2], 'my-lib : ' + '2.0.0a');
      } else {
        assert.equal(messages[2], 'jQuery : ' + (0, _views.jQuery)().jquery);
        assert.equal(messages[3], 'my-lib : ' + '2.0.0a');
      }

      _metal.libraries.deRegister('my-lib');
    };

    _proto4["@test disable log of version of libraries with an ENV var"] = function (assert) {
      var _this18 = this;

      var logged = false;
      _environment.ENV.LOG_VERSION = false;
      (0, _debug.setDebugFunction)('debug', function () {
        return logged = true;
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this18.createApplication();
      });
      assert.ok(!logged, 'library version logging skipped');
    };

    _proto4["@test can resolve custom router"] = function (assert) {
      var _this19 = this;

      var CustomRouter = _routing.Router.extend();

      (0, _internalTestHelpers.runTask)(function () {
        _this19.createApplication();

        _this19.add('router:main', CustomRouter);
      });
      assert.ok(this.application.__deprecatedInstance__.lookup('router:main') instanceof CustomRouter, 'application resolved the correct router');
    };

    _proto4["@test does not leak itself in onLoad._loaded"] = function (assert) {
      var _this20 = this;

      assert.equal(_application._loaded.application, undefined);
      (0, _internalTestHelpers.runTask)(function () {
        return _this20.createApplication();
      });
      assert.equal(_application._loaded.application, this.application);
      (0, _internalTestHelpers.runTask)(function () {
        return _this20.application.destroy();
      });
      assert.equal(_application._loaded.application, undefined);
    };

    _proto4["@test can build a registry via Application.buildRegistry() --- simulates ember-test-helpers"] = function (assert) {
      var namespace = _runtime.Object.create({
        Resolver: {
          create: function () {}
        }
      });

      var registry = _application.default.buildRegistry(namespace);

      assert.equal(registry.resolve('application:main'), namespace);
    };

    return _class4;
  }(_internalTestHelpers.AutobootApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application#buildRegistry',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class5, _AbstractTestCase);

    function _class5() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto5 = _class5.prototype;

    _proto5["@test can build a registry via Application.buildRegistry() --- simulates ember-test-helpers"] = function (assert) {
      var namespace = _runtime.Object.create({
        Resolver: {
          create: function () {}
        }
      });

      var registry = _application.default.buildRegistry(namespace);

      assert.equal(registry.resolve('application:main'), namespace);
    };

    return _class5;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Application - instance tracking',
  /*#__PURE__*/
  function (_ApplicationTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class6, _ApplicationTestCase3);

    function _class6() {
      return _ApplicationTestCase3.apply(this, arguments) || this;
    }

    var _proto6 = _class6.prototype;

    _proto6['@test tracks built instance'] = function testTracksBuiltInstance(assert) {
      var _this21 = this;

      var instance = this.application.buildInstance();
      (0, _runloop.run)(function () {
        _this21.application.destroy();
      });
      assert.ok(instance.isDestroyed, 'instance was destroyed');
    };

    _proto6['@test tracks built instances'] = function testTracksBuiltInstances(assert) {
      var _this22 = this;

      var instanceA = this.application.buildInstance();
      var instanceB = this.application.buildInstance();
      (0, _runloop.run)(function () {
        _this22.application.destroy();
      });
      assert.ok(instanceA.isDestroyed, 'instanceA was destroyed');
      assert.ok(instanceB.isDestroyed, 'instanceB was destroyed');
    };

    return _class6;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/application/tests/bootstrap-test", ["ember-babel", "@ember/polyfills", "internal-test-helpers"], function (_emberBabel, _polyfills, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application with default resolver and autoboot',
  /*#__PURE__*/
  function (_DefaultResolverAppli) {
    (0, _emberBabel.inheritsLoose)(_class, _DefaultResolverAppli);

    function _class() {
      return _DefaultResolverAppli.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test templates in script tags are extracted at application creation'] = function testTemplatesInScriptTagsAreExtractedAtApplicationCreation(assert) {
      var _this = this;

      (0, _internalTestHelpers.runTask)(function () {
        return _this.createApplication();
      });
      assert.equal(document.getElementById('app').textContent, 'Hello World!');
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "fixture",
      get: function () {
        return "\n      <div id=\"app\"></div>\n\n      <script type=\"text/x-handlebars\">Hello {{outlet}}</script>\n      <script type=\"text/x-handlebars\" id=\"index\">World!</script>\n    ";
      }
    }, {
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_DefaultResolverAppli.prototype.applicationOptions, {
          autoboot: true,
          rootElement: '#app'
        });
      }
    }]);
    return _class;
  }(_internalTestHelpers.DefaultResolverApplicationTestCase));
});
enifed("@ember/application/tests/dependency_injection/custom_resolver_test", ["ember-babel", "@ember/application/globals-resolver", "@ember/polyfills", "internal-test-helpers"], function (_emberBabel, _globalsResolver, _polyfills, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application with extended default resolver and autoboot',
  /*#__PURE__*/
  function (_DefaultResolverAppli) {
    (0, _emberBabel.inheritsLoose)(_class, _DefaultResolverAppli);

    function _class() {
      return _DefaultResolverAppli.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto["@test a resolver can be supplied to application"] = function () {
      var _this = this;

      (0, _internalTestHelpers.runTask)(function () {
        return _this.createApplication();
      });
      this.assertText('Fallback');
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "applicationOptions",
      get: function () {
        var applicationTemplate = this.compile("<h1>Fallback</h1>");

        var Resolver = _globalsResolver.default.extend({
          resolveTemplate: function (resolvable) {
            if (resolvable.fullNameWithoutType === 'application') {
              return applicationTemplate;
            } else {
              return this._super(resolvable);
            }
          }
        });

        return (0, _polyfills.assign)(_DefaultResolverAppli.prototype.applicationOptions, {
          Resolver: Resolver,
          autoboot: true
        });
      }
    }]);
    return _class;
  }(_internalTestHelpers.DefaultResolverApplicationTestCase));
});
enifed("@ember/application/tests/dependency_injection/default_resolver_test", ["ember-babel", "internal-test-helpers", "@ember/-internals/environment", "@ember/controller", "@ember/service", "@ember/-internals/runtime", "@ember/-internals/routing", "@ember/-internals/glimmer", "@ember/debug"], function (_emberBabel, _internalTestHelpers, _environment, _controller, _service, _runtime, _routing, _glimmer, _debug) {
  "use strict";

  /* globals EmberDev */
  (0, _internalTestHelpers.moduleFor)('Application Dependency Injection - Integration - default resolver',
  /*#__PURE__*/
  function (_DefaultResolverAppli) {
    (0, _emberBabel.inheritsLoose)(_class, _DefaultResolverAppli);

    function _class() {
      return _DefaultResolverAppli.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      var _this = this;

      (0, _internalTestHelpers.runTask)(function () {
        return _this.createApplication();
      });
      return this.visit('/');
    };
    /*
     * This first batch of tests are integration tests against the public
     * applicationInstance API.
     */


    _proto["@test the default resolver looks up templates in Ember.TEMPLATES"] = function (assert) {
      var fooTemplate = this.addTemplate('foo', "foo template");
      var fooBarTemplate = this.addTemplate('fooBar', "fooBar template");
      var fooBarBazTemplate = this.addTemplate('fooBar/baz', "fooBar/baz template");
      assert.equal(this.applicationInstance.factoryFor('template:foo').class, fooTemplate, 'resolves template:foo');
      assert.equal(this.applicationInstance.factoryFor('template:fooBar').class, fooBarTemplate, 'resolves template:foo_bar');
      assert.equal(this.applicationInstance.factoryFor('template:fooBar.baz').class, fooBarBazTemplate, 'resolves template:foo_bar.baz');
    };

    _proto["@test the default resolver looks up basic name as no prefix"] = function (assert) {
      var instance = this.applicationInstance.lookup('controller:basic');
      assert.ok(_controller.default.detect(instance), 'locator looks up correct controller');
    };

    _proto["@test the default resolver looks up arbitrary types on the namespace"] = function (assert) {
      var Class = this.application.FooManager = _runtime.Object.extend();

      var resolvedClass = this.application.resolveRegistration('manager:foo');
      assert.equal(Class, resolvedClass, 'looks up FooManager on application');
    };

    _proto["@test the default resolver resolves models on the namespace"] = function (assert) {
      var Class = this.application.Post = _runtime.Object.extend();

      var factoryClass = this.applicationInstance.factoryFor('model:post').class;
      assert.equal(Class, factoryClass, 'looks up Post model on application');
    };

    _proto["@test the default resolver resolves *:main on the namespace"] = function (assert) {
      var Class = this.application.FooBar = _runtime.Object.extend();

      var factoryClass = this.applicationInstance.factoryFor('foo-bar:main').class;
      assert.equal(Class, factoryClass, 'looks up FooBar type without name on application');
    };

    _proto["@test the default resolver resolves container-registered helpers"] = function (assert) {
      var shorthandHelper = (0, _glimmer.helper)(function () {});

      var helper = _glimmer.Helper.extend();

      this.application.register('helper:shorthand', shorthandHelper);
      this.application.register('helper:complete', helper);
      var lookedUpShorthandHelper = this.applicationInstance.factoryFor('helper:shorthand').class;
      assert.ok(lookedUpShorthandHelper.isHelperFactory, 'shorthand helper isHelper');
      var lookedUpHelper = this.applicationInstance.factoryFor('helper:complete').class;
      assert.ok(lookedUpHelper.isHelperFactory, 'complete helper is factory');
      assert.ok(helper.detect(lookedUpHelper), 'looked up complete helper');
    };

    _proto["@test the default resolver resolves container-registered helpers via lookupFor"] = function (assert) {
      var shorthandHelper = (0, _glimmer.helper)(function () {});

      var helper = _glimmer.Helper.extend();

      this.application.register('helper:shorthand', shorthandHelper);
      this.application.register('helper:complete', helper);
      var lookedUpShorthandHelper = this.applicationInstance.factoryFor('helper:shorthand').class;
      assert.ok(lookedUpShorthandHelper.isHelperFactory, 'shorthand helper isHelper');
      var lookedUpHelper = this.applicationInstance.factoryFor('helper:complete').class;
      assert.ok(lookedUpHelper.isHelperFactory, 'complete helper is factory');
      assert.ok(helper.detect(lookedUpHelper), 'looked up complete helper');
    };

    _proto["@test the default resolver resolves helpers on the namespace"] = function (assert) {
      var ShorthandHelper = (0, _glimmer.helper)(function () {});

      var CompleteHelper = _glimmer.Helper.extend();

      this.application.ShorthandHelper = ShorthandHelper;
      this.application.CompleteHelper = CompleteHelper;
      var resolvedShorthand = this.application.resolveRegistration('helper:shorthand');
      var resolvedComplete = this.application.resolveRegistration('helper:complete');
      assert.equal(resolvedShorthand, ShorthandHelper, 'resolve fetches the shorthand helper factory');
      assert.equal(resolvedComplete, CompleteHelper, 'resolve fetches the complete helper factory');
    };

    _proto["@test the default resolver resolves to the same instance, no matter the notation "] = function (assert) {
      this.application.NestedPostController = _controller.default.extend({});
      assert.equal(this.applicationInstance.lookup('controller:nested-post'), this.applicationInstance.lookup('controller:nested_post'), 'looks up NestedPost controller on application');
    };

    _proto["@test the default resolver throws an error if the fullName to resolve is invalid"] = function () {
      var _this2 = this;

      expectAssertion(function () {
        _this2.applicationInstance.resolveRegistration(undefined);
      }, /fullName must be a proper full name/);
      expectAssertion(function () {
        _this2.applicationInstance.resolveRegistration(null);
      }, /fullName must be a proper full name/);
      expectAssertion(function () {
        _this2.applicationInstance.resolveRegistration('');
      }, /fullName must be a proper full name/);
      expectAssertion(function () {
        _this2.applicationInstance.resolveRegistration('');
      }, /fullName must be a proper full name/);
      expectAssertion(function () {
        _this2.applicationInstance.resolveRegistration(':');
      }, /fullName must be a proper full name/);
      expectAssertion(function () {
        _this2.applicationInstance.resolveRegistration('model');
      }, /fullName must be a proper full name/);
      expectAssertion(function () {
        _this2.applicationInstance.resolveRegistration('model:');
      }, /fullName must be a proper full name/);
      expectAssertion(function () {
        _this2.applicationInstance.resolveRegistration(':type');
      }, /fullName must be a proper full name/);
    }
    /*
     * The following are integration tests against the private registry API.
     */
    ;

    _proto["@test lookup description"] = function (assert) {
      this.application.toString = function () {
        return 'App';
      };

      assert.equal(this.privateRegistry.describe('controller:foo'), 'App.FooController', 'Type gets appended at the end');
      assert.equal(this.privateRegistry.describe('controller:foo.bar'), 'App.FooBarController', 'dots are removed');
      assert.equal(this.privateRegistry.describe('model:foo'), 'App.Foo', "models don't get appended at the end");
    };

    _proto["@test assertion for routes without isRouteFactory property"] = function () {
      var _this3 = this;

      this.application.FooRoute = _glimmer.Component.extend();
      expectAssertion(function () {
        _this3.privateRegistry.resolve("route:foo");
      }, /to resolve to an Ember.Route/, 'Should assert');
    };

    _proto["@test no assertion for routes that extend from Route"] = function (assert) {
      assert.expect(0);
      this.application.FooRoute = _routing.Route.extend();
      this.privateRegistry.resolve("route:foo");
    };

    _proto["@test deprecation warning for service factories without isServiceFactory property"] = function () {
      var _this4 = this;

      expectAssertion(function () {
        _this4.application.FooService = _runtime.Object.extend();

        _this4.privateRegistry.resolve('service:foo');
      }, /Expected service:foo to resolve to an Ember.Service but instead it was TestApp\.FooService\./);
    };

    _proto["@test no deprecation warning for service factories that extend from Service"] = function (assert) {
      assert.expect(0);
      this.application.FooService = _service.default.extend();
      this.privateRegistry.resolve('service:foo');
    };

    _proto["@test deprecation warning for component factories without isComponentFactory property"] = function () {
      var _this5 = this;

      expectAssertion(function () {
        _this5.application.FooComponent = _runtime.Object.extend();

        _this5.privateRegistry.resolve('component:foo');
      }, /Expected component:foo to resolve to an Ember\.Component but instead it was TestApp\.FooComponent\./);
    };

    _proto["@test no deprecation warning for component factories that extend from Component"] = function () {
      expectNoDeprecation();
      this.application.FooView = _glimmer.Component.extend();
      this.privateRegistry.resolve('component:foo');
    };

    _proto["@test knownForType returns each item for a given type found"] = function (assert) {
      this.application.FooBarHelper = 'foo';
      this.application.BazQuxHelper = 'bar';
      var found = this.privateRegistry.resolver.knownForType('helper');
      assert.deepEqual(found, {
        'helper:foo-bar': true,
        'helper:baz-qux': true
      });
    };

    _proto["@test knownForType is not required to be present on the resolver"] = function (assert) {
      delete this.privateRegistry.resolver.knownForType;
      this.privateRegistry.resolver.knownForType('helper', function () {});
      assert.ok(true, 'does not error');
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "privateRegistry",
      get: function () {
        return this.application.__registry__;
      }
    }]);
    return _class;
  }(_internalTestHelpers.DefaultResolverApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application Dependency Injection - Integration - default resolver w/ other namespace',
  /*#__PURE__*/
  function (_DefaultResolverAppli2) {
    (0, _emberBabel.inheritsLoose)(_class2, _DefaultResolverAppli2);

    function _class2() {
      return _DefaultResolverAppli2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2.beforeEach = function beforeEach() {
      var _this6 = this;

      this.UserInterface = _environment.context.lookup.UserInterface = _runtime.Namespace.create();
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.createApplication();
      });
      return this.visit('/');
    };

    _proto2.teardown = function teardown() {
      var UserInterfaceNamespace = _runtime.Namespace.NAMESPACES_BY_ID['UserInterface'];

      if (UserInterfaceNamespace) {
        (0, _internalTestHelpers.runTask)(function () {
          UserInterfaceNamespace.destroy();
        });
      }

      _DefaultResolverAppli2.prototype.teardown.call(this);
    };

    _proto2["@test the default resolver can look things up in other namespaces"] = function (assert) {
      this.UserInterface.NavigationController = _controller.default.extend();
      var nav = this.applicationInstance.lookup('controller:userInterface/navigation');
      assert.ok(nav instanceof this.UserInterface.NavigationController, 'the result should be an instance of the specified class');
    };

    return _class2;
  }(_internalTestHelpers.DefaultResolverApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application Dependency Injection - Integration - default resolver',
  /*#__PURE__*/
  function (_DefaultResolverAppli3) {
    (0, _emberBabel.inheritsLoose)(_class3, _DefaultResolverAppli3);

    function _class3() {
      var _this7;

      _this7 = _DefaultResolverAppli3.call(this) || this;
      _this7._originalLookup = _environment.context.lookup;
      _this7._originalInfo = (0, _debug.getDebugFunction)('info');
      return _this7;
    }

    var _proto3 = _class3.prototype;

    _proto3.beforeEach = function beforeEach() {
      var _this8 = this;

      (0, _internalTestHelpers.runTask)(function () {
        return _this8.createApplication();
      });
      return this.visit('/');
    };

    _proto3.teardown = function teardown() {
      (0, _debug.setDebugFunction)('info', this._originalInfo);
      _environment.context.lookup = this._originalLookup;

      _DefaultResolverAppli3.prototype.teardown.call(this);
    };

    _proto3["@test the default resolver logs hits if 'LOG_RESOLVER' is set"] = function (assert) {
      if (EmberDev && EmberDev.runningProdBuild) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }

      assert.expect(3);
      this.application.LOG_RESOLVER = true;
      this.application.ScoobyDoo = _runtime.Object.extend();

      this.application.toString = function () {
        return 'App';
      };

      (0, _debug.setDebugFunction)('info', function (symbol, name, padding, lookupDescription) {
        assert.equal(symbol, '[]', 'proper symbol is printed when a module is found');
        assert.equal(name, 'doo:scooby', 'proper lookup value is logged');
        assert.equal(lookupDescription, 'App.ScoobyDoo');
      });
      this.applicationInstance.resolveRegistration('doo:scooby');
    };

    _proto3["@test the default resolver logs misses if 'LOG_RESOLVER' is set"] = function (assert) {
      if (EmberDev && EmberDev.runningProdBuild) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }

      assert.expect(3);
      this.application.LOG_RESOLVER = true;

      this.application.toString = function () {
        return 'App';
      };

      (0, _debug.setDebugFunction)('info', function (symbol, name, padding, lookupDescription) {
        assert.equal(symbol, '[ ]', 'proper symbol is printed when a module is not found');
        assert.equal(name, 'doo:scooby', 'proper lookup value is logged');
        assert.equal(lookupDescription, 'App.ScoobyDoo');
      });
      this.applicationInstance.resolveRegistration('doo:scooby');
    };

    _proto3["@test doesn't log without LOG_RESOLVER"] = function (assert) {
      if (EmberDev && EmberDev.runningProdBuild) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }

      var infoCount = 0;
      this.application.ScoobyDoo = _runtime.Object.extend();
      (0, _debug.setDebugFunction)('info', function () {
        return infoCount = infoCount + 1;
      });
      this.applicationInstance.resolveRegistration('doo:scooby');
      this.applicationInstance.resolveRegistration('doo:scrappy');
      assert.equal(infoCount, 0, 'console.info should not be called if LOG_RESOLVER is not set');
    };

    return _class3;
  }(_internalTestHelpers.DefaultResolverApplicationTestCase));
});
enifed("@ember/application/tests/dependency_injection/normalization_test", ["ember-babel", "@ember/runloop", "@ember/application", "internal-test-helpers"], function (_emberBabel, _runloop, _application, _internalTestHelpers) {
  "use strict";

  var application, registry;
  (0, _internalTestHelpers.moduleFor)('Application Dependency Injection - normalize',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      var _this;

      _this = _TestCase.call(this) || this;
      application = (0, _runloop.run)(_application.default, 'create');
      registry = application.__registry__;
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _TestCase.prototype.teardown.call(this);

      (0, _runloop.run)(application, 'destroy');
      application = undefined;
      registry = undefined;
    };

    _proto['@test normalization'] = function testNormalization(assert) {
      assert.ok(registry.normalize, 'registry#normalize is present');
      assert.equal(registry.normalize('foo:bar'), 'foo:bar');
      assert.equal(registry.normalize('controller:posts'), 'controller:posts');
      assert.equal(registry.normalize('controller:posts_index'), 'controller:postsIndex');
      assert.equal(registry.normalize('controller:posts.index'), 'controller:postsIndex');
      assert.equal(registry.normalize('controller:posts-index'), 'controller:postsIndex');
      assert.equal(registry.normalize('controller:posts.post.index'), 'controller:postsPostIndex');
      assert.equal(registry.normalize('controller:posts_post.index'), 'controller:postsPostIndex');
      assert.equal(registry.normalize('controller:posts.post_index'), 'controller:postsPostIndex');
      assert.equal(registry.normalize('controller:posts.post-index'), 'controller:postsPostIndex');
      assert.equal(registry.normalize('controller:postsIndex'), 'controller:postsIndex');
      assert.equal(registry.normalize('controller:blogPosts.index'), 'controller:blogPostsIndex');
      assert.equal(registry.normalize('controller:blog/posts.index'), 'controller:blog/postsIndex');
      assert.equal(registry.normalize('controller:blog/posts-index'), 'controller:blog/postsIndex');
      assert.equal(registry.normalize('controller:blog/posts.post.index'), 'controller:blog/postsPostIndex');
      assert.equal(registry.normalize('controller:blog/posts_post.index'), 'controller:blog/postsPostIndex');
      assert.equal(registry.normalize('controller:blog/posts_post-index'), 'controller:blog/postsPostIndex');
      assert.equal(registry.normalize('template:blog/posts_index'), 'template:blog/posts_index');
    };

    _proto['@test normalization is indempotent'] = function testNormalizationIsIndempotent(assert) {
      var examples = ['controller:posts', 'controller:posts.post.index', 'controller:blog/posts.post_index', 'template:foo_bar'];
      examples.forEach(function (example) {
        assert.equal(registry.normalize(registry.normalize(example)), registry.normalize(example));
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/application/tests/dependency_injection/to_string_test", ["ember-babel", "@ember/polyfills", "@ember/-internals/utils", "@ember/-internals/runtime", "internal-test-helpers"], function (_emberBabel, _polyfills, _utils, _runtime, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application Dependency Injection - DefaultResolver#toString',
  /*#__PURE__*/
  function (_DefaultResolverAppli) {
    (0, _emberBabel.inheritsLoose)(_class, _DefaultResolverAppli);

    function _class() {
      var _this;

      _this = _DefaultResolverAppli.call(this) || this;
      (0, _internalTestHelpers.runTask)(function () {
        return _this.createApplication();
      });
      _this.application.Post = _runtime.Object.extend();
      return _this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      return this.visit('/');
    };

    _proto['@test factories'] = function testFactories(assert) {
      var PostFactory = this.applicationInstance.factoryFor('model:post').class;
      assert.equal(PostFactory.toString(), 'TestApp.Post', 'expecting the model to be post');
    };

    _proto['@test instances'] = function testInstances(assert) {
      var post = this.applicationInstance.lookup('model:post');
      var guid = (0, _utils.guidFor)(post);
      assert.equal(post.toString(), '<TestApp.Post:' + guid + '>', 'expecting the model to be post');
    };

    return _class;
  }(_internalTestHelpers.DefaultResolverApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application Dependency Injection - Resolver#toString',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase);

    function _class2() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2.beforeEach = function beforeEach() {
      return this.visit('/');
    };

    _proto2['@test toString called on a resolver'] = function testToStringCalledOnAResolver(assert) {
      this.add('model:peter', _runtime.Object.extend());
      var peter = this.applicationInstance.lookup('model:peter');
      var guid = (0, _utils.guidFor)(peter);
      assert.equal(peter.toString(), "<model:peter:" + guid + ">", 'expecting the supermodel to be peter');
    };

    (0, _emberBabel.createClass)(_class2, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_ApplicationTestCase.prototype.applicationOptions, {
          Resolver:
          /*#__PURE__*/
          function (_ModuleBasedTestResol) {
            (0, _emberBabel.inheritsLoose)(Resolver, _ModuleBasedTestResol);

            function Resolver() {
              return _ModuleBasedTestResol.apply(this, arguments) || this;
            }

            var _proto3 = Resolver.prototype;

            _proto3.makeToString = function makeToString(_, fullName) {
              return fullName;
            };

            return Resolver;
          }(_internalTestHelpers.ModuleBasedTestResolver)
        });
      }
    }]);
    return _class2;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/application/tests/dependency_injection_test", ["ember-babel", "@ember/-internals/environment", "@ember/runloop", "@ember/-internals/runtime", "@ember/application", "internal-test-helpers"], function (_emberBabel, _environment, _runloop, _runtime, _application, _internalTestHelpers) {
  "use strict";

  var originalLookup = _environment.context.lookup;
  var registry, locator, application;
  (0, _internalTestHelpers.moduleFor)('Application Dependency Injection',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      var _this;

      _this = _TestCase.call(this) || this;
      application = (0, _runloop.run)(_application.default, 'create');
      application.Person = _runtime.Object.extend({});
      application.Orange = _runtime.Object.extend({});
      application.Email = _runtime.Object.extend({});
      application.User = _runtime.Object.extend({});
      application.PostIndexController = _runtime.Object.extend({});
      application.register('model:person', application.Person, {
        singleton: false
      });
      application.register('model:user', application.User, {
        singleton: false
      });
      application.register('fruit:favorite', application.Orange);
      application.register('communication:main', application.Email, {
        singleton: false
      });
      application.register('controller:postIndex', application.PostIndexController, {
        singleton: true
      });
      registry = application.__registry__;
      locator = application.__container__;
      _environment.context.lookup = {};
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _TestCase.prototype.teardown.call(this);

      (0, _runloop.run)(application, 'destroy');
      registry = application = locator = null;
      _environment.context.lookup = originalLookup;
    };

    _proto['@test container lookup is normalized'] = function testContainerLookupIsNormalized(assert) {
      var dotNotationController = locator.lookup('controller:post.index');
      var camelCaseController = locator.lookup('controller:postIndex');
      assert.ok(dotNotationController instanceof application.PostIndexController);
      assert.ok(camelCaseController instanceof application.PostIndexController);
      assert.equal(dotNotationController, camelCaseController);
    };

    _proto['@test registered entities can be looked up later'] = function testRegisteredEntitiesCanBeLookedUpLater(assert) {
      assert.equal(registry.resolve('model:person'), application.Person);
      assert.equal(registry.resolve('model:user'), application.User);
      assert.equal(registry.resolve('fruit:favorite'), application.Orange);
      assert.equal(registry.resolve('communication:main'), application.Email);
      assert.equal(registry.resolve('controller:postIndex'), application.PostIndexController);
      assert.equal(locator.lookup('fruit:favorite'), locator.lookup('fruit:favorite'), 'singleton lookup worked');
      assert.ok(locator.lookup('model:user') !== locator.lookup('model:user'), 'non-singleton lookup worked');
    };

    _proto['@test injections'] = function testInjections(assert) {
      application.inject('model', 'fruit', 'fruit:favorite');
      application.inject('model:user', 'communication', 'communication:main');
      var user = locator.lookup('model:user');
      var person = locator.lookup('model:person');
      var fruit = locator.lookup('fruit:favorite');
      assert.equal(user.get('fruit'), fruit);
      assert.equal(person.get('fruit'), fruit);
      assert.ok(application.Email.detectInstance(user.get('communication')));
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/application/tests/initializers_test", ["ember-babel", "@ember/polyfills", "internal-test-helpers", "@ember/application"], function (_emberBabel, _polyfills, _internalTestHelpers, _application) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application initializers',
  /*#__PURE__*/
  function (_AutobootApplicationT) {
    (0, _emberBabel.inheritsLoose)(_class, _AutobootApplicationT);

    function _class() {
      return _AutobootApplicationT.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.createSecondApplication = function createSecondApplication(options) {
      var MyApplication = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _application.default;
      var myOptions = (0, _polyfills.assign)(this.applicationOptions, {
        rootElement: '#two'
      }, options);
      var secondApp = this.secondApp = MyApplication.create(myOptions);
      return secondApp;
    };

    _proto.teardown = function teardown() {
      var _this = this;

      _AutobootApplicationT.prototype.teardown.call(this);

      if (this.secondApp) {
        (0, _internalTestHelpers.runTask)(function () {
          return _this.secondApp.destroy();
        });
      }
    };

    _proto["@test initializers require proper 'name' and 'initialize' properties"] = function () {
      var MyApplication = _application.default.extend();

      expectAssertion(function () {
        MyApplication.initializer({
          name: 'initializer'
        });
      });
      expectAssertion(function () {
        MyApplication.initializer({
          initialize: function () {}
        });
      });
    };

    _proto["@test initializers that throw errors cause the boot promise to reject with the error"] = function (assert) {
      var _this2 = this;

      assert.expect(2);

      var MyApplication = _application.default.extend();

      MyApplication.initializer({
        name: 'initializer',
        initialize: function () {
          throw new Error('boot failure');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        _this2.createApplication({
          autoboot: false
        }, MyApplication);
      });
      var app = this.application;

      try {
        (0, _internalTestHelpers.runTask)(function () {
          app.boot().then(function () {
            assert.ok(false, 'The boot promise should not resolve when there is a boot error');
          }, function (error) {
            assert.ok(error instanceof Error, 'The boot promise should reject with an error');
            assert.equal(error.message, 'boot failure');
          });
        });
      } catch (error) {
        assert.ok(false, 'The boot method should not throw');
        throw error;
      }
    };

    _proto["@test initializers are passed an App"] = function (assert) {
      var _this3 = this;

      var MyApplication = _application.default.extend();

      MyApplication.initializer({
        name: 'initializer',
        initialize: function (App) {
          assert.ok(App instanceof _application.default, 'initialize is passed an Application');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.createApplication({}, MyApplication);
      });
    };

    _proto["@test initializers can be registered in a specified order"] = function (assert) {
      var _this4 = this;

      var order = [];

      var MyApplication = _application.default.extend();

      MyApplication.initializer({
        name: 'fourth',
        after: 'third',
        initialize: function () {
          order.push('fourth');
        }
      });
      MyApplication.initializer({
        name: 'second',
        after: 'first',
        before: 'third',
        initialize: function () {
          order.push('second');
        }
      });
      MyApplication.initializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize: function () {
          order.push('fifth');
        }
      });
      MyApplication.initializer({
        name: 'first',
        before: 'second',
        initialize: function () {
          order.push('first');
        }
      });
      MyApplication.initializer({
        name: 'third',
        initialize: function () {
          order.push('third');
        }
      });
      MyApplication.initializer({
        name: 'sixth',
        initialize: function () {
          order.push('sixth');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.createApplication({}, MyApplication);
      });
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    };

    _proto["@test initializers can be registered in a specified order as an array"] = function (assert) {
      var _this5 = this;

      var order = [];

      var MyApplication = _application.default.extend();

      MyApplication.initializer({
        name: 'third',
        initialize: function () {
          order.push('third');
        }
      });
      MyApplication.initializer({
        name: 'second',
        after: 'first',
        before: ['third', 'fourth'],
        initialize: function () {
          order.push('second');
        }
      });
      MyApplication.initializer({
        name: 'fourth',
        after: ['second', 'third'],
        initialize: function () {
          order.push('fourth');
        }
      });
      MyApplication.initializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize: function () {
          order.push('fifth');
        }
      });
      MyApplication.initializer({
        name: 'first',
        before: ['second'],
        initialize: function () {
          order.push('first');
        }
      });
      MyApplication.initializer({
        name: 'sixth',
        initialize: function () {
          order.push('sixth');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.createApplication({}, MyApplication);
      });
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    };

    _proto["@test initializers can have multiple dependencies"] = function (assert) {
      var _this6 = this;

      var order = [];

      var MyApplication = _application.default.extend();

      var a = {
        name: 'a',
        before: 'b',
        initialize: function () {
          order.push('a');
        }
      };
      var b = {
        name: 'b',
        initialize: function () {
          order.push('b');
        }
      };
      var c = {
        name: 'c',
        after: 'b',
        initialize: function () {
          order.push('c');
        }
      };
      var afterB = {
        name: 'after b',
        after: 'b',
        initialize: function () {
          order.push('after b');
        }
      };
      var afterC = {
        name: 'after c',
        after: 'c',
        initialize: function () {
          order.push('after c');
        }
      };
      MyApplication.initializer(b);
      MyApplication.initializer(a);
      MyApplication.initializer(afterC);
      MyApplication.initializer(afterB);
      MyApplication.initializer(c);
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.createApplication({}, MyApplication);
      });
      assert.ok(order.indexOf(a.name) < order.indexOf(b.name), 'a < b');
      assert.ok(order.indexOf(b.name) < order.indexOf(c.name), 'b < c');
      assert.ok(order.indexOf(b.name) < order.indexOf(afterB.name), 'b < afterB');
      assert.ok(order.indexOf(c.name) < order.indexOf(afterC.name), 'c < afterC');
    };

    _proto["@test initializers set on Application subclasses are not shared between apps"] = function (assert) {
      var _this7 = this;

      var firstInitializerRunCount = 0;
      var secondInitializerRunCount = 0;

      var FirstApp = _application.default.extend();

      FirstApp.initializer({
        name: 'first',
        initialize: function () {
          firstInitializerRunCount++;
        }
      });

      var SecondApp = _application.default.extend();

      SecondApp.initializer({
        name: 'second',
        initialize: function () {
          secondInitializerRunCount++;
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.createApplication({}, FirstApp);
      });
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run');
      assert.equal(secondInitializerRunCount, 0, 'first initializer only was run');
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.createSecondApplication({}, SecondApp);
      });
      assert.equal(firstInitializerRunCount, 1, 'second initializer only was run');
      assert.equal(secondInitializerRunCount, 1, 'second initializer only was run');
    };

    _proto["@test initializers are concatenated"] = function (assert) {
      var _this8 = this;

      var firstInitializerRunCount = 0;
      var secondInitializerRunCount = 0;

      var FirstApp = _application.default.extend();

      FirstApp.initializer({
        name: 'first',
        initialize: function () {
          firstInitializerRunCount++;
        }
      });
      var SecondApp = FirstApp.extend();
      SecondApp.initializer({
        name: 'second',
        initialize: function () {
          secondInitializerRunCount++;
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.createApplication({}, FirstApp);
      });
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run when base class created');
      assert.equal(secondInitializerRunCount, 0, 'first initializer only was run when base class created');
      firstInitializerRunCount = 0;
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.createSecondApplication({}, SecondApp);
      });
      assert.equal(firstInitializerRunCount, 1, 'first initializer was run when subclass created');
      assert.equal(secondInitializerRunCount, 1, 'second initializers was run when subclass created');
    };

    _proto["@test initializers are per-app"] = function (assert) {
      assert.expect(2);

      var FirstApp = _application.default.extend();

      FirstApp.initializer({
        name: 'abc',
        initialize: function () {}
      });
      expectAssertion(function () {
        FirstApp.initializer({
          name: 'abc',
          initialize: function () {}
        });
      });

      var SecondApp = _application.default.extend();

      SecondApp.instanceInitializer({
        name: 'abc',
        initialize: function () {}
      });
      assert.ok(true, 'Two apps can have initializers named the same.');
    };

    _proto["@test initializers are executed in their own context"] = function (assert) {
      var _this9 = this;

      assert.expect(1);

      var MyApplication = _application.default.extend();

      MyApplication.initializer({
        name: 'coolInitializer',
        myProperty: 'cool',
        initialize: function () {
          assert.equal(this.myProperty, 'cool', 'should have access to its own context');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.createApplication({}, MyApplication);
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "fixture",
      get: function () {
        return "<div id=\"one\">ONE</div>\n      <div id=\"two\">TWO</div>\n    ";
      }
    }, {
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_AutobootApplicationT.prototype.applicationOptions, {
          rootElement: '#one'
        });
      }
    }]);
    return _class;
  }(_internalTestHelpers.AutobootApplicationTestCase));
});
enifed("@ember/application/tests/instance_initializers_test", ["ember-babel", "@ember/polyfills", "internal-test-helpers", "@ember/application/instance", "@ember/application"], function (_emberBabel, _polyfills, _internalTestHelpers, _instance, _application) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application instance initializers',
  /*#__PURE__*/
  function (_AutobootApplicationT) {
    (0, _emberBabel.inheritsLoose)(_class, _AutobootApplicationT);

    function _class() {
      return _AutobootApplicationT.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.createSecondApplication = function createSecondApplication(options) {
      var MyApplication = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _application.default;
      var myOptions = (0, _polyfills.assign)(this.applicationOptions, {
        rootElement: '#two'
      }, options);
      var secondApp = this.secondApp = MyApplication.create(myOptions);
      return secondApp;
    };

    _proto.teardown = function teardown() {
      var _this = this;

      _AutobootApplicationT.prototype.teardown.call(this);

      if (this.secondApp) {
        (0, _internalTestHelpers.runTask)(function () {
          return _this.secondApp.destroy();
        });
      }
    };

    _proto["@test initializers require proper 'name' and 'initialize' properties"] = function () {
      var _this2 = this;

      var MyApplication = _application.default.extend();

      expectAssertion(function () {
        MyApplication.instanceInitializer({
          name: 'initializer'
        });
      });
      expectAssertion(function () {
        MyApplication.instanceInitializer({
          initialize: function () {}
        });
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this2.createApplication({}, MyApplication);
      });
    };

    _proto["@test initializers are passed an app instance"] = function (assert) {
      var _this3 = this;

      var MyApplication = _application.default.extend();

      MyApplication.instanceInitializer({
        name: 'initializer',
        initialize: function (instance) {
          assert.ok(instance instanceof _instance.default, 'initialize is passed an application instance');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.createApplication({}, MyApplication);
      });
    };

    _proto["@test initializers can be registered in a specified order"] = function (assert) {
      var _this4 = this;

      var order = [];

      var MyApplication = _application.default.extend();

      MyApplication.instanceInitializer({
        name: 'fourth',
        after: 'third',
        initialize: function () {
          order.push('fourth');
        }
      });
      MyApplication.instanceInitializer({
        name: 'second',
        after: 'first',
        before: 'third',
        initialize: function () {
          order.push('second');
        }
      });
      MyApplication.instanceInitializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize: function () {
          order.push('fifth');
        }
      });
      MyApplication.instanceInitializer({
        name: 'first',
        before: 'second',
        initialize: function () {
          order.push('first');
        }
      });
      MyApplication.instanceInitializer({
        name: 'third',
        initialize: function () {
          order.push('third');
        }
      });
      MyApplication.instanceInitializer({
        name: 'sixth',
        initialize: function () {
          order.push('sixth');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this4.createApplication({}, MyApplication);
      });
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    };

    _proto["@test initializers can be registered in a specified order as an array"] = function (assert) {
      var _this5 = this;

      var order = [];

      var MyApplication = _application.default.extend();

      MyApplication.instanceInitializer({
        name: 'third',
        initialize: function () {
          order.push('third');
        }
      });
      MyApplication.instanceInitializer({
        name: 'second',
        after: 'first',
        before: ['third', 'fourth'],
        initialize: function () {
          order.push('second');
        }
      });
      MyApplication.instanceInitializer({
        name: 'fourth',
        after: ['second', 'third'],
        initialize: function () {
          order.push('fourth');
        }
      });
      MyApplication.instanceInitializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize: function () {
          order.push('fifth');
        }
      });
      MyApplication.instanceInitializer({
        name: 'first',
        before: ['second'],
        initialize: function () {
          order.push('first');
        }
      });
      MyApplication.instanceInitializer({
        name: 'sixth',
        initialize: function () {
          order.push('sixth');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this5.createApplication({}, MyApplication);
      });
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    };

    _proto["@test initializers can have multiple dependencies"] = function (assert) {
      var _this6 = this;

      var order = [];

      var MyApplication = _application.default.extend();

      var a = {
        name: 'a',
        before: 'b',
        initialize: function () {
          order.push('a');
        }
      };
      var b = {
        name: 'b',
        initialize: function () {
          order.push('b');
        }
      };
      var c = {
        name: 'c',
        after: 'b',
        initialize: function () {
          order.push('c');
        }
      };
      var afterB = {
        name: 'after b',
        after: 'b',
        initialize: function () {
          order.push('after b');
        }
      };
      var afterC = {
        name: 'after c',
        after: 'c',
        initialize: function () {
          order.push('after c');
        }
      };
      MyApplication.instanceInitializer(b);
      MyApplication.instanceInitializer(a);
      MyApplication.instanceInitializer(afterC);
      MyApplication.instanceInitializer(afterB);
      MyApplication.instanceInitializer(c);
      (0, _internalTestHelpers.runTask)(function () {
        return _this6.createApplication({}, MyApplication);
      });
      assert.ok(order.indexOf(a.name) < order.indexOf(b.name), 'a < b');
      assert.ok(order.indexOf(b.name) < order.indexOf(c.name), 'b < c');
      assert.ok(order.indexOf(b.name) < order.indexOf(afterB.name), 'b < afterB');
      assert.ok(order.indexOf(c.name) < order.indexOf(afterC.name), 'c < afterC');
    };

    _proto["@test initializers set on Application subclasses should not be shared between apps"] = function (assert) {
      var _this7 = this;

      var firstInitializerRunCount = 0;
      var secondInitializerRunCount = 0;

      var FirstApp = _application.default.extend();

      FirstApp.instanceInitializer({
        name: 'first',
        initialize: function () {
          firstInitializerRunCount++;
        }
      });

      var SecondApp = _application.default.extend();

      SecondApp.instanceInitializer({
        name: 'second',
        initialize: function () {
          secondInitializerRunCount++;
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.createApplication({}, FirstApp);
      });
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run');
      assert.equal(secondInitializerRunCount, 0, 'first initializer only was run');
      (0, _internalTestHelpers.runTask)(function () {
        return _this7.createSecondApplication({}, SecondApp);
      });
      assert.equal(firstInitializerRunCount, 1, 'second initializer only was run');
      assert.equal(secondInitializerRunCount, 1, 'second initializer only was run');
    };

    _proto["@test initializers are concatenated"] = function (assert) {
      var _this8 = this;

      var firstInitializerRunCount = 0;
      var secondInitializerRunCount = 0;

      var FirstApp = _application.default.extend();

      FirstApp.instanceInitializer({
        name: 'first',
        initialize: function () {
          firstInitializerRunCount++;
        }
      });
      var SecondApp = FirstApp.extend();
      SecondApp.instanceInitializer({
        name: 'second',
        initialize: function () {
          secondInitializerRunCount++;
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.createApplication({}, FirstApp);
      });
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run when base class created');
      assert.equal(secondInitializerRunCount, 0, 'first initializer only was run when base class created');
      firstInitializerRunCount = 0;
      (0, _internalTestHelpers.runTask)(function () {
        return _this8.createSecondApplication({}, SecondApp);
      });
      assert.equal(firstInitializerRunCount, 1, 'first initializer was run when subclass created');
      assert.equal(secondInitializerRunCount, 1, 'second initializers was run when subclass created');
    };

    _proto["@test initializers are per-app"] = function (assert) {
      var _this9 = this;

      assert.expect(2);

      var FirstApp = _application.default.extend();

      FirstApp.instanceInitializer({
        name: 'abc',
        initialize: function () {}
      });
      expectAssertion(function () {
        FirstApp.instanceInitializer({
          name: 'abc',
          initialize: function () {}
        });
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.createApplication({}, FirstApp);
      });

      var SecondApp = _application.default.extend();

      SecondApp.instanceInitializer({
        name: 'abc',
        initialize: function () {}
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this9.createSecondApplication({}, SecondApp);
      });
      assert.ok(true, 'Two apps can have initializers named the same.');
    };

    _proto["@test initializers are run before ready hook"] = function (assert) {
      var _this10 = this;

      assert.expect(2);

      var MyApplication = _application.default.extend({
        ready: function () {
          assert.ok(true, 'ready is called');
          readyWasCalled = false;
        }
      });

      var readyWasCalled = false;
      MyApplication.instanceInitializer({
        name: 'initializer',
        initialize: function () {
          assert.ok(!readyWasCalled, 'ready is not yet called');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this10.createApplication({}, MyApplication);
      });
    };

    _proto["@test initializers are executed in their own context"] = function (assert) {
      var _this11 = this;

      assert.expect(1);

      var MyApplication = _application.default.extend();

      MyApplication.instanceInitializer({
        name: 'coolInitializer',
        myProperty: 'cool',
        initialize: function () {
          assert.equal(this.myProperty, 'cool', 'should have access to its own context');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this11.createApplication({}, MyApplication);
      });
    };

    _proto["@test initializers get an instance on app reset"] = function (assert) {
      var _this12 = this;

      assert.expect(2);

      var MyApplication = _application.default.extend();

      MyApplication.instanceInitializer({
        name: 'giveMeAnInstance',
        initialize: function (instance) {
          assert.ok(Boolean(instance), 'Initializer got an instance');
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.createApplication({}, MyApplication);
      });
      (0, _internalTestHelpers.runTask)(function () {
        return _this12.application.reset();
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "fixture",
      get: function () {
        return "<div id=\"one\">ONE</div>\n      <div id=\"two\">TWO</div>\n    ";
      }
    }, {
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_AutobootApplicationT.prototype.applicationOptions, {
          rootElement: '#one'
        });
      }
    }]);
    return _class;
  }(_internalTestHelpers.AutobootApplicationTestCase));
});
enifed("@ember/application/tests/lazy_load_test", ["ember-babel", "@ember/runloop", "@ember/application", "internal-test-helpers"], function (_emberBabel, _runloop, _application, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Lazy Loading',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.afterEach = function afterEach() {
      var keys = Object.keys(_application._loaded);

      for (var i = 0; i < keys.length; i++) {
        delete _application._loaded[keys[i]];
      }
    };

    _proto['@test if a load hook is registered, it is executed when runLoadHooks are exected'] = function testIfALoadHookIsRegisteredItIsExecutedWhenRunLoadHooksAreExected(assert) {
      var count = 0;
      (0, _runloop.run)(function () {
        (0, _application.onLoad)('__test_hook__', function (object) {
          count += object;
        });
      });
      (0, _runloop.run)(function () {
        (0, _application.runLoadHooks)('__test_hook__', 1);
      });
      assert.equal(count, 1, 'the object was passed into the load hook');
    };

    _proto['@test if runLoadHooks was already run, it executes newly added hooks immediately'] = function testIfRunLoadHooksWasAlreadyRunItExecutesNewlyAddedHooksImmediately(assert) {
      var count = 0;
      (0, _runloop.run)(function () {
        (0, _application.onLoad)('__test_hook__', function (object) {
          return count += object;
        });
      });
      (0, _runloop.run)(function () {
        return (0, _application.runLoadHooks)('__test_hook__', 1);
      });
      count = 0;
      (0, _runloop.run)(function () {
        (0, _application.onLoad)('__test_hook__', function (object) {
          return count += object;
        });
      });
      assert.equal(count, 1, 'the original object was passed into the load hook');
    };

    _proto["@test hooks in ENV.EMBER_LOAD_HOOKS['hookName'] get executed"] = function testHooksInENVEMBER_LOAD_HOOKSHookNameGetExecuted(assert) {
      // Note that the necessary code to perform this test is run before
      // the Ember lib is loaded in tests/index.html
      (0, _runloop.run)(function () {
        (0, _application.runLoadHooks)('__before_ember_test_hook__', 1);
      });
      assert.equal(window.ENV.__test_hook_count__, 1, 'the object was passed into the load hook');
    };

    _proto['@test load hooks trigger a custom event'] = function testLoadHooksTriggerACustomEvent(assert) {
      if (typeof window === 'object' && typeof window.dispatchEvent === 'function' && typeof CustomEvent === 'function') {
        var eventObject = 'super duper awesome events';
        window.addEventListener('__test_hook_for_events__', function (e) {
          assert.ok(true, 'custom event was fired');
          assert.equal(e.detail, eventObject, 'event details are provided properly');
        });
        (0, _runloop.run)(function () {
          (0, _application.runLoadHooks)('__test_hook_for_events__', eventObject);
        });
      } else {
        assert.expect(0);
      }
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/application/tests/logging_test", ["ember-babel", "internal-test-helpers", "@ember/controller", "@ember/-internals/routing", "@ember/polyfills"], function (_emberBabel, _internalTestHelpers, _controller, _routing, _polyfills) {
  "use strict";

  /*globals EmberDev */
  var LoggingApplicationTestCase =
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(LoggingApplicationTestCase, _ApplicationTestCase);

    function LoggingApplicationTestCase() {
      var _this;

      _this = _ApplicationTestCase.call(this) || this;
      _this.logs = {};
      /* eslint-disable no-console */

      _this._originalLogger = console.info;

      console.info = function (_, _ref) {
        var fullName = _ref.fullName;

        if (!_this.logs.hasOwnProperty(fullName)) {
          _this.logs[fullName] = 0;
        }
        /* eslint-ensable no-console */


        _this.logs[fullName]++;
      };

      _this.router.map(function () {
        this.route('posts', {
          resetNamespace: true
        });
      });

      return _this;
    }

    var _proto = LoggingApplicationTestCase.prototype;

    _proto.teardown = function teardown() {
      /* eslint-disable no-console */
      console.info = this._originalLogger;
      /* eslint-enable no-console */

      _ApplicationTestCase.prototype.teardown.call(this);
    };

    return LoggingApplicationTestCase;
  }(_internalTestHelpers.ApplicationTestCase);

  (0, _internalTestHelpers.moduleFor)('Application with LOG_ACTIVE_GENERATION=true',
  /*#__PURE__*/
  function (_LoggingApplicationTe) {
    (0, _emberBabel.inheritsLoose)(_class, _LoggingApplicationTe);

    function _class() {
      return _LoggingApplicationTe.apply(this, arguments) || this;
    }

    var _proto2 = _class.prototype;

    _proto2['@test log class generation if logging enabled'] = function testLogClassGenerationIfLoggingEnabled(assert) {
      var _this2 = this;

      if (EmberDev && EmberDev.runningProdBuild) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }

      return this.visit('/posts').then(function () {
        assert.equal(Object.keys(_this2.logs).length, 4, 'expected logs');
      });
    };

    _proto2['@test actively generated classes get logged'] = function testActivelyGeneratedClassesGetLogged(assert) {
      var _this3 = this;

      if (EmberDev && EmberDev.runningProdBuild) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }

      return this.visit('/posts').then(function () {
        assert.equal(_this3.logs['controller:application'], 1, 'expected: ApplicationController was generated');
        assert.equal(_this3.logs['controller:posts'], 1, 'expected: PostsController was generated');
        assert.equal(_this3.logs['route:application'], 1, 'expected: ApplicationRoute was generated');
        assert.equal(_this3.logs['route:posts'], 1, 'expected: PostsRoute was generated');
      });
    };

    _proto2['@test predefined classes do not get logged'] = function testPredefinedClassesDoNotGetLogged(assert) {
      var _this4 = this;

      this.add('controller:application', _controller.default.extend());
      this.add('controller:posts', _controller.default.extend());
      this.add('route:application', _routing.Route.extend());
      this.add('route:posts', _routing.Route.extend());
      return this.visit('/posts').then(function () {
        assert.ok(!_this4.logs['controller:application'], 'did not expect: ApplicationController was generated');
        assert.ok(!_this4.logs['controller:posts'], 'did not expect: PostsController was generated');
        assert.ok(!_this4.logs['route:application'], 'did not expect: ApplicationRoute was generated');
        assert.ok(!_this4.logs['route:posts'], 'did not expect: PostsRoute was generated');
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_LoggingApplicationTe.prototype.applicationOptions, {
          LOG_ACTIVE_GENERATION: true
        });
      }
    }]);
    return _class;
  }(LoggingApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application when LOG_ACTIVE_GENERATION=false',
  /*#__PURE__*/
  function (_LoggingApplicationTe2) {
    (0, _emberBabel.inheritsLoose)(_class2, _LoggingApplicationTe2);

    function _class2() {
      return _LoggingApplicationTe2.apply(this, arguments) || this;
    }

    var _proto3 = _class2.prototype;

    _proto3["@test do NOT log class generation if logging disabled"] = function (assert) {
      var _this5 = this;

      return this.visit('/posts').then(function () {
        assert.equal(Object.keys(_this5.logs).length, 0, 'expected logs');
      });
    };

    (0, _emberBabel.createClass)(_class2, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_LoggingApplicationTe2.prototype.applicationOptions, {
          LOG_ACTIVE_GENERATION: false
        });
      }
    }]);
    return _class2;
  }(LoggingApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application with LOG_VIEW_LOOKUPS=true',
  /*#__PURE__*/
  function (_LoggingApplicationTe3) {
    (0, _emberBabel.inheritsLoose)(_class3, _LoggingApplicationTe3);

    function _class3() {
      return _LoggingApplicationTe3.apply(this, arguments) || this;
    }

    var _proto4 = _class3.prototype;

    _proto4["@test log when template and view are missing when flag is active"] = function (assert) {
      var _this6 = this;

      if (EmberDev && EmberDev.runningProdBuild) {
        assert.ok(true, 'Logging does not occur in production builds');
        return;
      }

      this.addTemplate('application', '{{outlet}}');
      return this.visit('/').then(function () {
        return _this6.visit('/posts');
      }).then(function () {
        assert.equal(_this6.logs['template:application'], undefined, 'expected: Should not log template:application since it exists.');
        assert.equal(_this6.logs['template:index'], 1, 'expected: Could not find "index" template or view.');
        assert.equal(_this6.logs['template:posts'], 1, 'expected: Could not find "posts" template or view.');
      });
    };

    (0, _emberBabel.createClass)(_class3, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_LoggingApplicationTe3.prototype.applicationOptions, {
          LOG_VIEW_LOOKUPS: true
        });
      }
    }]);
    return _class3;
  }(LoggingApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application with LOG_VIEW_LOOKUPS=false',
  /*#__PURE__*/
  function (_LoggingApplicationTe4) {
    (0, _emberBabel.inheritsLoose)(_class4, _LoggingApplicationTe4);

    function _class4() {
      return _LoggingApplicationTe4.apply(this, arguments) || this;
    }

    var _proto5 = _class4.prototype;

    _proto5["@test do not log when template and view are missing when flag is not true"] = function (assert) {
      var _this7 = this;

      return this.visit('/posts').then(function () {
        assert.equal(Object.keys(_this7.logs).length, 0, 'expected no logs');
      });
    };

    _proto5["@test do not log which views are used with templates when flag is not true"] = function (assert) {
      var _this8 = this;

      return this.visit('/posts').then(function () {
        assert.equal(Object.keys(_this8.logs).length, 0, 'expected no logs');
      });
    };

    (0, _emberBabel.createClass)(_class4, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_LoggingApplicationTe4.prototype.applicationOptions, {
          LOG_VIEW_LOOKUPS: false
        });
      }
    }]);
    return _class4;
  }(LoggingApplicationTestCase));
});
enifed("@ember/application/tests/readiness_test", ["ember-babel", "internal-test-helpers", "@ember/runloop", "@ember/application"], function (_emberBabel, _internalTestHelpers, _runloop, _application) {
  "use strict";

  var jQuery, application, Application;
  var readyWasCalled, domReady, readyCallbacks; // We are using a small mock of jQuery because jQuery is third-party code with
  // very well-defined semantics, and we want to confirm that a jQuery stub run
  // in a more minimal server environment that implements this behavior will be
  // sufficient for Ember's requirements.

  (0, _internalTestHelpers.moduleFor)('Application readiness',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.call(this) || this;
      readyWasCalled = 0;
      readyCallbacks = [];
      var jQueryInstance = {
        ready: function (callback) {
          readyCallbacks.push(callback);

          if (jQuery.isReady) {
            domReady();
          }
        }
      };

      jQuery = function () {
        return jQueryInstance;
      };

      jQuery.isReady = false;
      var domReadyCalled = 0;

      domReady = function () {
        if (domReadyCalled !== 0) {
          return;
        }

        domReadyCalled++;

        for (var i = 0; i < readyCallbacks.length; i++) {
          readyCallbacks[i]();
        }
      };

      Application = _application.default.extend({
        $: jQuery,
        ready: function () {
          readyWasCalled++;
        }
      });
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      if (application) {
        (0, _runloop.run)(function () {
          return application.destroy();
        });
        jQuery = readyCallbacks = domReady = Application = application = undefined;
      }
    } // These tests are confirming that if the callbacks passed into jQuery's ready hook is called
    // synchronously during the application's initialization, we get the same behavior as if
    // it was triggered after initialization.
    ;

    _proto["@test Application's ready event is called right away if jQuery is already ready"] = function testApplicationSReadyEventIsCalledRightAwayIfJQueryIsAlreadyReady(assert) {
      jQuery.isReady = true;
      (0, _runloop.run)(function () {
        application = Application.create({
          router: false
        });
        assert.equal(readyWasCalled, 0, 'ready is not called until later');
      });
      assert.equal(readyWasCalled, 1, 'ready was called');
      domReady();
      assert.equal(readyWasCalled, 1, "application's ready was not called again");
    };

    _proto["@test Application's ready event is called after the document becomes ready"] = function testApplicationSReadyEventIsCalledAfterTheDocumentBecomesReady(assert) {
      (0, _runloop.run)(function () {
        application = Application.create({
          router: false
        });
      });
      assert.equal(readyWasCalled, 0, "ready wasn't called yet");
      domReady();
      assert.equal(readyWasCalled, 1, 'ready was called now that DOM is ready');
    };

    _proto["@test Application's ready event can be deferred by other components"] = function testApplicationSReadyEventCanBeDeferredByOtherComponents(assert) {
      (0, _runloop.run)(function () {
        application = Application.create({
          router: false
        });
        application.deferReadiness();
      });
      assert.equal(readyWasCalled, 0, "ready wasn't called yet");
      domReady();
      assert.equal(readyWasCalled, 0, "ready wasn't called yet");
      (0, _runloop.run)(function () {
        application.advanceReadiness();
        assert.equal(readyWasCalled, 0);
      });
      assert.equal(readyWasCalled, 1, 'ready was called now all readiness deferrals are advanced');
    };

    _proto["@test Application's ready event can be deferred by other components"] = function testApplicationSReadyEventCanBeDeferredByOtherComponents(assert) {
      jQuery.isReady = false;
      (0, _runloop.run)(function () {
        application = Application.create({
          router: false
        });
        application.deferReadiness();
        assert.equal(readyWasCalled, 0, "ready wasn't called yet");
      });
      domReady();
      assert.equal(readyWasCalled, 0, "ready wasn't called yet");
      (0, _runloop.run)(function () {
        application.advanceReadiness();
      });
      assert.equal(readyWasCalled, 1, 'ready was called now all readiness deferrals are advanced');
      expectAssertion(function () {
        application.deferReadiness();
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/application/tests/reset_test", ["ember-babel", "@ember/runloop", "@ember/-internals/metal", "@ember/controller", "@ember/-internals/routing", "internal-test-helpers"], function (_emberBabel, _runloop, _metal, _controller, _routing, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application - resetting',
  /*#__PURE__*/
  function (_AutobootApplicationT) {
    (0, _emberBabel.inheritsLoose)(_class, _AutobootApplicationT);

    function _class() {
      return _AutobootApplicationT.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Brings its own run-loop if not provided'] = function testBringsItsOwnRunLoopIfNotProvided(assert) {
      var _this = this;

      assert.expect(0);
      (0, _runloop.run)(function () {
        return _this.createApplication();
      });
      this.application.reset();
    };

    _proto['@test Does not bring its own run loop if one is already provided'] = function testDoesNotBringItsOwnRunLoopIfOneIsAlreadyProvided(assert) {
      var _this2 = this;

      assert.expect(3);
      var didBecomeReady = false;
      (0, _runloop.run)(function () {
        return _this2.createApplication();
      });
      (0, _runloop.run)(function () {
        _this2.application.ready = function () {
          didBecomeReady = true;
        };

        _this2.application.reset();

        _this2.application.deferReadiness();

        assert.ok(!didBecomeReady, 'app is not ready');
      });
      assert.ok(!didBecomeReady, 'app is not ready');
      (0, _runloop.run)(this.application, 'advanceReadiness');
      assert.ok(didBecomeReady, 'app is ready');
    };

    _proto['@test When an application is reset, new instances of controllers are generated'] = function testWhenAnApplicationIsResetNewInstancesOfControllersAreGenerated(assert) {
      var _this3 = this;

      (0, _runloop.run)(function () {
        _this3.createApplication();

        _this3.add('controller:academic', _controller.default.extend());
      });
      var firstController = this.applicationInstance.lookup('controller:academic');
      var secondController = this.applicationInstance.lookup('controller:academic');
      this.application.reset();
      var thirdController = this.applicationInstance.lookup('controller:academic');
      assert.strictEqual(firstController, secondController, 'controllers looked up in succession should be the same instance');
      assert.ok(firstController.isDestroying, 'controllers are destroyed when their application is reset');
      assert.notStrictEqual(firstController, thirdController, 'controllers looked up after the application is reset should not be the same instance');
    };

    _proto['@test When an application is reset, the eventDispatcher is destroyed and recreated'] = function testWhenAnApplicationIsResetTheEventDispatcherIsDestroyedAndRecreated(assert) {
      var _this4 = this;

      var eventDispatcherWasSetup = 0;
      var eventDispatcherWasDestroyed = 0;
      var mockEventDispatcher = {
        setup: function () {
          eventDispatcherWasSetup++;
        },
        destroy: function () {
          eventDispatcherWasDestroyed++;
        }
      };
      (0, _runloop.run)(function () {
        _this4.createApplication();

        _this4.add('event_dispatcher:main', {
          create: function () {
            return mockEventDispatcher;
          }
        });

        assert.equal(eventDispatcherWasSetup, 0);
        assert.equal(eventDispatcherWasDestroyed, 0);
      });
      assert.equal(eventDispatcherWasSetup, 1);
      assert.equal(eventDispatcherWasDestroyed, 0);
      this.application.reset();
      assert.equal(eventDispatcherWasDestroyed, 1);
      assert.equal(eventDispatcherWasSetup, 2, 'setup called after reset');
    };

    _proto['@test When an application is reset, the router URL is reset to `/`'] = function testWhenAnApplicationIsResetTheRouterURLIsResetTo(assert) {
      var _this5 = this;

      (0, _runloop.run)(function () {
        _this5.createApplication();

        _this5.add('router:main', _routing.Router.extend({
          location: 'none'
        }));

        _this5.router.map(function () {
          this.route('one');
          this.route('two');
        });
      });
      var initialRouter, initialApplicationController;
      return this.visit('/one').then(function () {
        initialApplicationController = _this5.applicationInstance.lookup('controller:application');
        initialRouter = _this5.applicationInstance.lookup('router:main');
        var location = initialRouter.get('location');
        assert.equal(location.getURL(), '/one');
        expectDeprecation(function () {
          assert.equal((0, _metal.get)(initialApplicationController, 'currentPath'), 'one');
        }, 'Accessing `currentPath` on `controller:application` is deprecated, use the `currentPath` property on `service:router` instead.');

        _this5.application.reset();

        return _this5.application._bootPromise;
      }).then(function () {
        var applicationController = _this5.applicationInstance.lookup('controller:application');

        assert.strictEqual(applicationController, undefined, 'application controller no longer exists');
        return _this5.visit('/one');
      }).then(function () {
        var applicationController = _this5.applicationInstance.lookup('controller:application');

        var router = _this5.applicationInstance.lookup('router:main');

        var location = router.get('location');
        assert.notEqual(initialRouter, router, 'a different router instance was created');
        assert.notEqual(initialApplicationController, applicationController, 'a different application controller is created');
        assert.equal(location.getURL(), '/one');
        expectDeprecation(function () {
          assert.equal((0, _metal.get)(applicationController, 'currentPath'), 'one');
        }, 'Accessing `currentPath` on `controller:application` is deprecated, use the `currentPath` property on `service:router` instead.');
      });
    };

    _proto['@test When an application with advance/deferReadiness is reset, the app does correctly become ready after reset'] = function testWhenAnApplicationWithAdvanceDeferReadinessIsResetTheAppDoesCorrectlyBecomeReadyAfterReset(assert) {
      var _this6 = this;

      var readyCallCount = 0;
      (0, _runloop.run)(function () {
        _this6.createApplication({
          ready: function () {
            readyCallCount++;
          }
        });

        _this6.application.deferReadiness();

        assert.equal(readyCallCount, 0, 'ready has not yet been called');
      });
      (0, _runloop.run)(this.application, 'advanceReadiness');
      assert.equal(readyCallCount, 1, 'ready was called once');
      this.application.reset();
      assert.equal(readyCallCount, 2, 'ready was called twice');
    };

    return _class;
  }(_internalTestHelpers.AutobootApplicationTestCase));
});
enifed("@ember/application/tests/visit_test", ["ember-babel", "internal-test-helpers", "@ember/service", "@ember/-internals/runtime", "@ember/runloop", "@ember/application", "@ember/application/instance", "@ember/engine", "@ember/-internals/routing", "@ember/-internals/glimmer", "ember-template-compiler", "@ember/-internals/environment"], function (_emberBabel, _internalTestHelpers, _service, _runtime, _runloop, _application, _instance, _engine, _routing, _glimmer, _emberTemplateCompiler, _environment) {
  "use strict";

  function expectAsyncError() {
    _runtime.RSVP.off('error');
  }

  (0, _internalTestHelpers.moduleFor)('Application - visit()',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _runtime.RSVP.on('error', _runtime.onerrorDefault);

      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = false;

      _ApplicationTestCase.prototype.teardown.call(this);
    };

    _proto.createApplication = function createApplication(options) {
      return _ApplicationTestCase.prototype.createApplication.call(this, options, _application.default.extend());
    };

    _proto.assertEmptyFixture = function assertEmptyFixture(message) {
      this.assert.strictEqual(document.getElementById('qunit-fixture').children.length, 0, "there are no elements in the fixture element " + (message ? message : ''));
    };

    _proto["@test does not add serialize-mode markers by default"] = function (assert) {
      var templateContent = '<div class="foo">Hi, Mom!</div>';
      this.addTemplate('index', templateContent);
      var rootElement = document.createElement('div');
      var bootOptions = {
        isBrowser: false,
        rootElement: rootElement
      };
      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = false;
      return this.visit('/', bootOptions).then(function () {
        assert.equal(rootElement.innerHTML, templateContent, 'without serialize flag renders as expected');
      });
    };

    _proto["@test _renderMode: rehydration"] = function (assert) {
      var _this = this;

      assert.expect(2);
      var indexTemplate = '<div class="foo">Hi, Mom!</div>';
      this.addTemplate('index', indexTemplate);
      var rootElement = document.createElement('div');
      var bootOptions = {
        isBrowser: false,
        rootElement: rootElement,
        _renderMode: 'serialize'
      };
      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = false;
      return this.visit('/', bootOptions).then(function (instance) {
        assert.ok((0, _glimmer.isSerializationFirstNode)(instance.rootElement.firstChild), 'glimmer-vm comment node was not found');
      }).then(function () {
        return (0, _internalTestHelpers.runTask)(function () {
          _this.applicationInstance.destroy();

          _this.applicationInstance = null;
        });
      }).then(function () {
        bootOptions = {
          isBrowser: false,
          rootElement: rootElement,
          _renderMode: 'rehydrate'
        };

        _this.application.visit('/', bootOptions).then(function (instance) {
          assert.equal(instance.rootElement.innerHTML, indexTemplate, 'was not properly rehydrated');
        });
      });
    } // This tests whether the application is "autobooted" by registering an
    // instance initializer and asserting it never gets run. Since this is
    // inherently testing that async behavior *doesn't* happen, we set a
    // 500ms timeout to verify that when autoboot is set to false, the
    // instance initializer that would normally get called on DOM ready
    // does not fire.
    ;

    _proto["@test Applications with autoboot set to false do not autoboot"] = function (assert) {
      var _this2 = this;

      function delay(time) {
        return new _runtime.RSVP.Promise(function (resolve) {
          return (0, _runloop.later)(resolve, time);
        });
      }

      var appBooted = 0;
      var instanceBooted = 0;
      this.application.initializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          appBooted++;
        }
      });
      this.application.instanceInitializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          instanceBooted++;
        }
      });
      assert.ok(!this.applicationInstance, 'precond - no instance');
      assert.ok(appBooted === 0, 'precond - not booted');
      assert.ok(instanceBooted === 0, 'precond - not booted'); // Continue after 500ms

      return delay(500).then(function () {
        assert.ok(appBooted === 0, '500ms elapsed without app being booted');
        assert.ok(instanceBooted === 0, '500ms elapsed without instances being booted');
        return (0, _internalTestHelpers.runTask)(function () {
          return _this2.application.boot();
        });
      }).then(function () {
        assert.ok(appBooted === 1, 'app should boot when manually calling `app.boot()`');
        assert.ok(instanceBooted === 0, 'no instances should be booted automatically when manually calling `app.boot()');
      });
    };

    _proto["@test calling visit() on an app without first calling boot() should boot the app"] = function (assert) {
      var appBooted = 0;
      var instanceBooted = 0;
      this.application.initializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          appBooted++;
        }
      });
      this.application.instanceInitializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          instanceBooted++;
        }
      });
      return this.visit('/').then(function () {
        assert.ok(appBooted === 1, 'the app should be booted`');
        assert.ok(instanceBooted === 1, 'an instances should be booted');
      });
    };

    _proto["@test calling visit() on an already booted app should not boot it again"] = function (assert) {
      var _this3 = this;

      var appBooted = 0;
      var instanceBooted = 0;
      this.application.initializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          appBooted++;
        }
      });
      this.application.instanceInitializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          instanceBooted++;
        }
      });
      return (0, _internalTestHelpers.runTask)(function () {
        return _this3.application.boot();
      }).then(function () {
        assert.ok(appBooted === 1, 'the app should be booted');
        assert.ok(instanceBooted === 0, 'no instances should be booted');
        return _this3.visit('/');
      }).then(function () {
        assert.ok(appBooted === 1, 'the app should not be booted again');
        assert.ok(instanceBooted === 1, 'an instance should be booted');
        /*
         * Destroy the instance.
         */

        return (0, _internalTestHelpers.runTask)(function () {
          _this3.applicationInstance.destroy();

          _this3.applicationInstance = null;
        });
      }).then(function () {
        /*
         * Visit on the application a second time. The application should remain
         * booted, but a new instance will be created.
         */
        return _this3.application.visit('/').then(function (instance) {
          _this3.applicationInstance = instance;
        });
      }).then(function () {
        assert.ok(appBooted === 1, 'the app should not be booted again');
        assert.ok(instanceBooted === 2, 'another instance should be booted');
      });
    };

    _proto["@test visit() rejects on application boot failure"] = function (assert) {
      this.application.initializer({
        name: 'error',
        initialize: function () {
          throw new Error('boot failure');
        }
      });
      expectAsyncError();
      return this.visit('/').then(function () {
        assert.ok(false, 'It should not resolve the promise');
      }, function (error) {
        assert.ok(error instanceof Error, 'It should reject the promise with the boot error');
        assert.equal(error.message, 'boot failure');
      });
    };

    _proto["@test visit() rejects on instance boot failure"] = function (assert) {
      this.application.instanceInitializer({
        name: 'error',
        initialize: function () {
          throw new Error('boot failure');
        }
      });
      expectAsyncError();
      return this.visit('/').then(function () {
        assert.ok(false, 'It should not resolve the promise');
      }, function (error) {
        assert.ok(error instanceof Error, 'It should reject the promise with the boot error');
        assert.equal(error.message, 'boot failure');
      });
    };

    _proto["@test visit() follows redirects"] = function (assert) {
      this.router.map(function () {
        this.route('a');
        this.route('b', {
          path: '/b/:b'
        });
        this.route('c', {
          path: '/c/:c'
        });
      });
      this.add('route:a', _routing.Route.extend({
        afterModel: function () {
          this.replaceWith('b', 'zomg');
        }
      }));
      this.add('route:b', _routing.Route.extend({
        afterModel: function (params) {
          this.transitionTo('c', params.b);
        }
      }));
      /*
       * First call to `visit` is `this.application.visit` and returns the
       * applicationInstance.
       */

      return this.visit('/a').then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(instance.getURL(), '/c/zomg', 'It should follow all redirects');
      });
    };

    _proto["@test visit() rejects if an error occurred during a transition"] = function (assert) {
      this.router.map(function () {
        this.route('a');
        this.route('b', {
          path: '/b/:b'
        });
        this.route('c', {
          path: '/c/:c'
        });
      });
      this.add('route:a', _routing.Route.extend({
        afterModel: function () {
          this.replaceWith('b', 'zomg');
        }
      }));
      this.add('route:b', _routing.Route.extend({
        afterModel: function (params) {
          this.transitionTo('c', params.b);
        }
      }));
      this.add('route:c', _routing.Route.extend({
        afterModel: function () {
          throw new Error('transition failure');
        }
      }));
      expectAsyncError();
      return this.visit('/a').then(function () {
        assert.ok(false, 'It should not resolve the promise');
      }, function (error) {
        assert.ok(error instanceof Error, 'It should reject the promise with the boot error');
        assert.equal(error.message, 'transition failure');
      });
    };

    _proto["@test visit() chain"] = function (assert) {
      this.router.map(function () {
        this.route('a');
        this.route('b');
        this.route('c');
      });
      return this.visit('/').then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(instance.getURL(), '/');
        return instance.visit('/a');
      }).then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(instance.getURL(), '/a');
        return instance.visit('/b');
      }).then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(instance.getURL(), '/b');
        return instance.visit('/c');
      }).then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(instance.getURL(), '/c');
      });
    };

    _proto["@test visit() returns a promise that resolves when the view has rendered"] = function (assert) {
      var _this4 = this;

      this.addTemplate('application', "<h1>Hello world</h1>");
      this.assertEmptyFixture();
      return this.visit('/').then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.equal(_this4.element.textContent, 'Hello world', 'the application was rendered once the promise resolves');
      });
    };

    _proto["@test visit() returns a promise that resolves without rendering when shouldRender is set to false"] = function (assert) {
      var _this5 = this;

      assert.expect(3);
      this.addTemplate('application', '<h1>Hello world</h1>');
      this.assertEmptyFixture();
      return this.visit('/', {
        shouldRender: false
      }).then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');

        _this5.assertEmptyFixture('after visit');
      });
    };

    _proto["@test visit() renders a template when shouldRender is set to true"] = function (assert) {
      assert.expect(3);
      this.addTemplate('application', '<h1>Hello world</h1>');
      this.assertEmptyFixture();
      return this.visit('/', {
        shouldRender: true
      }).then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.strictEqual(document.querySelector('#qunit-fixture').children.length, 1, 'there is 1 element in the fixture element after visit');
      });
    };

    _proto["@test visit() returns a promise that resolves without rendering when shouldRender is set to false with Engines"] = function (assert) {
      var _this6 = this;

      assert.expect(3);
      this.router.map(function () {
        this.mount('blog');
      });
      this.addTemplate('application', '<h1>Hello world</h1>'); // Register engine

      var BlogEngine = _engine.default.extend();

      this.add('engine:blog', BlogEngine); // Register engine route map

      var BlogMap = function () {};

      this.add('route-map:blog', BlogMap);
      this.assertEmptyFixture();
      return this.visit('/blog', {
        shouldRender: false
      }).then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');

        _this6.assertEmptyFixture('after visit');
      });
    };

    _proto["@test visit() does not setup the event_dispatcher:main if isInteractive is false (with Engines) GH#15615"] = function (assert) {
      var _this7 = this;

      assert.expect(3);
      this.router.map(function () {
        this.mount('blog');
      });
      this.addTemplate('application', '<h1>Hello world</h1>{{outlet}}');
      this.add('event_dispatcher:main', {
        create: function () {
          throw new Error('should not happen!');
        }
      }); // Register engine

      var BlogEngine = _engine.default.extend({
        init: function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          this._super.apply(this, args);

          this.register('template:application', (0, _emberTemplateCompiler.compile)('{{cache-money}}'));
          this.register('template:components/cache-money', (0, _emberTemplateCompiler.compile)("\n          <p>Dis cache money</p>\n        "));
          this.register('component:cache-money', _glimmer.Component.extend({}));
        }
      });

      this.add('engine:blog', BlogEngine); // Register engine route map

      var BlogMap = function () {};

      this.add('route-map:blog', BlogMap);
      this.assertEmptyFixture();
      return this.visit('/blog', {
        isInteractive: false
      }).then(function (instance) {
        assert.ok(instance instanceof _instance.default, 'promise is resolved with an ApplicationInstance');
        assert.strictEqual(_this7.element.querySelector('p').textContent, 'Dis cache money', 'Engine component is resolved');
      });
    };

    _proto["@test visit() on engine resolves engine component"] = function (assert) {
      var _this8 = this;

      assert.expect(2);
      this.router.map(function () {
        this.mount('blog');
      }); // Register engine

      var BlogEngine = _engine.default.extend({
        init: function () {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          this._super.apply(this, args);

          this.register('template:application', (0, _emberTemplateCompiler.compile)('{{cache-money}}'));
          this.register('template:components/cache-money', (0, _emberTemplateCompiler.compile)("\n          <p>Dis cache money</p>\n        "));
          this.register('component:cache-money', _glimmer.Component.extend({}));
        }
      });

      this.add('engine:blog', BlogEngine); // Register engine route map

      var BlogMap = function () {};

      this.add('route-map:blog', BlogMap);
      this.assertEmptyFixture();
      return this.visit('/blog', {
        shouldRender: true
      }).then(function () {
        assert.strictEqual(_this8.element.querySelector('p').textContent, 'Dis cache money', 'Engine component is resolved');
      });
    };

    _proto["@test visit() on engine resolves engine helper"] = function (assert) {
      var _this9 = this;

      assert.expect(2);
      this.router.map(function () {
        this.mount('blog');
      }); // Register engine

      var BlogEngine = _engine.default.extend({
        init: function () {
          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          this._super.apply(this, args);

          this.register('template:application', (0, _emberTemplateCompiler.compile)('{{swag}}'));
          this.register('helper:swag', (0, _glimmer.helper)(function () {
            return 'turnt up';
          }));
        }
      });

      this.add('engine:blog', BlogEngine); // Register engine route map

      var BlogMap = function () {};

      this.add('route-map:blog', BlogMap);
      this.assertEmptyFixture();
      return this.visit('/blog', {
        shouldRender: true
      }).then(function () {
        assert.strictEqual(_this9.element.textContent, 'turnt up', 'Engine component is resolved');
      });
    };

    _proto["@test Ember Islands-style setup"] = function (assert) {
      var _this10 = this;

      var xFooInitCalled = false;
      var xFooDidInsertElementCalled = false;
      var xBarInitCalled = false;
      var xBarDidInsertElementCalled = false;
      this.router.map(function () {
        this.route('show', {
          path: '/:component_name'
        });
      });
      this.add('route:show', _routing.Route.extend({
        queryParams: {
          data: {
            refreshModel: true
          }
        },
        model: function (params) {
          return {
            componentName: params.component_name,
            componentData: params.data ? JSON.parse(params.data) : undefined
          };
        }
      }));

      var Counter = _runtime.Object.extend({
        value: 0,
        increment: function () {
          this.incrementProperty('value');
        }
      });

      this.add('service:isolatedCounter', Counter);
      this.add('service:sharedCounter', Counter.create());
      this.application.registerOptions('service:sharedCounter', {
        instantiate: false
      });
      this.addTemplate('show', '{{component model.componentName model=model.componentData}}');
      this.addTemplate('components/x-foo', "\n      <h1>X-Foo</h1>\n      <p>Hello {{model.name}}, I have been clicked {{isolatedCounter.value}} times ({{sharedCounter.value}} times combined)!</p>\n    ");
      this.add('component:x-foo', _glimmer.Component.extend({
        tagName: 'x-foo',
        isolatedCounter: (0, _service.inject)(),
        sharedCounter: (0, _service.inject)(),
        init: function () {
          this._super();

          xFooInitCalled = true;
        },
        didInsertElement: function () {
          xFooDidInsertElementCalled = true;
        },
        click: function () {
          this.get('isolatedCounter').increment();
          this.get('sharedCounter').increment();
        }
      }));
      this.addTemplate('components/x-bar', "\n      <h1>X-Bar</h1>\n      <button {{action \"incrementCounter\"}}>Join {{counter.value}} others in clicking me!</button>\n    ");
      this.add('component:x-bar', _glimmer.Component.extend({
        counter: (0, _service.inject)('sharedCounter'),
        actions: {
          incrementCounter: function () {
            this.get('counter').increment();
          }
        },
        init: function () {
          this._super();

          xBarInitCalled = true;
        },
        didInsertElement: function () {
          xBarDidInsertElementCalled = true;
        }
      }));
      var fixtureElement = document.querySelector('#qunit-fixture');
      var foo = document.createElement('div');
      var bar = document.createElement('div');
      fixtureElement.appendChild(foo);
      fixtureElement.appendChild(bar);
      var data = encodeURIComponent(JSON.stringify({
        name: 'Godfrey'
      }));
      var instances = [];
      return _runtime.RSVP.all([(0, _internalTestHelpers.runTask)(function () {
        return _this10.application.visit("/x-foo?data=" + data, {
          rootElement: foo
        });
      }), (0, _internalTestHelpers.runTask)(function () {
        return _this10.application.visit('/x-bar', {
          rootElement: bar
        });
      })]).then(function (_instances) {
        instances = _instances;
        assert.ok(xFooInitCalled);
        assert.ok(xFooDidInsertElementCalled);
        assert.ok(xBarInitCalled);
        assert.ok(xBarDidInsertElementCalled);
        assert.equal(foo.querySelector('h1').textContent, 'X-Foo');
        assert.equal(foo.querySelector('p').textContent, 'Hello Godfrey, I have been clicked 0 times (0 times combined)!');
        assert.ok(foo.textContent.indexOf('X-Bar') === -1);
        assert.equal(bar.querySelector('h1').textContent, 'X-Bar');
        assert.equal(bar.querySelector('button').textContent, 'Join 0 others in clicking me!');
        assert.ok(bar.textContent.indexOf('X-Foo') === -1);
        (0, _internalTestHelpers.runTask)(function () {
          _this10.click(foo.querySelector('x-foo'));
        });
        assert.equal(foo.querySelector('p').textContent, 'Hello Godfrey, I have been clicked 1 times (1 times combined)!');
        assert.equal(bar.querySelector('button').textContent, 'Join 1 others in clicking me!');
        (0, _internalTestHelpers.runTask)(function () {
          _this10.click(bar.querySelector('button'));

          _this10.click(bar.querySelector('button'));
        });
        assert.equal(foo.querySelector('p').textContent, 'Hello Godfrey, I have been clicked 1 times (3 times combined)!');
        assert.equal(bar.querySelector('button').textContent, 'Join 3 others in clicking me!');
      }).finally(function () {
        (0, _internalTestHelpers.runTask)(function () {
          instances.forEach(function (instance) {
            instance.destroy();
          });
        });
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("@ember/controller/tests/controller_test", ["ember-babel", "@ember/controller", "@ember/service", "@ember/-internals/runtime", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _controller, _service, _runtime, _metal, _internalTestHelpers) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }

    return desc;
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');
  }

  (0, _internalTestHelpers.moduleFor)('Controller event handling',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase);

    function _class2() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class2.prototype;

    _proto['@test Action can be handled by a function on actions object'] = function testActionCanBeHandledByAFunctionOnActionsObject(assert) {
      assert.expect(1);

      var TestController = _controller.default.extend({
        actions: {
          poke: function () {
            assert.ok(true, 'poked');
          }
        }
      });

      var controller = TestController.create();
      controller.send('poke');
    };

    _proto['@test A handled action can be bubbled to the target for continued processing'] = function testAHandledActionCanBeBubbledToTheTargetForContinuedProcessing(assert) {
      assert.expect(2);

      var TestController = _controller.default.extend({
        actions: {
          poke: function () {
            assert.ok(true, 'poked 1');
            return true;
          }
        }
      });

      var controller = TestController.create({
        target: _controller.default.extend({
          actions: {
            poke: function () {
              assert.ok(true, 'poked 2');
            }
          }
        }).create()
      });
      controller.send('poke');
    };

    _proto["@test Action can be handled by a superclass' actions object"] = function testActionCanBeHandledByASuperclassActionsObject(assert) {
      assert.expect(4);

      var SuperController = _controller.default.extend({
        actions: {
          foo: function () {
            assert.ok(true, 'foo');
          },
          bar: function (msg) {
            assert.equal(msg, 'HELLO');
          }
        }
      });

      var BarControllerMixin = _metal.Mixin.create({
        actions: {
          bar: function (msg) {
            assert.equal(msg, 'HELLO');

            this._super(msg);
          }
        }
      });

      var IndexController = SuperController.extend(BarControllerMixin, {
        actions: {
          baz: function () {
            assert.ok(true, 'baz');
          }
        }
      });
      var controller = IndexController.create({});
      controller.send('foo');
      controller.send('bar', 'HELLO');
      controller.send('baz');
    };

    _proto['@test .send asserts if called on a destroyed controller'] = function testSendAssertsIfCalledOnADestroyedController() {
      var owner = (0, _internalTestHelpers.buildOwner)();
      owner.register('controller:application', _controller.default.extend({
        toString: function () {
          return 'controller:rip-alley';
        }
      }));
      var controller = owner.lookup('controller:application');
      (0, _internalTestHelpers.runDestroy)(owner);
      expectAssertion(function () {
        controller.send('trigger-me-dead');
      }, "Attempted to call .send() with the action 'trigger-me-dead' on the destroyed object 'controller:rip-alley'.");
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Controller deprecations -> Controller Content -> Model Alias',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class4, _AbstractTestCase2);

    function _class4() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class4.prototype;

    _proto2['@test `content` is not moved to `model` when `model` is unset'] = function testContentIsNotMovedToModelWhenModelIsUnset(assert) {
      assert.expect(2);
      var controller;
      ignoreDeprecation(function () {
        controller = _controller.default.extend({
          content: 'foo-bar'
        }).create();
      });
      assert.notEqual(controller.get('model'), 'foo-bar', 'model is set properly');
      assert.equal(controller.get('content'), 'foo-bar', 'content is not set properly');
    };

    _proto2['@test specifying `content` (without `model` specified) does not result in deprecation'] = function testSpecifyingContentWithoutModelSpecifiedDoesNotResultInDeprecation(assert) {
      assert.expect(2);
      expectNoDeprecation();

      var controller = _controller.default.extend({
        content: 'foo-bar'
      }).create();

      assert.equal((0, _metal.get)(controller, 'content'), 'foo-bar');
    };

    _proto2['@test specifying `content` (with `model` specified) does not result in deprecation'] = function testSpecifyingContentWithModelSpecifiedDoesNotResultInDeprecation(assert) {
      assert.expect(3);
      expectNoDeprecation();

      var controller = _controller.default.extend({
        content: 'foo-bar',
        model: 'blammo'
      }).create();

      assert.equal((0, _metal.get)(controller, 'content'), 'foo-bar');
      assert.equal((0, _metal.get)(controller, 'model'), 'blammo');
    };

    return _class4;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Controller deprecations -> Controller injected properties',
  /*#__PURE__*/
  function (_AbstractTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class5, _AbstractTestCase3);

    function _class5() {
      return _AbstractTestCase3.apply(this, arguments) || this;
    }

    var _proto3 = _class5.prototype;

    _proto3['@test defining a controller on a non-controller should fail assertion'] = function testDefiningAControllerOnANonControllerShouldFailAssertion() {
      expectAssertion(function () {
        var owner = (0, _internalTestHelpers.buildOwner)();

        var AnObject = _runtime.Object.extend({
          foo: (0, _controller.inject)('bar')
        });

        owner.register('controller:bar', _runtime.Object.extend());
        owner.register('foo:main', AnObject);
        owner.lookup('foo:main');
      }, /Defining `foo` as an injected controller property on a non-controller \(`foo:main`\) is not allowed/);
    };

    _proto3['@test controllers can be injected into controllers'] = function testControllersCanBeInjectedIntoControllers(assert) {
      var owner = (0, _internalTestHelpers.buildOwner)();
      owner.register('controller:post', _controller.default.extend({
        postsController: (0, _controller.inject)('posts')
      }));
      owner.register('controller:posts', _controller.default.extend());
      var postController = owner.lookup('controller:post');
      var postsController = owner.lookup('controller:posts');
      assert.equal(postsController, postController.get('postsController'), 'controller.posts is injected');
    };

    _proto3['@test services can be injected into controllers'] = function testServicesCanBeInjectedIntoControllers(assert) {
      var owner = (0, _internalTestHelpers.buildOwner)();
      owner.register('controller:application', _controller.default.extend({
        authService: (0, _service.inject)('auth')
      }));
      owner.register('service:auth', _service.default.extend());
      var appController = owner.lookup('controller:application');
      var authService = owner.lookup('service:auth');
      assert.equal(authService, appController.get('authService'), 'service.auth is injected');
    };

    return _class5;
  }(_internalTestHelpers.AbstractTestCase));

  if (true
  /* EMBER_NATIVE_DECORATOR_SUPPORT */
  ) {
      (0, _internalTestHelpers.moduleFor)('Controller Injections',
      /*#__PURE__*/
      function (_AbstractTestCase4) {
        (0, _emberBabel.inheritsLoose)(_class6, _AbstractTestCase4);

        function _class6() {
          return _AbstractTestCase4.apply(this, arguments) || this;
        }

        var _proto4 = _class6.prototype;

        _proto4['@test works with native decorators'] = function testWorksWithNativeDecorators(assert) {
          var _dec, _class, _descriptor, _temp;

          var owner = (0, _internalTestHelpers.buildOwner)();

          var MainController =
          /*#__PURE__*/
          function (_Controller) {
            (0, _emberBabel.inheritsLoose)(MainController, _Controller);

            function MainController() {
              return _Controller.apply(this, arguments) || this;
            }

            return MainController;
          }(_controller.default);

          var IndexController = (_dec = (0, _controller.inject)('main'), (_class = (_temp =
          /*#__PURE__*/
          function (_Controller2) {
            (0, _emberBabel.inheritsLoose)(IndexController, _Controller2);

            function IndexController() {
              var _this;

              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              _this = _Controller2.call.apply(_Controller2, [this].concat(args)) || this;

              _initializerDefineProperty((0, _emberBabel.assertThisInitialized)(_this), "main", _descriptor, (0, _emberBabel.assertThisInitialized)(_this));

              return _this;
            }

            return IndexController;
          }(_controller.default), _temp), _descriptor = _applyDecoratedDescriptor(_class.prototype, "main", [_dec], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: null
          }), _class));
          owner.register('controller:main', MainController);
          owner.register('controller:index', IndexController);
          var index = owner.lookup('controller:index');
          assert.ok(index.main instanceof _controller.default, 'controller injected correctly');
        };

        _proto4['@test uses the decorated property key if not provided'] = function testUsesTheDecoratedPropertyKeyIfNotProvided(assert) {
          var _class3, _descriptor2, _temp2;

          var owner = (0, _internalTestHelpers.buildOwner)();

          var MainController =
          /*#__PURE__*/
          function (_Controller3) {
            (0, _emberBabel.inheritsLoose)(MainController, _Controller3);

            function MainController() {
              return _Controller3.apply(this, arguments) || this;
            }

            return MainController;
          }(_controller.default);

          var IndexController = (_class3 = (_temp2 =
          /*#__PURE__*/
          function (_Controller4) {
            (0, _emberBabel.inheritsLoose)(IndexController, _Controller4);

            function IndexController() {
              var _this2;

              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }

              _this2 = _Controller4.call.apply(_Controller4, [this].concat(args)) || this;

              _initializerDefineProperty((0, _emberBabel.assertThisInitialized)(_this2), "main", _descriptor2, (0, _emberBabel.assertThisInitialized)(_this2));

              return _this2;
            }

            return IndexController;
          }(_controller.default), _temp2), _descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "main", [_controller.inject], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: null
          }), _class3);
          owner.register('controller:main', MainController);
          owner.register('controller:index', IndexController);
          var index = owner.lookup('controller:index');
          assert.ok(index.main instanceof _controller.default, 'controller injected correctly');
        };

        return _class6;
      }(_internalTestHelpers.AbstractTestCase));
    }
});
enifed("@ember/debug/tests/handlers-test", ["ember-babel", "@ember/debug/lib/handlers", "internal-test-helpers"], function (_emberBabel, _handlers, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-debug: registerHandler',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      delete _handlers.HANDLERS.blarz;
    };

    _proto['@test calls handler on `invoke` when `falsey`'] = function testCallsHandlerOnInvokeWhenFalsey(assert) {
      assert.expect(2);

      function handler(message) {
        assert.ok(true, 'called handler');
        assert.equal(message, 'Foo bar');
      }

      (0, _handlers.registerHandler)('blarz', handler);
      (0, _handlers.invoke)('blarz', 'Foo bar', false);
    };

    _proto['@test does not call handler on `invoke` when `truthy`'] = function testDoesNotCallHandlerOnInvokeWhenTruthy(assert) {
      assert.expect(0);

      function handler() {
        assert.ok(false, 'called handler');
      }

      (0, _handlers.registerHandler)('blarz', handler);
      (0, _handlers.invoke)('blarz', 'Foo bar', true);
    };

    _proto['@test calling `invoke` without handlers does not throw an error'] = function testCallingInvokeWithoutHandlersDoesNotThrowAnError(assert) {
      assert.expect(0);
      (0, _handlers.invoke)('blarz', 'Foo bar', false);
    };

    _proto['@test invoking `next` argument calls the next handler'] = function testInvokingNextArgumentCallsTheNextHandler(assert) {
      assert.expect(2);

      function handler1() {
        assert.ok(true, 'called handler1');
      }

      function handler2(message, options, next) {
        assert.ok(true, 'called handler2');
        next(message, options);
      }

      (0, _handlers.registerHandler)('blarz', handler1);
      (0, _handlers.registerHandler)('blarz', handler2);
      (0, _handlers.invoke)('blarz', 'Foo', false);
    };

    _proto['@test invoking `next` when no other handlers exists does not error'] = function testInvokingNextWhenNoOtherHandlersExistsDoesNotError(assert) {
      assert.expect(1);

      function handler(message, options, next) {
        assert.ok(true, 'called handler1');
        next(message, options);
      }

      (0, _handlers.registerHandler)('blarz', handler);
      (0, _handlers.invoke)('blarz', 'Foo', false);
    };

    _proto['@test handlers are called in the proper order'] = function testHandlersAreCalledInTheProperOrder(assert) {
      assert.expect(11);
      var expectedMessage = 'This is the message';
      var expectedOptions = {
        id: 'foo-bar'
      };
      var expected = ['first', 'second', 'third', 'fourth', 'fifth'];
      var actualCalls = [];

      function generateHandler(item) {
        return function (message, options, next) {
          assert.equal(message, expectedMessage, "message supplied to " + item + " handler is correct");
          assert.equal(options, expectedOptions, "options supplied to " + item + " handler is correct");
          actualCalls.push(item);
          next(message, options);
        };
      }

      expected.forEach(function (item) {
        return (0, _handlers.registerHandler)('blarz', generateHandler(item));
      });
      (0, _handlers.invoke)('blarz', expectedMessage, false, expectedOptions);
      assert.deepEqual(actualCalls, expected.reverse(), 'handlers were called in proper order');
    };

    _proto['@test not invoking `next` prevents further handlers from being called'] = function testNotInvokingNextPreventsFurtherHandlersFromBeingCalled(assert) {
      assert.expect(1);

      function handler1() {
        assert.ok(false, 'called handler1');
      }

      function handler2() {
        assert.ok(true, 'called handler2');
      }

      (0, _handlers.registerHandler)('blarz', handler1);
      (0, _handlers.registerHandler)('blarz', handler2);
      (0, _handlers.invoke)('blarz', 'Foo', false);
    };

    _proto['@test handlers can call `next` with custom message and/or options'] = function testHandlersCanCallNextWithCustomMessageAndOrOptions(assert) {
      assert.expect(4);
      var initialMessage = 'initial message';
      var initialOptions = {
        id: 'initial-options'
      };
      var handler2Message = 'Handler2 Message';
      var handler2Options = {
        id: 'handler-2'
      };

      function handler1(message, options) {
        assert.equal(message, handler2Message, 'handler2 message provided to handler1');
        assert.equal(options, handler2Options, 'handler2 options provided to handler1');
      }

      function handler2(message, options, next) {
        assert.equal(message, initialMessage, 'initial message provided to handler2');
        assert.equal(options, initialOptions, 'initial options proivided to handler2');
        next(handler2Message, handler2Options);
      }

      (0, _handlers.registerHandler)('blarz', handler1);
      (0, _handlers.registerHandler)('blarz', handler2);
      (0, _handlers.invoke)('blarz', initialMessage, false, initialOptions);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/debug/tests/main_test", ["ember-babel", "@ember/-internals/environment", "@ember/-internals/runtime", "@ember/debug/lib/handlers", "@ember/debug/lib/deprecate", "@ember/debug/lib/warn", "@ember/debug/index", "internal-test-helpers"], function (_emberBabel, _environment, _runtime, _handlers, _deprecate, _warn, _index, _internalTestHelpers) {
  "use strict";

  var originalEnvValue;
  var originalDeprecateHandler;
  var originalWarnHandler;
  var originalConsoleWarn = console.warn; // eslint-disable-line no-console

  var noop = function () {};

  (0, _internalTestHelpers.moduleFor)('ember-debug',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      var _this;

      _this = _TestCase.call(this) || this;
      originalEnvValue = _environment.ENV.RAISE_ON_DEPRECATION;
      originalDeprecateHandler = _handlers.HANDLERS.deprecate;
      originalWarnHandler = _handlers.HANDLERS.warn;
      _environment.ENV.RAISE_ON_DEPRECATION = true;
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _handlers.HANDLERS.deprecate = originalDeprecateHandler;
      _handlers.HANDLERS.warn = originalWarnHandler;
      _environment.ENV.RAISE_ON_DEPRECATION = originalEnvValue;
    };

    _proto.afterEach = function afterEach() {
      console.warn = originalConsoleWarn; // eslint-disable-line no-console
    };

    _proto['@test deprecate does not throw if RAISE_ON_DEPRECATION is false'] = function testDeprecateDoesNotThrowIfRAISE_ON_DEPRECATIONIsFalse(assert) {
      assert.expect(1);
      console.warn = noop; // eslint-disable-line no-console

      _environment.ENV.RAISE_ON_DEPRECATION = false;

      try {
        (0, _index.deprecate)('Should not throw', false, {
          id: 'test',
          until: 'forever'
        });
        assert.ok(true, 'deprecate did not throw');
      } catch (e) {
        assert.ok(false, "Expected deprecate not to throw but it did: " + e.message);
      }
    };

    _proto['@test deprecate resets deprecation level to RAISE if ENV.RAISE_ON_DEPRECATION is set'] = function testDeprecateResetsDeprecationLevelToRAISEIfENVRAISE_ON_DEPRECATIONIsSet(assert) {
      assert.expect(2);
      console.warn = noop; // eslint-disable-line no-console

      _environment.ENV.RAISE_ON_DEPRECATION = false;

      try {
        (0, _index.deprecate)('Should not throw', false, {
          id: 'test',
          until: 'forever'
        });
        assert.ok(true, 'deprecate did not throw');
      } catch (e) {
        assert.ok(false, "Expected deprecate not to throw but it did: " + e.message);
      }

      _environment.ENV.RAISE_ON_DEPRECATION = true;
      assert.throws(function () {
        (0, _index.deprecate)('Should throw', false, {
          id: 'test',
          until: 'forever'
        });
      }, /Should throw/);
    };

    _proto['@test When ENV.RAISE_ON_DEPRECATION is true, it is still possible to silence a deprecation by id'] = function testWhenENVRAISE_ON_DEPRECATIONIsTrueItIsStillPossibleToSilenceADeprecationById(assert) {
      assert.expect(3);
      _environment.ENV.RAISE_ON_DEPRECATION = true;
      (0, _deprecate.registerHandler)(function (message, options, next) {
        if (!options || options.id !== 'my-deprecation') {
          next.apply(void 0, arguments);
        }
      });

      try {
        (0, _index.deprecate)('should be silenced with matching id', false, {
          id: 'my-deprecation',
          until: 'forever'
        });
        assert.ok(true, 'Did not throw when level is set by id');
      } catch (e) {
        assert.ok(false, "Expected deprecate not to throw but it did: " + e.message);
      }

      assert.throws(function () {
        (0, _index.deprecate)('Should throw with no matching id', false, {
          id: 'test',
          until: 'forever'
        });
      }, /Should throw with no matching id/);
      assert.throws(function () {
        (0, _index.deprecate)('Should throw with non-matching id', false, {
          id: 'other-id',
          until: 'forever'
        });
      }, /Should throw with non-matching id/);
    };

    _proto['@test deprecate throws deprecation if second argument is falsy'] = function testDeprecateThrowsDeprecationIfSecondArgumentIsFalsy(assert) {
      assert.expect(3);
      assert.throws(function () {
        return (0, _index.deprecate)('Deprecation is thrown', false, {
          id: 'test',
          until: 'forever'
        });
      });
      assert.throws(function () {
        return (0, _index.deprecate)('Deprecation is thrown', '', {
          id: 'test',
          until: 'forever'
        });
      });
      assert.throws(function () {
        return (0, _index.deprecate)('Deprecation is thrown', 0, {
          id: 'test',
          until: 'forever'
        });
      });
    };

    _proto['@test deprecate does not invoke a function as the second argument'] = function testDeprecateDoesNotInvokeAFunctionAsTheSecondArgument(assert) {
      assert.expect(1);
      (0, _index.deprecate)('Deprecation is thrown', function () {
        assert.ok(false, 'this function should not be invoked');
      }, {
        id: 'test',
        until: 'forever'
      });
      assert.ok(true, 'deprecations were not thrown');
    };

    _proto['@test deprecate does not throw deprecations if second argument is truthy'] = function testDeprecateDoesNotThrowDeprecationsIfSecondArgumentIsTruthy(assert) {
      assert.expect(1);
      (0, _index.deprecate)('Deprecation is thrown', true, {
        id: 'test',
        until: 'forever'
      });
      (0, _index.deprecate)('Deprecation is thrown', '1', {
        id: 'test',
        until: 'forever'
      });
      (0, _index.deprecate)('Deprecation is thrown', 1, {
        id: 'test',
        until: 'forever'
      });
      assert.ok(true, 'deprecations were not thrown');
    };

    _proto['@test assert throws if second argument is falsy'] = function testAssertThrowsIfSecondArgumentIsFalsy(assert) {
      assert.expect(3);
      assert.throws(function () {
        return (0, _index.assert)('Assertion is thrown', false);
      });
      assert.throws(function () {
        return (0, _index.assert)('Assertion is thrown', '');
      });
      assert.throws(function () {
        return (0, _index.assert)('Assertion is thrown', 0);
      });
    };

    _proto['@test assert does not throw if second argument is a function'] = function testAssertDoesNotThrowIfSecondArgumentIsAFunction(assert) {
      assert.expect(1);
      (0, _index.assert)('Assertion is thrown', function () {
        return true;
      });
      assert.ok(true, 'assertions were not thrown');
    };

    _proto['@test assert does not throw if second argument is falsy'] = function testAssertDoesNotThrowIfSecondArgumentIsFalsy(assert) {
      assert.expect(1);
      (0, _index.assert)('Assertion is thrown', true);
      (0, _index.assert)('Assertion is thrown', '1');
      (0, _index.assert)('Assertion is thrown', 1);
      assert.ok(true, 'assertions were not thrown');
    };

    _proto['@test assert does not throw if second argument is an object'] = function testAssertDoesNotThrowIfSecondArgumentIsAnObject(assert) {
      assert.expect(1);

      var Igor = _runtime.Object.extend();

      (0, _index.assert)('is truthy', Igor);
      (0, _index.assert)('is truthy', Igor.create());
      assert.ok(true, 'assertions were not thrown');
    };

    _proto['@test deprecate does not throw a deprecation at log and silence'] = function testDeprecateDoesNotThrowADeprecationAtLogAndSilence(assert) {
      assert.expect(4);
      var id = 'ABC';
      var until = 'forever';
      var shouldThrow = false;
      (0, _deprecate.registerHandler)(function (message, options) {
        if (options && options.id === id) {
          if (shouldThrow) {
            throw new Error(message);
          }
        }
      });

      try {
        (0, _index.deprecate)('Deprecation for testing purposes', false, {
          id: id,
          until: until
        });
        assert.ok(true, 'Deprecation did not throw');
      } catch (e) {
        assert.ok(false, 'Deprecation was thrown despite being added to blacklist');
      }

      try {
        (0, _index.deprecate)('Deprecation for testing purposes', false, {
          id: id,
          until: until
        });
        assert.ok(true, 'Deprecation did not throw');
      } catch (e) {
        assert.ok(false, 'Deprecation was thrown despite being added to blacklist');
      }

      shouldThrow = true;
      assert.throws(function () {
        (0, _index.deprecate)('Deprecation is thrown', false, {
          id: id,
          until: until
        });
      });
      assert.throws(function () {
        (0, _index.deprecate)('Deprecation is thrown', false, {
          id: id,
          until: until
        });
      });
    };

    _proto['@test deprecate without options triggers an assertion'] = function testDeprecateWithoutOptionsTriggersAnAssertion(assert) {
      assert.expect(2);
      assert.throws(function () {
        return (0, _index.deprecate)('foo');
      }, new RegExp(_deprecate.missingOptionsDeprecation), 'proper assertion is triggered when options is missing');
      assert.throws(function () {
        return (0, _index.deprecate)('foo', false, {});
      }, new RegExp(_deprecate.missingOptionsDeprecation), 'proper assertion is triggered when options is missing');
    };

    _proto['@test deprecate without options.id triggers an assertion'] = function testDeprecateWithoutOptionsIdTriggersAnAssertion(assert) {
      assert.expect(1);
      assert.throws(function () {
        return (0, _index.deprecate)('foo', false, {
          until: 'forever'
        });
      }, new RegExp(_deprecate.missingOptionsIdDeprecation), 'proper assertion is triggered when options.id is missing');
    };

    _proto['@test deprecate without options.until triggers an assertion'] = function testDeprecateWithoutOptionsUntilTriggersAnAssertion(assert) {
      assert.expect(1);
      assert.throws(function () {
        return (0, _index.deprecate)('foo', false, {
          id: 'test'
        });
      }, new RegExp(_deprecate.missingOptionsUntilDeprecation), 'proper assertion is triggered when options.until is missing');
    };

    _proto['@test warn without options triggers an assert'] = function testWarnWithoutOptionsTriggersAnAssert(assert) {
      assert.expect(1);
      assert.throws(function () {
        return (0, _index.warn)('foo');
      }, new RegExp(_warn.missingOptionsDeprecation), 'deprecation is triggered when options is missing');
    };

    _proto['@test warn without options.id triggers an assertion'] = function testWarnWithoutOptionsIdTriggersAnAssertion(assert) {
      assert.expect(1);
      assert.throws(function () {
        return (0, _index.warn)('foo', false, {});
      }, new RegExp(_warn.missingOptionsIdDeprecation), 'deprecation is triggered when options is missing');
    };

    _proto['@test warn without options.id nor test triggers an assertion'] = function testWarnWithoutOptionsIdNorTestTriggersAnAssertion(assert) {
      assert.expect(1);
      assert.throws(function () {
        return (0, _index.warn)('foo', {});
      }, new RegExp(_warn.missingOptionsIdDeprecation), 'deprecation is triggered when options is missing');
    };

    _proto['@test warn without test but with options does not trigger an assertion'] = function testWarnWithoutTestButWithOptionsDoesNotTriggerAnAssertion(assert) {
      assert.expect(1);
      (0, _warn.registerHandler)(function (message) {
        assert.equal(message, 'foo', 'warning was triggered');
      });
      (0, _index.warn)('foo', {
        id: 'ember-debug.do-not-raise'
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/engine/tests/engine_initializers_test", ["ember-babel", "@ember/runloop", "@ember/engine", "internal-test-helpers"], function (_emberBabel, _runloop, _engine, _internalTestHelpers) {
  "use strict";

  var MyEngine, myEngine, myEngineInstance;
  (0, _internalTestHelpers.moduleFor)('Engine initializers',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _runloop.run)(function () {
        if (myEngineInstance) {
          myEngineInstance.destroy();
          myEngineInstance = null;
        }

        if (myEngine) {
          myEngine.destroy();
          myEngine = null;
        }
      });
    };

    _proto["@test initializers require proper 'name' and 'initialize' properties"] = function testInitializersRequireProperNameAndInitializeProperties() {
      MyEngine = _engine.default.extend();
      expectAssertion(function () {
        (0, _runloop.run)(function () {
          MyEngine.initializer({
            name: 'initializer'
          });
        });
      });
      expectAssertion(function () {
        (0, _runloop.run)(function () {
          MyEngine.initializer({
            initialize: function () {}
          });
        });
      });
    };

    _proto['@test initializers are passed an Engine'] = function testInitializersArePassedAnEngine(assert) {
      MyEngine = _engine.default.extend();
      MyEngine.initializer({
        name: 'initializer',
        initialize: function (engine) {
          assert.ok(engine instanceof _engine.default, 'initialize is passed an Engine');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = myEngine.buildInstance();
    };

    _proto['@test initializers can be registered in a specified order'] = function testInitializersCanBeRegisteredInASpecifiedOrder(assert) {
      var order = [];
      MyEngine = _engine.default.extend();
      MyEngine.initializer({
        name: 'fourth',
        after: 'third',
        initialize: function () {
          order.push('fourth');
        }
      });
      MyEngine.initializer({
        name: 'second',
        after: 'first',
        before: 'third',
        initialize: function () {
          order.push('second');
        }
      });
      MyEngine.initializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize: function () {
          order.push('fifth');
        }
      });
      MyEngine.initializer({
        name: 'first',
        before: 'second',
        initialize: function () {
          order.push('first');
        }
      });
      MyEngine.initializer({
        name: 'third',
        initialize: function () {
          order.push('third');
        }
      });
      MyEngine.initializer({
        name: 'sixth',
        initialize: function () {
          order.push('sixth');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = myEngine.buildInstance();
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    };

    _proto['@test initializers can be registered in a specified order as an array'] = function testInitializersCanBeRegisteredInASpecifiedOrderAsAnArray(assert) {
      var order = [];
      MyEngine = _engine.default.extend();
      MyEngine.initializer({
        name: 'third',
        initialize: function () {
          order.push('third');
        }
      });
      MyEngine.initializer({
        name: 'second',
        after: 'first',
        before: ['third', 'fourth'],
        initialize: function () {
          order.push('second');
        }
      });
      MyEngine.initializer({
        name: 'fourth',
        after: ['second', 'third'],
        initialize: function () {
          order.push('fourth');
        }
      });
      MyEngine.initializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize: function () {
          order.push('fifth');
        }
      });
      MyEngine.initializer({
        name: 'first',
        before: ['second'],
        initialize: function () {
          order.push('first');
        }
      });
      MyEngine.initializer({
        name: 'sixth',
        initialize: function () {
          order.push('sixth');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = myEngine.buildInstance();
      assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    };

    _proto['@test initializers can have multiple dependencies'] = function testInitializersCanHaveMultipleDependencies(assert) {
      var order = [];
      MyEngine = _engine.default.extend();
      var a = {
        name: 'a',
        before: 'b',
        initialize: function () {
          order.push('a');
        }
      };
      var b = {
        name: 'b',
        initialize: function () {
          order.push('b');
        }
      };
      var c = {
        name: 'c',
        after: 'b',
        initialize: function () {
          order.push('c');
        }
      };
      var afterB = {
        name: 'after b',
        after: 'b',
        initialize: function () {
          order.push('after b');
        }
      };
      var afterC = {
        name: 'after c',
        after: 'c',
        initialize: function () {
          order.push('after c');
        }
      };
      MyEngine.initializer(b);
      MyEngine.initializer(a);
      MyEngine.initializer(afterC);
      MyEngine.initializer(afterB);
      MyEngine.initializer(c);
      myEngine = MyEngine.create();
      myEngineInstance = myEngine.buildInstance();
      assert.ok(order.indexOf(a.name) < order.indexOf(b.name), 'a < b');
      assert.ok(order.indexOf(b.name) < order.indexOf(c.name), 'b < c');
      assert.ok(order.indexOf(b.name) < order.indexOf(afterB.name), 'b < afterB');
      assert.ok(order.indexOf(c.name) < order.indexOf(afterC.name), 'c < afterC');
    };

    _proto['@test initializers set on Engine subclasses are not shared between engines'] = function testInitializersSetOnEngineSubclassesAreNotSharedBetweenEngines(assert) {
      var firstInitializerRunCount = 0;
      var secondInitializerRunCount = 0;

      var FirstEngine = _engine.default.extend();

      FirstEngine.initializer({
        name: 'first',
        initialize: function () {
          firstInitializerRunCount++;
        }
      });

      var SecondEngine = _engine.default.extend();

      SecondEngine.initializer({
        name: 'second',
        initialize: function () {
          secondInitializerRunCount++;
        }
      });
      var firstEngine = FirstEngine.create();
      var firstEngineInstance = firstEngine.buildInstance();
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run');
      assert.equal(secondInitializerRunCount, 0, 'first initializer only was run');
      var secondEngine = SecondEngine.create();
      var secondEngineInstance = secondEngine.buildInstance();
      assert.equal(firstInitializerRunCount, 1, 'second initializer only was run');
      assert.equal(secondInitializerRunCount, 1, 'second initializer only was run');
      (0, _runloop.run)(function () {
        firstEngineInstance.destroy();
        secondEngineInstance.destroy();
        firstEngine.destroy();
        secondEngine.destroy();
      });
    };

    _proto['@test initializers are concatenated'] = function testInitializersAreConcatenated(assert) {
      var firstInitializerRunCount = 0;
      var secondInitializerRunCount = 0;

      var FirstEngine = _engine.default.extend();

      FirstEngine.initializer({
        name: 'first',
        initialize: function () {
          firstInitializerRunCount++;
        }
      });
      var SecondEngine = FirstEngine.extend();
      SecondEngine.initializer({
        name: 'second',
        initialize: function () {
          secondInitializerRunCount++;
        }
      });
      var firstEngine = FirstEngine.create();
      var firstEngineInstance = firstEngine.buildInstance();
      assert.equal(firstInitializerRunCount, 1, 'first initializer only was run when base class created');
      assert.equal(secondInitializerRunCount, 0, 'second initializer was not run when first base class created');
      firstInitializerRunCount = 0;
      var secondEngine = SecondEngine.create();
      var secondEngineInstance = secondEngine.buildInstance();
      assert.equal(firstInitializerRunCount, 1, 'first initializer was run when subclass created');
      assert.equal(secondInitializerRunCount, 1, 'second initializers was run when subclass created');
      (0, _runloop.run)(function () {
        firstEngineInstance.destroy();
        secondEngineInstance.destroy();
        firstEngine.destroy();
        secondEngine.destroy();
      });
    };

    _proto['@test initializers are per-engine'] = function testInitializersArePerEngine(assert) {
      assert.expect(2);

      var FirstEngine = _engine.default.extend();

      FirstEngine.initializer({
        name: 'abc',
        initialize: function () {}
      });
      expectAssertion(function () {
        FirstEngine.initializer({
          name: 'abc',
          initialize: function () {}
        });
      });

      var SecondEngine = _engine.default.extend();

      SecondEngine.instanceInitializer({
        name: 'abc',
        initialize: function () {}
      });
      assert.ok(true, 'Two engines can have initializers named the same.');
    };

    _proto['@test initializers are executed in their own context'] = function testInitializersAreExecutedInTheirOwnContext(assert) {
      assert.expect(1);
      MyEngine = _engine.default.extend();
      MyEngine.initializer({
        name: 'coolInitializer',
        myProperty: 'cool',
        initialize: function () {
          assert.equal(this.myProperty, 'cool', 'should have access to its own context');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = myEngine.buildInstance();
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/engine/tests/engine_instance_initializers_test", ["ember-babel", "@ember/runloop", "@ember/engine", "@ember/engine/instance", "internal-test-helpers"], function (_emberBabel, _runloop, _engine, _instance, _internalTestHelpers) {
  "use strict";

  var MyEngine, myEngine, myEngineInstance;

  function buildEngineInstance(EngineClass) {
    var engineInstance = EngineClass.buildInstance();
    (0, _engine.setEngineParent)(engineInstance, {
      lookup: function () {
        return {};
      },
      resolveRegistration: function () {
        return {};
      }
    });
    return engineInstance;
  }

  (0, _internalTestHelpers.moduleFor)('Engine instance initializers',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _TestCase.prototype.teardown.call(this);

      (0, _runloop.run)(function () {
        if (myEngineInstance) {
          myEngineInstance.destroy();
        }

        if (myEngine) {
          myEngine.destroy();
        }
      });
      MyEngine = myEngine = myEngineInstance = undefined;
    };

    _proto["@test initializers require proper 'name' and 'initialize' properties"] = function testInitializersRequireProperNameAndInitializeProperties() {
      MyEngine = _engine.default.extend();
      expectAssertion(function () {
        (0, _runloop.run)(function () {
          MyEngine.instanceInitializer({
            name: 'initializer'
          });
        });
      });
      expectAssertion(function () {
        (0, _runloop.run)(function () {
          MyEngine.instanceInitializer({
            initialize: function () {}
          });
        });
      });
    };

    _proto['@test initializers are passed an engine instance'] = function testInitializersArePassedAnEngineInstance(assert) {
      MyEngine = _engine.default.extend();
      MyEngine.instanceInitializer({
        name: 'initializer',
        initialize: function (instance) {
          assert.ok(instance instanceof _instance.default, 'initialize is passed an engine instance');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = buildEngineInstance(myEngine);
      return myEngineInstance.boot();
    };

    _proto['@test initializers can be registered in a specified order'] = function testInitializersCanBeRegisteredInASpecifiedOrder(assert) {
      var order = [];
      MyEngine = _engine.default.extend();
      MyEngine.instanceInitializer({
        name: 'fourth',
        after: 'third',
        initialize: function () {
          order.push('fourth');
        }
      });
      MyEngine.instanceInitializer({
        name: 'second',
        after: 'first',
        before: 'third',
        initialize: function () {
          order.push('second');
        }
      });
      MyEngine.instanceInitializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize: function () {
          order.push('fifth');
        }
      });
      MyEngine.instanceInitializer({
        name: 'first',
        before: 'second',
        initialize: function () {
          order.push('first');
        }
      });
      MyEngine.instanceInitializer({
        name: 'third',
        initialize: function () {
          order.push('third');
        }
      });
      MyEngine.instanceInitializer({
        name: 'sixth',
        initialize: function () {
          order.push('sixth');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = buildEngineInstance(myEngine);
      return myEngineInstance.boot().then(function () {
        assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
      });
    };

    _proto['@test initializers can be registered in a specified order as an array'] = function testInitializersCanBeRegisteredInASpecifiedOrderAsAnArray(assert) {
      var order = [];
      MyEngine = _engine.default.extend();
      MyEngine.instanceInitializer({
        name: 'third',
        initialize: function () {
          order.push('third');
        }
      });
      MyEngine.instanceInitializer({
        name: 'second',
        after: 'first',
        before: ['third', 'fourth'],
        initialize: function () {
          order.push('second');
        }
      });
      MyEngine.instanceInitializer({
        name: 'fourth',
        after: ['second', 'third'],
        initialize: function () {
          order.push('fourth');
        }
      });
      MyEngine.instanceInitializer({
        name: 'fifth',
        after: 'fourth',
        before: 'sixth',
        initialize: function () {
          order.push('fifth');
        }
      });
      MyEngine.instanceInitializer({
        name: 'first',
        before: ['second'],
        initialize: function () {
          order.push('first');
        }
      });
      MyEngine.instanceInitializer({
        name: 'sixth',
        initialize: function () {
          order.push('sixth');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = buildEngineInstance(myEngine);
      return myEngineInstance.boot().then(function () {
        assert.deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
      });
    };

    _proto['@test initializers can have multiple dependencies'] = function testInitializersCanHaveMultipleDependencies(assert) {
      var order = [];
      MyEngine = _engine.default.extend();
      var a = {
        name: 'a',
        before: 'b',
        initialize: function () {
          order.push('a');
        }
      };
      var b = {
        name: 'b',
        initialize: function () {
          order.push('b');
        }
      };
      var c = {
        name: 'c',
        after: 'b',
        initialize: function () {
          order.push('c');
        }
      };
      var afterB = {
        name: 'after b',
        after: 'b',
        initialize: function () {
          order.push('after b');
        }
      };
      var afterC = {
        name: 'after c',
        after: 'c',
        initialize: function () {
          order.push('after c');
        }
      };
      MyEngine.instanceInitializer(b);
      MyEngine.instanceInitializer(a);
      MyEngine.instanceInitializer(afterC);
      MyEngine.instanceInitializer(afterB);
      MyEngine.instanceInitializer(c);
      myEngine = MyEngine.create();
      myEngineInstance = buildEngineInstance(myEngine);
      return myEngineInstance.boot().then(function () {
        assert.ok(order.indexOf(a.name) < order.indexOf(b.name), 'a < b');
        assert.ok(order.indexOf(b.name) < order.indexOf(c.name), 'b < c');
        assert.ok(order.indexOf(b.name) < order.indexOf(afterB.name), 'b < afterB');
        assert.ok(order.indexOf(c.name) < order.indexOf(afterC.name), 'c < afterC');
      });
    };

    _proto['@test initializers set on Engine subclasses should not be shared between engines'] = function testInitializersSetOnEngineSubclassesShouldNotBeSharedBetweenEngines(assert) {
      var firstInitializerRunCount = 0;
      var secondInitializerRunCount = 0;

      var FirstEngine = _engine.default.extend();

      var firstEngine, firstEngineInstance;
      FirstEngine.instanceInitializer({
        name: 'first',
        initialize: function () {
          firstInitializerRunCount++;
        }
      });

      var SecondEngine = _engine.default.extend();

      var secondEngine, secondEngineInstance;
      SecondEngine.instanceInitializer({
        name: 'second',
        initialize: function () {
          secondInitializerRunCount++;
        }
      });
      firstEngine = FirstEngine.create();
      firstEngineInstance = buildEngineInstance(firstEngine);
      return firstEngineInstance.boot().then(function () {
        assert.equal(firstInitializerRunCount, 1, 'first initializer only was run');
        assert.equal(secondInitializerRunCount, 0, 'first initializer only was run');
        secondEngine = SecondEngine.create();
        secondEngineInstance = buildEngineInstance(secondEngine);
        return secondEngineInstance.boot();
      }).then(function () {
        assert.equal(firstInitializerRunCount, 1, 'second initializer only was run');
        assert.equal(secondInitializerRunCount, 1, 'second initializer only was run');
        (0, _runloop.run)(function () {
          firstEngineInstance.destroy();
          secondEngineInstance.destroy();
          firstEngine.destroy();
          secondEngine.destroy();
        });
      });
    };

    _proto['@test initializers are concatenated'] = function testInitializersAreConcatenated(assert) {
      var firstInitializerRunCount = 0;
      var secondInitializerRunCount = 0;

      var FirstEngine = _engine.default.extend();

      FirstEngine.instanceInitializer({
        name: 'first',
        initialize: function () {
          firstInitializerRunCount++;
        }
      });
      var SecondEngine = FirstEngine.extend();
      SecondEngine.instanceInitializer({
        name: 'second',
        initialize: function () {
          secondInitializerRunCount++;
        }
      });
      var firstEngine = FirstEngine.create();
      var firstEngineInstance = buildEngineInstance(firstEngine);
      var secondEngine, secondEngineInstance;
      return firstEngineInstance.boot().then(function () {
        assert.equal(firstInitializerRunCount, 1, 'first initializer only was run when base class created');
        assert.equal(secondInitializerRunCount, 0, 'second initializer was not run when first base class created');
        firstInitializerRunCount = 0;
        secondEngine = SecondEngine.create();
        secondEngineInstance = buildEngineInstance(secondEngine);
        return secondEngineInstance.boot();
      }).then(function () {
        assert.equal(firstInitializerRunCount, 1, 'first initializer was run when subclass created');
        assert.equal(secondInitializerRunCount, 1, 'second initializers was run when subclass created');
        (0, _runloop.run)(function () {
          firstEngineInstance.destroy();
          secondEngineInstance.destroy();
          firstEngine.destroy();
          secondEngine.destroy();
        });
      });
    };

    _proto['@test initializers are per-engine'] = function testInitializersArePerEngine(assert) {
      assert.expect(2);

      var FirstEngine = _engine.default.extend();

      FirstEngine.instanceInitializer({
        name: 'abc',
        initialize: function () {}
      });
      expectAssertion(function () {
        FirstEngine.instanceInitializer({
          name: 'abc',
          initialize: function () {}
        });
      });

      var SecondEngine = _engine.default.extend();

      SecondEngine.instanceInitializer({
        name: 'abc',
        initialize: function () {}
      });
      assert.ok(true, 'Two engines can have initializers named the same.');
    };

    _proto['@test initializers are executed in their own context'] = function testInitializersAreExecutedInTheirOwnContext(assert) {
      assert.expect(1);

      var MyEngine = _engine.default.extend();

      MyEngine.instanceInitializer({
        name: 'coolInitializer',
        myProperty: 'cool',
        initialize: function () {
          assert.equal(this.myProperty, 'cool', 'should have access to its own context');
        }
      });
      myEngine = MyEngine.create();
      myEngineInstance = buildEngineInstance(myEngine);
      return myEngineInstance.boot();
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/engine/tests/engine_instance_test", ["ember-babel", "@ember/engine", "@ember/engine/instance", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _engine, _instance, _runloop, _internalTestHelpers) {
  "use strict";

  var engine, engineInstance;
  (0, _internalTestHelpers.moduleFor)('EngineInstance',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      var _this;

      _this = _TestCase.call(this) || this;
      (0, _runloop.run)(function () {
        engine = _engine.default.create({
          router: null
        });
      });
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      if (engineInstance) {
        (0, _runloop.run)(engineInstance, 'destroy');
        engineInstance = undefined;
      }

      if (engine) {
        (0, _runloop.run)(engine, 'destroy');
        engine = undefined;
      }
    };

    _proto['@test an engine instance can be created based upon a base engine'] = function testAnEngineInstanceCanBeCreatedBasedUponABaseEngine(assert) {
      (0, _runloop.run)(function () {
        engineInstance = _instance.default.create({
          base: engine
        });
      });
      assert.ok(engineInstance, 'instance should be created');
      assert.equal(engineInstance.base, engine, 'base should be set to engine');
    };

    _proto['@test unregistering a factory clears all cached instances of that factory'] = function testUnregisteringAFactoryClearsAllCachedInstancesOfThatFactory(assert) {
      assert.expect(3);
      engineInstance = (0, _runloop.run)(function () {
        return _instance.default.create({
          base: engine
        });
      });
      var PostComponent = (0, _internalTestHelpers.factory)();
      engineInstance.register('component:post', PostComponent);
      var postComponent1 = engineInstance.lookup('component:post');
      assert.ok(postComponent1, 'lookup creates instance');
      engineInstance.unregister('component:post');
      engineInstance.register('component:post', PostComponent);
      var postComponent2 = engineInstance.lookup('component:post');
      assert.ok(postComponent2, 'lookup creates instance');
      assert.notStrictEqual(postComponent1, postComponent2, 'lookup creates a brand new instance because previous one was reset');
    };

    _proto['@test can be booted when its parent has been set'] = function testCanBeBootedWhenItsParentHasBeenSet(assert) {
      assert.expect(3);
      engineInstance = (0, _runloop.run)(function () {
        return _instance.default.create({
          base: engine
        });
      });
      expectAssertion(function () {
        engineInstance._bootSync();
      }, "An engine instance's parent must be set via `setEngineParent(engine, parent)` prior to calling `engine.boot()`.");
      (0, _engine.setEngineParent)(engineInstance, {}); // Stub `cloneParentDependencies`, the internals of which are tested along
      // with application instances.

      engineInstance.cloneParentDependencies = function () {
        assert.ok(true, 'parent dependencies are cloned');
      };

      return engineInstance.boot().then(function () {
        assert.ok(true, 'boot successful');
      });
    };

    _proto['@test can build a child instance of a registered engine'] = function testCanBuildAChildInstanceOfARegisteredEngine(assert) {
      var ChatEngine = _engine.default.extend();

      var chatEngineInstance;
      engine.register('engine:chat', ChatEngine);
      (0, _runloop.run)(function () {
        engineInstance = _instance.default.create({
          base: engine
        }); // Try to build an unregistered engine.

        assert.throws(function () {
          engineInstance.buildChildEngineInstance('fake');
        }, "You attempted to mount the engine 'fake', but it is not registered with its parent."); // Build the `chat` engine, registered above.

        chatEngineInstance = engineInstance.buildChildEngineInstance('chat');
      });
      assert.ok(chatEngineInstance, 'child engine instance successfully created');
      assert.strictEqual((0, _engine.getEngineParent)(chatEngineInstance), engineInstance, 'child engine instance is assigned the correct parent');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/engine/tests/engine_parent_test", ["ember-babel", "@ember/engine", "internal-test-helpers"], function (_emberBabel, _engine, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('EngineParent',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto["@test An engine's parent can be set with `setEngineParent` and retrieved with `getEngineParent`"] = function testAnEngineSParentCanBeSetWithSetEngineParentAndRetrievedWithGetEngineParent(assert) {
      var engine = {};
      var parent = {};
      assert.strictEqual((0, _engine.getEngineParent)(engine), undefined, 'parent has not been set');
      (0, _engine.setEngineParent)(engine, parent);
      assert.strictEqual((0, _engine.getEngineParent)(engine), parent, 'parent has been set');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/engine/tests/engine_test", ["ember-babel", "@ember/-internals/environment", "@ember/runloop", "@ember/engine", "@ember/-internals/runtime", "@ember/-internals/container", "internal-test-helpers"], function (_emberBabel, _environment, _runloop, _engine, _runtime, _container, _internalTestHelpers) {
  "use strict";

  function _templateObject4() {
    const data = _taggedTemplateLiteralLoose(["template-compiler:main"]);

    _templateObject4 = function () {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    const data = _taggedTemplateLiteralLoose(["template:components/-default"]);

    _templateObject3 = function () {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    const data = _taggedTemplateLiteralLoose(["-bucket-cache:main"]);

    _templateObject2 = function () {
      return data;
    };

    return data;
  }

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["-bucket-cache:main"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  var engine;
  var originalLookup = _environment.context.lookup;
  (0, _internalTestHelpers.moduleFor)('Engine',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      var _this;

      _this = _TestCase.call(this) || this;
      (0, _runloop.run)(function () {
        engine = _engine.default.create();
        _environment.context.lookup = {
          TestEngine: engine
        };
      });
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _environment.context.lookup = originalLookup;

      if (engine) {
        (0, _runloop.run)(engine, 'destroy');
        engine = null;
      }
    };

    _proto['@test acts like a namespace'] = function testActsLikeANamespace(assert) {
      engine.Foo = _runtime.Object.extend();
      assert.equal(engine.Foo.toString(), 'TestEngine.Foo', 'Classes pick up their parent namespace');
    };

    _proto['@test builds a registry'] = function testBuildsARegistry(assert) {
      assert.strictEqual(engine.resolveRegistration('application:main'), engine, "application:main is registered");
      assert.deepEqual(engine.registeredOptionsForType('component'), {
        singleton: false
      }, "optionsForType 'component'");
      assert.deepEqual(engine.registeredOptionsForType('view'), {
        singleton: false
      }, "optionsForType 'view'");
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'controller:basic');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'view', '_viewRegistry', '-view-registry:main');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'renderer', '_viewRegistry', '-view-registry:main');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'route', '_topLevelViewTemplate', 'template:-outlet');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'view:-outlet', 'namespace', 'application:main');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'controller', 'target', 'router:main');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'controller', 'namespace', 'application:main');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'router', '_bucketCache', (0, _container.privatize)(_templateObject()));
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'route', '_bucketCache', (0, _container.privatize)(_templateObject2()));
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'route', '_router', 'router:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'component:-text-field');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'component:-checkbox');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'component:link-to');

      if (true
      /* EMBER_GLIMMER_ANGLE_BRACKET_BUILT_INS */
      ) {
          (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'component:textarea');
        } else {
        (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'component:-text-area');
      }

      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'service:-routing');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'service:-routing', 'router', 'router:main'); // DEBUGGING

      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'resolver-for-debugging:main');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'container-debug-adapter:main', 'resolver', 'resolver-for-debugging:main');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'data-adapter:main', 'containerDebugAdapter', 'container-debug-adapter:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'container-debug-adapter:main');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'component-lookup:main');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'service:-dom-changes', 'document', 'service:-document');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'service:-dom-tree-construction', 'document', 'service:-document');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'view:-outlet');
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, (0, _container.privatize)(_templateObject3()));
      (0, _internalTestHelpers.verifyRegistration)(assert, engine, 'template:-outlet');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'view:-outlet', 'template', 'template:-outlet');
      (0, _internalTestHelpers.verifyInjection)(assert, engine, 'template', 'compiler', (0, _container.privatize)(_templateObject4()));
      assert.deepEqual(engine.registeredOptionsForType('helper'), {
        instantiate: false
      }, "optionsForType 'helper'");
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/error/tests/index_test", ["ember-babel", "@ember/error", "internal-test-helpers"], function (_emberBabel, _error, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember Error Throwing',
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _TestCase);

    function _class() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test new EmberError displays provided message'] = function testNewEmberErrorDisplaysProvidedMessage(assert) {
      assert.throws(function () {
        throw new _error.default('A Message');
      }, function (e) {
        return e.message === 'A Message';
      }, 'the assigned message was displayed');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/instrumentation/tests/index-test", ["ember-babel", "@ember/instrumentation", "internal-test-helpers"], function (_emberBabel, _instrumentation, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember Instrumentation',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.afterEach = function afterEach() {
      (0, _instrumentation.reset)();
    };

    _proto['@test execute block even if no listeners'] = function testExecuteBlockEvenIfNoListeners(assert) {
      var result = (0, _instrumentation.instrument)('render', {}, function () {
        return 'hello';
      });
      assert.equal(result, 'hello', 'called block');
    };

    _proto['@test subscribing to a simple path receives the listener'] = function testSubscribingToASimplePathReceivesTheListener(assert) {
      assert.expect(12);
      var sentPayload = {};
      var count = 0;
      (0, _instrumentation.subscribe)('render', {
        before: function (name, timestamp, payload) {
          if (count === 0) {
            assert.strictEqual(name, 'render');
          } else {
            assert.strictEqual(name, 'render.handlebars');
          }

          assert.ok(typeof timestamp === 'number');
          assert.strictEqual(payload, sentPayload);
        },
        after: function (name, timestamp, payload) {
          if (count === 0) {
            assert.strictEqual(name, 'render');
          } else {
            assert.strictEqual(name, 'render.handlebars');
          }

          assert.ok(typeof timestamp === 'number');
          assert.strictEqual(payload, sentPayload);
          count++;
        }
      });
      (0, _instrumentation.instrument)('render', sentPayload, function () {});
      (0, _instrumentation.instrument)('render.handlebars', sentPayload, function () {});
    };

    _proto['@test returning a value from the before callback passes it to the after callback'] = function testReturningAValueFromTheBeforeCallbackPassesItToTheAfterCallback(assert) {
      assert.expect(2);
      var passthru1 = {};
      var passthru2 = {};
      (0, _instrumentation.subscribe)('render', {
        before: function () {
          return passthru1;
        },
        after: function (name, timestamp, payload, beforeValue) {
          assert.strictEqual(beforeValue, passthru1);
        }
      });
      (0, _instrumentation.subscribe)('render', {
        before: function () {
          return passthru2;
        },
        after: function (name, timestamp, payload, beforeValue) {
          assert.strictEqual(beforeValue, passthru2);
        }
      });
      (0, _instrumentation.instrument)('render', null, function () {});
    };

    _proto['@test instrument with 2 args (name, callback) no payload'] = function testInstrumentWith2ArgsNameCallbackNoPayload(assert) {
      assert.expect(1);
      (0, _instrumentation.subscribe)('render', {
        before: function (name, timestamp, payload) {
          assert.deepEqual(payload, {});
        },
        after: function () {}
      });
      (0, _instrumentation.instrument)('render', function () {});
    };

    _proto['@test instrument with 3 args (name, callback, binding) no payload'] = function testInstrumentWith3ArgsNameCallbackBindingNoPayload(assert) {
      assert.expect(2);
      var binding = {};
      (0, _instrumentation.subscribe)('render', {
        before: function (name, timestamp, payload) {
          assert.deepEqual(payload, {});
        },
        after: function () {}
      });
      (0, _instrumentation.instrument)('render', function () {
        assert.deepEqual(this, binding);
      }, binding);
    };

    _proto['@test instrument with 3 args (name, payload, callback) with payload'] = function testInstrumentWith3ArgsNamePayloadCallbackWithPayload(assert) {
      assert.expect(1);
      var expectedPayload = {
        hi: 1
      };
      (0, _instrumentation.subscribe)('render', {
        before: function (name, timestamp, payload) {
          assert.deepEqual(payload, expectedPayload);
        },
        after: function () {}
      });
      (0, _instrumentation.instrument)('render', expectedPayload, function () {});
    };

    _proto['@test instrument with 4 args (name, payload, callback, binding) with payload'] = function testInstrumentWith4ArgsNamePayloadCallbackBindingWithPayload(assert) {
      assert.expect(2);
      var expectedPayload = {
        hi: 1
      };
      var binding = {};
      (0, _instrumentation.subscribe)('render', {
        before: function (name, timestamp, payload) {
          assert.deepEqual(payload, expectedPayload);
        },
        after: function () {}
      });
      (0, _instrumentation.instrument)('render', expectedPayload, function () {
        assert.deepEqual(this, binding);
      }, binding);
    };

    _proto['@test raising an exception in the instrumentation attaches it to the payload'] = function testRaisingAnExceptionInTheInstrumentationAttachesItToThePayload(assert) {
      assert.expect(3);
      var error = new Error('Instrumentation');
      (0, _instrumentation.subscribe)('render', {
        before: function () {},
        after: function (name, timestamp, payload) {
          assert.strictEqual(payload.exception, error);
        }
      });
      (0, _instrumentation.subscribe)('render', {
        before: function () {},
        after: function (name, timestamp, payload) {
          assert.strictEqual(payload.exception, error);
        }
      });
      assert.throws(function () {
        return (0, _instrumentation.instrument)('render.handlebars', null, function () {
          throw error;
        });
      }, /Instrumentation/);
    };

    _proto['@test it is possible to add a new subscriber after the first instrument'] = function testItIsPossibleToAddANewSubscriberAfterTheFirstInstrument(assert) {
      (0, _instrumentation.instrument)('render.handlebars', null, function () {});
      (0, _instrumentation.subscribe)('render', {
        before: function () {
          assert.ok(true, 'Before callback was called');
        },
        after: function () {
          assert.ok(true, 'After callback was called');
        }
      });
      (0, _instrumentation.instrument)('render.handlebars', null, function () {});
    };

    _proto['@test it is possible to remove a subscriber'] = function testItIsPossibleToRemoveASubscriber(assert) {
      assert.expect(4);
      var count = 0;
      var subscriber = (0, _instrumentation.subscribe)('render', {
        before: function () {
          assert.equal(count, 0);
          assert.ok(true, 'Before callback was called');
        },
        after: function () {
          assert.equal(count, 0);
          assert.ok(true, 'After callback was called');
          count++;
        }
      });
      (0, _instrumentation.instrument)('render.handlebars', null, function () {});
      (0, _instrumentation.unsubscribe)(subscriber);
      (0, _instrumentation.instrument)('render.handlebars', null, function () {});
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/object/tests/action_test", ["ember-babel", "@ember/-internals/glimmer", "@ember/-internals/runtime", "internal-test-helpers", "@ember/object/index"], function (_emberBabel, _glimmer, _runtime, _internalTestHelpers, _index) {
  "use strict";

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["\n            <button {{action 'foo'}}>Click Foo!</button>\n            <button {{action 'bar'}}>Click Bar!</button>\n            <button {{action 'baz'}}>Click Baz!</button>\n            <button {{action 'qux'}}>Click Qux!</button>\n          "]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }

    return desc;
  }

  if (true
  /* EMBER_NATIVE_DECORATOR_SUPPORT */
  ) {
      (0, _internalTestHelpers.moduleFor)('@action decorator',
      /*#__PURE__*/
      function (_RenderingTestCase) {
        (0, _emberBabel.inheritsLoose)(_class11, _RenderingTestCase);

        function _class11() {
          return _RenderingTestCase.apply(this, arguments) || this;
        }

        var _proto = _class11.prototype;

        _proto['@test action decorator works with ES6 class'] = function testActionDecoratorWorksWithES6Class(assert) {
          var _class;

          var FooComponent = (_class =
          /*#__PURE__*/
          function (_Component) {
            (0, _emberBabel.inheritsLoose)(FooComponent, _Component);

            function FooComponent() {
              return _Component.apply(this, arguments) || this;
            }

            var _proto2 = FooComponent.prototype;

            _proto2.foo = function foo() {
              assert.ok(true, 'called!');
            };

            return FooComponent;
          }(_glimmer.Component), _applyDecoratedDescriptor(_class.prototype, "foo", [_index.action], Object.getOwnPropertyDescriptor(_class.prototype, "foo"), _class.prototype), _class);
          this.registerComponent('foo-bar', {
            ComponentClass: FooComponent,
            template: "<button {{action 'foo'}}>Click Me!</button>"
          });
          this.render('{{foo-bar}}');
          this.$('button').click();
        };

        _proto['@test action decorator does not add actions to superclass'] = function testActionDecoratorDoesNotAddActionsToSuperclass(assert) {
          var _class2, _class3;

          var Foo = (_class2 =
          /*#__PURE__*/
          function (_EmberObject) {
            (0, _emberBabel.inheritsLoose)(Foo, _EmberObject);

            function Foo() {
              return _EmberObject.apply(this, arguments) || this;
            }

            var _proto3 = Foo.prototype;

            _proto3.foo = function foo() {// Do nothing
            };

            return Foo;
          }(_runtime.Object), _applyDecoratedDescriptor(_class2.prototype, "foo", [_index.action], Object.getOwnPropertyDescriptor(_class2.prototype, "foo"), _class2.prototype), _class2);
          var Bar = (_class3 =
          /*#__PURE__*/
          function (_Foo) {
            (0, _emberBabel.inheritsLoose)(Bar, _Foo);

            function Bar() {
              return _Foo.apply(this, arguments) || this;
            }

            var _proto4 = Bar.prototype;

            _proto4.bar = function bar() {
              assert.ok(false, 'called');
            };

            return Bar;
          }(Foo), _applyDecoratedDescriptor(_class3.prototype, "bar", [_index.action], Object.getOwnPropertyDescriptor(_class3.prototype, "bar"), _class3.prototype), _class3);
          var foo = Foo.create();
          var bar = Bar.create();
          assert.equal(typeof foo.actions.foo, 'function', 'foo has foo action');
          assert.equal(typeof foo.actions.bar, 'undefined', 'foo does not have bar action');
          assert.equal(typeof bar.actions.foo, 'function', 'bar has foo action');
          assert.equal(typeof bar.actions.bar, 'function', 'bar has bar action');
        };

        _proto['@test actions are properly merged through traditional and ES6 prototype hierarchy'] = function testActionsAreProperlyMergedThroughTraditionalAndES6PrototypeHierarchy(assert) {
          var _class4, _class5;

          assert.expect(4);

          var FooComponent = _glimmer.Component.extend({
            actions: {
              foo: function () {
                assert.ok(true, 'foo called!');
              }
            }
          });

          var BarComponent = (_class4 =
          /*#__PURE__*/
          function (_FooComponent) {
            (0, _emberBabel.inheritsLoose)(BarComponent, _FooComponent);

            function BarComponent() {
              return _FooComponent.apply(this, arguments) || this;
            }

            var _proto5 = BarComponent.prototype;

            _proto5.bar = function bar() {
              assert.ok(true, 'bar called!');
            };

            return BarComponent;
          }(FooComponent), _applyDecoratedDescriptor(_class4.prototype, "bar", [_index.action], Object.getOwnPropertyDescriptor(_class4.prototype, "bar"), _class4.prototype), _class4);
          var BazComponent = BarComponent.extend({
            actions: {
              baz: function () {
                assert.ok(true, 'baz called!');
              }
            }
          });
          var QuxComponent = (_class5 =
          /*#__PURE__*/
          function (_BazComponent) {
            (0, _emberBabel.inheritsLoose)(QuxComponent, _BazComponent);

            function QuxComponent() {
              return _BazComponent.apply(this, arguments) || this;
            }

            var _proto6 = QuxComponent.prototype;

            _proto6.qux = function qux() {
              assert.ok(true, 'qux called!');
            };

            return QuxComponent;
          }(BazComponent), _applyDecoratedDescriptor(_class5.prototype, "qux", [_index.action], Object.getOwnPropertyDescriptor(_class5.prototype, "qux"), _class5.prototype), _class5);
          this.registerComponent('qux-component', {
            ComponentClass: QuxComponent,
            template: (0, _internalTestHelpers.strip)(_templateObject())
          });
          this.render('{{qux-component}}');
          this.$('button').click();
        };

        _proto['@test action decorator super works with native class methods'] = function testActionDecoratorSuperWorksWithNativeClassMethods(assert) {
          var _class6;

          var FooComponent =
          /*#__PURE__*/
          function (_Component2) {
            (0, _emberBabel.inheritsLoose)(FooComponent, _Component2);

            function FooComponent() {
              return _Component2.apply(this, arguments) || this;
            }

            var _proto7 = FooComponent.prototype;

            _proto7.foo = function foo() {
              assert.ok(true, 'called!');
            };

            return FooComponent;
          }(_glimmer.Component);

          var BarComponent = (_class6 =
          /*#__PURE__*/
          function (_FooComponent2) {
            (0, _emberBabel.inheritsLoose)(BarComponent, _FooComponent2);

            function BarComponent() {
              return _FooComponent2.apply(this, arguments) || this;
            }

            var _proto8 = BarComponent.prototype;

            _proto8.foo = function foo() {
              _FooComponent2.prototype.foo.call(this);
            };

            return BarComponent;
          }(FooComponent), _applyDecoratedDescriptor(_class6.prototype, "foo", [_index.action], Object.getOwnPropertyDescriptor(_class6.prototype, "foo"), _class6.prototype), _class6);
          this.registerComponent('bar-bar', {
            ComponentClass: BarComponent,
            template: "<button {{action 'foo'}}>Click Me!</button>"
          });
          this.render('{{bar-bar}}');
          this.$('button').click();
        };

        _proto['@test action decorator super works with traditional class methods'] = function testActionDecoratorSuperWorksWithTraditionalClassMethods(assert) {
          var _class7;

          var FooComponent = _glimmer.Component.extend({
            foo: function () {
              assert.ok(true, 'called!');
            }
          });

          var BarComponent = (_class7 =
          /*#__PURE__*/
          function (_FooComponent3) {
            (0, _emberBabel.inheritsLoose)(BarComponent, _FooComponent3);

            function BarComponent() {
              return _FooComponent3.apply(this, arguments) || this;
            }

            var _proto9 = BarComponent.prototype;

            _proto9.foo = function foo() {
              _FooComponent3.prototype.foo.call(this);
            };

            return BarComponent;
          }(FooComponent), _applyDecoratedDescriptor(_class7.prototype, "foo", [_index.action], Object.getOwnPropertyDescriptor(_class7.prototype, "foo"), _class7.prototype), _class7);
          this.registerComponent('bar-bar', {
            ComponentClass: BarComponent,
            template: "<button {{action 'foo'}}>Click Me!</button>"
          });
          this.render('{{bar-bar}}');
          this.$('button').click();
        } // This test fails with _classes_ compiled in loose mode
        ;

        _proto['@skip action decorator works with parent native class actions'] = function skipActionDecoratorWorksWithParentNativeClassActions(assert) {
          var _class8, _class9;

          var FooComponent = (_class8 =
          /*#__PURE__*/
          function (_Component3) {
            (0, _emberBabel.inheritsLoose)(FooComponent, _Component3);

            function FooComponent() {
              return _Component3.apply(this, arguments) || this;
            }

            var _proto10 = FooComponent.prototype;

            _proto10.foo = function foo() {
              assert.ok(true, 'called!');
            };

            return FooComponent;
          }(_glimmer.Component), _applyDecoratedDescriptor(_class8.prototype, "foo", [_index.action], Object.getOwnPropertyDescriptor(_class8.prototype, "foo"), _class8.prototype), _class8);
          var BarComponent = (_class9 =
          /*#__PURE__*/
          function (_FooComponent4) {
            (0, _emberBabel.inheritsLoose)(BarComponent, _FooComponent4);

            function BarComponent() {
              return _FooComponent4.apply(this, arguments) || this;
            }

            var _proto11 = BarComponent.prototype;

            _proto11.foo = function foo() {
              _FooComponent4.prototype.foo.call(this);
            };

            return BarComponent;
          }(FooComponent), _applyDecoratedDescriptor(_class9.prototype, "foo", [_index.action], Object.getOwnPropertyDescriptor(_class9.prototype, "foo"), _class9.prototype), _class9);
          this.registerComponent('bar-bar', {
            ComponentClass: BarComponent,
            template: "<button {{action 'foo'}}>Click Me!</button>"
          });
          this.render('{{bar-bar}}');
          this.$('button').click();
        };

        _proto['@test action decorator binds functions'] = function testActionDecoratorBindsFunctions(assert) {
          var _class10, _temp;

          var FooComponent = (_class10 = (_temp =
          /*#__PURE__*/
          function (_Component4) {
            (0, _emberBabel.inheritsLoose)(FooComponent, _Component4);

            function FooComponent() {
              var _this;

              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              _this = _Component4.call.apply(_Component4, [this].concat(args)) || this;
              _this.bar = 'some value';
              return _this;
            }

            var _proto12 = FooComponent.prototype;

            _proto12.foo = function foo() {
              assert.equal(this.bar, 'some value', 'context bound correctly');
            };

            return FooComponent;
          }(_glimmer.Component), _temp), _applyDecoratedDescriptor(_class10.prototype, "foo", [_index.action], Object.getOwnPropertyDescriptor(_class10.prototype, "foo"), _class10.prototype), _class10);
          this.registerComponent('foo-bar', {
            ComponentClass: FooComponent,
            template: '<button onclick={{this.foo}}>Click Me!</button>'
          });
          this.render('{{foo-bar}}');
          this.$('button').click();
        } // This test fails with _classes_ compiled in loose mode
        ;

        _proto['@skip action decorator super works correctly when bound'] = function skipActionDecoratorSuperWorksCorrectlyWhenBound(assert) {
          var _class12, _temp2, _class14;

          var FooComponent = (_class12 = (_temp2 =
          /*#__PURE__*/
          function (_Component5) {
            (0, _emberBabel.inheritsLoose)(FooComponent, _Component5);

            function FooComponent() {
              var _this2;

              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }

              _this2 = _Component5.call.apply(_Component5, [this].concat(args)) || this;
              _this2.bar = 'some value';
              return _this2;
            }

            var _proto13 = FooComponent.prototype;

            _proto13.foo = function foo() {
              assert.equal(this.bar, 'some value', 'context bound correctly');
            };

            return FooComponent;
          }(_glimmer.Component), _temp2), _applyDecoratedDescriptor(_class12.prototype, "foo", [_index.action], Object.getOwnPropertyDescriptor(_class12.prototype, "foo"), _class12.prototype), _class12);
          var BarComponent = (_class14 =
          /*#__PURE__*/
          function (_FooComponent5) {
            (0, _emberBabel.inheritsLoose)(BarComponent, _FooComponent5);

            function BarComponent() {
              return _FooComponent5.apply(this, arguments) || this;
            }

            var _proto14 = BarComponent.prototype;

            _proto14.foo = function foo() {
              _FooComponent5.prototype.foo.call(this);
            };

            return BarComponent;
          }(FooComponent), _applyDecoratedDescriptor(_class14.prototype, "foo", [_index.action], Object.getOwnPropertyDescriptor(_class14.prototype, "foo"), _class14.prototype), _class14);
          this.registerComponent('bar-bar', {
            ComponentClass: BarComponent,
            template: '<button onclick={{this.foo}}>Click Me!</button>'
          });
          this.render('{{bar-bar}}');
          this.$('button').click();
        };

        _proto['@test action decorator throws an error if applied to non-methods'] = function testActionDecoratorThrowsAnErrorIfAppliedToNonMethods() {
          expectAssertion(function () {
            var _class15, _descriptor, _temp3;

            var TestObject = (_class15 = (_temp3 =
            /*#__PURE__*/
            function (_EmberObject2) {
              (0, _emberBabel.inheritsLoose)(TestObject, _EmberObject2);

              function TestObject() {
                var _this3;

                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args[_key3] = arguments[_key3];
                }

                _this3 = _EmberObject2.call.apply(_EmberObject2, [this].concat(args)) || this;

                _initializerDefineProperty((0, _emberBabel.assertThisInitialized)(_this3), "foo", _descriptor, (0, _emberBabel.assertThisInitialized)(_this3));

                return _this3;
              }

              return TestObject;
            }(_runtime.Object), _temp3), _descriptor = _applyDecoratedDescriptor(_class15.prototype, "foo", [_index.action], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 'bar';
              }
            }), _class15);
            new TestObject();
          }, /The @action decorator must be applied to methods/);
        };

        _proto['@test action decorator throws an error if passed a function in native classes'] = function testActionDecoratorThrowsAnErrorIfPassedAFunctionInNativeClasses() {
          expectAssertion(function () {
            var _dec, _class17, _descriptor2, _temp4;

            var TestObject = (_dec = (0, _index.action)(function () {}), (_class17 = (_temp4 =
            /*#__PURE__*/
            function (_EmberObject3) {
              (0, _emberBabel.inheritsLoose)(TestObject, _EmberObject3);

              function TestObject() {
                var _this4;

                for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                  args[_key4] = arguments[_key4];
                }

                _this4 = _EmberObject3.call.apply(_EmberObject3, [this].concat(args)) || this;

                _initializerDefineProperty((0, _emberBabel.assertThisInitialized)(_this4), "foo", _descriptor2, (0, _emberBabel.assertThisInitialized)(_this4));

                return _this4;
              }

              return TestObject;
            }(_runtime.Object), _temp4), _descriptor2 = _applyDecoratedDescriptor(_class17.prototype, "foo", [_dec], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function () {
                return 'bar';
              }
            }), _class17));
            new TestObject();
          }, /The @action decorator may only be passed a method when used in classic classes/);
        };

        _proto['@test action decorator can be used as a classic decorator with strings'] = function testActionDecoratorCanBeUsedAsAClassicDecoratorWithStrings(assert) {
          var FooComponent = _glimmer.Component.extend({
            foo: (0, _index.action)(function () {
              assert.ok(true, 'called!');
            })
          });

          this.registerComponent('foo-bar', {
            ComponentClass: FooComponent,
            template: "<button {{action 'foo'}}>Click Me!</button>"
          });
          this.render('{{foo-bar}}');
          this.$('button').click();
        };

        _proto['@test action decorator can be used as a classic decorator directly'] = function testActionDecoratorCanBeUsedAsAClassicDecoratorDirectly(assert) {
          var FooComponent = _glimmer.Component.extend({
            foo: (0, _index.action)(function () {
              assert.ok(true, 'called!');
            })
          });

          this.registerComponent('foo-bar', {
            ComponentClass: FooComponent,
            template: '<button onclick={{this.foo}}>Click Me!</button>'
          });
          this.render('{{foo-bar}}');
          this.$('button').click();
        };

        return _class11;
      }(_internalTestHelpers.RenderingTestCase));
    }
});
enifed("@ember/object/tests/computed/computed_macros_test", ["ember-babel", "@ember/-internals/metal", "@ember/object/computed", "@ember/-internals/runtime", "internal-test-helpers"], function (_emberBabel, _metal, _computed, _runtime, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('CP macros',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Ember.computed.empty'] = function testEmberComputedEmpty(assert) {
      var obj = _runtime.Object.extend({
        bestLannister: null,
        lannisters: null,
        bestLannisterUnspecified: (0, _computed.empty)('bestLannister'),
        noLannistersKnown: (0, _computed.empty)('lannisters')
      }).create({
        lannisters: (0, _runtime.A)()
      });

      assert.equal((0, _metal.get)(obj, 'bestLannisterUnspecified'), true, 'bestLannister initially empty');
      assert.equal((0, _metal.get)(obj, 'noLannistersKnown'), true, 'lannisters initially empty');
      (0, _metal.get)(obj, 'lannisters').pushObject('Tyrion');
      (0, _metal.set)(obj, 'bestLannister', 'Tyrion');
      assert.equal((0, _metal.get)(obj, 'bestLannisterUnspecified'), false, 'empty respects strings');
      assert.equal((0, _metal.get)(obj, 'noLannistersKnown'), false, 'empty respects array mutations');
    };

    _proto['@test Ember.computed.notEmpty'] = function testEmberComputedNotEmpty(assert) {
      var obj = _runtime.Object.extend({
        bestLannister: null,
        lannisters: null,
        bestLannisterSpecified: (0, _computed.notEmpty)('bestLannister'),
        LannistersKnown: (0, _computed.notEmpty)('lannisters')
      }).create({
        lannisters: (0, _runtime.A)()
      });

      assert.equal((0, _metal.get)(obj, 'bestLannisterSpecified'), false, 'bestLannister initially empty');
      assert.equal((0, _metal.get)(obj, 'LannistersKnown'), false, 'lannisters initially empty');
      (0, _metal.get)(obj, 'lannisters').pushObject('Tyrion');
      (0, _metal.set)(obj, 'bestLannister', 'Tyrion');
      assert.equal((0, _metal.get)(obj, 'bestLannisterSpecified'), true, 'empty respects strings');
      assert.equal((0, _metal.get)(obj, 'LannistersKnown'), true, 'empty respects array mutations');
    };

    _proto['@test computed.not'] = function testComputedNot(assert) {
      var obj = {
        foo: true
      };
      (0, _metal.defineProperty)(obj, 'notFoo', (0, _computed.not)('foo'));
      assert.equal((0, _metal.get)(obj, 'notFoo'), false);
      obj = {
        foo: {
          bar: true
        }
      };
      (0, _metal.defineProperty)(obj, 'notFoo', (0, _computed.not)('foo.bar'));
      assert.equal((0, _metal.get)(obj, 'notFoo'), false);
    };

    _proto['@test computed.empty'] = function testComputedEmpty(assert) {
      var obj = {
        foo: [],
        bar: undefined,
        baz: null,
        quz: ''
      };
      (0, _metal.defineProperty)(obj, 'fooEmpty', (0, _computed.empty)('foo'));
      (0, _metal.defineProperty)(obj, 'barEmpty', (0, _computed.empty)('bar'));
      (0, _metal.defineProperty)(obj, 'bazEmpty', (0, _computed.empty)('baz'));
      (0, _metal.defineProperty)(obj, 'quzEmpty', (0, _computed.empty)('quz'));
      assert.equal((0, _metal.get)(obj, 'fooEmpty'), true);
      (0, _metal.set)(obj, 'foo', [1]);
      assert.equal((0, _metal.get)(obj, 'fooEmpty'), false);
      assert.equal((0, _metal.get)(obj, 'barEmpty'), true);
      assert.equal((0, _metal.get)(obj, 'bazEmpty'), true);
      assert.equal((0, _metal.get)(obj, 'quzEmpty'), true);
      (0, _metal.set)(obj, 'quz', 'asdf');
      assert.equal((0, _metal.get)(obj, 'quzEmpty'), false);
    };

    _proto['@test computed.bool'] = function testComputedBool(assert) {
      var obj = {
        foo: function () {},
        bar: 'asdf',
        baz: null,
        quz: false
      };
      (0, _metal.defineProperty)(obj, 'fooBool', (0, _computed.bool)('foo'));
      (0, _metal.defineProperty)(obj, 'barBool', (0, _computed.bool)('bar'));
      (0, _metal.defineProperty)(obj, 'bazBool', (0, _computed.bool)('baz'));
      (0, _metal.defineProperty)(obj, 'quzBool', (0, _computed.bool)('quz'));
      assert.equal((0, _metal.get)(obj, 'fooBool'), true);
      assert.equal((0, _metal.get)(obj, 'barBool'), true);
      assert.equal((0, _metal.get)(obj, 'bazBool'), false);
      assert.equal((0, _metal.get)(obj, 'quzBool'), false);
    };

    _proto['@test computed.alias'] = function testComputedAlias(assert) {
      var obj = {
        bar: 'asdf',
        baz: null,
        quz: false
      };
      (0, _metal.defineProperty)(obj, 'bay', (0, _metal.computed)(function () {
        return 'apple';
      }));
      (0, _metal.defineProperty)(obj, 'barAlias', (0, _metal.alias)('bar'));
      (0, _metal.defineProperty)(obj, 'bazAlias', (0, _metal.alias)('baz'));
      (0, _metal.defineProperty)(obj, 'quzAlias', (0, _metal.alias)('quz'));
      (0, _metal.defineProperty)(obj, 'bayAlias', (0, _metal.alias)('bay'));
      assert.equal((0, _metal.get)(obj, 'barAlias'), 'asdf');
      assert.equal((0, _metal.get)(obj, 'bazAlias'), null);
      assert.equal((0, _metal.get)(obj, 'quzAlias'), false);
      assert.equal((0, _metal.get)(obj, 'bayAlias'), 'apple');
      (0, _metal.set)(obj, 'barAlias', 'newBar');
      (0, _metal.set)(obj, 'bazAlias', 'newBaz');
      (0, _metal.set)(obj, 'quzAlias', null);
      assert.equal((0, _metal.get)(obj, 'barAlias'), 'newBar');
      assert.equal((0, _metal.get)(obj, 'bazAlias'), 'newBaz');
      assert.equal((0, _metal.get)(obj, 'quzAlias'), null);
      assert.equal((0, _metal.get)(obj, 'bar'), 'newBar');
      assert.equal((0, _metal.get)(obj, 'baz'), 'newBaz');
      assert.equal((0, _metal.get)(obj, 'quz'), null);
    };

    _proto['@test computed.alias set'] = function testComputedAliasSet(assert) {
      var obj = {};
      var constantValue = 'always `a`';
      (0, _metal.defineProperty)(obj, 'original', (0, _metal.computed)({
        get: function () {
          return constantValue;
        },
        set: function () {
          return constantValue;
        }
      }));
      (0, _metal.defineProperty)(obj, 'aliased', (0, _metal.alias)('original'));
      assert.equal((0, _metal.get)(obj, 'original'), constantValue);
      assert.equal((0, _metal.get)(obj, 'aliased'), constantValue);
      (0, _metal.set)(obj, 'aliased', 'should not set to this value');
      assert.equal((0, _metal.get)(obj, 'original'), constantValue);
      assert.equal((0, _metal.get)(obj, 'aliased'), constantValue);
    };

    _proto['@test computed.match'] = function testComputedMatch(assert) {
      var obj = {
        name: 'Paul'
      };
      (0, _metal.defineProperty)(obj, 'isPaul', (0, _computed.match)('name', /Paul/));
      assert.equal((0, _metal.get)(obj, 'isPaul'), true, 'is Paul');
      (0, _metal.set)(obj, 'name', 'Pierre');
      assert.equal((0, _metal.get)(obj, 'isPaul'), false, 'is not Paul anymore');
    };

    _proto['@test computed.notEmpty'] = function testComputedNotEmpty(assert) {
      var obj = {
        items: [1]
      };
      (0, _metal.defineProperty)(obj, 'hasItems', (0, _computed.notEmpty)('items'));
      assert.equal((0, _metal.get)(obj, 'hasItems'), true, 'is not empty');
      (0, _metal.set)(obj, 'items', []);
      assert.equal((0, _metal.get)(obj, 'hasItems'), false, 'is empty');
    };

    _proto['@test computed.equal'] = function testComputedEqual(assert) {
      var obj = {
        name: 'Paul'
      };
      (0, _metal.defineProperty)(obj, 'isPaul', (0, _computed.equal)('name', 'Paul'));
      assert.equal((0, _metal.get)(obj, 'isPaul'), true, 'is Paul');
      (0, _metal.set)(obj, 'name', 'Pierre');
      assert.equal((0, _metal.get)(obj, 'isPaul'), false, 'is not Paul anymore');
    };

    _proto['@test computed.gt'] = function testComputedGt(assert) {
      var obj = {
        number: 2
      };
      (0, _metal.defineProperty)(obj, 'isGreaterThenOne', (0, _computed.gt)('number', 1));
      assert.equal((0, _metal.get)(obj, 'isGreaterThenOne'), true, 'is gt');
      (0, _metal.set)(obj, 'number', 1);
      assert.equal((0, _metal.get)(obj, 'isGreaterThenOne'), false, 'is not gt');
      (0, _metal.set)(obj, 'number', 0);
      assert.equal((0, _metal.get)(obj, 'isGreaterThenOne'), false, 'is not gt');
    };

    _proto['@test computed.gte'] = function testComputedGte(assert) {
      var obj = {
        number: 2
      };
      (0, _metal.defineProperty)(obj, 'isGreaterOrEqualThenOne', (0, _computed.gte)('number', 1));
      assert.equal((0, _metal.get)(obj, 'isGreaterOrEqualThenOne'), true, 'is gte');
      (0, _metal.set)(obj, 'number', 1);
      assert.equal((0, _metal.get)(obj, 'isGreaterOrEqualThenOne'), true, 'is gte');
      (0, _metal.set)(obj, 'number', 0);
      assert.equal((0, _metal.get)(obj, 'isGreaterOrEqualThenOne'), false, 'is not gte');
    };

    _proto['@test computed.lt'] = function testComputedLt(assert) {
      var obj = {
        number: 0
      };
      (0, _metal.defineProperty)(obj, 'isLesserThenOne', (0, _computed.lt)('number', 1));
      assert.equal((0, _metal.get)(obj, 'isLesserThenOne'), true, 'is lt');
      (0, _metal.set)(obj, 'number', 1);
      assert.equal((0, _metal.get)(obj, 'isLesserThenOne'), false, 'is not lt');
      (0, _metal.set)(obj, 'number', 2);
      assert.equal((0, _metal.get)(obj, 'isLesserThenOne'), false, 'is not lt');
    };

    _proto['@test computed.lte'] = function testComputedLte(assert) {
      var obj = {
        number: 0
      };
      (0, _metal.defineProperty)(obj, 'isLesserOrEqualThenOne', (0, _computed.lte)('number', 1));
      assert.equal((0, _metal.get)(obj, 'isLesserOrEqualThenOne'), true, 'is lte');
      (0, _metal.set)(obj, 'number', 1);
      assert.equal((0, _metal.get)(obj, 'isLesserOrEqualThenOne'), true, 'is lte');
      (0, _metal.set)(obj, 'number', 2);
      assert.equal((0, _metal.get)(obj, 'isLesserOrEqualThenOne'), false, 'is not lte');
    };

    _proto['@test computed.and two properties'] = function testComputedAndTwoProperties(assert) {
      var obj = {
        one: true,
        two: true
      };
      (0, _metal.defineProperty)(obj, 'oneAndTwo', (0, _computed.and)('one', 'two'));
      assert.equal((0, _metal.get)(obj, 'oneAndTwo'), true, 'one and two');
      (0, _metal.set)(obj, 'one', false);
      assert.equal((0, _metal.get)(obj, 'oneAndTwo'), false, 'one and not two');
      (0, _metal.set)(obj, 'one', null);
      (0, _metal.set)(obj, 'two', 'Yes');
      assert.equal((0, _metal.get)(obj, 'oneAndTwo'), null, 'returns falsy value as in &&');
      (0, _metal.set)(obj, 'one', true);
      (0, _metal.set)(obj, 'two', 2);
      assert.equal((0, _metal.get)(obj, 'oneAndTwo'), 2, 'returns truthy value as in &&');
    };

    _proto['@test computed.and three properties'] = function testComputedAndThreeProperties(assert) {
      var obj = {
        one: true,
        two: true,
        three: true
      };
      (0, _metal.defineProperty)(obj, 'oneTwoThree', (0, _computed.and)('one', 'two', 'three'));
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one and two and three');
      (0, _metal.set)(obj, 'one', false);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), false, 'one and not two and not three');
      (0, _metal.set)(obj, 'one', true);
      (0, _metal.set)(obj, 'two', 2);
      (0, _metal.set)(obj, 'three', 3);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), 3, 'returns truthy value as in &&');
    };

    _proto['@test computed.and expand properties'] = function testComputedAndExpandProperties(assert) {
      var obj = {
        one: true,
        two: true,
        three: true
      };
      (0, _metal.defineProperty)(obj, 'oneTwoThree', (0, _computed.and)('{one,two,three}'));
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one and two and three');
      (0, _metal.set)(obj, 'one', false);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), false, 'one and not two and not three');
      (0, _metal.set)(obj, 'one', true);
      (0, _metal.set)(obj, 'two', 2);
      (0, _metal.set)(obj, 'three', 3);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), 3, 'returns truthy value as in &&');
    };

    _proto['@test computed.or two properties'] = function testComputedOrTwoProperties(assert) {
      var obj = {
        one: true,
        two: true
      };
      (0, _metal.defineProperty)(obj, 'oneOrTwo', (0, _computed.or)('one', 'two'));
      assert.equal((0, _metal.get)(obj, 'oneOrTwo'), true, 'one or two');
      (0, _metal.set)(obj, 'one', false);
      assert.equal((0, _metal.get)(obj, 'oneOrTwo'), true, 'one or two');
      (0, _metal.set)(obj, 'two', false);
      assert.equal((0, _metal.get)(obj, 'oneOrTwo'), false, 'nor one nor two');
      (0, _metal.set)(obj, 'two', null);
      assert.equal((0, _metal.get)(obj, 'oneOrTwo'), null, 'returns last falsy value as in ||');
      (0, _metal.set)(obj, 'two', true);
      assert.equal((0, _metal.get)(obj, 'oneOrTwo'), true, 'one or two');
      (0, _metal.set)(obj, 'one', 1);
      assert.equal((0, _metal.get)(obj, 'oneOrTwo'), 1, 'returns truthy value as in ||');
    };

    _proto['@test computed.or three properties'] = function testComputedOrThreeProperties(assert) {
      var obj = {
        one: true,
        two: true,
        three: true
      };
      (0, _metal.defineProperty)(obj, 'oneTwoThree', (0, _computed.or)('one', 'two', 'three'));
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _metal.set)(obj, 'one', false);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _metal.set)(obj, 'two', false);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _metal.set)(obj, 'three', false);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), false, 'one or two or three');
      (0, _metal.set)(obj, 'three', null);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), null, 'returns last falsy value as in ||');
      (0, _metal.set)(obj, 'two', true);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _metal.set)(obj, 'one', 1);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), 1, 'returns truthy value as in ||');
    };

    _proto['@test computed.or expand properties'] = function testComputedOrExpandProperties(assert) {
      var obj = {
        one: true,
        two: true,
        three: true
      };
      (0, _metal.defineProperty)(obj, 'oneTwoThree', (0, _computed.or)('{one,two,three}'));
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _metal.set)(obj, 'one', false);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _metal.set)(obj, 'two', false);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _metal.set)(obj, 'three', false);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), false, 'one or two or three');
      (0, _metal.set)(obj, 'three', null);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), null, 'returns last falsy value as in ||');
      (0, _metal.set)(obj, 'two', true);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), true, 'one or two or three');
      (0, _metal.set)(obj, 'one', 1);
      assert.equal((0, _metal.get)(obj, 'oneTwoThree'), 1, 'returns truthy value as in ||');
    };

    _proto['@test computed.or and computed.and warn about dependent keys with spaces'] = function testComputedOrAndComputedAndWarnAboutDependentKeysWithSpaces() {
      var obj = {
        one: true,
        two: true
      };
      expectAssertion(function () {
        (0, _metal.defineProperty)(obj, 'oneOrTwo', (0, _computed.or)('one', 'two three'));
      }, /Dependent keys passed to computed\.or\(\) can't have spaces\./);
      expectAssertion(function () {
        (0, _metal.defineProperty)(obj, 'oneAndTwo', (0, _computed.and)('one', 'two three'));
      }, /Dependent keys passed to computed\.and\(\) can't have spaces\./);
    };

    _proto['@test computed.oneWay'] = function testComputedOneWay(assert) {
      var obj = {
        firstName: 'Teddy',
        lastName: 'Zeenny'
      };
      (0, _metal.defineProperty)(obj, 'nickName', (0, _computed.oneWay)('firstName'));
      assert.equal((0, _metal.get)(obj, 'firstName'), 'Teddy');
      assert.equal((0, _metal.get)(obj, 'lastName'), 'Zeenny');
      assert.equal((0, _metal.get)(obj, 'nickName'), 'Teddy');
      (0, _metal.set)(obj, 'nickName', 'TeddyBear');
      assert.equal((0, _metal.get)(obj, 'firstName'), 'Teddy');
      assert.equal((0, _metal.get)(obj, 'lastName'), 'Zeenny');
      assert.equal((0, _metal.get)(obj, 'nickName'), 'TeddyBear');
      (0, _metal.set)(obj, 'firstName', 'TEDDDDDDDDYYY');
      assert.equal((0, _metal.get)(obj, 'nickName'), 'TeddyBear');
    };

    _proto['@test computed.readOnly'] = function testComputedReadOnly(assert) {
      var obj = {
        firstName: 'Teddy',
        lastName: 'Zeenny'
      };
      (0, _metal.defineProperty)(obj, 'nickName', (0, _computed.readOnly)('firstName'));
      assert.equal((0, _metal.get)(obj, 'firstName'), 'Teddy');
      assert.equal((0, _metal.get)(obj, 'lastName'), 'Zeenny');
      assert.equal((0, _metal.get)(obj, 'nickName'), 'Teddy');
      assert.throws(function () {
        (0, _metal.set)(obj, 'nickName', 'TeddyBear');
      }, / /);
      assert.equal((0, _metal.get)(obj, 'firstName'), 'Teddy');
      assert.equal((0, _metal.get)(obj, 'lastName'), 'Zeenny');
      assert.equal((0, _metal.get)(obj, 'nickName'), 'Teddy');
      (0, _metal.set)(obj, 'firstName', 'TEDDDDDDDDYYY');
      assert.equal((0, _metal.get)(obj, 'nickName'), 'TEDDDDDDDDYYY');
    };

    _proto['@test computed.deprecatingAlias'] = function testComputedDeprecatingAlias(assert) {
      var obj = {
        bar: 'asdf',
        baz: null,
        quz: false
      };
      (0, _metal.defineProperty)(obj, 'bay', (0, _metal.computed)(function () {
        return 'apple';
      }));
      (0, _metal.defineProperty)(obj, 'barAlias', (0, _computed.deprecatingAlias)('bar', {
        id: 'bar-deprecation',
        until: 'some.version'
      }));
      (0, _metal.defineProperty)(obj, 'bazAlias', (0, _computed.deprecatingAlias)('baz', {
        id: 'baz-deprecation',
        until: 'some.version'
      }));
      (0, _metal.defineProperty)(obj, 'quzAlias', (0, _computed.deprecatingAlias)('quz', {
        id: 'quz-deprecation',
        until: 'some.version'
      }));
      (0, _metal.defineProperty)(obj, 'bayAlias', (0, _computed.deprecatingAlias)('bay', {
        id: 'bay-deprecation',
        until: 'some.version'
      }));
      expectDeprecation(function () {
        assert.equal((0, _metal.get)(obj, 'barAlias'), 'asdf');
      }, 'Usage of `barAlias` is deprecated, use `bar` instead.');
      expectDeprecation(function () {
        assert.equal((0, _metal.get)(obj, 'bazAlias'), null);
      }, 'Usage of `bazAlias` is deprecated, use `baz` instead.');
      expectDeprecation(function () {
        assert.equal((0, _metal.get)(obj, 'quzAlias'), false);
      }, 'Usage of `quzAlias` is deprecated, use `quz` instead.');
      expectDeprecation(function () {
        assert.equal((0, _metal.get)(obj, 'bayAlias'), 'apple');
      }, 'Usage of `bayAlias` is deprecated, use `bay` instead.');
      expectDeprecation(function () {
        (0, _metal.set)(obj, 'barAlias', 'newBar');
      }, 'Usage of `barAlias` is deprecated, use `bar` instead.');
      expectDeprecation(function () {
        (0, _metal.set)(obj, 'bazAlias', 'newBaz');
      }, 'Usage of `bazAlias` is deprecated, use `baz` instead.');
      expectDeprecation(function () {
        (0, _metal.set)(obj, 'quzAlias', null);
      }, 'Usage of `quzAlias` is deprecated, use `quz` instead.');
      assert.equal((0, _metal.get)(obj, 'barAlias'), 'newBar');
      assert.equal((0, _metal.get)(obj, 'bazAlias'), 'newBaz');
      assert.equal((0, _metal.get)(obj, 'quzAlias'), null);
      assert.equal((0, _metal.get)(obj, 'bar'), 'newBar');
      assert.equal((0, _metal.get)(obj, 'baz'), 'newBaz');
      assert.equal((0, _metal.get)(obj, 'quz'), null);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/object/tests/computed/macro_decorators_test", ["ember-babel", "internal-test-helpers", "@ember/-internals/metal", "@ember/object/computed"], function (_emberBabel, _internalTestHelpers, _metal, _computed) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }

    return desc;
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');
  }

  if (true
  /* EMBER_NATIVE_DECORATOR_SUPPORT */
  ) {
      (0, _internalTestHelpers.moduleFor)('computed macros - decorators - assertions',
      /*#__PURE__*/
      function (_AbstractTestCase) {
        (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase);

        function _class2() {
          return _AbstractTestCase.apply(this, arguments) || this;
        }

        var _proto = _class2.prototype;

        _proto['@test and throws an error if used without parameters'] = function testAndThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class, _descriptor, _temp;

            var Foo = (_class = (_temp = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor, this);
            }, _temp), _descriptor = _applyDecoratedDescriptor(_class.prototype, "foo", [_computed.and], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class);
            new Foo();
          }, /You attempted to use @and/);
        };

        _proto['@test alias throws an error if used without parameters'] = function testAliasThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class3, _descriptor2, _temp2;

            var Foo = (_class3 = (_temp2 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor2, this);
            }, _temp2), _descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "foo", [_metal.alias], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class3);
            new Foo();
          }, /You attempted to use @alias/);
        };

        _proto['@test bool throws an error if used without parameters'] = function testBoolThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class5, _descriptor3, _temp3;

            var Foo = (_class5 = (_temp3 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor3, this);
            }, _temp3), _descriptor3 = _applyDecoratedDescriptor(_class5.prototype, "foo", [_computed.bool], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class5);
            new Foo();
          }, /You attempted to use @bool/);
        };

        _proto['@test collect throws an error if used without parameters'] = function testCollectThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class7, _descriptor4, _temp4;

            var Foo = (_class7 = (_temp4 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor4, this);
            }, _temp4), _descriptor4 = _applyDecoratedDescriptor(_class7.prototype, "foo", [_computed.collect], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class7);
            new Foo();
          }, /You attempted to use @collect/);
        };

        _proto['@test deprecatingAlias throws an error if used without parameters'] = function testDeprecatingAliasThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class9, _descriptor5, _temp5;

            var Foo = (_class9 = (_temp5 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor5, this);
            }, _temp5), _descriptor5 = _applyDecoratedDescriptor(_class9.prototype, "foo", [_computed.deprecatingAlias], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class9);
            new Foo();
          }, /You attempted to use @deprecatingAlias/);
        };

        _proto['@test empty throws an error if used without parameters'] = function testEmptyThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class11, _descriptor6, _temp6;

            var Foo = (_class11 = (_temp6 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor6, this);
            }, _temp6), _descriptor6 = _applyDecoratedDescriptor(_class11.prototype, "foo", [_computed.empty], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class11);
            new Foo();
          }, /You attempted to use @empty/);
        };

        _proto['@test equal throws an error if used without parameters'] = function testEqualThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class13, _descriptor7, _temp7;

            var Foo = (_class13 = (_temp7 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor7, this);
            }, _temp7), _descriptor7 = _applyDecoratedDescriptor(_class13.prototype, "foo", [_computed.equal], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class13);
            new Foo();
          }, /You attempted to use @equal/);
        };

        _proto['@test filter throws an error if used without parameters'] = function testFilterThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class15, _descriptor8, _temp8;

            var Foo = (_class15 = (_temp8 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor8, this);
            }, _temp8), _descriptor8 = _applyDecoratedDescriptor(_class15.prototype, "foo", [_computed.filter], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class15);
            new Foo();
          }, /You attempted to use @filter/);
        };

        _proto['@test filterBy throws an error if used without parameters'] = function testFilterByThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class17, _descriptor9, _temp9;

            var Foo = (_class17 = (_temp9 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor9, this);
            }, _temp9), _descriptor9 = _applyDecoratedDescriptor(_class17.prototype, "foo", [_computed.filterBy], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class17);
            new Foo();
          }, /You attempted to use @filterBy/);
        };

        _proto['@test gt throws an error if used without parameters'] = function testGtThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class19, _descriptor10, _temp10;

            var Foo = (_class19 = (_temp10 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor10, this);
            }, _temp10), _descriptor10 = _applyDecoratedDescriptor(_class19.prototype, "foo", [_computed.gt], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class19);
            new Foo();
          }, /You attempted to use @gt/);
        };

        _proto['@test gte throws an error if used without parameters'] = function testGteThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class21, _descriptor11, _temp11;

            var Foo = (_class21 = (_temp11 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor11, this);
            }, _temp11), _descriptor11 = _applyDecoratedDescriptor(_class21.prototype, "foo", [_computed.gte], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class21);
            new Foo();
          }, /You attempted to use @gte/);
        };

        _proto['@test intersect throws an error if used without parameters'] = function testIntersectThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class23, _descriptor12, _temp12;

            var Foo = (_class23 = (_temp12 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor12, this);
            }, _temp12), _descriptor12 = _applyDecoratedDescriptor(_class23.prototype, "foo", [_computed.intersect], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class23);
            new Foo();
          }, /You attempted to use @intersect/);
        };

        _proto['@test lt throws an error if used without parameters'] = function testLtThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class25, _descriptor13, _temp13;

            var Foo = (_class25 = (_temp13 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor13, this);
            }, _temp13), _descriptor13 = _applyDecoratedDescriptor(_class25.prototype, "foo", [_computed.lt], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class25);
            new Foo();
          }, /You attempted to use @lt/);
        };

        _proto['@test lte throws an error if used without parameters'] = function testLteThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class27, _descriptor14, _temp14;

            var Foo = (_class27 = (_temp14 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor14, this);
            }, _temp14), _descriptor14 = _applyDecoratedDescriptor(_class27.prototype, "foo", [_computed.lte], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class27);
            new Foo();
          }, /You attempted to use @lte/);
        };

        _proto['@test map throws an error if used without parameters'] = function testMapThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class29, _descriptor15, _temp15;

            var Foo = (_class29 = (_temp15 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor15, this);
            }, _temp15), _descriptor15 = _applyDecoratedDescriptor(_class29.prototype, "foo", [_computed.map], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class29);
            new Foo();
          }, /You attempted to use @map/);
        };

        _proto['@test mapBy throws an error if used without parameters'] = function testMapByThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class31, _descriptor16, _temp16;

            var Foo = (_class31 = (_temp16 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor16, this);
            }, _temp16), _descriptor16 = _applyDecoratedDescriptor(_class31.prototype, "foo", [_computed.mapBy], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class31);
            new Foo();
          }, /You attempted to use @mapBy/);
        };

        _proto['@test match throws an error if used without parameters'] = function testMatchThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class33, _descriptor17, _temp17;

            var Foo = (_class33 = (_temp17 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor17, this);
            }, _temp17), _descriptor17 = _applyDecoratedDescriptor(_class33.prototype, "foo", [_computed.match], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class33);
            new Foo();
          }, /You attempted to use @match/);
        };

        _proto['@test max throws an error if used without parameters'] = function testMaxThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class35, _descriptor18, _temp18;

            var Foo = (_class35 = (_temp18 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor18, this);
            }, _temp18), _descriptor18 = _applyDecoratedDescriptor(_class35.prototype, "foo", [_computed.max], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class35);
            new Foo();
          }, /You attempted to use @max/);
        };

        _proto['@test min throws an error if used without parameters'] = function testMinThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class37, _descriptor19, _temp19;

            var Foo = (_class37 = (_temp19 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor19, this);
            }, _temp19), _descriptor19 = _applyDecoratedDescriptor(_class37.prototype, "foo", [_computed.min], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class37);
            new Foo();
          }, /You attempted to use @min/);
        };

        _proto['@test not throws an error if used without parameters'] = function testNotThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class39, _descriptor20, _temp20;

            var Foo = (_class39 = (_temp20 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor20, this);
            }, _temp20), _descriptor20 = _applyDecoratedDescriptor(_class39.prototype, "foo", [_computed.not], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class39);
            new Foo();
          }, /You attempted to use @not/);
        };

        _proto['@test notEmpty throws an error if used without parameters'] = function testNotEmptyThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class41, _descriptor21, _temp21;

            var Foo = (_class41 = (_temp21 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor21, this);
            }, _temp21), _descriptor21 = _applyDecoratedDescriptor(_class41.prototype, "foo", [_computed.notEmpty], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class41);
            new Foo();
          }, /You attempted to use @notEmpty/);
        };

        _proto['@test oneWay throws an error if used without parameters'] = function testOneWayThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class43, _descriptor22, _temp22;

            var Foo = (_class43 = (_temp22 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor22, this);
            }, _temp22), _descriptor22 = _applyDecoratedDescriptor(_class43.prototype, "foo", [_computed.oneWay], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class43);
            new Foo();
          }, /You attempted to use @oneWay/);
        };

        _proto['@test or throws an error if used without parameters'] = function testOrThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class45, _descriptor23, _temp23;

            var Foo = (_class45 = (_temp23 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor23, this);
            }, _temp23), _descriptor23 = _applyDecoratedDescriptor(_class45.prototype, "foo", [_computed.or], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class45);
            new Foo();
          }, /You attempted to use @or/);
        };

        _proto['@test readOnly throws an error if used without parameters'] = function testReadOnlyThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class47, _descriptor24, _temp24;

            var Foo = (_class47 = (_temp24 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor24, this);
            }, _temp24), _descriptor24 = _applyDecoratedDescriptor(_class47.prototype, "foo", [_computed.readOnly], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class47);
            new Foo();
          }, /You attempted to use @readOnly/);
        };

        _proto['@test setDiff throws an error if used without parameters'] = function testSetDiffThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class49, _descriptor25, _temp25;

            var Foo = (_class49 = (_temp25 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor25, this);
            }, _temp25), _descriptor25 = _applyDecoratedDescriptor(_class49.prototype, "foo", [_computed.setDiff], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class49);
            new Foo();
          }, /You attempted to use @setDiff/);
        };

        _proto['@test sort throws an error if used without parameters'] = function testSortThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class51, _descriptor26, _temp26;

            var Foo = (_class51 = (_temp26 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor26, this);
            }, _temp26), _descriptor26 = _applyDecoratedDescriptor(_class51.prototype, "foo", [_computed.sort], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class51);
            new Foo();
          }, /You attempted to use @sort/);
        };

        _proto['@test sum throws an error if used without parameters'] = function testSumThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class53, _descriptor27, _temp27;

            var Foo = (_class53 = (_temp27 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor27, this);
            }, _temp27), _descriptor27 = _applyDecoratedDescriptor(_class53.prototype, "foo", [_computed.sum], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class53);
            new Foo();
          }, /You attempted to use @sum/);
        };

        _proto['@test union throws an error if used without parameters'] = function testUnionThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class55, _descriptor28, _temp28;

            var Foo = (_class55 = (_temp28 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor28, this);
            }, _temp28), _descriptor28 = _applyDecoratedDescriptor(_class55.prototype, "foo", [_computed.union], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class55);
            new Foo();
          }, /You attempted to use @uniq\/@union/);
        };

        _proto['@test uniq throws an error if used without parameters'] = function testUniqThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class57, _descriptor29, _temp29;

            var Foo = (_class57 = (_temp29 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor29, this);
            }, _temp29), _descriptor29 = _applyDecoratedDescriptor(_class57.prototype, "foo", [_computed.uniq], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class57);
            new Foo();
          }, /You attempted to use @uniq\/@union/);
        };

        _proto['@test uniqBy throws an error if used without parameters'] = function testUniqByThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class59, _descriptor30, _temp30;

            var Foo = (_class59 = (_temp30 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor30, this);
            }, _temp30), _descriptor30 = _applyDecoratedDescriptor(_class59.prototype, "foo", [_computed.uniqBy], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class59);
            new Foo();
          }, /You attempted to use @uniqBy/);
        };

        _proto['@test alias throws an error if used without parameters'] = function testAliasThrowsAnErrorIfUsedWithoutParameters() {
          expectAssertion(function () {
            var _class61, _descriptor31, _temp31;

            var Foo = (_class61 = (_temp31 = function Foo() {
              _initializerDefineProperty(this, "foo", _descriptor31, this);
            }, _temp31), _descriptor31 = _applyDecoratedDescriptor(_class61.prototype, "foo", [_metal.alias], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: null
            }), _class61);
            new Foo();
          }, /You attempted to use @alias/);
        };

        return _class2;
      }(_internalTestHelpers.AbstractTestCase));
    }
});
enifed("@ember/object/tests/computed/reduce_computed_macros_test", ["ember-babel", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/runtime", "@ember/object/computed", "internal-test-helpers"], function (_emberBabel, _runloop, _metal, _runtime, _computed, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }

    return desc;
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');
  }

  var obj;
  (0, _internalTestHelpers.moduleFor)('map',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase);

    function _class2() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class2.prototype;

    _proto.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        mapped: (0, _computed.map)('array.@each.v', function (item) {
          return item.v;
        }),
        mappedObjects: (0, _computed.map)('arrayObjects.@each.v', function (item) {
          return {
            name: item.v.name
          };
        })
      }).create({
        arrayObjects: (0, _runtime.A)([{
          v: {
            name: 'Robert'
          }
        }, {
          v: {
            name: 'Leanna'
          }
        }]),
        array: (0, _runtime.A)([{
          v: 1
        }, {
          v: 3
        }, {
          v: 2
        }, {
          v: 1
        }])
      });
    };

    _proto.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto['@test map is readOnly'] = function testMapIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('mapped', 1);
      }, /Cannot set read-only property "mapped" on object:/);
    };

    _proto['@test it maps simple properties'] = function testItMapsSimpleProperties(assert) {
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 1]);
      obj.get('array').pushObject({
        v: 5
      });
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 1, 5]);
      (0, _runtime.removeAt)(obj.get('array'), 3);
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 5]);
    };

    _proto['@test it maps simple unshifted properties'] = function testItMapsSimpleUnshiftedProperties(assert) {
      var array = (0, _runtime.A)();
      obj = _runtime.Object.extend({
        mapped: (0, _computed.map)('array', function (item) {
          return item.toUpperCase();
        })
      }).create({
        array: array
      });
      array.unshiftObject('c');
      array.unshiftObject('b');
      array.unshiftObject('a');
      array.popObject();
      assert.deepEqual(obj.get('mapped'), ['A', 'B'], 'properties unshifted in sequence are mapped correctly');
    };

    _proto['@test it has the correct `this`'] = function testItHasTheCorrectThis(assert) {
      obj = _runtime.Object.extend({
        mapped: (0, _computed.map)('array', function (item) {
          assert.equal(this, obj, 'should have correct context');
          return this.upperCase(item);
        }),
        upperCase: function (string) {
          return string.toUpperCase();
        }
      }).create({
        array: ['a', 'b', 'c']
      });
      assert.deepEqual(obj.get('mapped'), ['A', 'B', 'C'], 'properties unshifted in sequence are mapped correctly');
    };

    _proto['@test it passes the index to the callback'] = function testItPassesTheIndexToTheCallback(assert) {
      var array = ['a', 'b', 'c'];
      obj = _runtime.Object.extend({
        mapped: (0, _computed.map)('array', function (item, index) {
          return index;
        })
      }).create({
        array: array
      });
      assert.deepEqual(obj.get('mapped'), [0, 1, 2], 'index is passed to callback correctly');
    };

    _proto['@test it maps objects'] = function testItMapsObjects(assert) {
      assert.deepEqual(obj.get('mappedObjects'), [{
        name: 'Robert'
      }, {
        name: 'Leanna'
      }]);
      obj.get('arrayObjects').pushObject({
        v: {
          name: 'Eddard'
        }
      });
      assert.deepEqual(obj.get('mappedObjects'), [{
        name: 'Robert'
      }, {
        name: 'Leanna'
      }, {
        name: 'Eddard'
      }]);
      (0, _runtime.removeAt)(obj.get('arrayObjects'), 1);
      assert.deepEqual(obj.get('mappedObjects'), [{
        name: 'Robert'
      }, {
        name: 'Eddard'
      }]);
      (0, _metal.set)(obj.get('arrayObjects')[0], 'v', {
        name: 'Stannis'
      });
      assert.deepEqual(obj.get('mappedObjects'), [{
        name: 'Stannis'
      }, {
        name: 'Eddard'
      }]);
    };

    _proto['@test it maps unshifted objects with property observers'] = function testItMapsUnshiftedObjectsWithPropertyObservers(assert) {
      var array = (0, _runtime.A)();
      var cObj = {
        v: 'c'
      };
      obj = _runtime.Object.extend({
        mapped: (0, _computed.map)('array.@each.v', function (item) {
          return (0, _metal.get)(item, 'v').toUpperCase();
        })
      }).create({
        array: array
      });
      array.unshiftObject(cObj);
      array.unshiftObject({
        v: 'b'
      });
      array.unshiftObject({
        v: 'a'
      });
      (0, _metal.set)(cObj, 'v', 'd');
      assert.deepEqual(array.mapBy('v'), ['a', 'b', 'd'], 'precond - unmapped array is correct');
      assert.deepEqual(obj.get('mapped'), ['A', 'B', 'D'], 'properties unshifted in sequence are mapped correctly');
    };

    _proto['@test it updates if additional dependent keys are modified'] = function testItUpdatesIfAdditionalDependentKeysAreModified(assert) {
      obj = _runtime.Object.extend({
        mapped: (0, _computed.map)('array', ['key'], function (item) {
          return item[this.key];
        })
      }).create({
        key: 'name',
        array: (0, _runtime.A)([{
          name: 'Cercei',
          house: 'Lannister'
        }])
      });
      assert.deepEqual(obj.get('mapped'), ['Cercei'], 'precond - mapped array is initially correct');
      obj.set('key', 'house');
      assert.deepEqual(obj.get('mapped'), ['Lannister'], 'mapped prop updates correctly when additional dependency is updated');
    };

    _proto['@test it throws on bad inputs'] = function testItThrowsOnBadInputs() {
      expectAssertion(function () {
        (0, _computed.map)('items.@each.{prop}', 'foo');
      }, /The final parameter provided to map must be a callback function/);
      expectAssertion(function () {
        (0, _computed.map)('items.@each.{prop}', 'foo', function () {});
      }, /The second parameter provided to map must either be the callback or an array of additional dependent keys/);
      expectAssertion(function () {
        (0, _computed.map)('items.@each.{prop}', function () {}, ['foo']);
      }, /The final parameter provided to map must be a callback function/);
      expectAssertion(function () {
        (0, _computed.map)('items.@each.{prop}', ['foo']);
      }, /The final parameter provided to map must be a callback function/);
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('mapBy',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class3, _AbstractTestCase2);

    function _class3() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class3.prototype;

    _proto2.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        mapped: (0, _computed.mapBy)('array', 'v')
      }).create({
        array: (0, _runtime.A)([{
          v: 1
        }, {
          v: 3
        }, {
          v: 2
        }, {
          v: 1
        }])
      });
    };

    _proto2.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto2['@test mapBy is readOnly'] = function testMapByIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('mapped', 1);
      }, /Cannot set read-only property "mapped" on object:/);
    };

    _proto2['@test it maps properties'] = function testItMapsProperties(assert) {
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 1]);
      obj.get('array').pushObject({
        v: 5
      });
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 1, 5]);
      (0, _runtime.removeAt)(obj.get('array'), 3);
      assert.deepEqual(obj.get('mapped'), [1, 3, 2, 5]);
    };

    _proto2['@test it is observable'] =
    /*#__PURE__*/
    function () {
      var _testItIsObservable = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var calls;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              calls = 0;
              assert.deepEqual(obj.get('mapped'), [1, 3, 2, 1]);
              (0, _metal.addObserver)(obj, 'mapped.@each', function () {
                return calls++;
              });
              obj.get('array').pushObject({
                v: 5
              });
              _context.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              assert.equal(calls, 1, 'mapBy is observable');

            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function testItIsObservable(_x) {
        return _testItIsObservable.apply(this, arguments);
      }

      return testItIsObservable;
    }();

    return _class3;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('filter',
  /*#__PURE__*/
  function (_AbstractTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class4, _AbstractTestCase3);

    function _class4() {
      return _AbstractTestCase3.apply(this, arguments) || this;
    }

    var _proto3 = _class4.prototype;

    _proto3.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        filtered: (0, _computed.filter)('array', function (item) {
          return item % 2 === 0;
        })
      }).create({
        array: (0, _runtime.A)([1, 2, 3, 4, 5, 6, 7, 8])
      });
    };

    _proto3.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto3['@test filter is readOnly'] = function testFilterIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('filtered', 1);
      }, /Cannot set read-only property "filtered" on object:/);
    };

    _proto3['@test it filters according to the specified filter function'] = function testItFiltersAccordingToTheSpecifiedFilterFunction(assert) {
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'filter filters by the specified function');
    };

    _proto3['@test it passes the index to the callback'] = function testItPassesTheIndexToTheCallback(assert) {
      obj = _runtime.Object.extend({
        filtered: (0, _computed.filter)('array', function (item, index) {
          return index === 1;
        })
      }).create({
        array: ['a', 'b', 'c']
      });
      assert.deepEqual((0, _metal.get)(obj, 'filtered'), ['b'], 'index is passed to callback correctly');
    };

    _proto3['@test it has the correct `this`'] = function testItHasTheCorrectThis(assert) {
      obj = _runtime.Object.extend({
        filtered: (0, _computed.filter)('array', function (item, index) {
          assert.equal(this, obj);
          return this.isOne(index);
        }),
        isOne: function (value) {
          return value === 1;
        }
      }).create({
        array: ['a', 'b', 'c']
      });
      assert.deepEqual((0, _metal.get)(obj, 'filtered'), ['b'], 'index is passed to callback correctly');
    };

    _proto3['@test it passes the array to the callback'] = function testItPassesTheArrayToTheCallback(assert) {
      obj = _runtime.Object.extend({
        filtered: (0, _computed.filter)('array', function (item, index, array) {
          return index === (0, _metal.get)(array, 'length') - 2;
        })
      }).create({
        array: (0, _runtime.A)(['a', 'b', 'c'])
      });
      assert.deepEqual(obj.get('filtered'), ['b'], 'array is passed to callback correctly');
    };

    _proto3['@test it caches properly'] = function testItCachesProperly(assert) {
      var array = obj.get('array');
      var filtered = obj.get('filtered');
      assert.ok(filtered === obj.get('filtered'));
      array.addObject(11);
      var newFiltered = obj.get('filtered');
      assert.ok(filtered !== newFiltered);
      assert.ok(obj.get('filtered') === newFiltered);
    };

    _proto3['@test it updates as the array is modified'] = function testItUpdatesAsTheArrayIsModified(assert) {
      var array = obj.get('array');
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct');
      array.addObject(11);
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'objects not passing the filter are not added');
      array.addObject(12);
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8, 12], 'objects passing the filter are added');
      array.removeObject(3);
      array.removeObject(4);
      assert.deepEqual(obj.get('filtered'), [2, 6, 8, 12], 'objects removed from the dependent array are removed from the computed array');
    };

    _proto3['@test the dependent array can be cleared one at a time'] = function testTheDependentArrayCanBeClearedOneAtATime(assert) {
      var array = (0, _metal.get)(obj, 'array');
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct'); // clear 1-8 but in a random order

      array.removeObject(3);
      array.removeObject(1);
      array.removeObject(2);
      array.removeObject(4);
      array.removeObject(8);
      array.removeObject(6);
      array.removeObject(5);
      array.removeObject(7);
      assert.deepEqual(obj.get('filtered'), [], 'filtered array cleared correctly');
    };

    _proto3['@test the dependent array can be `clear`ed directly (#3272)'] = function testTheDependentArrayCanBeClearEdDirectly3272(assert) {
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct');
      obj.get('array').clear();
      assert.deepEqual(obj.get('filtered'), [], 'filtered array cleared correctly');
    };

    _proto3['@test it updates as the array is replaced'] = function testItUpdatesAsTheArrayIsReplaced(assert) {
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct');
      obj.set('array', [20, 21, 22, 23, 24]);
      assert.deepEqual(obj.get('filtered'), [20, 22, 24], 'computed array is updated when array is changed');
    };

    _proto3['@test it updates properly on @each with {} dependencies'] = function testItUpdatesProperlyOnEachWithDependencies(assert) {
      var item = _runtime.Object.create({
        prop: true
      });

      obj = _runtime.Object.extend({
        filtered: (0, _computed.filter)('items.@each.{prop}', function (item) {
          return item.get('prop') === true;
        })
      }).create({
        items: (0, _runtime.A)([item])
      });
      assert.deepEqual(obj.get('filtered'), [item]);
      item.set('prop', false);
      assert.deepEqual(obj.get('filtered'), []);
    };

    _proto3['@test it updates if additional dependent keys are modified'] = function testItUpdatesIfAdditionalDependentKeysAreModified(assert) {
      obj = _runtime.Object.extend({
        filtered: (0, _computed.filter)('array', ['modulo'], function (item) {
          return item % this.modulo === 0;
        })
      }).create({
        modulo: 2,
        array: (0, _runtime.A)([1, 2, 3, 4, 5, 6, 7, 8])
      });
      assert.deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct');
      obj.set('modulo', 3);
      assert.deepEqual(obj.get('filtered'), [3, 6], 'filtered prop updates correctly when additional dependency is updated');
    };

    _proto3['@test it throws on bad inputs'] = function testItThrowsOnBadInputs() {
      expectAssertion(function () {
        (0, _computed.filter)('items.@each.{prop}', 'foo');
      }, /The final parameter provided to filter must be a callback function/);
      expectAssertion(function () {
        (0, _computed.filter)('items.@each.{prop}', 'foo', function () {});
      }, /The second parameter provided to filter must either be the callback or an array of additional dependent keys/);
      expectAssertion(function () {
        (0, _computed.filter)('items.@each.{prop}', function () {}, ['foo']);
      }, /The final parameter provided to filter must be a callback function/);
      expectAssertion(function () {
        (0, _computed.filter)('items.@each.{prop}', ['foo']);
      }, /The final parameter provided to filter must be a callback function/);
    };

    return _class4;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('filterBy',
  /*#__PURE__*/
  function (_AbstractTestCase4) {
    (0, _emberBabel.inheritsLoose)(_class5, _AbstractTestCase4);

    function _class5() {
      return _AbstractTestCase4.apply(this, arguments) || this;
    }

    var _proto4 = _class5.prototype;

    _proto4.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        a1s: (0, _computed.filterBy)('array', 'a', 1),
        as: (0, _computed.filterBy)('array', 'a'),
        bs: (0, _computed.filterBy)('array', 'b')
      }).create({
        array: (0, _runtime.A)([{
          name: 'one',
          a: 1,
          b: false
        }, {
          name: 'two',
          a: 2,
          b: false
        }, {
          name: 'three',
          a: 1,
          b: true
        }, {
          name: 'four',
          b: true
        }])
      });
    };

    _proto4.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto4['@test filterBy is readOnly'] = function testFilterByIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('as', 1);
      }, /Cannot set read-only property "as" on object:/);
    };

    _proto4['@test properties can be filtered by truthiness'] = function testPropertiesCanBeFilteredByTruthiness(assert) {
      assert.deepEqual(obj.get('as').mapBy('name'), ['one', 'two', 'three'], 'properties can be filtered by existence');
      assert.deepEqual(obj.get('bs').mapBy('name'), ['three', 'four'], 'booleans can be filtered');
      (0, _metal.set)(obj.get('array')[0], 'a', undefined);
      (0, _metal.set)(obj.get('array')[3], 'a', true);
      (0, _metal.set)(obj.get('array')[0], 'b', true);
      (0, _metal.set)(obj.get('array')[3], 'b', false);
      assert.deepEqual(obj.get('as').mapBy('name'), ['two', 'three', 'four'], 'arrays computed by filter property respond to property changes');
      assert.deepEqual(obj.get('bs').mapBy('name'), ['one', 'three'], 'arrays computed by filtered property respond to property changes');
      obj.get('array').pushObject({
        name: 'five',
        a: 6,
        b: true
      });
      assert.deepEqual(obj.get('as').mapBy('name'), ['two', 'three', 'four', 'five'], 'arrays computed by filter property respond to added objects');
      assert.deepEqual(obj.get('bs').mapBy('name'), ['one', 'three', 'five'], 'arrays computed by filtered property respond to added objects');
      obj.get('array').popObject();
      assert.deepEqual(obj.get('as').mapBy('name'), ['two', 'three', 'four'], 'arrays computed by filter property respond to removed objects');
      assert.deepEqual(obj.get('bs').mapBy('name'), ['one', 'three'], 'arrays computed by filtered property respond to removed objects');
      obj.set('array', [{
        name: 'six',
        a: 12,
        b: true
      }]);
      assert.deepEqual(obj.get('as').mapBy('name'), ['six'], 'arrays computed by filter property respond to array changes');
      assert.deepEqual(obj.get('bs').mapBy('name'), ['six'], 'arrays computed by filtered property respond to array changes');
    };

    _proto4['@test properties can be filtered by values'] = function testPropertiesCanBeFilteredByValues(assert) {
      assert.deepEqual(obj.get('a1s').mapBy('name'), ['one', 'three'], 'properties can be filtered by matching value');
      obj.get('array').pushObject({
        name: 'five',
        a: 1
      });
      assert.deepEqual(obj.get('a1s').mapBy('name'), ['one', 'three', 'five'], 'arrays computed by matching value respond to added objects');
      obj.get('array').popObject();
      assert.deepEqual(obj.get('a1s').mapBy('name'), ['one', 'three'], 'arrays computed by matching value respond to removed objects');
      (0, _metal.set)(obj.get('array')[1], 'a', 1);
      (0, _metal.set)(obj.get('array')[2], 'a', 2);
      assert.deepEqual(obj.get('a1s').mapBy('name'), ['one', 'two'], 'arrays computed by matching value respond to modified properties');
    };

    _proto4['@test properties values can be replaced'] = function testPropertiesValuesCanBeReplaced(assert) {
      obj = _runtime.Object.extend({
        a1s: (0, _computed.filterBy)('array', 'a', 1),
        a1bs: (0, _computed.filterBy)('a1s', 'b')
      }).create({
        array: []
      });
      assert.deepEqual(obj.get('a1bs').mapBy('name'), [], 'properties can be filtered by matching value');
      (0, _metal.set)(obj, 'array', [{
        name: 'item1',
        a: 1,
        b: true
      }]);
      assert.deepEqual(obj.get('a1bs').mapBy('name'), ['item1'], 'properties can be filtered by matching value');
    };

    return _class5;
  }(_internalTestHelpers.AbstractTestCase));
  [['uniq', _computed.uniq], ['union', _computed.union]].forEach(function (tuple) {
    var name = tuple[0],
        macro = tuple[1];
    (0, _internalTestHelpers.moduleFor)("computed." + name,
    /*#__PURE__*/
    function (_AbstractTestCase5) {
      (0, _emberBabel.inheritsLoose)(_class6, _AbstractTestCase5);

      function _class6() {
        return _AbstractTestCase5.apply(this, arguments) || this;
      }

      var _proto5 = _class6.prototype;

      _proto5.beforeEach = function beforeEach() {
        obj = _runtime.Object.extend({
          union: macro('array', 'array2', 'array3')
        }).create({
          array: (0, _runtime.A)([1, 2, 3, 4, 5, 6]),
          array2: (0, _runtime.A)([4, 5, 6, 7, 8, 9, 4, 5, 6, 7, 8, 9]),
          array3: (0, _runtime.A)([1, 8, 10])
        });
      };

      _proto5.afterEach = function afterEach() {
        (0, _runloop.run)(obj, 'destroy');
      };

      _proto5["@test " + name + " is readOnly"] = function (assert) {
        assert.throws(function () {
          obj.set('union', 1);
        }, /Cannot set read-only property "union" on object:/);
      };

      _proto5['@test does not include duplicates'] = function testDoesNotIncludeDuplicates(assert) {
        var array = obj.get('array');
        var array2 = obj.get('array2');
        assert.deepEqual(obj.get('union').sort(function (x, y) {
          return x - y;
        }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], name + ' does not include duplicates');
        array.pushObject(8);
        assert.deepEqual(obj.get('union').sort(function (x, y) {
          return x - y;
        }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], name + ' does not add existing items');
        array.pushObject(11);
        assert.deepEqual(obj.get('union').sort(function (x, y) {
          return x - y;
        }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], name + ' adds new items');
        (0, _runtime.removeAt)(array2, 6); // remove 7

        assert.deepEqual(obj.get('union').sort(function (x, y) {
          return x - y;
        }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], name + ' does not remove items that are still in the dependent array');
        array2.removeObject(7);
        assert.deepEqual(obj.get('union').sort(function (x, y) {
          return x - y;
        }), [1, 2, 3, 4, 5, 6, 8, 9, 10, 11], name + ' removes items when their last instance is gone');
      };

      _proto5['@test has set-union semantics'] = function testHasSetUnionSemantics(assert) {
        var array = obj.get('array');
        assert.deepEqual(obj.get('union').sort(function (x, y) {
          return x - y;
        }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], name + ' is initially correct');
        array.removeObject(6);
        assert.deepEqual(obj.get('union').sort(function (x, y) {
          return x - y;
        }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 'objects are not removed if they exist in other dependent arrays');
        array.clear();
        assert.deepEqual(obj.get('union').sort(function (x, y) {
          return x - y;
        }), [1, 4, 5, 6, 7, 8, 9, 10], 'objects are removed when they are no longer in any dependent array');
      };

      return _class6;
    }(_internalTestHelpers.AbstractTestCase));
  });
  (0, _internalTestHelpers.moduleFor)('computed.uniqBy',
  /*#__PURE__*/
  function (_AbstractTestCase6) {
    (0, _emberBabel.inheritsLoose)(_class7, _AbstractTestCase6);

    function _class7() {
      return _AbstractTestCase6.apply(this, arguments) || this;
    }

    var _proto6 = _class7.prototype;

    _proto6.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        list: null,
        uniqueById: (0, _computed.uniqBy)('list', 'id')
      }).create({
        list: (0, _runtime.A)([{
          id: 1,
          value: 'one'
        }, {
          id: 2,
          value: 'two'
        }, {
          id: 1,
          value: 'one'
        }])
      });
    };

    _proto6.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto6['@test uniqBy is readOnly'] = function testUniqByIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('uniqueById', 1);
      }, /Cannot set read-only property "uniqueById" on object:/);
    };

    _proto6['@test does not include duplicates'] = function testDoesNotIncludeDuplicates(assert) {
      assert.deepEqual(obj.get('uniqueById'), [{
        id: 1,
        value: 'one'
      }, {
        id: 2,
        value: 'two'
      }]);
    };

    _proto6['@test it does not share state among instances'] = function testItDoesNotShareStateAmongInstances(assert) {
      var MyObject = _runtime.Object.extend({
        list: [],
        uniqueByName: (0, _computed.uniqBy)('list', 'name')
      });

      var a = MyObject.create({
        list: [{
          name: 'bob'
        }, {
          name: 'mitch'
        }, {
          name: 'mitch'
        }]
      });
      var b = MyObject.create({
        list: [{
          name: 'warren'
        }, {
          name: 'mitch'
        }]
      });
      assert.deepEqual(a.get('uniqueByName'), [{
        name: 'bob'
      }, {
        name: 'mitch'
      }]); // Making sure that 'mitch' appears

      assert.deepEqual(b.get('uniqueByName'), [{
        name: 'warren'
      }, {
        name: 'mitch'
      }]);
    };

    _proto6['@test it handles changes to the dependent array'] = function testItHandlesChangesToTheDependentArray(assert) {
      obj.get('list').pushObject({
        id: 3,
        value: 'three'
      });
      assert.deepEqual(obj.get('uniqueById'), [{
        id: 1,
        value: 'one'
      }, {
        id: 2,
        value: 'two'
      }, {
        id: 3,
        value: 'three'
      }], 'The list includes three');
      obj.get('list').pushObject({
        id: 3,
        value: 'three'
      });
      assert.deepEqual(obj.get('uniqueById'), [{
        id: 1,
        value: 'one'
      }, {
        id: 2,
        value: 'two'
      }, {
        id: 3,
        value: 'three'
      }], 'The list does not include a duplicate three');
    };

    _proto6['@test it returns an empty array when computed on a non-array'] = function testItReturnsAnEmptyArrayWhenComputedOnANonArray(assert) {
      var MyObject = _runtime.Object.extend({
        list: null,
        uniq: (0, _computed.uniqBy)('list', 'name')
      });

      var a = MyObject.create({
        list: 'not an array'
      });
      assert.deepEqual(a.get('uniq'), []);
    };

    return _class7;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('computed.intersect',
  /*#__PURE__*/
  function (_AbstractTestCase7) {
    (0, _emberBabel.inheritsLoose)(_class8, _AbstractTestCase7);

    function _class8() {
      return _AbstractTestCase7.apply(this, arguments) || this;
    }

    var _proto7 = _class8.prototype;

    _proto7.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        intersection: (0, _computed.intersect)('array', 'array2', 'array3')
      }).create({
        array: (0, _runtime.A)([1, 2, 3, 4, 5, 6]),
        array2: (0, _runtime.A)([3, 3, 3, 4, 5]),
        array3: (0, _runtime.A)([3, 5, 6, 7, 8])
      });
    };

    _proto7.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto7['@test intersect is readOnly'] = function testIntersectIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('intersection', 1);
      }, /Cannot set read-only property "intersection" on object:/);
    };

    _proto7['@test it has set-intersection semantics'] = function testItHasSetIntersectionSemantics(assert) {
      var array2 = obj.get('array2');
      var array3 = obj.get('array3');
      assert.deepEqual(obj.get('intersection').sort(function (x, y) {
        return x - y;
      }), [3, 5], 'intersection is initially correct');
      array2.shiftObject();
      assert.deepEqual(obj.get('intersection').sort(function (x, y) {
        return x - y;
      }), [3, 5], 'objects are not removed when they are still in all dependent arrays');
      array2.shiftObject();
      assert.deepEqual(obj.get('intersection').sort(function (x, y) {
        return x - y;
      }), [3, 5], 'objects are not removed when they are still in all dependent arrays');
      array2.shiftObject();
      assert.deepEqual(obj.get('intersection'), [5], 'objects are removed once they are gone from all dependent arrays');
      array2.pushObject(1);
      assert.deepEqual(obj.get('intersection'), [5], 'objects are not added as long as they are missing from any dependent array');
      array3.pushObject(1);
      assert.deepEqual(obj.get('intersection').sort(function (x, y) {
        return x - y;
      }), [1, 5], 'objects added once they belong to all dependent arrays');
    };

    return _class8;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('setDiff',
  /*#__PURE__*/
  function (_AbstractTestCase8) {
    (0, _emberBabel.inheritsLoose)(_class9, _AbstractTestCase8);

    function _class9() {
      return _AbstractTestCase8.apply(this, arguments) || this;
    }

    var _proto8 = _class9.prototype;

    _proto8.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        diff: (0, _computed.setDiff)('array', 'array2')
      }).create({
        array: (0, _runtime.A)([1, 2, 3, 4, 5, 6, 7]),
        array2: (0, _runtime.A)([3, 4, 5, 10])
      });
    };

    _proto8.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto8['@test setDiff is readOnly'] = function testSetDiffIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('diff', 1);
      }, /Cannot set read-only property "diff" on object:/);
    };

    _proto8['@test it asserts if given fewer or more than two dependent properties'] = function testItAssertsIfGivenFewerOrMoreThanTwoDependentProperties() {
      expectAssertion(function () {
        _runtime.Object.extend({
          diff: (0, _computed.setDiff)('array')
        }).create({
          array: (0, _runtime.A)([1, 2, 3, 4, 5, 6, 7]),
          array2: (0, _runtime.A)([3, 4, 5])
        });
      }, /\`computed\.setDiff\` requires exactly two dependent arrays/, 'setDiff requires two dependent arrays');
      expectAssertion(function () {
        _runtime.Object.extend({
          diff: (0, _computed.setDiff)('array', 'array2', 'array3')
        }).create({
          array: (0, _runtime.A)([1, 2, 3, 4, 5, 6, 7]),
          array2: (0, _runtime.A)([3, 4, 5]),
          array3: (0, _runtime.A)([7])
        });
      }, /\`computed\.setDiff\` requires exactly two dependent arrays/, 'setDiff requires two dependent arrays');
    };

    _proto8['@test it has set-diff semantics'] = function testItHasSetDiffSemantics(assert) {
      var array1 = obj.get('array');
      var array2 = obj.get('array2');
      assert.deepEqual(obj.get('diff').sort(function (x, y) {
        return x - y;
      }), [1, 2, 6, 7], 'set-diff is initially correct');
      array2.popObject();
      assert.deepEqual(obj.get('diff').sort(function (x, y) {
        return x - y;
      }), [1, 2, 6, 7], 'removing objects from the remove set has no effect if the object is not in the keep set');
      array2.shiftObject();
      assert.deepEqual(obj.get('diff').sort(function (x, y) {
        return x - y;
      }), [1, 2, 3, 6, 7], "removing objects from the remove set adds them if they're in the keep set");
      array1.removeObject(3);
      assert.deepEqual(obj.get('diff').sort(function (x, y) {
        return x - y;
      }), [1, 2, 6, 7], 'removing objects from the keep array removes them from the computed array');
      array1.pushObject(5);
      assert.deepEqual(obj.get('diff').sort(function (x, y) {
        return x - y;
      }), [1, 2, 6, 7], 'objects added to the keep array that are in the remove array are not added to the computed array');
      array1.pushObject(22);
      assert.deepEqual(obj.get('diff').sort(function (x, y) {
        return x - y;
      }), [1, 2, 6, 7, 22], 'objects added to the keep array not in the remove array are added to the computed array');
    };

    return _class9;
  }(_internalTestHelpers.AbstractTestCase));

  var SortWithSortPropertiesTestCase =
  /*#__PURE__*/
  function (_AbstractTestCase9) {
    (0, _emberBabel.inheritsLoose)(SortWithSortPropertiesTestCase, _AbstractTestCase9);

    function SortWithSortPropertiesTestCase() {
      return _AbstractTestCase9.apply(this, arguments) || this;
    }

    var _proto9 = SortWithSortPropertiesTestCase.prototype;

    _proto9.beforeEach = function beforeEach() {
      this.obj = this.buildObject();
    };

    _proto9.afterEach = function afterEach() {
      if (this.obj) {
        this.cleanupObject();
      }
    };

    _proto9['@test sort is readOnly'] = function testSortIsReadOnly(assert) {
      var _this = this;

      assert.throws(function () {
        (0, _metal.set)(_this.obj, 'sortedItems', 1);
      }, /Cannot set read-only property "sortedItems" on object:/);
    };

    _proto9['@test arrays are initially sorted'] = function testArraysAreInitiallySorted(assert) {
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'array is initially sorted');
    };

    _proto9['@test default sort order is correct'] = function testDefaultSortOrderIsCorrect(assert) {
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'array is initially sorted');
    };

    _proto9['@test changing the dependent array updates the sorted array'] = function testChangingTheDependentArrayUpdatesTheSortedArray(assert) {
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _metal.set)(this.obj, 'items', [{
        fname: 'Roose',
        lname: 'Bolton'
      }, {
        fname: 'Theon',
        lname: 'Greyjoy'
      }, {
        fname: 'Ramsey',
        lname: 'Bolton'
      }, {
        fname: 'Stannis',
        lname: 'Baratheon'
      }]);
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Stannis', 'Ramsey', 'Roose', 'Theon'], 'changing dependent array updates sorted array');
    };

    _proto9['@test adding to the dependent array updates the sorted array'] = function testAddingToTheDependentArrayUpdatesTheSortedArray(assert) {
      var items = this.obj.items;
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      items.pushObject({
        fname: 'Tyrion',
        lname: 'Lannister'
      });
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb'], 'Adding to the dependent array updates the sorted array');
    };

    _proto9['@test removing from the dependent array updates the sorted array'] = function testRemovingFromTheDependentArrayUpdatesTheSortedArray(assert) {
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      this.obj.items.popObject();
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Robb'], 'Removing from the dependent array updates the sorted array');
    };

    _proto9['@test distinct items may be sort-equal, although their relative order will not be guaranteed'] = function testDistinctItemsMayBeSortEqualAlthoughTheirRelativeOrderWillNotBeGuaranteed(assert) {
      // We recreate jaime and "Cersei" here only for test stability: we want
      // their guid-ordering to be deterministic
      var jaimeInDisguise = {
        fname: 'Cersei',
        lname: 'Lannister',
        age: 34
      };
      var jaime = {
        fname: 'Jaime',
        lname: 'Lannister',
        age: 34
      };
      var items = this.obj.items;
      items.replace(0, 1, [jaime]);
      items.replace(1, 1, [jaimeInDisguise]);
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _metal.set)(jaimeInDisguise, 'fname', 'Jaime');
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Jaime', 'Jaime', 'Bran', 'Robb'], 'sorted array is updated');
      (0, _metal.set)(jaimeInDisguise, 'fname', 'Cersei');
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'sorted array is updated');
    };

    _proto9['@test guid sort-order fallback with a search proxy is not confused by non-search ObjectProxys'] = function testGuidSortOrderFallbackWithASearchProxyIsNotConfusedByNonSearchObjectProxys(assert) {
      var tyrion = {
        fname: 'Tyrion',
        lname: 'Lannister'
      };

      var tyrionInDisguise = _runtime.ObjectProxy.create({
        fname: 'Yollo',
        lname: '',
        content: tyrion
      });

      var items = this.obj.items;
      items.pushObject(tyrion);
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb']);
      items.pushObject(tyrionInDisguise);
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Yollo', 'Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb']);
    };

    _proto9['@test updating sort properties detaches observers for old sort properties'] = function testUpdatingSortPropertiesDetachesObserversForOldSortProperties(assert) {
      var objectToRemove = this.obj.items[3];
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _metal.set)(this.obj, 'itemSorting', (0, _runtime.A)(['fname:desc']));
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Robb', 'Jaime', 'Cersei', 'Bran'], 'after updating sort properties array is updated');
      this.obj.items.removeObject(objectToRemove);
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Robb', 'Jaime', 'Cersei'], 'after removing item array is updated');
      (0, _metal.set)(objectToRemove, 'lname', 'Updated-Stark');
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Robb', 'Jaime', 'Cersei'], 'after changing removed item array is not updated');
    };

    _proto9['@test sort works if array property is null (non array value) on first evaluation of computed prop'] = function testSortWorksIfArrayPropertyIsNullNonArrayValueOnFirstEvaluationOfComputedProp(assert) {
      (0, _metal.set)(this.obj, 'items', null);
      assert.deepEqual(this.obj.sortedItems, []);
      (0, _metal.set)(this.obj, 'items', (0, _runtime.A)([{
        fname: 'Cersei',
        lname: 'Lanister'
      }]));
      assert.deepEqual(this.obj.sortedItems, [{
        fname: 'Cersei',
        lname: 'Lanister'
      }]);
    };

    _proto9['@test updating sort properties updates the sorted array'] = function testUpdatingSortPropertiesUpdatesTheSortedArray(assert) {
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _metal.set)(this.obj, 'itemSorting', (0, _runtime.A)(['fname:desc']));
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Robb', 'Jaime', 'Cersei', 'Bran'], 'after updating sort properties array is updated');
    };

    _proto9['@test updating sort properties invalidates the sorted array'] = function testUpdatingSortPropertiesInvalidatesTheSortedArray(assert) {
      var sortProps = this.obj.itemSorting;
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      sortProps.clear();
      sortProps.pushObject('fname');
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Bran', 'Cersei', 'Jaime', 'Robb'], 'after updating sort properties array is updated');
    };

    _proto9['@test updating new sort properties invalidates the sorted array'] = function testUpdatingNewSortPropertiesInvalidatesTheSortedArray(assert) {
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _metal.set)(this.obj, 'itemSorting', (0, _runtime.A)(['age:desc', 'fname:asc']));
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Robb', 'Bran'], 'precond - array is correct after item sorting is changed');
      (0, _metal.set)(this.obj.items[1], 'age', 29);
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Jaime', 'Cersei', 'Robb', 'Bran'], 'after updating sort properties array is updated');
    };

    _proto9['@test sort direction defaults to ascending'] = function testSortDirectionDefaultsToAscending(assert) {
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb']);
    };

    _proto9['@test sort direction defaults to ascending (with sort property change)'] = function testSortDirectionDefaultsToAscendingWithSortPropertyChange(assert) {
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _metal.set)(this.obj, 'itemSorting', (0, _runtime.A)(['fname']));
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Bran', 'Cersei', 'Jaime', 'Robb'], 'sort direction defaults to ascending');
    };

    _proto9["@test updating an item's sort properties updates the sorted array"] = function testUpdatingAnItemSSortPropertiesUpdatesTheSortedArray(assert) {
      var tyrionInDisguise = this.obj.items[1];
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _metal.set)(tyrionInDisguise, 'fname', 'Tyrion');
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Jaime', 'Tyrion', 'Bran', 'Robb'], "updating an item's sort properties updates the sorted array");
    };

    _proto9["@test updating several of an item's sort properties updated the sorted array"] = function testUpdatingSeveralOfAnItemSSortPropertiesUpdatedTheSortedArray(assert) {
      var sansaInDisguise = this.obj.items[1];
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _metal.setProperties)(sansaInDisguise, {
        fname: 'Sansa',
        lname: 'Stark'
      });
      assert.deepEqual(this.obj.sortedItems.mapBy('fname'), ['Jaime', 'Bran', 'Robb', 'Sansa'], "updating an item's sort properties updates the sorted array");
    };

    _proto9["@test updating an item's sort properties does not error when binary search does a self compare (#3273)"] = function testUpdatingAnItemSSortPropertiesDoesNotErrorWhenBinarySearchDoesASelfCompare3273(assert) {
      var jaime = {
        name: 'Jaime',
        status: 1
      };
      var cersei = {
        name: 'Cersei',
        status: 2
      };
      this.cleanupObject();
      this.obj = this.buildObject([jaime, cersei], ['status']);
      assert.deepEqual(this.obj.sortedItems, [jaime, cersei], 'precond - array is initially sorted');
      (0, _metal.set)(cersei, 'status', 3);
      assert.deepEqual(this.obj.sortedItems, [jaime, cersei], 'array is sorted correctly');
      (0, _metal.set)(cersei, 'status', 2);
      assert.deepEqual(this.obj.sortedItems, [jaime, cersei], 'array is sorted correctly');
    };

    _proto9['@test array should not be sorted if sort properties array is empty'] = function testArrayShouldNotBeSortedIfSortPropertiesArrayIsEmpty(assert) {
      this.cleanupObject(); // This bug only manifests when array.sort(() => 0) is not equal to array.
      // In order for this to happen, the browser must use an unstable sort and the
      // array must be sufficient large. On Chrome, 12 items is currently sufficient.

      this.obj = this.buildObject((0, _runtime.A)([6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5]), []);
      assert.deepEqual(this.obj.sortedItems, [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5], 'array is not changed');
    };

    _proto9['@test array should update if items to be sorted is replaced when sort properties array is empty'] = function testArrayShouldUpdateIfItemsToBeSortedIsReplacedWhenSortPropertiesArrayIsEmpty(assert) {
      this.cleanupObject();
      this.obj = this.buildObject((0, _runtime.A)([6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5]), (0, _runtime.A)([]));
      assert.deepEqual(this.obj.sortedItems, [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5], 'array is not changed');
      (0, _metal.set)(this.obj, 'items', (0, _runtime.A)([5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4]));
      assert.deepEqual(this.obj.sortedItems, [5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4], 'array was updated');
    };

    _proto9['@test array should update if items to be sorted is mutated when sort properties array is empty'] = function testArrayShouldUpdateIfItemsToBeSortedIsMutatedWhenSortPropertiesArrayIsEmpty(assert) {
      this.cleanupObject();
      this.obj = this.buildObject((0, _runtime.A)([6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5]), (0, _runtime.A)([]));
      assert.deepEqual(this.obj.sortedItems, [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5], 'array is not changed');
      this.obj.items.pushObject(12);
      assert.deepEqual(this.obj.sortedItems, [6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5, 12], 'array was updated');
    };

    _proto9['@test array observers do not leak'] = function testArrayObserversDoNotLeak(assert) {
      var daria = {
        name: 'Daria'
      };
      var jane = {
        name: 'Jane'
      };
      var sisters = [jane, daria];
      var sortProps = (0, _runtime.A)(['name']);
      this.cleanupObject();
      this.obj = this.buildObject(sisters, sortProps);
      this.obj.sortedItems;
      this.cleanupObject();

      try {
        sortProps.pushObject({
          name: 'Anna'
        });
        assert.ok(true);
      } catch (e) {
        assert.ok(false, e);
      }
    };

    _proto9['@test property paths in sort properties update the sorted array'] = function testPropertyPathsInSortPropertiesUpdateTheSortedArray(assert) {
      var jaime = {
        relatedObj: {
          status: 1,
          firstName: 'Jaime',
          lastName: 'Lannister'
        }
      };
      var cersei = {
        relatedObj: {
          status: 2,
          firstName: 'Cersei',
          lastName: 'Lannister'
        }
      };

      var sansa = _runtime.Object.create({
        relatedObj: {
          status: 3,
          firstName: 'Sansa',
          lastName: 'Stark'
        }
      });

      this.cleanupObject();
      this.obj = this.buildObject([jaime, cersei, sansa], ['relatedObj.status']);
      assert.deepEqual(this.obj.sortedItems, [jaime, cersei, sansa], 'precond - array is initially sorted');
      (0, _metal.set)(cersei, 'status', 3);
      assert.deepEqual(this.obj.sortedItems, [jaime, cersei, sansa], 'array is sorted correctly');
      (0, _metal.set)(cersei, 'status', 1);
      assert.deepEqual(this.obj.sortedItems, [jaime, cersei, sansa], 'array is sorted correctly');
      sansa.set('status', 1);
      assert.deepEqual(this.obj.sortedItems, [jaime, cersei, sansa], 'array is sorted correctly');
      (0, _metal.set)(this.obj, 'itemSorting', ['relatedObj.firstName']);
      assert.deepEqual(this.obj.sortedItems, [cersei, jaime, sansa], 'array is sorted correctly');
    };

    _proto9['@test if the dependentKey is neither an array nor object, it will return an empty array'] = function testIfTheDependentKeyIsNeitherAnArrayNorObjectItWillReturnAnEmptyArray(assert) {
      (0, _metal.set)(this.obj, 'items', null);
      assert.ok((0, _runtime.isArray)(this.obj.sortedItems), 'returns an empty arrays');
      (0, _metal.set)(this.obj, 'array', undefined);
      assert.ok((0, _runtime.isArray)(this.obj.sortedItems), 'returns an empty arrays');
      (0, _metal.set)(this.obj, 'array', 'not an array');
      assert.ok((0, _runtime.isArray)(this.obj.sortedItems), 'returns an empty arrays');
    };

    return SortWithSortPropertiesTestCase;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _internalTestHelpers.moduleFor)('sort - sortProperties - Ember.Object',
  /*#__PURE__*/
  function (_SortWithSortProperti) {
    (0, _emberBabel.inheritsLoose)(_class10, _SortWithSortProperti);

    function _class10() {
      return _SortWithSortProperti.apply(this, arguments) || this;
    }

    var _proto10 = _class10.prototype;

    _proto10.buildObject = function buildObject(_items, _itemSorting) {
      var items = _items || (0, _runtime.A)([{
        fname: 'Jaime',
        lname: 'Lannister',
        age: 34
      }, {
        fname: 'Cersei',
        lname: 'Lannister',
        age: 34
      }, {
        fname: 'Robb',
        lname: 'Stark',
        age: 16
      }, {
        fname: 'Bran',
        lname: 'Stark',
        age: 8
      }]);

      var itemSorting = _itemSorting || (0, _runtime.A)(['lname', 'fname']);

      return _runtime.Object.extend({
        sortedItems: (0, _computed.sort)('items', 'itemSorting')
      }).create({
        itemSorting: itemSorting,
        items: items
      });
    };

    _proto10.cleanupObject = function cleanupObject() {
      (0, _runloop.run)(this.obj, 'destroy');
    };

    return _class10;
  }(SortWithSortPropertiesTestCase));

  if (true
  /* EMBER_NATIVE_DECORATOR_SUPPORT */
  ) {
      (0, _internalTestHelpers.moduleFor)('sort - sortProperties - Native Class',
      /*#__PURE__*/
      function (_SortWithSortProperti2) {
        (0, _emberBabel.inheritsLoose)(_class11, _SortWithSortProperti2);

        function _class11() {
          return _SortWithSortProperti2.apply(this, arguments) || this;
        }

        var _proto11 = _class11.prototype;

        _proto11.buildObject = function buildObject(_items, _itemSorting) {
          var _dec, _class, _descriptor, _temp;

          var items = _items || (0, _runtime.A)([{
            fname: 'Jaime',
            lname: 'Lannister',
            age: 34
          }, {
            fname: 'Cersei',
            lname: 'Lannister',
            age: 34
          }, {
            fname: 'Robb',
            lname: 'Stark',
            age: 16
          }, {
            fname: 'Bran',
            lname: 'Stark',
            age: 8
          }]);

          var itemSorting = _itemSorting || (0, _runtime.A)(['lname', 'fname']);

          return new (_dec = (0, _computed.sort)('items', 'itemSorting'), (_class = (_temp = function _class() {
            this.items = items;
            this.itemSorting = itemSorting;

            _initializerDefineProperty(this, "sortedItems", _descriptor, this);
          }, _temp), _descriptor = _applyDecoratedDescriptor(_class.prototype, "sortedItems", [_dec], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: null
          }), _class))();
        };

        _proto11.cleanupObject = function cleanupObject() {};

        return _class11;
      }(SortWithSortPropertiesTestCase));
    }

  function sortByLnameFname(a, b) {
    var lna = (0, _metal.get)(a, 'lname');
    var lnb = (0, _metal.get)(b, 'lname');

    if (lna !== lnb) {
      return lna > lnb ? 1 : -1;
    }

    return sortByFnameAsc(a, b);
  }

  function sortByFnameAsc(a, b) {
    var fna = (0, _metal.get)(a, 'fname');
    var fnb = (0, _metal.get)(b, 'fname');

    if (fna === fnb) {
      return 0;
    }

    return fna > fnb ? 1 : -1;
  }

  (0, _internalTestHelpers.moduleFor)('sort - sort function',
  /*#__PURE__*/
  function (_AbstractTestCase10) {
    (0, _emberBabel.inheritsLoose)(_class12, _AbstractTestCase10);

    function _class12() {
      return _AbstractTestCase10.apply(this, arguments) || this;
    }

    var _proto12 = _class12.prototype;

    _proto12.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        sortedItems: (0, _computed.sort)('items.@each.fname', sortByLnameFname)
      }).create({
        items: (0, _runtime.A)([{
          fname: 'Jaime',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Cersei',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Robb',
          lname: 'Stark',
          age: 16
        }, {
          fname: 'Bran',
          lname: 'Stark',
          age: 8
        }])
      });
    };

    _proto12.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto12['@test sort has correct `this`'] = function testSortHasCorrectThis(assert) {
      var obj = _runtime.Object.extend({
        sortedItems: (0, _computed.sort)('items.@each.fname', function (a, b) {
          assert.equal(this, obj, 'expected the object to be `this`');
          return this.sortByLastName(a, b);
        }),
        sortByLastName: function (a, b) {
          return sortByFnameAsc(a, b);
        }
      }).create({
        items: (0, _runtime.A)([{
          fname: 'Jaime',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Cersei',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Robb',
          lname: 'Stark',
          age: 16
        }, {
          fname: 'Bran',
          lname: 'Stark',
          age: 8
        }])
      });

      obj.get('sortedItems');
    };

    _proto12['@test sort (with function) is readOnly'] = function testSortWithFunctionIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('sortedItems', 1);
      }, /Cannot set read-only property "sortedItems" on object:/);
    };

    _proto12['@test arrays are initially sorted'] = function testArraysAreInitiallySorted(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'array is initially sorted');
    };

    _proto12['@test default sort order is correct'] = function testDefaultSortOrderIsCorrect(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'array is initially sorted');
    };

    _proto12['@test changing the dependent array updates the sorted array'] = function testChangingTheDependentArrayUpdatesTheSortedArray(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      obj.set('items', [{
        fname: 'Roose',
        lname: 'Bolton'
      }, {
        fname: 'Theon',
        lname: 'Greyjoy'
      }, {
        fname: 'Ramsey',
        lname: 'Bolton'
      }, {
        fname: 'Stannis',
        lname: 'Baratheon'
      }]);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Stannis', 'Ramsey', 'Roose', 'Theon'], 'changing dependent array updates sorted array');
    };

    _proto12['@test adding to the dependent array updates the sorted array'] = function testAddingToTheDependentArrayUpdatesTheSortedArray(assert) {
      var items = obj.get('items');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      items.pushObject({
        fname: 'Tyrion',
        lname: 'Lannister'
      });
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb'], 'Adding to the dependent array updates the sorted array');
    };

    _proto12['@test removing from the dependent array updates the sorted array'] = function testRemovingFromTheDependentArrayUpdatesTheSortedArray(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      obj.get('items').popObject();
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Robb'], 'Removing from the dependent array updates the sorted array');
    };

    _proto12['@test distinct items may be sort-equal, although their relative order will not be guaranteed'] = function testDistinctItemsMayBeSortEqualAlthoughTheirRelativeOrderWillNotBeGuaranteed(assert) {
      // We recreate jaime and "Cersei" here only for test stability: we want
      // their guid-ordering to be deterministic
      var jaimeInDisguise = {
        fname: 'Cersei',
        lname: 'Lannister',
        age: 34
      };
      var jaime = {
        fname: 'Jaime',
        lname: 'Lannister',
        age: 34
      };
      var items = obj.get('items');
      items.replace(0, 1, [jaime]);
      items.replace(1, 1, [jaimeInDisguise]);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _metal.set)(jaimeInDisguise, 'fname', 'Jaime');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Jaime', 'Bran', 'Robb'], 'sorted array is updated');
      (0, _metal.set)(jaimeInDisguise, 'fname', 'Cersei');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'sorted array is updated');
    };

    _proto12['@test guid sort-order fallback with a search proxy is not confused by non-search ObjectProxys'] = function testGuidSortOrderFallbackWithASearchProxyIsNotConfusedByNonSearchObjectProxys(assert) {
      var tyrion = {
        fname: 'Tyrion',
        lname: 'Lannister'
      };

      var tyrionInDisguise = _runtime.ObjectProxy.create({
        fname: 'Yollo',
        lname: '',
        content: tyrion
      });

      var items = obj.get('items');
      items.pushObject(tyrion);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb']);
      items.pushObject(tyrionInDisguise);
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Yollo', 'Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb']);
    };

    _proto12['@test changing item properties specified via @each triggers a resort of the modified item'] = function testChangingItemPropertiesSpecifiedViaEachTriggersAResortOfTheModifiedItem(assert) {
      var items = (0, _metal.get)(obj, 'items');
      var tyrionInDisguise = items[1];
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
      (0, _metal.set)(tyrionInDisguise, 'fname', 'Tyrion');
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Tyrion', 'Bran', 'Robb'], 'updating a specified property on an item resorts it');
    };

    _proto12['@test changing item properties not specified via @each does not trigger a resort'] = function testChangingItemPropertiesNotSpecifiedViaEachDoesNotTriggerAResort(assert) {
      if (!false
      /* EMBER_METAL_TRACKED_PROPERTIES */
      ) {
          var items = obj.get('items');
          var cersei = items[1];
          assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');
          (0, _metal.set)(cersei, 'lname', 'Stark'); // plot twist! (possibly not canon)
          // The array has become unsorted.  If your sort function is sensitive to
          // properties, they *must* be specified as dependent item property keys or
          // we'll be doing binary searches on unsorted arrays.

          assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'updating an unspecified property on an item does not resort it');
        } else {
        assert.expect(0);
      }
    };

    _proto12['@test sort updates if additional dependent keys are present'] = function testSortUpdatesIfAdditionalDependentKeysArePresent(assert) {
      obj = _runtime.Object.extend({
        sortedItems: (0, _computed.sort)('items', ['sortFunction'], function () {
          return this.sortFunction.apply(this, arguments);
        })
      }).create({
        sortFunction: sortByLnameFname,
        items: (0, _runtime.A)([{
          fname: 'Jaime',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Cersei',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Robb',
          lname: 'Stark',
          age: 16
        }, {
          fname: 'Bran',
          lname: 'Stark',
          age: 8
        }])
      });
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'array is initially sorted');
      obj.set('sortFunction', function (a, b) {
        if (a.age > b.age) {
          return -1;
        } else if (a.age < b.age) {
          return 1;
        }

        return 0;
      });
      assert.deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Cersei', 'Robb', 'Bran'], 'array is updated when dependent key changes');
    };

    _proto12['@test it throws on bad inputs'] = function testItThrowsOnBadInputs() {
      expectAssertion(function () {
        (0, _computed.sort)('foo', 'bar', 'baz');
      }, /`computed.sort` can either be used with an array of sort properties or with a sort function/);
      expectAssertion(function () {
        (0, _computed.sort)('foo', ['bar'], 'baz');
      }, /`computed.sort` can either be used with an array of sort properties or with a sort function/);
      expectAssertion(function () {
        (0, _computed.sort)('foo', 'bar', function () {});
      }, /`computed.sort` can either be used with an array of sort properties or with a sort function/);
      expectAssertion(function () {
        (0, _computed.sort)('foo', ['bar'], function () {}, 'baz');
      }, /`computed.sort` can either be used with an array of sort properties or with a sort function/);
    };

    return _class12;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('sort - stability',
  /*#__PURE__*/
  function (_AbstractTestCase11) {
    (0, _emberBabel.inheritsLoose)(_class13, _AbstractTestCase11);

    function _class13() {
      return _AbstractTestCase11.apply(this, arguments) || this;
    }

    var _proto13 = _class13.prototype;

    _proto13.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        sortProps: ['count', 'name'],
        sortedItems: (0, _computed.sort)('items', 'sortProps')
      }).create({
        items: [{
          name: 'A',
          count: 1,
          thing: 4
        }, {
          name: 'B',
          count: 1,
          thing: 3
        }, {
          name: 'C',
          count: 1,
          thing: 2
        }, {
          name: 'D',
          count: 1,
          thing: 4
        }]
      });
    };

    _proto13.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto13['@test sorts correctly as only one property changes'] = function testSortsCorrectlyAsOnlyOnePropertyChanges(assert) {
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'initial');
      (0, _metal.set)(obj.get('items')[3], 'count', 2);
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'final');
    };

    return _class13;
  }(_internalTestHelpers.AbstractTestCase));
  var klass;
  (0, _internalTestHelpers.moduleFor)('sort - concurrency',
  /*#__PURE__*/
  function (_AbstractTestCase12) {
    (0, _emberBabel.inheritsLoose)(_class14, _AbstractTestCase12);

    function _class14() {
      return _AbstractTestCase12.apply(this, arguments) || this;
    }

    var _proto14 = _class14.prototype;

    _proto14.beforeEach = function beforeEach() {
      klass = _runtime.Object.extend({
        sortProps: ['count'],
        sortedItems: (0, _computed.sort)('items', 'sortProps'),
        customSortedItems: (0, _computed.sort)('items.@each.count', function (a, b) {
          return a.count - b.count;
        })
      });
      obj = klass.create({
        items: (0, _runtime.A)([{
          name: 'A',
          count: 1,
          thing: 4,
          id: 1
        }, {
          name: 'B',
          count: 2,
          thing: 3,
          id: 2
        }, {
          name: 'C',
          count: 3,
          thing: 2,
          id: 3
        }, {
          name: 'D',
          count: 4,
          thing: 1,
          id: 4
        }])
      });
    };

    _proto14.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto14['@test sorts correctly after mutation to the sort properties'] = function testSortsCorrectlyAfterMutationToTheSortProperties(assert) {
      var sorted = obj.get('sortedItems');
      assert.deepEqual(sorted.mapBy('name'), ['A', 'B', 'C', 'D'], 'initial');
      (0, _metal.set)(obj.get('items')[1], 'count', 5);
      (0, _metal.set)(obj.get('items')[2], 'count', 6);
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'final');
    };

    _proto14['@test sort correctly after mutation to the sort'] = function testSortCorrectlyAfterMutationToTheSort(assert) {
      assert.deepEqual(obj.get('customSortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'initial');
      (0, _metal.set)(obj.get('items')[1], 'count', 5);
      (0, _metal.set)(obj.get('items')[2], 'count', 6);
      assert.deepEqual(obj.get('customSortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'final');
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'final');
    };

    _proto14['@test sort correctly on multiple instances of the same class'] = function testSortCorrectlyOnMultipleInstancesOfTheSameClass(assert) {
      var obj2 = klass.create({
        items: (0, _runtime.A)([{
          name: 'W',
          count: 23,
          thing: 4
        }, {
          name: 'X',
          count: 24,
          thing: 3
        }, {
          name: 'Y',
          count: 25,
          thing: 2
        }, {
          name: 'Z',
          count: 26,
          thing: 1
        }])
      });
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['W', 'X', 'Y', 'Z'], 'initial');
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'initial');
      (0, _metal.set)(obj.get('items')[1], 'count', 5);
      (0, _metal.set)(obj.get('items')[2], 'count', 6);
      (0, _metal.set)(obj2.get('items')[1], 'count', 27);
      (0, _metal.set)(obj2.get('items')[2], 'count', 28);
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'final');
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['W', 'Z', 'X', 'Y'], 'final');
      obj.set('sortProps', ['thing']);
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['D', 'C', 'B', 'A'], 'final');
      obj2.notifyPropertyChange('sortedItems'); // invalidate to flush, to get DK refreshed

      obj2.get('sortedItems'); // flush to get updated DK

      obj2.set('items.firstObject.count', 9999);
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['Z', 'X', 'Y', 'W'], 'final');
    };

    _proto14['@test sort correctly when multiple sorts are chained on the same instance of a class'] = function testSortCorrectlyWhenMultipleSortsAreChainedOnTheSameInstanceOfAClass(assert) {
      var obj2 = klass.extend({
        items: (0, _metal.computed)('sibling.sortedItems.[]', function () {
          return this.get('sibling.sortedItems');
        }),
        asdf: (0, _metal.observer)('sibling.sortedItems.[]', function () {
          this.get('sibling.sortedItems');
        })
      }).create({
        sibling: obj
      });
      /*
                                                                           
                                             sortedProps                              sortedProps2
                                                                           
                                                                                              
                                                                                 
                                                           CP (sort)        
                                                                                 
                                                                                              
                                                                
                                                                            
         items     items.@each.count  sortedItems  items.@each.count  sortedItems2
                                                                            
                                                                
      */

      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'obj.sortedItems.name should be sorted alpha');
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'obj2.sortedItems.name should be sorted alpha');
      (0, _metal.set)(obj.get('items')[1], 'count', 5);
      (0, _metal.set)(obj.get('items')[2], 'count', 6);
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'obj.sortedItems.name should now have changed');
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'obj2.sortedItems.name should still mirror sortedItems2');
      obj.set('sortProps', ['thing']);
      obj2.set('sortProps', ['id']);
      assert.deepEqual(obj2.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'we now sort obj2 by id, so we expect a b c d');
      assert.deepEqual(obj.get('sortedItems').mapBy('name'), ['D', 'C', 'B', 'A'], 'we now sort obj by thing');
    };

    return _class14;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('max',
  /*#__PURE__*/
  function (_AbstractTestCase13) {
    (0, _emberBabel.inheritsLoose)(_class15, _AbstractTestCase13);

    function _class15() {
      return _AbstractTestCase13.apply(this, arguments) || this;
    }

    var _proto15 = _class15.prototype;

    _proto15.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        max: (0, _computed.max)('items')
      }).create({
        items: (0, _runtime.A)([1, 2, 3])
      });
    };

    _proto15.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto15['@test max is readOnly'] = function testMaxIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('max', 1);
      }, /Cannot set read-only property "max" on object:/);
    };

    _proto15['@test max tracks the max number as objects are added'] = function testMaxTracksTheMaxNumberAsObjectsAreAdded(assert) {
      assert.equal(obj.get('max'), 3, 'precond - max is initially correct');
      var items = obj.get('items');
      items.pushObject(5);
      assert.equal(obj.get('max'), 5, 'max updates when a larger number is added');
      items.pushObject(2);
      assert.equal(obj.get('max'), 5, 'max does not update when a smaller number is added');
    };

    _proto15['@test max recomputes when the current max is removed'] = function testMaxRecomputesWhenTheCurrentMaxIsRemoved(assert) {
      assert.equal(obj.get('max'), 3, 'precond - max is initially correct');
      obj.get('items').removeObject(2);
      assert.equal(obj.get('max'), 3, 'max is unchanged when a non-max item is removed');
      obj.get('items').removeObject(3);
      assert.equal(obj.get('max'), 1, 'max is recomputed when the current max is removed');
    };

    return _class15;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('min',
  /*#__PURE__*/
  function (_AbstractTestCase14) {
    (0, _emberBabel.inheritsLoose)(_class16, _AbstractTestCase14);

    function _class16() {
      return _AbstractTestCase14.apply(this, arguments) || this;
    }

    var _proto16 = _class16.prototype;

    _proto16.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        min: (0, _computed.min)('items')
      }).create({
        items: (0, _runtime.A)([1, 2, 3])
      });
    };

    _proto16.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto16['@test min is readOnly'] = function testMinIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('min', 1);
      }, /Cannot set read-only property "min" on object:/);
    };

    _proto16['@test min tracks the min number as objects are added'] = function testMinTracksTheMinNumberAsObjectsAreAdded(assert) {
      assert.equal(obj.get('min'), 1, 'precond - min is initially correct');
      obj.get('items').pushObject(-2);
      assert.equal(obj.get('min'), -2, 'min updates when a smaller number is added');
      obj.get('items').pushObject(2);
      assert.equal(obj.get('min'), -2, 'min does not update when a larger number is added');
    };

    _proto16['@test min recomputes when the current min is removed'] = function testMinRecomputesWhenTheCurrentMinIsRemoved(assert) {
      var items = obj.get('items');
      assert.equal(obj.get('min'), 1, 'precond - min is initially correct');
      items.removeObject(2);
      assert.equal(obj.get('min'), 1, 'min is unchanged when a non-min item is removed');
      items.removeObject(1);
      assert.equal(obj.get('min'), 3, 'min is recomputed when the current min is removed');
    };

    return _class16;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('Ember.arrayComputed - mixed sugar',
  /*#__PURE__*/
  function (_AbstractTestCase15) {
    (0, _emberBabel.inheritsLoose)(_class17, _AbstractTestCase15);

    function _class17() {
      return _AbstractTestCase15.apply(this, arguments) || this;
    }

    var _proto17 = _class17.prototype;

    _proto17.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        lannisters: (0, _computed.filterBy)('items', 'lname', 'Lannister'),
        lannisterSorting: (0, _runtime.A)(['fname']),
        sortedLannisters: (0, _computed.sort)('lannisters', 'lannisterSorting'),
        starks: (0, _computed.filterBy)('items', 'lname', 'Stark'),
        starkAges: (0, _computed.mapBy)('starks', 'age'),
        oldestStarkAge: (0, _computed.max)('starkAges')
      }).create({
        items: (0, _runtime.A)([{
          fname: 'Jaime',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Cersei',
          lname: 'Lannister',
          age: 34
        }, {
          fname: 'Robb',
          lname: 'Stark',
          age: 16
        }, {
          fname: 'Bran',
          lname: 'Stark',
          age: 8
        }])
      });
    };

    _proto17.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto17['@test filtering and sorting can be combined'] = function testFilteringAndSortingCanBeCombined(assert) {
      var items = obj.get('items');
      assert.deepEqual(obj.get('sortedLannisters').mapBy('fname'), ['Cersei', 'Jaime'], 'precond - array is initially filtered and sorted');
      items.pushObject({
        fname: 'Tywin',
        lname: 'Lannister'
      });
      items.pushObject({
        fname: 'Lyanna',
        lname: 'Stark'
      });
      items.pushObject({
        fname: 'Gerion',
        lname: 'Lannister'
      });
      assert.deepEqual(obj.get('sortedLannisters').mapBy('fname'), ['Cersei', 'Gerion', 'Jaime', 'Tywin'], 'updates propagate to array');
    };

    _proto17['@test filtering, sorting and reduce (max) can be combined'] = function testFilteringSortingAndReduceMaxCanBeCombined(assert) {
      var items = obj.get('items');
      assert.equal(16, obj.get('oldestStarkAge'), 'precond - end of chain is initially correct');
      items.pushObject({
        fname: 'Rickon',
        lname: 'Stark',
        age: 5
      });
      assert.equal(16, obj.get('oldestStarkAge'), 'chain is updated correctly');
      items.pushObject({
        fname: 'Eddard',
        lname: 'Stark',
        age: 35
      });
      assert.equal(35, obj.get('oldestStarkAge'), 'chain is updated correctly');
    };

    return _class17;
  }(_internalTestHelpers.AbstractTestCase));

  function todo(name, priority) {
    return _runtime.Object.create({
      name: name,
      priority: priority
    });
  }

  function priorityComparator(todoA, todoB) {
    var pa = parseInt((0, _metal.get)(todoA, 'priority'), 10);
    var pb = parseInt((0, _metal.get)(todoB, 'priority'), 10);
    return pa - pb;
  }

  function evenPriorities(todo) {
    var p = parseInt((0, _metal.get)(todo, 'priority'), 10);
    return p % 2 === 0;
  }

  (0, _internalTestHelpers.moduleFor)('Ember.arrayComputed - chains',
  /*#__PURE__*/
  function (_AbstractTestCase16) {
    (0, _emberBabel.inheritsLoose)(_class18, _AbstractTestCase16);

    function _class18() {
      return _AbstractTestCase16.apply(this, arguments) || this;
    }

    var _proto18 = _class18.prototype;

    _proto18.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        sorted: (0, _computed.sort)('todos.@each.priority', priorityComparator),
        filtered: (0, _computed.filter)('sorted.@each.priority', evenPriorities)
      }).create({
        todos: (0, _runtime.A)([todo('E', 4), todo('D', 3), todo('C', 2), todo('B', 1), todo('A', 0)])
      });
    };

    _proto18.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto18['@test it can filter and sort when both depend on the same item property'] = function testItCanFilterAndSortWhenBothDependOnTheSameItemProperty(assert) {
      assert.deepEqual(obj.get('todos').mapBy('name'), ['E', 'D', 'C', 'B', 'A'], 'precond - todos initially correct');
      assert.deepEqual(obj.get('sorted').mapBy('name'), ['A', 'B', 'C', 'D', 'E'], 'precond - sorted initially correct');
      assert.deepEqual(obj.get('filtered').mapBy('name'), ['A', 'C', 'E'], 'precond - filtered initially correct');
      (0, _metal.set)(obj.get('todos')[1], 'priority', 6);
      assert.deepEqual(obj.get('todos').mapBy('name'), ['E', 'D', 'C', 'B', 'A'], 'precond - todos remain correct');
      assert.deepEqual(obj.get('sorted').mapBy('name'), ['A', 'B', 'C', 'E', 'D'], 'precond - sorted updated correctly');
      assert.deepEqual(obj.get('filtered').mapBy('name'), ['A', 'C', 'E', 'D'], 'filtered updated correctly');
    };

    return _class18;
  }(_internalTestHelpers.AbstractTestCase));
  var userFnCalls;
  (0, _internalTestHelpers.moduleFor)('Chaining array and reduced CPs',
  /*#__PURE__*/
  function (_AbstractTestCase17) {
    (0, _emberBabel.inheritsLoose)(_class19, _AbstractTestCase17);

    function _class19() {
      return _AbstractTestCase17.apply(this, arguments) || this;
    }

    var _proto19 = _class19.prototype;

    _proto19.beforeEach = function beforeEach() {
      userFnCalls = 0;
      obj = _runtime.Object.extend({
        mapped: (0, _computed.mapBy)('array', 'v'),
        max: (0, _computed.max)('mapped'),
        maxDidChange: (0, _metal.observer)('max', function () {
          return userFnCalls++;
        })
      }).create({
        array: (0, _runtime.A)([{
          v: 1
        }, {
          v: 3
        }, {
          v: 2
        }, {
          v: 1
        }])
      });
    };

    _proto19.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto19['@test it computes interdependent array computed properties'] =
    /*#__PURE__*/
    function () {
      var _testItComputesInterdependentArrayComputedProperties = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        var calls;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              assert.equal(obj.get('max'), 3, 'sanity - it properly computes the maximum value');
              calls = 0;
              (0, _metal.addObserver)(obj, 'max', function () {
                return calls++;
              });
              obj.get('array').pushObject({
                v: 5
              });
              _context2.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              assert.equal(obj.get('max'), 5, 'maximum value is updated correctly');
              assert.equal(userFnCalls, 1, 'object defined observers fire');
              assert.equal(calls, 1, 'runtime created observers fire');

            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));

      function testItComputesInterdependentArrayComputedProperties(_x2) {
        return _testItComputesInterdependentArrayComputedProperties.apply(this, arguments);
      }

      return testItComputesInterdependentArrayComputedProperties;
    }();

    return _class19;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('sum',
  /*#__PURE__*/
  function (_AbstractTestCase18) {
    (0, _emberBabel.inheritsLoose)(_class20, _AbstractTestCase18);

    function _class20() {
      return _AbstractTestCase18.apply(this, arguments) || this;
    }

    var _proto20 = _class20.prototype;

    _proto20.beforeEach = function beforeEach() {
      obj = _runtime.Object.extend({
        total: (0, _computed.sum)('array')
      }).create({
        array: (0, _runtime.A)([1, 2, 3])
      });
    };

    _proto20.afterEach = function afterEach() {
      (0, _runloop.run)(obj, 'destroy');
    };

    _proto20['@test sum is readOnly'] = function testSumIsReadOnly(assert) {
      assert.throws(function () {
        obj.set('total', 1);
      }, /Cannot set read-only property "total" on object:/);
    };

    _proto20['@test sums the values in the dependentKey'] = function testSumsTheValuesInTheDependentKey(assert) {
      assert.equal(obj.get('total'), 6, 'sums the values');
    };

    _proto20['@test if the dependentKey is neither an array nor object, it will return `0`'] = function testIfTheDependentKeyIsNeitherAnArrayNorObjectItWillReturn0(assert) {
      (0, _metal.set)(obj, 'array', null);
      assert.equal((0, _metal.get)(obj, 'total'), 0, 'returns 0');
      (0, _metal.set)(obj, 'array', undefined);
      assert.equal((0, _metal.get)(obj, 'total'), 0, 'returns 0');
      (0, _metal.set)(obj, 'array', 'not an array');
      assert.equal((0, _metal.get)(obj, 'total'), 0, 'returns 0');
    };

    _proto20['@test updates when array is modified'] = function testUpdatesWhenArrayIsModified(assert) {
      obj.get('array').pushObject(1);
      assert.equal(obj.get('total'), 7, 'recomputed when elements are added');
      obj.get('array').popObject();
      assert.equal(obj.get('total'), 6, 'recomputes when elements are removed');
    };

    return _class20;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('collect',
  /*#__PURE__*/
  function (_AbstractTestCase19) {
    (0, _emberBabel.inheritsLoose)(_class21, _AbstractTestCase19);

    function _class21() {
      return _AbstractTestCase19.apply(this, arguments) || this;
    }

    var _proto21 = _class21.prototype;

    _proto21['@test works'] = function testWorks(assert) {
      var obj = {
        one: 'foo',
        two: 'bar',
        three: null
      };
      (0, _metal.defineProperty)(obj, 'all', (0, _computed.collect)('one', 'two', 'three', 'four'));
      assert.deepEqual((0, _metal.get)(obj, 'all'), ['foo', 'bar', null, null], 'have all of them');
      (0, _metal.set)(obj, 'four', true);
      assert.deepEqual((0, _metal.get)(obj, 'all'), ['foo', 'bar', null, true], 'have all of them');
      var a = [];
      (0, _metal.set)(obj, 'one', 0);
      (0, _metal.set)(obj, 'three', a);
      assert.deepEqual((0, _metal.get)(obj, 'all'), [0, 'bar', a, true], 'have all of them');
    };

    return _class21;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/polyfills/tests/assign_test", ["ember-babel", "@ember/polyfills", "internal-test-helpers"], function (_emberBabel, _polyfills, _internalTestHelpers) {
  "use strict";

  var AssignTests =
  /*#__PURE__*/
  function (_TestCase) {
    (0, _emberBabel.inheritsLoose)(AssignTests, _TestCase);

    function AssignTests() {
      return _TestCase.apply(this, arguments) || this;
    }

    var _proto = AssignTests.prototype;

    _proto['@test merging objects'] = function testMergingObjects(assert) {
      var trgt = {
        a: 1
      };
      var src1 = {
        b: 2
      };
      var src2 = {
        c: 3
      };
      this.assign(trgt, src1, src2);
      assert.deepEqual(trgt, {
        a: 1,
        b: 2,
        c: 3
      }, 'assign copies values from one or more source objects to a target object');
      assert.deepEqual(src1, {
        b: 2
      }, 'assign does not change source object 1');
      assert.deepEqual(src2, {
        c: 3
      }, 'assign does not change source object 2');
    };

    _proto['@test merging objects with same property'] = function testMergingObjectsWithSameProperty(assert) {
      var trgt = {
        a: 1,
        b: 1
      };
      var src1 = {
        a: 2,
        b: 2
      };
      var src2 = {
        a: 3
      };
      this.assign(trgt, src1, src2);
      assert.deepEqual(trgt, {
        a: 3,
        b: 2
      }, 'properties are overwritten by other objects that have the same properties later in the parameters order');
    };

    _proto['@test null'] = function testNull(assert) {
      var trgt = {
        a: 1
      };
      this.assign(trgt, null);
      assert.deepEqual(trgt, {
        a: 1
      }, 'null as a source parameter is ignored');
    };

    _proto['@test undefined'] = function testUndefined(assert) {
      var trgt = {
        a: 1
      };
      this.assign(trgt, null);
      assert.deepEqual(trgt, {
        a: 1
      }, 'undefined as a source parameter is ignored');
    };

    return AssignTests;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _internalTestHelpers.moduleFor)('Ember.assign (polyfill)',
  /*#__PURE__*/
  function (_AssignTests) {
    (0, _emberBabel.inheritsLoose)(_class, _AssignTests);

    function _class() {
      return _AssignTests.apply(this, arguments) || this;
    }

    var _proto2 = _class.prototype;

    _proto2.assign = function assign() {
      return _polyfills.assignPolyfill.apply(void 0, arguments);
    };

    return _class;
  }(AssignTests));
  (0, _internalTestHelpers.moduleFor)('Ember.assign (maybe not-polyfill ;) )',
  /*#__PURE__*/
  function (_AssignTests2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AssignTests2);

    function _class2() {
      return _AssignTests2.apply(this, arguments) || this;
    }

    var _proto3 = _class2.prototype;

    _proto3.assign = function assign() {
      return _polyfills.assign.apply(void 0, arguments);
    };

    return _class2;
  }(AssignTests));
});
enifed("@ember/polyfills/tests/merge_test", ["ember-babel", "@ember/polyfills", "internal-test-helpers"], function (_emberBabel, _polyfills, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Ember.merge',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test merging objects'] = function testMergingObjects(assert) {
      var src1 = {
        a: 1
      };
      var src2 = {
        b: 2
      };
      expectDeprecation(function () {
        (0, _polyfills.merge)(src1, src2);
      }, 'Use of `merge` has been deprecated. Please use `assign` instead.');
      assert.deepEqual(src1, {
        a: 1,
        b: 2
      }, 'merge copies values from second source object to first object');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/debounce_test", ["ember-babel", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('debounce',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test debounce - with target, with method, without args'] = function testDebounceWithTargetWithMethodWithoutArgs(assert) {
      var done = assert.async();
      var calledWith = [];
      var target = {
        someFunc: function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          calledWith.push(args);
        }
      };
      (0, _runloop.debounce)(target, target.someFunc, 10);
      (0, _runloop.debounce)(target, target.someFunc, 10);
      (0, _runloop.debounce)(target, target.someFunc, 10);
      setTimeout(function () {
        assert.deepEqual(calledWith, [[]], 'someFunc called once with correct arguments');
        done();
      }, 20);
    };

    _proto['@test debounce - with target, with method name, without args'] = function testDebounceWithTargetWithMethodNameWithoutArgs(assert) {
      var done = assert.async();
      var calledWith = [];
      var target = {
        someFunc: function () {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          calledWith.push(args);
        }
      };
      (0, _runloop.debounce)(target, 'someFunc', 10);
      (0, _runloop.debounce)(target, 'someFunc', 10);
      (0, _runloop.debounce)(target, 'someFunc', 10);
      setTimeout(function () {
        assert.deepEqual(calledWith, [[]], 'someFunc called once with correct arguments');
        done();
      }, 20);
    };

    _proto['@test debounce - without target, without args'] = function testDebounceWithoutTargetWithoutArgs(assert) {
      var done = assert.async();
      var calledWith = [];

      function someFunc() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        calledWith.push(args);
      }

      (0, _runloop.debounce)(someFunc, 10);
      (0, _runloop.debounce)(someFunc, 10);
      (0, _runloop.debounce)(someFunc, 10);
      setTimeout(function () {
        assert.deepEqual(calledWith, [[]], 'someFunc called once with correct arguments');
        done();
      }, 20);
    };

    _proto['@test debounce - without target, with args'] = function testDebounceWithoutTargetWithArgs(assert) {
      var done = assert.async();
      var calledWith = [];

      function someFunc() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        calledWith.push(args);
      }

      (0, _runloop.debounce)(someFunc, {
        isFoo: true
      }, 10);
      (0, _runloop.debounce)(someFunc, {
        isBar: true
      }, 10);
      (0, _runloop.debounce)(someFunc, {
        isBaz: true
      }, 10);
      setTimeout(function () {
        assert.deepEqual(calledWith, [[{
          isBaz: true
        }]], 'someFunc called once with correct arguments');
        done();
      }, 20);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/later_test", ["ember-babel", "internal-test-helpers", "@ember/polyfills", "@ember/runloop"], function (_emberBabel, _internalTestHelpers, _polyfills, _runloop) {
  "use strict";

  var originalSetTimeout = window.setTimeout;
  var originalDateValueOf = Date.prototype.valueOf;
  var originalPlatform = _runloop.backburner._platform;

  function wait(callback) {
    var maxWaitCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    originalSetTimeout(function () {
      if (maxWaitCount > 0 && ((0, _runloop.hasScheduledTimers)() || (0, _runloop.getCurrentRunLoop)())) {
        wait(callback, maxWaitCount - 1);
        return;
      }

      callback();
    }, 10);
  } // Synchronous "sleep". This simulates work being done
  // after later was called but before the run loop
  // has flushed. In previous versions, this would have
  // caused the later callback to have run from
  // within the run loop flush, since by the time the
  // run loop has to flush, it would have considered
  // the timer already expired.


  function pauseUntil(time) {
    while (Date.now() < time) {
      /* do nothing - sleeping */
    }
  }

  (0, _internalTestHelpers.moduleFor)('run.later',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _runloop.backburner._platform = originalPlatform;
      window.setTimeout = originalSetTimeout;
      Date.prototype.valueOf = originalDateValueOf;
    };

    _proto['@test should invoke after specified period of time - function only'] = function testShouldInvokeAfterSpecifiedPeriodOfTimeFunctionOnly(assert) {
      var done = assert.async();
      var invoked = false;
      (0, _runloop.run)(function () {
        (0, _runloop.later)(function () {
          return invoked = true;
        }, 100);
      });
      wait(function () {
        assert.equal(invoked, true, 'should have invoked later item');
        done();
      });
    };

    _proto['@test should invoke after specified period of time - target/method'] = function testShouldInvokeAfterSpecifiedPeriodOfTimeTargetMethod(assert) {
      var done = assert.async();
      var obj = {
        invoked: false
      };
      (0, _runloop.run)(function () {
        (0, _runloop.later)(obj, function () {
          this.invoked = true;
        }, 100);
      });
      wait(function () {
        assert.equal(obj.invoked, true, 'should have invoked later item');
        done();
      });
    };

    _proto['@test should invoke after specified period of time - target/method/args'] = function testShouldInvokeAfterSpecifiedPeriodOfTimeTargetMethodArgs(assert) {
      var done = assert.async();
      var obj = {
        invoked: 0
      };
      (0, _runloop.run)(function () {
        (0, _runloop.later)(obj, function (amt) {
          this.invoked += amt;
        }, 10, 100);
      });
      wait(function () {
        assert.equal(obj.invoked, 10, 'should have invoked later item');
        done();
      });
    };

    _proto['@test should always invoke within a separate runloop'] = function testShouldAlwaysInvokeWithinASeparateRunloop(assert) {
      var done = assert.async();
      var obj = {
        invoked: 0
      };
      var firstRunLoop, secondRunLoop;
      (0, _runloop.run)(function () {
        firstRunLoop = (0, _runloop.getCurrentRunLoop)();
        (0, _runloop.later)(obj, function (amt) {
          this.invoked += amt;
          secondRunLoop = (0, _runloop.getCurrentRunLoop)();
        }, 10, 1);
        pauseUntil(Date.now() + 100);
      });
      assert.ok(firstRunLoop, 'first run loop captured');
      assert.ok(!(0, _runloop.getCurrentRunLoop)(), "shouldn't be in a run loop after flush");
      assert.equal(obj.invoked, 0, "shouldn't have invoked later item yet");
      wait(function () {
        assert.equal(obj.invoked, 10, 'should have invoked later item');
        assert.ok(secondRunLoop, 'second run loop took place');
        assert.ok(secondRunLoop !== firstRunLoop, 'two different run loops took place');
        done();
      });
    } // Our current implementation doesn't allow us to correctly enforce this ordering.
    // We should probably implement a queue to provide this guarantee.
    // See https://github.com/emberjs/ember.js/issues/3526 for more information.
    // asyncTest('callback order', function() {
    //   let array = [];
    //   function fn(val) { array.push(val); }
    //   run(function() {
    //     later(this, fn, 4, 5);
    //     later(this, fn, 1, 1);
    //     later(this, fn, 5, 10);
    //     later(this, fn, 2, 3);
    //     later(this, fn, 3, 3);
    //   });
    //   deepEqual(array, []);
    //   wait(function() {
    //     QUnit.start();
    //     deepEqual(array, [1,2,3,4,5], 'callbacks were called in expected order');
    //   });
    // });
    // Out current implementation doesn't allow us to properly enforce what is tested here.
    // We should probably fix it, but it's not technically a bug right now.
    // See https://github.com/emberjs/ember.js/issues/3522 for more information.
    // asyncTest('callbacks coalesce into same run loop if expiring at the same time', function() {
    //   let array = [];
    //   function fn(val) { array.push(getCurrentRunLoop()); }
    //   run(function() {
    //     // Force +new Date to return the same result while scheduling
    //     // later timers. Otherwise: non-determinism!
    //     let now = +new Date();
    //     Date.prototype.valueOf = function() { return now; };
    //     later(this, fn, 10);
    //     later(this, fn, 200);
    //     later(this, fn, 200);
    //     Date.prototype.valueOf = originalDateValueOf;
    //   });
    //   deepEqual(array, []);
    //   wait(function() {
    //     QUnit.start();
    //     equal(array.length, 3, 'all callbacks called');
    //     ok(array[0] !== array[1], 'first two callbacks have different run loops');
    //     ok(array[0], 'first runloop present');
    //     ok(array[1], 'second runloop present');
    //     equal(array[1], array[2], 'last two callbacks got the same run loop');
    //   });
    // });
    ;

    _proto['@test inception calls to later should run callbacks in separate run loops'] = function testInceptionCallsToLaterShouldRunCallbacksInSeparateRunLoops(assert) {
      var done = assert.async();
      var runLoop, finished;
      (0, _runloop.run)(function () {
        runLoop = (0, _runloop.getCurrentRunLoop)();
        assert.ok(runLoop);
        (0, _runloop.later)(function () {
          assert.ok((0, _runloop.getCurrentRunLoop)() && (0, _runloop.getCurrentRunLoop)() !== runLoop, 'first later callback has own run loop');
          runLoop = (0, _runloop.getCurrentRunLoop)();
          (0, _runloop.later)(function () {
            assert.ok((0, _runloop.getCurrentRunLoop)() && (0, _runloop.getCurrentRunLoop)() !== runLoop, 'second later callback has own run loop');
            finished = true;
          }, 40);
        }, 40);
      });
      wait(function () {
        assert.ok(finished, 'all .later callbacks run');
        done();
      });
    };

    _proto['@test setTimeout should never run with a negative wait'] = function testSetTimeoutShouldNeverRunWithANegativeWait(assert) {
      var done = assert.async(); // Rationale: The old run loop code was susceptible to an occasional
      // bug where invokeLaterTimers would be scheduled with a setTimeout
      // with a negative wait. Modern browsers normalize this to 0, but
      // older browsers (IE <= 8) break with a negative wait, which
      // happens when an expired timer callback takes a while to run,
      // which is what we simulate here.

      var newSetTimeoutUsed;
      _runloop.backburner._platform = (0, _polyfills.assign)({}, originalPlatform, {
        setTimeout: function () {
          var wait = arguments[arguments.length - 1];
          newSetTimeoutUsed = true;
          assert.ok(!isNaN(wait) && wait >= 0, 'wait is a non-negative number');
          return originalPlatform.setTimeout.apply(originalPlatform, arguments);
        }
      });
      var count = 0;
      (0, _runloop.run)(function () {
        (0, _runloop.later)(function () {
          count++; // This will get run first. Waste some time.
          // This is intended to break invokeLaterTimers code by taking a
          // long enough time that other timers should technically expire. It's
          // fine that they're not called in this run loop; just need to
          // make sure that invokeLaterTimers doesn't end up scheduling
          // a negative setTimeout.

          pauseUntil(Date.now() + 60);
        }, 1);
        (0, _runloop.later)(function () {
          assert.equal(count, 1, 'callbacks called in order');
        }, 50);
      });
      wait(function () {
        assert.ok(newSetTimeoutUsed, 'stub setTimeout was used');
        done();
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/next_test", ["ember-babel", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('run.next',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test should invoke immediately on next timeout'] = function testShouldInvokeImmediatelyOnNextTimeout(assert) {
      var done = assert.async();
      var invoked = false;
      (0, _runloop.run)(function () {
        return (0, _runloop.next)(function () {
          return invoked = true;
        });
      });
      assert.equal(invoked, false, 'should not have invoked yet');
      setTimeout(function () {
        assert.equal(invoked, true, 'should have invoked later item');
        done();
      }, 20);
    };

    _proto['@test callback should be called from within separate loop'] = function testCallbackShouldBeCalledFromWithinSeparateLoop(assert) {
      var done = assert.async();
      var firstRunLoop, secondRunLoop;
      (0, _runloop.run)(function () {
        firstRunLoop = (0, _runloop.getCurrentRunLoop)();
        (0, _runloop.next)(function () {
          return secondRunLoop = (0, _runloop.getCurrentRunLoop)();
        });
      });
      setTimeout(function () {
        assert.ok(secondRunLoop, 'callback was called from within run loop');
        assert.ok(firstRunLoop && secondRunLoop !== firstRunLoop, 'two separate run loops were invoked');
        done();
      }, 20);
    };

    _proto['@test multiple calls to next share coalesce callbacks into same run loop'] = function testMultipleCallsToNextShareCoalesceCallbacksIntoSameRunLoop(assert) {
      var done = assert.async();
      var secondRunLoop, thirdRunLoop;
      (0, _runloop.run)(function () {
        (0, _runloop.next)(function () {
          return secondRunLoop = (0, _runloop.getCurrentRunLoop)();
        });
        (0, _runloop.next)(function () {
          return thirdRunLoop = (0, _runloop.getCurrentRunLoop)();
        });
      });
      setTimeout(function () {
        assert.ok(secondRunLoop && secondRunLoop === thirdRunLoop, 'callbacks coalesced into same run loop');
        done();
      }, 20);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/once_test", ["ember-babel", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/once_test',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test calling invokeOnce more than once invokes only once'] = function testCallingInvokeOnceMoreThanOnceInvokesOnlyOnce(assert) {
      var count = 0;
      (0, _runloop.run)(function () {
        function F() {
          count++;
        }

        (0, _runloop.once)(F);
        (0, _runloop.once)(F);
        (0, _runloop.once)(F);
      });
      assert.equal(count, 1, 'should have invoked once');
    };

    _proto['@test should differentiate based on target'] = function testShouldDifferentiateBasedOnTarget(assert) {
      var A = {
        count: 0
      };
      var B = {
        count: 0
      };
      (0, _runloop.run)(function () {
        function F() {
          this.count++;
        }

        (0, _runloop.once)(A, F);
        (0, _runloop.once)(B, F);
        (0, _runloop.once)(A, F);
        (0, _runloop.once)(B, F);
      });
      assert.equal(A.count, 1, 'should have invoked once on A');
      assert.equal(B.count, 1, 'should have invoked once on B');
    };

    _proto['@test should ignore other arguments - replacing previous ones'] = function testShouldIgnoreOtherArgumentsReplacingPreviousOnes(assert) {
      var A = {
        count: 0
      };
      var B = {
        count: 0
      };
      (0, _runloop.run)(function () {
        function F(amt) {
          this.count += amt;
        }

        (0, _runloop.once)(A, F, 10);
        (0, _runloop.once)(B, F, 20);
        (0, _runloop.once)(A, F, 30);
        (0, _runloop.once)(B, F, 40);
      });
      assert.equal(A.count, 30, 'should have invoked once on A');
      assert.equal(B.count, 40, 'should have invoked once on B');
    };

    _proto['@test should be inside of a runloop when running'] = function testShouldBeInsideOfARunloopWhenRunning(assert) {
      (0, _runloop.run)(function () {
        (0, _runloop.once)(function () {
          return assert.ok(Boolean((0, _runloop.getCurrentRunLoop)()), 'should have a runloop');
        });
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/onerror_test", ["ember-babel", "@ember/runloop", "@ember/-internals/error-handling", "@ember/debug", "internal-test-helpers"], function (_emberBabel, _runloop, _errorHandling, _debug, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/onerror_test',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test With Ember.onerror undefined, errors in run are thrown'] = function testWithEmberOnerrorUndefinedErrorsInRunAreThrown(assert) {
      var thrown = new Error('Boom!');
      var original = (0, _errorHandling.getOnerror)();
      var caught;
      (0, _errorHandling.setOnerror)(undefined);

      try {
        (0, _runloop.run)(function () {
          throw thrown;
        });
      } catch (error) {
        caught = error;
      } finally {
        (0, _errorHandling.setOnerror)(original);
      }

      assert.deepEqual(caught, thrown);
    };

    _proto['@test With Ember.onerror set, errors in run are caught'] = function testWithEmberOnerrorSetErrorsInRunAreCaught(assert) {
      var thrown = new Error('Boom!');
      var original = (0, _errorHandling.getOnerror)();
      var originalDispatchOverride = (0, _errorHandling.getDispatchOverride)();
      var originalIsTesting = (0, _debug.isTesting)();
      var caught;
      (0, _errorHandling.setOnerror)(function (error) {
        caught = error;
      });
      (0, _errorHandling.setDispatchOverride)(null);
      (0, _debug.setTesting)(false);

      try {
        (0, _runloop.run)(function () {
          throw thrown;
        });
      } finally {
        (0, _errorHandling.setOnerror)(original);
        (0, _errorHandling.setDispatchOverride)(originalDispatchOverride);
        (0, _debug.setTesting)(originalIsTesting);
      }

      assert.deepEqual(caught, thrown);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/run_bind_test", ["ember-babel", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/run_bind_test',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test bind builds a run-loop wrapped callback handler'] = function testBindBuildsARunLoopWrappedCallbackHandler(assert) {
      assert.expect(3);
      var obj = {
        value: 0,
        increment: function (increment) {
          assert.ok((0, _runloop.getCurrentRunLoop)(), 'expected a run-loop');
          return this.value += increment;
        }
      };
      var proxiedFunction = (0, _runloop.bind)(obj, obj.increment, 1);
      assert.equal(proxiedFunction(), 1);
      assert.equal(obj.value, 1);
    };

    _proto['@test bind keeps the async callback arguments'] = function testBindKeepsTheAsyncCallbackArguments(assert) {
      assert.expect(4);

      function asyncCallback(increment, increment2, increment3) {
        assert.ok((0, _runloop.getCurrentRunLoop)(), 'expected a run-loop');
        assert.equal(increment, 1);
        assert.equal(increment2, 2);
        assert.equal(increment3, 3);
      }

      function asyncFunction(fn) {
        fn(2, 3);
      }

      asyncFunction((0, _runloop.bind)(asyncCallback, asyncCallback, 1));
    };

    _proto['@test [GH#16652] bind throws an error if callback is undefined'] = function testGH16652BindThrowsAnErrorIfCallbackIsUndefined() {
      var assertBindThrows = function (msg) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        expectAssertion(function () {
          _runloop.bind.apply(void 0, args);
        }, /could not find a suitable method to bind/, msg);
      };

      assertBindThrows('without arguments');
      assertBindThrows('with one arguments that is not a function', 'myMethod');
      assertBindThrows('if second parameter is not a function and not a property in first parameter', Object.create(null), 'myMethod');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/run_test", ["ember-babel", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/run_test',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test run invokes passed function, returning value'] = function testRunInvokesPassedFunctionReturningValue(assert) {
      var obj = {
        foo: function () {
          return [this.bar, 'FOO'];
        },
        bar: 'BAR',
        checkArgs: function (arg1, arg2) {
          return [arg1, this.bar, arg2];
        }
      };
      assert.equal((0, _runloop.run)(function () {
        return 'FOO';
      }), 'FOO', 'pass function only');
      assert.deepEqual((0, _runloop.run)(obj, obj.foo), ['BAR', 'FOO'], 'pass obj and obj.method');
      assert.deepEqual((0, _runloop.run)(obj, 'foo'), ['BAR', 'FOO'], 'pass obj and "method"');
      assert.deepEqual((0, _runloop.run)(obj, obj.checkArgs, 'hello', 'world'), ['hello', 'BAR', 'world'], 'pass obj, obj.method, and extra arguments');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/schedule_test", ["ember-babel", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/schedule_test',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test scheduling item in queue should defer until finished'] = function testSchedulingItemInQueueShouldDeferUntilFinished(assert) {
      var cnt = 0;
      (0, _runloop.run)(function () {
        (0, _runloop.schedule)('actions', function () {
          return cnt++;
        });
        (0, _runloop.schedule)('actions', function () {
          return cnt++;
        });
        assert.equal(cnt, 0, 'should not run action yet');
      });
      assert.equal(cnt, 2, 'should flush actions now');
    };

    _proto['@test a scheduled item can be canceled'] = function testAScheduledItemCanBeCanceled(assert) {
      var hasRan = false;
      (0, _runloop.run)(function () {
        var cancelId = (0, _runloop.schedule)('actions', function () {
          return hasRan = true;
        });
        (0, _runloop.cancel)(cancelId);
      });
      assert.notOk(hasRan, 'should not have ran callback run');
    };

    _proto['@test nested runs should queue each phase independently'] = function testNestedRunsShouldQueueEachPhaseIndependently(assert) {
      var cnt = 0;
      (0, _runloop.run)(function () {
        (0, _runloop.schedule)('actions', function () {
          return cnt++;
        });
        assert.equal(cnt, 0, 'should not run action yet');
        (0, _runloop.run)(function () {
          (0, _runloop.schedule)('actions', function () {
            return cnt++;
          });
        });
        assert.equal(cnt, 1, 'should not run action yet');
      });
      assert.equal(cnt, 2, 'should flush actions now');
    };

    _proto['@test prior queues should be flushed before moving on to next queue'] = function testPriorQueuesShouldBeFlushedBeforeMovingOnToNextQueue(assert) {
      var order = [];
      (0, _runloop.run)(function () {
        var runLoop = (0, _runloop.getCurrentRunLoop)();
        assert.ok(runLoop, 'run loop present');
        (0, _runloop.schedule)('actions', function () {
          order.push('actions');
          assert.equal(runLoop, (0, _runloop.getCurrentRunLoop)(), 'same run loop used');
        });
        (0, _runloop.schedule)('afterRender', function () {
          order.push('afterRender');
          assert.equal(runLoop, (0, _runloop.getCurrentRunLoop)(), 'same run loop used');
          (0, _runloop.schedule)('afterRender', function () {
            order.push('afterRender');
            assert.equal(runLoop, (0, _runloop.getCurrentRunLoop)(), 'same run loop used');
          });
          (0, _runloop.schedule)('actions', function () {
            order.push('actions');
            assert.equal(runLoop, (0, _runloop.getCurrentRunLoop)(), 'same run loop used');
          });
        });
        (0, _runloop.schedule)('destroy', function () {
          order.push('destroy');
          assert.equal(runLoop, (0, _runloop.getCurrentRunLoop)(), 'same run loop used');
        });
      });
      assert.deepEqual(order, ['actions', 'afterRender', 'actions', 'afterRender', 'destroy']);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/runloop/tests/unwind_test", ["ember-babel", "@ember/runloop", "@ember/error", "internal-test-helpers"], function (_emberBabel, _runloop, _error, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('system/run_loop/unwind_test',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test RunLoop unwinds despite unhandled exception'] = function testRunLoopUnwindsDespiteUnhandledException(assert) {
      var initialRunLoop = (0, _runloop.getCurrentRunLoop)();
      assert.throws(function () {
        (0, _runloop.run)(function () {
          (0, _runloop.schedule)('actions', function () {
            throw new _error.default('boom!');
          });
        });
      }, Error, 'boom!'); // The real danger at this point is that calls to autorun will stick
      // tasks into the already-dead runloop, which will never get
      // flushed. I can't easily demonstrate this in a unit test because
      // autorun explicitly doesn't work in test mode. - ef4

      assert.equal((0, _runloop.getCurrentRunLoop)(), initialRunLoop, 'Previous run loop should be cleaned up despite exception');
    };

    _proto['@test run unwinds despite unhandled exception'] = function testRunUnwindsDespiteUnhandledException(assert) {
      var initialRunLoop = (0, _runloop.getCurrentRunLoop)();
      assert.throws(function () {
        (0, _runloop.run)(function () {
          throw new _error.default('boom!');
        });
      }, _error.default, 'boom!');
      assert.equal((0, _runloop.getCurrentRunLoop)(), initialRunLoop, 'Previous run loop should be cleaned up despite exception');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/service/tests/service_test", ["ember-babel", "@ember/service", "@ember/-internals/runtime", "internal-test-helpers"], function (_emberBabel, _service, _runtime, _internalTestHelpers) {
  "use strict";

  function _initializerDefineProperty(target, property, descriptor, context) {
    if (!descriptor) return;
    Object.defineProperty(target, property, {
      enumerable: descriptor.enumerable,
      configurable: descriptor.configurable,
      writable: descriptor.writable,
      value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
    });
  }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
    var desc = {};
    Object.keys(descriptor).forEach(function (key) {
      desc[key] = descriptor[key];
    });
    desc.enumerable = !!desc.enumerable;
    desc.configurable = !!desc.configurable;

    if ('value' in desc || desc.initializer) {
      desc.writable = true;
    }

    desc = decorators.slice().reverse().reduce(function (desc, decorator) {
      return decorator(target, property, desc) || desc;
    }, desc);

    if (context && desc.initializer !== void 0) {
      desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
      desc.initializer = undefined;
    }

    if (desc.initializer === void 0) {
      Object.defineProperty(target, property, desc);
      desc = null;
    }

    return desc;
  }

  function _initializerWarningHelper(descriptor, context) {
    throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and set to use loose mode. ' + 'To use proposal-class-properties in spec mode with decorators, wait for ' + 'the next major version of decorators in stage 2.');
  }

  if (true
  /* EMBER_NATIVE_DECORATOR_SUPPORT */
  ) {
      (0, _internalTestHelpers.moduleFor)('inject - decorator',
      /*#__PURE__*/
      function (_AbstractTestCase) {
        (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase);

        function _class2() {
          return _AbstractTestCase.apply(this, arguments) || this;
        }

        var _proto = _class2.prototype;

        _proto['@test works with native decorators'] = function testWorksWithNativeDecorators(assert) {
          var _dec, _class, _descriptor, _temp;

          var owner = (0, _internalTestHelpers.buildOwner)();

          var MainService =
          /*#__PURE__*/
          function (_Service) {
            (0, _emberBabel.inheritsLoose)(MainService, _Service);

            function MainService() {
              return _Service.apply(this, arguments) || this;
            }

            return MainService;
          }(_service.default);

          var Foo = (_dec = (0, _service.inject)('main'), (_class = (_temp =
          /*#__PURE__*/
          function (_EmberObject) {
            (0, _emberBabel.inheritsLoose)(Foo, _EmberObject);

            function Foo() {
              var _this;

              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              _this = _EmberObject.call.apply(_EmberObject, [this].concat(args)) || this;

              _initializerDefineProperty((0, _emberBabel.assertThisInitialized)(_this), "main", _descriptor, (0, _emberBabel.assertThisInitialized)(_this));

              return _this;
            }

            return Foo;
          }(_runtime.Object), _temp), _descriptor = _applyDecoratedDescriptor(_class.prototype, "main", [_dec], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: null
          }), _class));
          owner.register('service:main', MainService);
          owner.register('foo:main', Foo);
          var foo = owner.lookup('foo:main');
          assert.ok(foo.main instanceof _service.default, 'service injected correctly');
        };

        _proto['@test uses the decorated property key if not provided'] = function testUsesTheDecoratedPropertyKeyIfNotProvided(assert) {
          var _class3, _descriptor2, _temp2;

          var owner = (0, _internalTestHelpers.buildOwner)();

          var MainService =
          /*#__PURE__*/
          function (_Service2) {
            (0, _emberBabel.inheritsLoose)(MainService, _Service2);

            function MainService() {
              return _Service2.apply(this, arguments) || this;
            }

            return MainService;
          }(_service.default);

          var Foo = (_class3 = (_temp2 =
          /*#__PURE__*/
          function (_EmberObject2) {
            (0, _emberBabel.inheritsLoose)(Foo, _EmberObject2);

            function Foo() {
              var _this2;

              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }

              _this2 = _EmberObject2.call.apply(_EmberObject2, [this].concat(args)) || this;

              _initializerDefineProperty((0, _emberBabel.assertThisInitialized)(_this2), "main", _descriptor2, (0, _emberBabel.assertThisInitialized)(_this2));

              return _this2;
            }

            return Foo;
          }(_runtime.Object), _temp2), _descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "main", [_service.inject], {
            configurable: true,
            enumerable: true,
            writable: true,
            initializer: null
          }), _class3);
          owner.register('service:main', MainService);
          owner.register('foo:main', Foo);
          var foo = owner.lookup('foo:main');
          assert.ok(foo.main instanceof _service.default, 'service injected correctly');
        };

        return _class2;
      }(_internalTestHelpers.AbstractTestCase));
    }
});
enifed("@ember/string/tests/camelize_test", ["ember-babel", "@ember/-internals/environment", "@ember/string", "internal-test-helpers"], function (_emberBabel, _environment, _string, _internalTestHelpers) {
  "use strict";

  function test(assert, given, expected, description) {
    assert.deepEqual((0, _string.camelize)(given), expected, description);

    if (_environment.ENV.EXTEND_PROTOTYPES.String) {
      assert.deepEqual(given.camelize(), expected, description);
    }
  }

  (0, _internalTestHelpers.moduleFor)('EmberStringUtils.camelize',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test String.prototype.camelize is not modified without EXTEND_PROTOTYPES'] = function testStringPrototypeCamelizeIsNotModifiedWithoutEXTEND_PROTOTYPES(assert) {
      if (!_environment.ENV.EXTEND_PROTOTYPES.String) {
        assert.ok('undefined' === typeof String.prototype.camelize, 'String.prototype helper disabled');
      } else {
        assert.expect(0);
      }
    };

    _proto['@test String camelize tests'] = function testStringCamelizeTests(assert) {
      test(assert, 'my favorite items', 'myFavoriteItems', 'camelize normal string');
      test(assert, 'I Love Ramen', 'iLoveRamen', 'camelize capitalized string');
      test(assert, 'css-class-name', 'cssClassName', 'camelize dasherized string');
      test(assert, 'action_name', 'actionName', 'camelize underscored string');
      test(assert, 'action.name', 'actionName', 'camelize dot notation string');
      test(assert, 'innerHTML', 'innerHTML', 'does nothing with camelcased string');
      test(assert, 'PrivateDocs/OwnerInvoice', 'privateDocs/ownerInvoice', 'camelize namespaced classified string');
      test(assert, 'private_docs/owner_invoice', 'privateDocs/ownerInvoice', 'camelize namespaced underscored string');
      test(assert, 'private-docs/owner-invoice', 'privateDocs/ownerInvoice', 'camelize namespaced dasherized string');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/string/tests/capitalize_test", ["ember-babel", "@ember/-internals/environment", "@ember/string", "internal-test-helpers"], function (_emberBabel, _environment, _string, _internalTestHelpers) {
  "use strict";

  function test(assert, given, expected, description) {
    assert.deepEqual((0, _string.capitalize)(given), expected, description);

    if (_environment.ENV.EXTEND_PROTOTYPES.String) {
      assert.deepEqual(given.capitalize(), expected, description);
    }
  }

  (0, _internalTestHelpers.moduleFor)('EmberStringUtils.capitalize',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test String.prototype.capitalize is not modified without EXTEND_PROTOTYPES'] = function testStringPrototypeCapitalizeIsNotModifiedWithoutEXTEND_PROTOTYPES(assert) {
      if (!_environment.ENV.EXTEND_PROTOTYPES.String) {
        assert.ok('undefined' === typeof String.prototype.capitalize, 'String.prototype helper disabled');
      } else {
        assert.expect(0);
      }
    };

    _proto['@test String capitalize tests'] = function testStringCapitalizeTests(assert) {
      test(assert, 'my favorite items', 'My favorite items', 'capitalize normal string');
      test(assert, 'css-class-name', 'Css-class-name', 'capitalize dasherized string');
      test(assert, 'action_name', 'Action_name', 'capitalize underscored string');
      test(assert, 'innerHTML', 'InnerHTML', 'capitalize camelcased string');
      test(assert, 'Capitalized string', 'Capitalized string', 'does nothing with capitalized string');
      test(assert, 'privateDocs/ownerInvoice', 'PrivateDocs/OwnerInvoice', 'capitalize namespaced camelized string');
      test(assert, 'private_docs/owner_invoice', 'Private_docs/Owner_invoice', 'capitalize namespaced underscored string');
      test(assert, 'private-docs/owner-invoice', 'Private-docs/Owner-invoice', 'capitalize namespaced dasherized string');
      test(assert, 'abc', 'abc', 'capitalize string with accent character');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/string/tests/classify_test", ["ember-babel", "@ember/-internals/environment", "@ember/string", "internal-test-helpers"], function (_emberBabel, _environment, _string, _internalTestHelpers) {
  "use strict";

  function test(assert, given, expected, description) {
    assert.deepEqual((0, _string.classify)(given), expected, description);

    if (_environment.ENV.EXTEND_PROTOTYPES.String) {
      assert.deepEqual(given.classify(), expected, description);
    }
  }

  (0, _internalTestHelpers.moduleFor)('EmberStringUtils.classify',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test String.prototype.classify is not modified without EXTEND_PROTOTYPES'] = function testStringPrototypeClassifyIsNotModifiedWithoutEXTEND_PROTOTYPES(assert) {
      if (!_environment.ENV.EXTEND_PROTOTYPES.String) {
        assert.ok('undefined' === typeof String.prototype.classify, 'String.prototype helper disabled');
      } else {
        assert.expect(0);
      }
    };

    _proto['@test String classify tests'] = function testStringClassifyTests(assert) {
      test(assert, 'my favorite items', 'MyFavoriteItems', 'classify normal string');
      test(assert, 'css-class-name', 'CssClassName', 'classify dasherized string');
      test(assert, 'action_name', 'ActionName', 'classify underscored string');
      test(assert, 'privateDocs/ownerInvoice', 'PrivateDocs/OwnerInvoice', 'classify namespaced camelized string');
      test(assert, 'private_docs/owner_invoice', 'PrivateDocs/OwnerInvoice', 'classify namespaced underscored string');
      test(assert, 'private-docs/owner-invoice', 'PrivateDocs/OwnerInvoice', 'classify namespaced dasherized string');
      test(assert, '-view-registry', '_ViewRegistry', 'classify prefixed dasherized string');
      test(assert, 'components/-text-field', 'Components/_TextField', 'classify namespaced prefixed dasherized string');
      test(assert, '_Foo_Bar', '_FooBar', 'classify underscore-prefixed underscored string');
      test(assert, '_Foo-Bar', '_FooBar', 'classify underscore-prefixed dasherized string');
      test(assert, '_foo/_bar', '_Foo/_Bar', 'classify underscore-prefixed-namespaced underscore-prefixed string');
      test(assert, '-foo/_bar', '_Foo/_Bar', 'classify dash-prefixed-namespaced underscore-prefixed string');
      test(assert, '-foo/-bar', '_Foo/_Bar', 'classify dash-prefixed-namespaced dash-prefixed string');
      test(assert, 'InnerHTML', 'InnerHTML', 'does nothing with classified string');
      test(assert, '_FooBar', '_FooBar', 'does nothing with classified prefixed string');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/string/tests/dasherize_test", ["ember-babel", "@ember/-internals/environment", "@ember/string", "internal-test-helpers"], function (_emberBabel, _environment, _string, _internalTestHelpers) {
  "use strict";

  function test(assert, given, expected, description) {
    assert.deepEqual((0, _string.dasherize)(given), expected, description);

    if (_environment.ENV.EXTEND_PROTOTYPES.String) {
      assert.deepEqual(given.dasherize(), expected, description);
    }
  }

  (0, _internalTestHelpers.moduleFor)('EmberStringUtils.dasherize',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test String.prototype.dasherize is not modified without EXTEND_PROTOTYPES'] = function testStringPrototypeDasherizeIsNotModifiedWithoutEXTEND_PROTOTYPES(assert) {
      if (!_environment.ENV.EXTEND_PROTOTYPES.String) {
        assert.ok('undefined' === typeof String.prototype.dasherize, 'String.prototype helper disabled');
      } else {
        assert.expect(0);
      }
    };

    _proto['@test String dasherize tests'] = function testStringDasherizeTests(assert) {
      test(assert, 'my favorite items', 'my-favorite-items', 'dasherize normal string');
      test(assert, 'css-class-name', 'css-class-name', 'does nothing with dasherized string');
      test(assert, 'action_name', 'action-name', 'dasherize underscored string');
      test(assert, 'innerHTML', 'inner-html', 'dasherize camelcased string');
      test(assert, 'toString', 'to-string', 'dasherize string that is the property name of Object.prototype');
      test(assert, 'PrivateDocs/OwnerInvoice', 'private-docs/owner-invoice', 'dasherize namespaced classified string');
      test(assert, 'privateDocs/ownerInvoice', 'private-docs/owner-invoice', 'dasherize namespaced camelized string');
      test(assert, 'private_docs/owner_invoice', 'private-docs/owner-invoice', 'dasherize namespaced underscored string');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/string/tests/decamelize_test", ["ember-babel", "@ember/-internals/environment", "@ember/string", "internal-test-helpers"], function (_emberBabel, _environment, _string, _internalTestHelpers) {
  "use strict";

  function test(assert, given, expected, description) {
    assert.deepEqual((0, _string.decamelize)(given), expected, description);

    if (_environment.ENV.EXTEND_PROTOTYPES.String) {
      assert.deepEqual(given.decamelize(), expected, description);
    }
  }

  (0, _internalTestHelpers.moduleFor)('EmberStringUtils.decamelize',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test String.prototype.decamelize is not modified without EXTEND_PROTOTYPES'] = function testStringPrototypeDecamelizeIsNotModifiedWithoutEXTEND_PROTOTYPES(assert) {
      if (!_environment.ENV.EXTEND_PROTOTYPES.String) {
        assert.ok('undefined' === typeof String.prototype.decamelize, 'String.prototype helper disabled');
      } else {
        assert.expect(0);
      }
    };

    _proto['@test String decamelize tests'] = function testStringDecamelizeTests(assert) {
      test(assert, 'my favorite items', 'my favorite items', 'does nothing with normal string');
      test(assert, 'css-class-name', 'css-class-name', 'does nothing with dasherized string');
      test(assert, 'action_name', 'action_name', 'does nothing with underscored string');
      test(assert, 'innerHTML', 'inner_html', 'converts a camelized string into all lower case separated by underscores.');
      test(assert, 'size160Url', 'size160_url', 'decamelizes strings with numbers');
      test(assert, 'PrivateDocs/OwnerInvoice', 'private_docs/owner_invoice', 'decamelize namespaced classified string');
      test(assert, 'privateDocs/ownerInvoice', 'private_docs/owner_invoice', 'decamelize namespaced camelized string');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/string/tests/loc_test", ["ember-babel", "@ember/-internals/environment", "@ember/string", "@ember/string/lib/string_registry", "internal-test-helpers"], function (_emberBabel, _environment, _string, _string_registry, _internalTestHelpers) {
  "use strict";

  var oldString;

  function test(assert, given, args, expected, description) {
    assert.equal((0, _string.loc)(given, args), expected, description);

    if (_environment.ENV.EXTEND_PROTOTYPES.String) {
      assert.deepEqual(given.loc.apply(given, args), expected, description);
    }
  }

  (0, _internalTestHelpers.moduleFor)('EmberStringUtils.loc',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      oldString = (0, _string_registry.getStrings)();
      (0, _string_registry.setStrings)({
        '_Hello World': 'Bonjour le monde',
        '_Hello %@': 'Bonjour %@',
        '_Hello %@ %@': 'Bonjour %@ %@',
        '_Hello %@# %@#': 'Bonjour %@2 %@1'
      });
    };

    _proto.afterEach = function afterEach() {
      (0, _string_registry.setStrings)(oldString);
    };

    _proto['@test String.prototype.loc is not available without EXTEND_PROTOTYPES'] = function testStringPrototypeLocIsNotAvailableWithoutEXTEND_PROTOTYPES(assert) {
      if (!_environment.ENV.EXTEND_PROTOTYPES.String) {
        assert.ok('undefined' === typeof String.prototype.loc, 'String.prototype helper disabled');
      } else {
        assert.expect(0);
      }
    };

    _proto['@test String loc tests'] = function testStringLocTests(assert) {
      test(assert, '_Hello World', [], 'Bonjour le monde', "loc('_Hello World') => 'Bonjour le monde'");
      test(assert, '_Hello %@ %@', ['John', 'Doe'], 'Bonjour John Doe', "loc('_Hello %@ %@', ['John', 'Doe']) => 'Bonjour John Doe'");
      test(assert, '_Hello %@# %@#', ['John', 'Doe'], 'Bonjour Doe John', "loc('_Hello %@# %@#', ['John', 'Doe']) => 'Bonjour Doe John'");
      test(assert, '_Not In Strings', [], '_Not In Strings', "loc('_Not In Strings') => '_Not In Strings'");
    };

    _proto['@test works with argument form'] = function testWorksWithArgumentForm(assert) {
      assert.equal((0, _string.loc)('_Hello %@', 'John'), 'Bonjour John');
      assert.equal((0, _string.loc)('_Hello %@ %@', ['John'], 'Doe'), 'Bonjour John Doe');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/string/tests/underscore_test", ["ember-babel", "@ember/-internals/environment", "@ember/string", "internal-test-helpers"], function (_emberBabel, _environment, _string, _internalTestHelpers) {
  "use strict";

  function test(assert, given, expected, description) {
    assert.deepEqual((0, _string.underscore)(given), expected, description);

    if (_environment.ENV.EXTEND_PROTOTYPES.String) {
      assert.deepEqual(given.underscore(), expected, description);
    }
  }

  (0, _internalTestHelpers.moduleFor)('EmberStringUtils.underscore',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test String.prototype.underscore is not available without EXTEND_PROTOTYPES'] = function testStringPrototypeUnderscoreIsNotAvailableWithoutEXTEND_PROTOTYPES(assert) {
      if (!_environment.ENV.EXTEND_PROTOTYPES.String) {
        assert.ok('undefined' === typeof String.prototype.underscore, 'String.prototype helper disabled');
      } else {
        assert.expect(0);
      }
    };

    _proto['@test String underscore tests'] = function testStringUnderscoreTests(assert) {
      test(assert, 'my favorite items', 'my_favorite_items', 'with normal string');
      test(assert, 'css-class-name', 'css_class_name', 'with dasherized string');
      test(assert, 'action_name', 'action_name', 'does nothing with underscored string');
      test(assert, 'innerHTML', 'inner_html', 'with camelcased string');
      test(assert, 'PrivateDocs/OwnerInvoice', 'private_docs/owner_invoice', 'underscore namespaced classified string');
      test(assert, 'privateDocs/ownerInvoice', 'private_docs/owner_invoice', 'underscore namespaced camelized string');
      test(assert, 'private-docs/owner-invoice', 'private_docs/owner_invoice', 'underscore namespaced dasherized string');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("@ember/string/tests/w_test", ["ember-babel", "@ember/-internals/environment", "@ember/string", "internal-test-helpers"], function (_emberBabel, _environment, _string, _internalTestHelpers) {
  "use strict";

  function test(assert, given, expected, description) {
    assert.deepEqual((0, _string.w)(given), expected, description);

    if (_environment.ENV.EXTEND_PROTOTYPES.String) {
      assert.deepEqual(given.w(), expected, description);
    }
  }

  (0, _internalTestHelpers.moduleFor)('EmberStringUtils.w',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test String.prototype.w is not available without EXTEND_PROTOTYPES'] = function testStringPrototypeWIsNotAvailableWithoutEXTEND_PROTOTYPES(assert) {
      if (!_environment.ENV.EXTEND_PROTOTYPES.String) {
        assert.ok('undefined' === typeof String.prototype.w, 'String.prototype helper disabled');
      } else {
        assert.expect(0);
      }
    };

    _proto['@test String w tests'] = function testStringWTests(assert) {
      test(assert, 'one two three', ['one', 'two', 'three'], "w('one two three') => ['one','two','three']");
      test(assert, 'one   two  three', ['one', 'two', 'three'], "w('one    two    three') with extra spaces between words => ['one','two','three']");
      test(assert, 'one\ttwo  three', ['one', 'two', 'three'], "w('one two three') with tabs");
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/plugins/assert-if-helper-without-arguments-test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert-if-helper-without-argument',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto["@test block if helper expects one argument"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("{{#if}}aVal{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "#if requires a single argument. ('baz/foo-bar' @ L1:C0) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if val1 val2}}aVal{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "#if requires a single argument. ('baz/foo-bar' @ L1:C0) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if}}aVal{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "#if requires a single argument. ('baz/foo-bar' @ L1:C0) ");
    };

    _proto["@test inline if helper expects between one and three arguments"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("{{if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "The inline form of the 'if' helper expects two or three arguments. ('baz/foo-bar' @ L1:C0) ");
      (0, _index.compile)("{{if foo bar baz}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto['@test subexpression if helper expects between one and three arguments'] = function testSubexpressionIfHelperExpectsBetweenOneAndThreeArguments() {
      expectAssertion(function () {
        (0, _index.compile)("{{input foo=(if)}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "The inline form of the 'if' helper expects two or three arguments. ('baz/foo-bar' @ L1:C12) ");
      (0, _index.compile)("{{some-thing foo=(if foo bar baz)}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/plugins/assert-input-helper-without-block-test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert-input-helper-without-block',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Using {{#input}}{{/input}} is not valid'] = function testUsingInputInputIsNotValid() {
      var expectedMessage = "The {{input}} helper cannot be used in block form. ('baz/foo-bar' @ L1:C0) ";
      expectAssertion(function () {
        (0, _index.compile)('{{#input value="123"}}Completely invalid{{/input}}', {
          moduleName: 'baz/foo-bar'
        });
      }, expectedMessage);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/plugins/assert-local-variable-shadowing-helper-invocation-test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert-local-variable-shadowing-helper-invocation',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto["@test block statements shadowing sub-expression invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            {{concat (foo)}}\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C21) ");
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            {{concat (foo bar baz)}}\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C21) "); // Not shadowed

      (0, _index.compile)("\n        {{#let foo as |foo|}}{{/let}}\n        {{concat (foo)}}\n        {{concat (foo bar baz)}}", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          {{concat foo}}\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        {{#let (concat foo) as |concat|}}\n          {{input value=concat}}\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test element nodes shadowing sub-expression invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          <Foo as |foo|>\n            {{concat (foo)}}\n          </Foo>", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C21) ");
      expectAssertion(function () {
        (0, _index.compile)("\n          <Foo as |foo|>\n            {{concat (foo bar baz)}}\n          </Foo>", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C21) "); // Not shadowed

      (0, _index.compile)("\n        <Foo as |foo|></Foo>\n        {{concat (foo)}}\n        {{concat (foo bar baz)}}", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        <Foo as |foo|>\n          {{concat foo}}\n        </Foo>", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        <Foo foo={{concat foo}} as |concat|>\n          {{input value=concat}}\n        </Foo>", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test deeply nested sub-expression invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <FooBar as |bar|>\n              {{#each items as |baz|}}\n                {{concat (foo)}}\n              {{/each}}\n            </FooBar>\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L5:C25) ");
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <FooBar as |bar|>\n              {{#each items as |baz|}}\n                {{concat (foo bar baz)}}\n              {{/each}}\n            </FooBar>\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L5:C25) "); // Not shadowed

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n            {{/each}}\n            {{concat (baz)}}\n            {{concat (baz bat)}}\n          </FooBar>\n          {{concat (bar)}}\n          {{concat (bar baz bat)}}\n        {{/let}}\n        {{concat (foo)}}\n        {{concat (foo bar baz bat)}}", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n              {{concat foo}}\n            {{/each}}\n          </FooBar>\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        {{#let (foo foo) as |foo|}}\n          <FooBar bar=(bar bar) as |bar|>\n            {{#each (baz baz) as |baz|}}\n              {{concat foo bar baz}}\n            {{/each}}\n          </FooBar>\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test block statements shadowing attribute sub-expression invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <div class={{concat (foo bar baz)}} />\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C32) "); // Not shadowed

      (0, _index.compile)("\n        {{#let foo as |foo|}}{{/let}}\n        <div class={{concat (foo)}} />\n        <div class={{concat (foo bar baz)}} />", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <div class={{concat foo}} />\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        {{#let (foo foo) as |foo|}}\n          <div class={{concat foo}} />\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test element nodes shadowing attribute sub-expression invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          <Foo as |foo|>\n            <div class={{concat (foo bar baz)}} />\n          </Foo>", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C32) "); // Not shadowed

      (0, _index.compile)("\n        <Foo as |foo|></Foo>\n        <div class={{concat (foo)}} />\n        <div class={{concat (foo bar baz)}} />", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        <Foo as |foo|>\n          <div class={{concat foo}} />\n        </Foo>", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        <Foo foo={{foo foo}} as |foo|>\n          <div class={{concat foo}} />\n        </Foo>", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test deeply nested attribute sub-expression invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <FooBar as |bar|>\n              {{#each items as |baz|}}\n                <div class={{concat (foo bar baz)}} />\n              {{/each}}\n            </FooBar>\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L5:C36) "); // Not shadowed

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n            {{/each}}\n            <div class={{concat (baz)}} />\n            <div class={{concat (baz bat)}} />\n          </FooBar>\n          <div class={{concat (bar)}} />\n          <div class={{concat (bar baz bat)}} />\n        {{/let}}\n        <div class={{concat (foo)}} />\n        <div class={{concat (foo bar baz bat)}} />", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n              <div class={{concat foo}} />\n            {{/each}}\n          </FooBar>\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        {{#let (foo foo) as |foo|}}\n          <FooBar bar=(bar bar) as |bar|>\n            {{#each (baz baz) as |baz|}}\n              <div class={{concat foo bar baz}} />\n            {{/each}}\n          </FooBar>\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test block statements shadowing attribute mustache invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <div class={{foo bar baz}} />\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C23) "); // Not shadowed

      (0, _index.compile)("\n        {{#let foo as |foo|}}{{/let}}\n        <div class={{foo}} />\n        <div class={{foo bar baz}} />", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <div class={{foo}} />\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        {{#let (concat foo) as |concat|}}\n          <div class={{concat}} />\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test element nodes shadowing attribute mustache invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          <Foo as |foo|>\n            <div class={{foo bar baz}} />\n          </Foo>", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C23) "); // Not shadowed

      (0, _index.compile)("\n        <Foo as |foo|></Foo>\n        <div class={{foo}} />\n        <div class={{foo bar baz}} />", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        <Foo as |foo|>\n          <div class={{foo}} />\n        </Foo>", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        <Foo foo={{concat foo}} as |concat|>\n          <div class={{concat}} />\n        </Foo>", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test deeply nested attribute mustache invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <FooBar as |bar|>\n              {{#each items as |baz|}}\n                <div class={{foo bar baz}} />\n              {{/each}}\n            </FooBar>\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` helper because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L5:C27) "); // Not shadowed

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n            {{/each}}\n            <div class={{baz}} />\n            <div class={{baz bat}} />\n          </FooBar>\n          <div class={{bar}} />\n          <div class={{bar baz bat}} />\n        {{/let}}\n        <div class={{foo}} />\n        <div class={{foo bar baz bat}} />", {
        moduleName: 'baz/foo-bar'
      }); // Not invocations

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n              <div class={{foo}} />\n            {{/each}}\n          </FooBar>\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        {{#let (foo foo) as |foo|}}\n          <FooBar bar=(bar bar) as |bar|>\n            {{#each (baz baz) as |baz|}}\n              <div foo={{foo}} bar={{bar}} baz={{baz}} />\n            {{/each}}\n          </FooBar>\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test block statements shadowing mustache invocations"] = function (assert) {
      // These are fine, because they should already be considered contextual
      // component invocations, not helper invocations
      assert.expect(0);
      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          {{foo}}\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          {{foo bar baz}}\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test element nodes shadowing mustache invocations"] = function (assert) {
      // These are fine, because they should already be considered contextual
      // component invocations, not helper invocations
      assert.expect(0);
      (0, _index.compile)("\n        <Foo as |foo|>\n          {{foo}}\n        </Foo>", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        <Foo as |foo|>\n          {{foo bar baz}}\n        </Foo>", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test deeply nested mustache invocations"] = function (assert) {
      // These are fine, because they should already be considered contextual
      // component invocations, not helper invocations
      assert.expect(0);
      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n              {{foo}}\n            {{/each}}\n          </FooBar>\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n              {{foo bar baz}}\n            {{/each}}\n          </FooBar>\n        {{/let}}", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test block statements shadowing modifier invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <div {{foo}} />\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` modifier because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C17) ");
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <div {{foo bar baz}} />\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` modifier because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C17) "); // Not shadowed

      (0, _index.compile)("\n        {{#let foo as |foo|}}{{/let}}\n        <div {{foo}} />\n        <div {{foo bar baz}} />", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test element nodes shadowing modifier invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          <Foo as |foo|>\n            <div {{foo}} />\n          </Foo>", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` modifier because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C17) ");
      expectAssertion(function () {
        (0, _index.compile)("\n          <Foo as |foo|>\n            <div {{foo bar baz}} />\n          </Foo>", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` modifier because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L3:C17) "); // Not shadowed

      (0, _index.compile)("\n        <Foo as |foo|></Foo>\n        <div {{foo}} />\n        <div {{foo bar baz}} />", {
        moduleName: 'baz/foo-bar'
      });
    };

    _proto["@test deeply nested modifier invocations"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <FooBar as |bar|>\n              {{#each items as |baz|}}\n                <div {{foo}} />\n              {{/each}}\n            </FooBar>\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` modifier because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L5:C21) ");
      expectAssertion(function () {
        (0, _index.compile)("\n          {{#let foo as |foo|}}\n            <FooBar as |bar|>\n              {{#each items as |baz|}}\n                <div {{foo bar baz}} />\n              {{/each}}\n            </FooBar>\n          {{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "Cannot invoke the `foo` modifier because it was shadowed by a local variable (i.e. a block param) with the same name. Please rename the local variable to resolve the conflict. ('baz/foo-bar' @ L5:C21) "); // Not shadowed

      (0, _index.compile)("\n        {{#let foo as |foo|}}\n          <FooBar as |bar|>\n            {{#each items as |baz|}}\n            {{/each}}\n            <div {{baz}} />\n            <div {{baz bat}} />\n          </FooBar>\n          <div {{bar}} />\n          <div {{bar baz bat}} />\n        {{/let}}\n        <div {{foo}} />\n        <div {{foo bar baz bat}} />", {
        moduleName: 'baz/foo-bar'
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/plugins/assert-modifiers-not-in-components-test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  if (!true
  /* EMBER_GLIMMER_FORWARD_MODIFIERS_WITH_SPLATTRIBUTES */
  ) {
      (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert-modifiers-not-in-components',
      /*#__PURE__*/
      function (_AbstractTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

        function _class() {
          return _AbstractTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto["@test modifiers are not allowed in components"] = function () {
          expectAssertion(function () {
            (0, _index.compile)("<TheFoo {{bar \"something\" foo=\"else\"}}/>", {
              moduleName: 'the-foo'
            });
          }, "Passing modifiers to components require the \"ember-glimmer-forward-modifiers-with-splattributes\" canary feature, which has not been stabilized yet. See RFC #435 for details. ('the-foo' @ L1:C0) ");
          expectAssertion(function () {
            (0, _index.compile)("<this.foo {{bar \"something\" foo=\"else\"}}></this.foo>", {
              moduleName: 'the-foo'
            });
          }, "Passing modifiers to components require the \"ember-glimmer-forward-modifiers-with-splattributes\" canary feature, which has not been stabilized yet. See RFC #435 for details. ('the-foo' @ L1:C0) ");
          expectAssertion(function () {
            (0, _index.compile)("<api.foo {{bar \"something\" foo=\"else\"}}></api.foo>", {
              moduleName: 'the-foo'
            });
          }, "Passing modifiers to components require the \"ember-glimmer-forward-modifiers-with-splattributes\" canary feature, which has not been stabilized yet. See RFC #435 for details. ('the-foo' @ L1:C0) ");
          expectAssertion(function () {
            (0, _index.compile)("<@foo {{bar \"something\" foo=\"else\"}}></@foo>", {
              moduleName: 'the-foo'
            });
          }, "Passing modifiers to components require the \"ember-glimmer-forward-modifiers-with-splattributes\" canary feature, which has not been stabilized yet. See RFC #435 for details. ('the-foo' @ L1:C0) ");
          expectAssertion(function () {
            (0, _index.compile)("{{#let this.foo as |local|}}<local {{bar \"something\" foo=\"else\"}}></local>{{/let}}", {
              moduleName: 'the-foo'
            });
          }, "Passing modifiers to components require the \"ember-glimmer-forward-modifiers-with-splattributes\" canary feature, which has not been stabilized yet. See RFC #435 for details. ('the-foo' @ L1:C28) ");
          expectAssertion(function () {
            (0, _index.compile)("<Parent as |local|><local {{bar \"something\" foo=\"else\"}}></local></Parent>", {
              moduleName: 'the-foo'
            });
          }, "Passing modifiers to components require the \"ember-glimmer-forward-modifiers-with-splattributes\" canary feature, which has not been stabilized yet. See RFC #435 for details. ('the-foo' @ L1:C19) ");
        };

        return _class;
      }(_internalTestHelpers.AbstractTestCase));
    }
});
enifed("ember-template-compiler/tests/plugins/assert-reserved-named-arguments-test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert-reserved-named-arguments',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto["@test '@arguments' is reserved"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("{{@arguments}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@arguments' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if @arguments}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@arguments' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(function () {
        (0, _index.compile)("{{input type=(if @arguments \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@arguments' is reserved. ('baz/foo-bar' @ L1:C17) ");
    };

    _proto["@test '@args' is reserved"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("{{@args}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@args' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if @args}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@args' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(function () {
        (0, _index.compile)("{{input type=(if @args \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@args' is reserved. ('baz/foo-bar' @ L1:C17) ");
    };

    _proto["@test '@block' is reserved"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("{{@block}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@block' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if @block}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@block' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(function () {
        (0, _index.compile)("{{input type=(if @block \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@block' is reserved. ('baz/foo-bar' @ L1:C17) ");
    };

    _proto["@test '@else' is reserved"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("{{@else}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@else' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if @else}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@else' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(function () {
        (0, _index.compile)("{{input type=(if @else \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@else' is reserved. ('baz/foo-bar' @ L1:C17) ");
    } // anything else that doesn't start with a lower case letter
    ;

    _proto["@test '@Arguments' is reserved"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("{{@Arguments}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Arguments' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if @Arguments}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Arguments' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(function () {
        (0, _index.compile)("{{input type=(if @Arguments \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Arguments' is reserved. ('baz/foo-bar' @ L1:C17) ");
    };

    _proto["@test '@Args' is reserved"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("{{@Args}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Args' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if @Args}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Args' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(function () {
        (0, _index.compile)("{{input type=(if @Args \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Args' is reserved. ('baz/foo-bar' @ L1:C17) ");
    };

    _proto["@test '@FOO' is reserved"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("{{@FOO}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@FOO' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if @FOO}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@FOO' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(function () {
        (0, _index.compile)("{{input type=(if @FOO \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@FOO' is reserved. ('baz/foo-bar' @ L1:C17) ");
    };

    _proto["@test '@Foo' is reserved"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("{{@Foo}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Foo' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if @Foo}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Foo' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(function () {
        (0, _index.compile)("{{input type=(if @Foo \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@Foo' is reserved. ('baz/foo-bar' @ L1:C17) ");
    };

    _proto["@test '@.' is reserved"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("{{@.}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@.' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if @.}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@.' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(function () {
        (0, _index.compile)("{{input type=(if @. \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@.' is reserved. ('baz/foo-bar' @ L1:C17) ");
    };

    _proto["@test '@_' is reserved"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("{{@_}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@_' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if @_}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@_' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(function () {
        (0, _index.compile)("{{input type=(if @_ \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@_' is reserved. ('baz/foo-bar' @ L1:C17) ");
    };

    _proto["@test '@-' is reserved"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("{{@-}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@-' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if @-}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@-' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(function () {
        (0, _index.compile)("{{input type=(if @- \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@-' is reserved. ('baz/foo-bar' @ L1:C17) ");
    };

    _proto["@test '@$' is reserved"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("{{@$}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@$' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if @$}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@$' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(function () {
        (0, _index.compile)("{{input type=(if @$ \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@$' is reserved. ('baz/foo-bar' @ L1:C17) ");
    };

    _proto["@test '@__ARGS__' is reserved"] = function () {
      expectAssertion(function () {
        (0, _index.compile)("<Foo @__ARGS__=\"bar\" />", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@__ARGS__' is reserved. ('baz/foo-bar' @ L1:C5) ");
      expectAssertion(function () {
        (0, _index.compile)("{{foo __ARGS__=\"bar\"}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'__ARGS__' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#let (component \"foo\" __ARGS__=\"bar\") as |c|}}{{c}}{{/let}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'__ARGS__' is reserved. ('baz/foo-bar' @ L1:C24) ");
      expectAssertion(function () {
        (0, _index.compile)("{{@__ARGS__}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@__ARGS__' is reserved. ('baz/foo-bar' @ L1:C2) ");
      expectAssertion(function () {
        (0, _index.compile)("{{#if @__ARGS__}}Yup{{/if}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@__ARGS__' is reserved. ('baz/foo-bar' @ L1:C6) ");
      expectAssertion(function () {
        (0, _index.compile)("{{input type=(if @__ARGS__ \"bar\" \"baz\")}}", {
          moduleName: 'baz/foo-bar'
        });
      }, "'@__ARGS__' is reserved. ('baz/foo-bar' @ L1:C17) ");
    };

    _proto["@test '@' is de facto reserved (parse error)"] = function (assert) {
      assert.throws(function () {
        (0, _index.compile)('{{@}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(function () {
        (0, _index.compile)('{{#if @}}Yup{{/if}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(function () {
        (0, _index.compile)('{{input type=(if @ "bar" "baz")}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
    };

    _proto["@test '@0' is de facto reserved (parse error)"] = function (assert) {
      assert.throws(function () {
        (0, _index.compile)('{{@0}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(function () {
        (0, _index.compile)('{{#if @0}}Yup{{/if}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(function () {
        (0, _index.compile)('{{input type=(if @0 "bar" "baz")}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
    };

    _proto["@test '@1' is de facto reserved (parse error)"] = function (assert) {
      assert.throws(function () {
        (0, _index.compile)('{{@1}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(function () {
        (0, _index.compile)('{{#if @1}}Yup{{/if}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(function () {
        (0, _index.compile)('{{input type=(if @1 "bar" "baz")}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
    };

    _proto["@test '@2' is de facto reserved (parse error)"] = function (assert) {
      assert.throws(function () {
        (0, _index.compile)('{{@2}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(function () {
        (0, _index.compile)('{{#if @2}}Yup{{/if}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(function () {
        (0, _index.compile)('{{input type=(if @2 "bar" "baz")}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
    };

    _proto["@test '@@' is de facto reserved (parse error)"] = function (assert) {
      assert.throws(function () {
        (0, _index.compile)('{{@@}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(function () {
        (0, _index.compile)('{{#if @@}}Yup{{/if}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(function () {
        (0, _index.compile)('{{input type=(if @@ "bar" "baz")}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
    };

    _proto["@test '@=' is de facto reserved (parse error)"] = function (assert) {
      assert.throws(function () {
        (0, _index.compile)('{{@=}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(function () {
        (0, _index.compile)('{{#if @=}}Yup{{/if}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(function () {
        (0, _index.compile)('{{input type=(if @= "bar" "baz")}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
    };

    _proto["@test '@!' is de facto reserved (parse error)"] = function (assert) {
      assert.throws(function () {
        (0, _index.compile)('{{@!}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(function () {
        (0, _index.compile)('{{#if @!}}Yup{{/if}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
      assert.throws(function () {
        (0, _index.compile)('{{input type=(if @! "bar" "baz")}}', {
          moduleName: 'baz/foo-bar'
        });
      }, /Expecting 'ID'/);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/plugins/assert-splattribute-expression-test", ["ember-babel", "internal-test-helpers", "ember-template-compiler/index"], function (_emberBabel, _internalTestHelpers, _index) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: assert-splattribute-expression',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.expectedMessage = function expectedMessage(locInfo) {
      return "`...attributes` can only be used in the element position e.g. `<div ...attributes />`. It cannot be used as a path. (" + locInfo + ") ";
    };

    _proto['@test ...attributes is in element space'] = function testAttributesIsInElementSpace(assert) {
      assert.expect(0);
      (0, _index.compile)('<div ...attributes>Foo</div>');
    };

    _proto['@test {{...attributes}} is not valid'] = function testAttributesIsNotValid() {
      expectAssertion(function () {
        (0, _index.compile)('<div>{{...attributes}}</div>', {
          moduleName: 'foo-bar'
        });
      }, this.expectedMessage("'foo-bar' @ L1:C7"));
    };

    _proto['@test {{...attributes}} is not valid path expression'] = function testAttributesIsNotValidPathExpression() {
      expectAssertion(function () {
        (0, _index.compile)('<div>{{...attributes}}</div>', {
          moduleName: 'foo-bar'
        });
      }, this.expectedMessage("'foo-bar' @ L1:C7"));
    };

    _proto['@test {{...attributes}} is not valid modifier'] = function testAttributesIsNotValidModifier() {
      expectAssertion(function () {
        (0, _index.compile)('<div {{...attributes}}>Wat</div>', {
          moduleName: 'foo-bar'
        });
      }, this.expectedMessage("'foo-bar' @ L1:C7"));
    };

    _proto['@test {{...attributes}} is not valid attribute'] = function testAttributesIsNotValidAttribute() {
      expectAssertion(function () {
        (0, _index.compile)('<div class={{...attributes}}>Wat</div>', {
          moduleName: 'foo-bar'
        });
      }, this.expectedMessage("'foo-bar' @ L1:C13"));
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/plugins/deprecate-send-action-test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  var EVENTS = ['insert-newline', 'enter', 'escape-press', 'focus-in', 'focus-out', 'key-press', 'key-up', 'key-down'];

  var DeprecateSendActionTest =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(DeprecateSendActionTest, _AbstractTestCase);

    function DeprecateSendActionTest() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    return DeprecateSendActionTest;
  }(_internalTestHelpers.AbstractTestCase);

  EVENTS.forEach(function (e) {
    DeprecateSendActionTest.prototype["@test Using `{{input " + e + "=\"actionName\"}}` provides a deprecation"] = function () {
      var expectedMessage = "Passing actions to components as strings (like `{{input " + e + "=\"foo-bar\"}}`) is deprecated. Please use closure actions instead (`{{input " + e + "=(action \"foo-bar\")}}`). ('baz/foo-bar' @ L1:C0) ";
      expectDeprecation(function () {
        (0, _index.compile)("{{input " + e + "=\"foo-bar\"}}", {
          moduleName: 'baz/foo-bar'
        });
      }, expectedMessage);
    };
  });
  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: deprecate-send-action', DeprecateSendActionTest);
});
enifed("ember-template-compiler/tests/plugins/transform-component-invocation-test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: transforms component invocation',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Does not throw a compiler error for component invocations'] = function testDoesNotThrowACompilerErrorForComponentInvocations(assert) {
      assert.expect(0);
      ['{{this.modal open}}', '{{this.modal isOpen=true}}', '{{#this.modal}}Woot{{/this.modal}}', '{{@modal open}}', // RFC#311
      '{{@modal isOpen=true}}', // RFC#311
      '{{#@modal}}Woot{{/@modal}}', // RFC#311
      '{{c.modal open}}', '{{c.modal isOpen=true}}', '{{#c.modal}}Woot{{/c.modal}}', '{{#my-component as |c|}}{{c name="Chad"}}{{/my-component}}', // RFC#311
      '{{#my-component as |c|}}{{c "Chad"}}{{/my-component}}', // RFC#311
      '{{#my-component as |c|}}{{#c}}{{/c}}{{/my-component}}', // RFC#311
      '<input disabled={{true}}>', // GH#15740
      '<td colspan={{3}}></td>'].forEach(function (layout, i) {
        (0, _index.compile)(layout, {
          moduleName: "example-" + i
        });
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/plugins/transform-input-type-syntax-test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: input type syntax',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Can compile an {{input}} helper that has a sub-expression value as its type'] = function testCanCompileAnInputHelperThatHasASubExpressionValueAsItsType(assert) {
      assert.expect(0);
      (0, _index.compile)("{{input type=(if true 'password' 'text')}}");
    };

    _proto['@test Can compile an {{input}} helper with a string literal type'] = function testCanCompileAnInputHelperWithAStringLiteralType(assert) {
      assert.expect(0);
      (0, _index.compile)("{{input type='text'}}");
    };

    _proto['@test Can compile an {{input}} helper with a type stored in a var'] = function testCanCompileAnInputHelperWithATypeStoredInAVar(assert) {
      assert.expect(0);
      (0, _index.compile)("{{input type=_type}}");
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/plugins/transform-link-to-test", ["ember-babel", "ember-template-compiler/tests/utils/transform-test-case", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _transformTestCase, _index, _internalTestHelpers) {
  "use strict";

  if (true
  /* EMBER_GLIMMER_ANGLE_BRACKET_BUILT_INS */
  ) {
      (0, _internalTestHelpers.moduleFor)('ember-template-compiler: transforming inline {{link-to}} into the block form',
      /*#__PURE__*/
      function (_TransformTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _TransformTestCase);

        function _class() {
          return _TransformTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto['@test it transforms an inline {{link-to}} into its block form'] = function testItTransformsAnInlineLinkToIntoItsBlockForm() {
          this.assertTransformed("{{link-to 'foo' 'index'}}", "{{#link-to route='index'}}foo{{/link-to}}");
        };

        _proto['@test bound link title'] = function testBoundLinkTitle() {
          this.assertTransformed("{{link-to foo 'index'}}", "{{#link-to route='index'}}{{foo}}{{/link-to}}");
          this.assertTransformed("{{link-to this.foo 'index'}}", "{{#link-to route='index'}}{{this.foo}}{{/link-to}}");
          this.assertTransformed("{{link-to foo.bar.baz 'index'}}", "{{#link-to route='index'}}{{foo.bar.baz}}{{/link-to}}");
          this.assertTransformed("{{link-to @foo 'index'}}", "{{#link-to route='index'}}{{@foo}}{{/link-to}}");
        };

        _proto['@test sexp link title'] = function testSexpLinkTitle() {
          this.assertTransformed("{{link-to (foo) 'index'}}", "{{#link-to route='index'}}{{foo}}{{/link-to}}");
          this.assertTransformed("{{link-to (foo bar) 'index'}}", "{{#link-to route='index'}}{{foo bar}}{{/link-to}}");
          this.assertTransformed("{{link-to (foo bar baz=bat) 'index'}}", "{{#link-to route='index'}}{{foo bar baz=bat}}{{/link-to}}");
        };

        return _class;
      }(_transformTestCase.default));
      (0, _internalTestHelpers.moduleFor)('ember-template-compiler: transforming inline {{{link-to}}} into the block form',
      /*#__PURE__*/
      function (_TransformTestCase2) {
        (0, _emberBabel.inheritsLoose)(_class2, _TransformTestCase2);

        function _class2() {
          return _TransformTestCase2.apply(this, arguments) || this;
        }

        var _proto2 = _class2.prototype;

        _proto2['@test it transforms an inline {{{link-to}}} into its block form'] = function testItTransformsAnInlineLinkToIntoItsBlockForm() {
          this.assertTransformed("{{{link-to 'foo' 'index'}}}", "{{#link-to route='index'}}foo{{/link-to}}");
        };

        _proto2['@test bound link title'] = function testBoundLinkTitle() {
          this.assertTransformed("{{{link-to foo 'index'}}}", "{{#link-to route='index'}}{{{foo}}}{{/link-to}}");
          this.assertTransformed("{{{link-to this.foo 'index'}}}", "{{#link-to route='index'}}{{{this.foo}}}{{/link-to}}");
          this.assertTransformed("{{{link-to foo.bar.baz 'index'}}}", "{{#link-to route='index'}}{{{foo.bar.baz}}}{{/link-to}}");
          this.assertTransformed("{{{link-to @foo 'index'}}}", "{{#link-to route='index'}}{{{@foo}}}{{/link-to}}");
        };

        _proto2['@test sexp link title'] = function testSexpLinkTitle() {
          this.assertTransformed("{{{link-to (foo) 'index'}}}", "{{#link-to route='index'}}{{{foo}}}{{/link-to}}");
          this.assertTransformed("{{{link-to (foo bar) 'index'}}}", "{{#link-to route='index'}}{{{foo bar}}}{{/link-to}}");
          this.assertTransformed("{{{link-to (foo bar baz=bat) 'index'}}}", "{{#link-to route='index'}}{{{foo bar baz=bat}}}{{/link-to}}");
        };

        return _class2;
      }(_transformTestCase.default));
      (0, _internalTestHelpers.moduleFor)('ember-template-compiler: transforming positional arguments into named arguments',
      /*#__PURE__*/
      function (_TransformTestCase3) {
        (0, _emberBabel.inheritsLoose)(_class3, _TransformTestCase3);

        function _class3() {
          return _TransformTestCase3.apply(this, arguments) || this;
        }

        var _proto3 = _class3.prototype;

        _proto3['@test no arguments'] = function testNoArguments() {
          expectAssertion(function () {
            return (0, _index.compile)('{{#link-to}}zomg{{/link-to}}', {
              moduleName: '-top-level'
            });
          }, /You must provide one or more parameters to the `{{link-to}}` component. \('-top-level' @ L1:C0\)/);
          expectAssertion(function () {
            return (0, _index.compile)('{{#link-to class="wow"}}zomg{{/link-to}}', {
              moduleName: '-top-level'
            });
          }, /You must provide one or more parameters to the `{{link-to}}` component. \('-top-level' @ L1:C0\)/); // these are ok

          (0, _index.compile)('{{#link-to params=foo}}zomg{{/link-to}}', {
            moduleName: '-top-level'
          });
          (0, _index.compile)('{{#link-to route=foo}}zomg{{/link-to}}', {
            moduleName: '-top-level'
          });
          (0, _index.compile)('{{#link-to model=foo}}zomg{{/link-to}}', {
            moduleName: '-top-level'
          });
          (0, _index.compile)('{{#link-to models=foo}}zomg{{/link-to}}', {
            moduleName: '-top-level'
          });
          (0, _index.compile)('{{#link-to query=foo}}zomg{{/link-to}}', {
            moduleName: '-top-level'
          });
        };

        _proto3['@test mixing positional and named arguments'] = function testMixingPositionalAndNamedArguments() {
          expectAssertion(function () {
            return (0, _index.compile)('{{#link-to foo params=bar}}zomg{{/link-to}}', {
              moduleName: '-top-level'
            });
          }, /cannot pass positional parameters and the `params` argument to the `{{link-to}}` component at the same time. \('-top-level' @ L1:C0\)/);
          expectAssertion(function () {
            return (0, _index.compile)('{{#link-to foo route=bar}}zomg{{/link-to}}', {
              moduleName: '-top-level'
            });
          }, /cannot pass positional parameters and the `route` argument to the `{{link-to}}` component at the same time. \('-top-level' @ L1:C0\)/);
          expectAssertion(function () {
            return (0, _index.compile)('{{#link-to foo model=bar}}zomg{{/link-to}}', {
              moduleName: '-top-level'
            });
          }, /cannot pass positional parameters and the `model` argument to the `{{link-to}}` component at the same time. \('-top-level' @ L1:C0\)/);
          expectAssertion(function () {
            return (0, _index.compile)('{{#link-to foo models=bar}}zomg{{/link-to}}', {
              moduleName: '-top-level'
            });
          }, /cannot pass positional parameters and the `models` argument to the `{{link-to}}` component at the same time. \('-top-level' @ L1:C0\)/);
          expectAssertion(function () {
            return (0, _index.compile)('{{#link-to foo query=bar}}zomg{{/link-to}}', {
              moduleName: '-top-level'
            });
          }, /cannot pass positional parameters and the `query` argument to the `{{link-to}}` component at the same time. \('-top-level' @ L1:C0\)/);
        };

        _proto3['@test route only'] = function testRouteOnly() {
          this.assertTransformed("{{#link-to 'foo'}}Foo{{/link-to}}", "{{#link-to route='foo'}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to foo}}Foo{{/link-to}}", "{{#link-to route=foo}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to this.foo}}Foo{{/link-to}}", "{{#link-to route=this.foo}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to foo.bar.baz}}Foo{{/link-to}}", "{{#link-to route=foo.bar.baz}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to @foo}}Foo{{/link-to}}", "{{#link-to route=@foo}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to @foo}}Foo{{/link-to}}", "{{#link-to route=@foo}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to (foo)}}Foo{{/link-to}}", "{{#link-to route=(foo)}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to (foo bar)}}Foo{{/link-to}}", "{{#link-to route=(foo bar)}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to (foo bar baz=bat)}}Foo{{/link-to}}", "{{#link-to route=(foo bar baz=bat)}}Foo{{/link-to}}");
        };

        _proto3['@test single model'] = function testSingleModel() {
          this.assertTransformed("{{#link-to 'foo' 'bar'}}Foo{{/link-to}}", "{{#link-to route='foo' model='bar'}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' bar}}Foo{{/link-to}}", "{{#link-to route='foo' model=bar}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' this.bar}}Foo{{/link-to}}", "{{#link-to route='foo' model=this.bar}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' bar.baz.bat}}Foo{{/link-to}}", "{{#link-to route='foo' model=bar.baz.bat}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' @bar}}Foo{{/link-to}}", "{{#link-to route='foo' model=@bar}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' (bar)}}Foo{{/link-to}}", "{{#link-to route='foo' model=(bar)}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' (bar baz)}}Foo{{/link-to}}", "{{#link-to route='foo' model=(bar baz)}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' (bar baz bat=wat)}}Foo{{/link-to}}", "{{#link-to route='foo' model=(bar baz bat=wat)}}Foo{{/link-to}}");
        };

        _proto3['@test multi models'] = function testMultiModels() {
          this.assertTransformed("{{#link-to 'foo' 'bar' 'baz' 'bat'}}Foo{{/link-to}}", "{{#link-to route='foo' models=(array 'bar' 'baz' 'bat')}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' bar baz bat}}Foo{{/link-to}}", "{{#link-to route='foo' models=(array bar baz bat)}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' this.bar this.baz this.bat}}Foo{{/link-to}}", "{{#link-to route='foo' models=(array this.bar this.baz this.bat)}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' bar.baz.bat baz.bat.bar bat.bar.baz}}Foo{{/link-to}}", "{{#link-to route='foo' models=(array bar.baz.bat baz.bat.bar bat.bar.baz)}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' @bar @baz @bat}}Foo{{/link-to}}", "{{#link-to route='foo' models=(array @bar @baz @bat)}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' (bar) (baz) (bat)}}Foo{{/link-to}}", "{{#link-to route='foo' models=(array (bar) (baz) (bat))}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' (bar baz) (baz bat) (bat bar)}}Foo{{/link-to}}", "{{#link-to route='foo' models=(array (bar baz) (baz bat) (bat bar))}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' (bar baz bat=wat) (baz bat wat=bar) (bat wat bar=baz)}}Foo{{/link-to}}", "{{#link-to route='foo' models=(array (bar baz bat=wat) (baz bat wat=bar) (bat wat bar=baz))}}Foo{{/link-to}}");
        };

        _proto3['@test query params'] = function testQueryParams() {
          this.assertTransformed("{{#link-to (query-params)}}Foo{{/link-to}}", "{{#link-to query=(hash)}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to (query-params foo='bar' baz=bat)}}Foo{{/link-to}}", "{{#link-to query=(hash foo='bar' baz=bat)}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' (query-params foo='bar' baz=bat)}}Foo{{/link-to}}", "{{#link-to query=(hash foo='bar' baz=bat) route='foo'}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' 'bar' (query-params foo='bar' baz=bat)}}Foo{{/link-to}}", "{{#link-to query=(hash foo='bar' baz=bat) route='foo' model='bar'}}Foo{{/link-to}}");
          this.assertTransformed("{{#link-to 'foo' 'bar' 'baz' 'bat' 'wat' (query-params foo='bar' baz=bat)}}Foo{{/link-to}}", "{{#link-to query=(hash foo='bar' baz=bat) route='foo' models=(array 'bar' 'baz' 'bat' 'wat')}}Foo{{/link-to}}");
        };

        return _class3;
      }(_transformTestCase.default));
    } else {
    (0, _internalTestHelpers.moduleFor)('ember-template-compiler: transforming inline {{link-to}} into the block form',
    /*#__PURE__*/
    function (_TransformTestCase4) {
      (0, _emberBabel.inheritsLoose)(_class4, _TransformTestCase4);

      function _class4() {
        return _TransformTestCase4.apply(this, arguments) || this;
      }

      var _proto4 = _class4.prototype;

      _proto4['@test it transforms an inline {{link-to}} into its block form'] = function testItTransformsAnInlineLinkToIntoItsBlockForm() {
        this.assertTransformed("{{link-to 'foo' 'index'}}", "{{#link-to 'index'}}foo{{/link-to}}");
      };

      _proto4['@test bound link title'] = function testBoundLinkTitle() {
        this.assertTransformed("{{link-to foo 'index'}}", "{{#link-to 'index'}}{{foo}}{{/link-to}}");
        this.assertTransformed("{{link-to this.foo 'index'}}", "{{#link-to 'index'}}{{this.foo}}{{/link-to}}");
        this.assertTransformed("{{link-to foo.bar.baz 'index'}}", "{{#link-to 'index'}}{{foo.bar.baz}}{{/link-to}}");
        this.assertTransformed("{{link-to @foo 'index'}}", "{{#link-to 'index'}}{{@foo}}{{/link-to}}");
      };

      _proto4['@test sexp link title'] = function testSexpLinkTitle() {
        this.assertTransformed("{{link-to (foo) 'index'}}", "{{#link-to 'index'}}{{foo}}{{/link-to}}");
        this.assertTransformed("{{link-to (foo bar) 'index'}}", "{{#link-to 'index'}}{{foo bar}}{{/link-to}}");
        this.assertTransformed("{{link-to (foo bar baz=bat) 'index'}}", "{{#link-to 'index'}}{{foo bar baz=bat}}{{/link-to}}");
      };

      return _class4;
    }(_transformTestCase.default));
    (0, _internalTestHelpers.moduleFor)('ember-template-compiler: transforming inline {{{link-to}}} into the block form',
    /*#__PURE__*/
    function (_TransformTestCase5) {
      (0, _emberBabel.inheritsLoose)(_class5, _TransformTestCase5);

      function _class5() {
        return _TransformTestCase5.apply(this, arguments) || this;
      }

      var _proto5 = _class5.prototype;

      _proto5['@test it transforms an inline {{{link-to}}} into its block form'] = function testItTransformsAnInlineLinkToIntoItsBlockForm() {
        this.assertTransformed("{{{link-to 'foo' 'index'}}}", "{{#link-to 'index'}}foo{{/link-to}}");
      };

      _proto5['@test bound link title'] = function testBoundLinkTitle() {
        this.assertTransformed("{{{link-to foo 'index'}}}", "{{#link-to 'index'}}{{{foo}}}{{/link-to}}");
        this.assertTransformed("{{{link-to this.foo 'index'}}}", "{{#link-to 'index'}}{{{this.foo}}}{{/link-to}}");
        this.assertTransformed("{{{link-to foo.bar.baz 'index'}}}", "{{#link-to 'index'}}{{{foo.bar.baz}}}{{/link-to}}");
        this.assertTransformed("{{{link-to @foo 'index'}}}", "{{#link-to 'index'}}{{{@foo}}}{{/link-to}}");
      };

      _proto5['@test sexp link title'] = function testSexpLinkTitle() {
        this.assertTransformed("{{{link-to (foo) 'index'}}}", "{{#link-to 'index'}}{{{foo}}}{{/link-to}}");
        this.assertTransformed("{{{link-to (foo bar) 'index'}}}", "{{#link-to 'index'}}{{{foo bar}}}{{/link-to}}");
        this.assertTransformed("{{{link-to (foo bar baz=bat) 'index'}}}", "{{#link-to 'index'}}{{{foo bar baz=bat}}}{{/link-to}}");
      };

      return _class5;
    }(_transformTestCase.default));
  }
});
enifed("ember-template-compiler/tests/system/bootstrap-test", ["ember-babel", "@ember/runloop", "@ember/-internals/glimmer", "ember-template-compiler/lib/system/bootstrap", "internal-test-helpers"], function (_emberBabel, _runloop, _glimmer, _bootstrap, _internalTestHelpers) {
  "use strict";

  var component, fixture;

  function checkTemplate(templateName, assert) {
    (0, _runloop.run)(function () {
      return (0, _bootstrap.default)({
        context: fixture,
        hasTemplate: _glimmer.hasTemplate,
        setTemplate: _glimmer.setTemplate
      });
    });
    var template = (0, _glimmer.getTemplate)(templateName);
    var qunitFixture = document.querySelector('#qunit-fixture');
    assert.ok(template, 'template is available on Ember.TEMPLATES');
    assert.notOk(qunitFixture.querySelector('script'), 'script removed');
    var owner = (0, _internalTestHelpers.buildOwner)();
    owner.register('template:-top-level', template);
    owner.register('component:-top-level', _glimmer.Component.extend({
      layoutName: '-top-level',
      firstName: 'Tobias',
      drug: 'teamocil'
    }));
    component = owner.lookup('component:-top-level');
    (0, _internalTestHelpers.runAppend)(component);
    assert.equal(qunitFixture.textContent.trim(), 'Tobias takes teamocil', 'template works');
    (0, _internalTestHelpers.runDestroy)(owner);
  }

  (0, _internalTestHelpers.moduleFor)('ember-templates: bootstrap',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      fixture = document.getElementById('qunit-fixture');
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _glimmer.setTemplates)({});
      fixture = component = null;
    };

    _proto['@test template with data-template-name should add a new template to Ember.TEMPLATES'] = function testTemplateWithDataTemplateNameShouldAddANewTemplateToEmberTEMPLATES(assert) {
      fixture.innerHTML = '<script type="text/x-handlebars" data-template-name="funkyTemplate">{{firstName}} takes {{drug}}</script>';
      checkTemplate('funkyTemplate', assert);
    };

    _proto['@test template with id instead of data-template-name should add a new template to Ember.TEMPLATES'] = function testTemplateWithIdInsteadOfDataTemplateNameShouldAddANewTemplateToEmberTEMPLATES(assert) {
      fixture.innerHTML = '<script type="text/x-handlebars" id="funkyTemplate" >{{firstName}} takes {{drug}}</script>';
      checkTemplate('funkyTemplate', assert);
    };

    _proto['@test template without data-template-name or id should default to application'] = function testTemplateWithoutDataTemplateNameOrIdShouldDefaultToApplication(assert) {
      fixture.innerHTML = '<script type="text/x-handlebars">{{firstName}} takes {{drug}}</script>';
      checkTemplate('application', assert);
    } // Add this test case, only for typeof Handlebars === 'object';
    ;

    _proto[(typeof Handlebars === 'object' ? '@test' : '@skip') + " template with type text/x-raw-handlebars should be parsed"] = function (assert) {
      fixture.innerHTML = '<script type="text/x-raw-handlebars" data-template-name="funkyTemplate">{{name}}</script>';
      (0, _runloop.run)(function () {
        return (0, _bootstrap.default)({
          context: fixture,
          hasTemplate: _glimmer.hasTemplate,
          setTemplate: _glimmer.setTemplate
        });
      });
      var template = (0, _glimmer.getTemplate)('funkyTemplate');
      assert.ok(template, 'template with name funkyTemplate available'); // This won't even work with Ember templates

      assert.equal(template({
        name: 'Tobias'
      }).trim(), 'Tobias');
    };

    _proto['@test duplicated default application templates should throw exception'] = function testDuplicatedDefaultApplicationTemplatesShouldThrowException(assert) {
      fixture.innerHTML = '<script type="text/x-handlebars">first</script><script type="text/x-handlebars">second</script>';
      assert.throws(function () {
        return (0, _bootstrap.default)({
          context: fixture,
          hasTemplate: _glimmer.hasTemplate,
          setTemplate: _glimmer.setTemplate
        });
      }, /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
    };

    _proto['@test default default application template and id application template present should throw exception'] = function testDefaultDefaultApplicationTemplateAndIdApplicationTemplatePresentShouldThrowException(assert) {
      fixture.innerHTML = '<script type="text/x-handlebars">first</script><script type="text/x-handlebars" id="application">second</script>';
      assert.throws(function () {
        return (0, _bootstrap.default)({
          context: fixture,
          hasTemplate: _glimmer.hasTemplate,
          setTemplate: _glimmer.setTemplate
        });
      }, /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
    };

    _proto['@test default application template and data-template-name application template present should throw exception'] = function testDefaultApplicationTemplateAndDataTemplateNameApplicationTemplatePresentShouldThrowException(assert) {
      fixture.innerHTML = '<script type="text/x-handlebars">first</script><script type="text/x-handlebars" data-template-name="application">second</script>';
      assert.throws(function () {
        return (0, _bootstrap.default)({
          context: fixture,
          hasTemplate: _glimmer.hasTemplate,
          setTemplate: _glimmer.setTemplate
        });
      }, /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
    };

    _proto['@test duplicated template id should throw exception'] = function testDuplicatedTemplateIdShouldThrowException(assert) {
      fixture.innerHTML = '<script type="text/x-handlebars" id="funkyTemplate">first</script><script type="text/x-handlebars" id="funkyTemplate">second</script>';
      assert.throws(function () {
        return (0, _bootstrap.default)({
          context: fixture,
          hasTemplate: _glimmer.hasTemplate,
          setTemplate: _glimmer.setTemplate
        });
      }, /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
    };

    _proto['@test duplicated template data-template-name should throw exception'] = function testDuplicatedTemplateDataTemplateNameShouldThrowException(assert) {
      fixture.innerHTML = '<script type="text/x-handlebars" data-template-name="funkyTemplate">first</script><script type="text/x-handlebars" data-template-name="funkyTemplate">second</script>';
      assert.throws(function () {
        return (0, _bootstrap.default)({
          context: fixture,
          hasTemplate: _glimmer.hasTemplate,
          setTemplate: _glimmer.setTemplate
        });
      }, /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/system/compile_options_test", ["ember-babel", "ember-template-compiler/index", "internal-test-helpers"], function (_emberBabel, _index, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: default compile options',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test default options are a new copy'] = function testDefaultOptionsAreANewCopy(assert) {
      assert.notEqual((0, _index.compileOptions)(), (0, _index.compileOptions)());
    };

    _proto['@test has default AST plugins'] = function testHasDefaultASTPlugins(assert) {
      assert.expect(_index.defaultPlugins.length);
      var plugins = (0, _index.compileOptions)().plugins.ast;

      for (var i = 0; i < _index.defaultPlugins.length; i++) {
        var plugin = _index.defaultPlugins[i];
        assert.ok(plugins.indexOf(plugin) > -1, "includes " + plugin);
      }
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  var customTransformCounter = 0;

  var LegacyCustomTransform =
  /*#__PURE__*/
  function () {
    function LegacyCustomTransform(options) {
      customTransformCounter++;
      this.options = options;
      this.syntax = null;
    }

    var _proto2 = LegacyCustomTransform.prototype;

    _proto2.transform = function transform(ast) {
      var walker = new this.syntax.Walker();
      walker.visit(ast, function (node) {
        if (node.type !== 'ElementNode') {
          return;
        }

        for (var i = 0; i < node.attributes.length; i++) {
          var attribute = node.attributes[i];

          if (attribute.name === 'data-test') {
            node.attributes.splice(i, 1);
          }
        }
      });
      return ast;
    };

    return LegacyCustomTransform;
  }();

  function customTransform() {
    customTransformCounter++;
    return {
      name: 'remove-data-test',
      visitor: {
        ElementNode: function (node) {
          for (var i = 0; i < node.attributes.length; i++) {
            var attribute = node.attributes[i];

            if (attribute.name === 'data-test') {
              node.attributes.splice(i, 1);
            }
          }
        }
      }
    };
  }

  var CustomPluginsTests =
  /*#__PURE__*/
  function (_RenderingTestCase) {
    (0, _emberBabel.inheritsLoose)(CustomPluginsTests, _RenderingTestCase);

    function CustomPluginsTests() {
      return _RenderingTestCase.apply(this, arguments) || this;
    }

    var _proto3 = CustomPluginsTests.prototype;

    _proto3.afterEach = function afterEach() {
      customTransformCounter = 0;
      return _RenderingTestCase.prototype.afterEach.call(this);
    };

    _proto3['@test custom plugins can be used'] = function testCustomPluginsCanBeUsed() {
      this.render('<div data-test="foo" data-blah="derp" class="hahaha"></div>');
      this.assertElement(this.firstChild, {
        tagName: 'div',
        attrs: {
          class: 'hahaha',
          'data-blah': 'derp'
        },
        content: ''
      });
    };

    _proto3['@test wrapped plugins are only invoked once per template'] = function testWrappedPluginsAreOnlyInvokedOncePerTemplate(assert) {
      this.render('<div>{{#if falsey}}nope{{/if}}</div>');
      assert.equal(customTransformCounter, 1, 'transform should only be instantiated once');
    };

    return CustomPluginsTests;
  }(_internalTestHelpers.RenderingTestCase);

  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: registerPlugin with a custom plugins in legacy format',
  /*#__PURE__*/
  function (_CustomPluginsTests) {
    (0, _emberBabel.inheritsLoose)(_class2, _CustomPluginsTests);

    function _class2() {
      return _CustomPluginsTests.apply(this, arguments) || this;
    }

    var _proto4 = _class2.prototype;

    _proto4.beforeEach = function beforeEach() {
      (0, _index.registerPlugin)('ast', LegacyCustomTransform);
    };

    _proto4.afterEach = function afterEach() {
      (0, _index.unregisterPlugin)('ast', LegacyCustomTransform);
      return _CustomPluginsTests.prototype.afterEach.call(this);
    };

    _proto4['@test custom registered plugins are deduplicated'] = function testCustomRegisteredPluginsAreDeduplicated(assert) {
      (0, _index.registerPlugin)('ast', LegacyCustomTransform);
      this.registerTemplate('application', '<div data-test="foo" data-blah="derp" class="hahaha"></div>');
      assert.equal(customTransformCounter, 1, 'transform should only be instantiated once');
    };

    return _class2;
  }(CustomPluginsTests));
  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: registerPlugin with a custom plugins',
  /*#__PURE__*/
  function (_CustomPluginsTests2) {
    (0, _emberBabel.inheritsLoose)(_class3, _CustomPluginsTests2);

    function _class3() {
      return _CustomPluginsTests2.apply(this, arguments) || this;
    }

    var _proto5 = _class3.prototype;

    _proto5.beforeEach = function beforeEach() {
      (0, _index.registerPlugin)('ast', customTransform);
    };

    _proto5.afterEach = function afterEach() {
      (0, _index.unregisterPlugin)('ast', customTransform);
      return _CustomPluginsTests2.prototype.afterEach.call(this);
    };

    _proto5['@test custom registered plugins are deduplicated'] = function testCustomRegisteredPluginsAreDeduplicated(assert) {
      (0, _index.registerPlugin)('ast', customTransform);
      this.registerTemplate('application', '<div data-test="foo" data-blah="derp" class="hahaha"></div>');
      assert.equal(customTransformCounter, 1, 'transform should only be instantiated once');
    };

    return _class3;
  }(CustomPluginsTests));
  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: custom plugins in legacy format passed to compile',
  /*#__PURE__*/
  function (_RenderingTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class4, _RenderingTestCase2);

    function _class4() {
      return _RenderingTestCase2.apply(this, arguments) || this;
    }

    var _proto6 = _class4.prototype; // override so that we can provide custom AST plugins to compile

    _proto6.compile = function compile(templateString) {
      return (0, _index.compile)(templateString, {
        plugins: {
          ast: [LegacyCustomTransform]
        }
      });
    };

    return _class4;
  }(_internalTestHelpers.RenderingTestCase));
  (0, _internalTestHelpers.moduleFor)('ember-template-compiler: custom plugins passed to compile',
  /*#__PURE__*/
  function (_RenderingTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class5, _RenderingTestCase3);

    function _class5() {
      return _RenderingTestCase3.apply(this, arguments) || this;
    }

    var _proto7 = _class5.prototype; // override so that we can provide custom AST plugins to compile

    _proto7.compile = function compile(templateString) {
      return (0, _index.compile)(templateString, {
        plugins: {
          ast: [customTransform]
        }
      });
    };

    return _class5;
  }(_internalTestHelpers.RenderingTestCase));
});
enifed("ember-template-compiler/tests/system/dasherize-component-name-test", ["ember-babel", "ember-template-compiler/lib/system/dasherize-component-name", "internal-test-helpers"], function (_emberBabel, _dasherizeComponentName, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('dasherize-component-name',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test names are correctly dasherized'] = function testNamesAreCorrectlyDasherized(assert) {
      assert.equal(_dasherizeComponentName.default.get('Foo'), 'foo');
      assert.equal(_dasherizeComponentName.default.get('foo-bar'), 'foo-bar');
      assert.equal(_dasherizeComponentName.default.get('FooBar'), 'foo-bar');
      assert.equal(_dasherizeComponentName.default.get('F3Bar'), 'f3-bar');
      assert.equal(_dasherizeComponentName.default.get('Foo3Bar'), 'foo3-bar');
      assert.equal(_dasherizeComponentName.default.get('Foo3barBaz'), 'foo3bar-baz');
      assert.equal(_dasherizeComponentName.default.get('FooB3ar'), 'foo-b3ar');
      assert.equal(_dasherizeComponentName.default.get('XBlah'), 'x-blah');
      assert.equal(_dasherizeComponentName.default.get('X-Blah'), 'x-blah');
      assert.equal(_dasherizeComponentName.default.get('Foo@BarBaz'), 'foo@bar-baz');
      assert.equal(_dasherizeComponentName.default.get('Foo@Bar-Baz'), 'foo@bar-baz');

      if (true
      /* EMBER_GLIMMER_ANGLE_BRACKET_NESTED_LOOKUP */
      ) {
          assert.equal(_dasherizeComponentName.default.get('Foo::BarBaz'), 'foo/bar-baz');
          assert.equal(_dasherizeComponentName.default.get('Foo::Bar-Baz'), 'foo/bar-baz');
          assert.equal(_dasherizeComponentName.default.get('Foo::BarBaz::Bang'), 'foo/bar-baz/bang');
        } else {
        assert.equal(_dasherizeComponentName.default.get('Foo::BarBaz'), 'foo::bar-baz');
        assert.equal(_dasherizeComponentName.default.get('Foo::Bar-Baz'), 'foo::bar-baz');
      }
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-template-compiler/tests/utils/transform-test-case", ["exports", "ember-babel", "@glimmer/compiler", "internal-test-helpers", "ember-template-compiler/index"], function (_exports, _emberBabel, _compiler, _internalTestHelpers, _index) {
  "use strict";

  _exports.default = void 0;

  var _default =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_default, _AbstractTestCase);

    function _default() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _default.prototype;

    _proto.assertTransformed = function assertTransformed(before, after) {
      this.assert.deepEqual(deloc(ast(before)), deloc(ast(after)));
    };

    return _default;
  }(_internalTestHelpers.AbstractTestCase);

  _exports.default = _default;

  function ast(template) {
    var program = null;

    function extractProgram() {
      return {
        name: 'extract-program',
        visitor: {
          Program: {
            exit: function (node) {
              program = clone(node);
            }
          }
        }
      };
    }

    var options = (0, _index.compileOptions)({
      moduleName: '-top-level'
    });
    options.plugins.ast.push(extractProgram);
    (0, _compiler.precompile)(template, options);
    return program;
  }

  function clone(node) {
    var out = Object.create(null);
    var keys = Object.keys(node);
    keys.forEach(function (key) {
      var value = node[key];

      if (value !== null && typeof value === 'object') {
        out[key] = clone(value);
      } else {
        out[key] = value;
      }
    });
    return out;
  }

  function deloc(node) {
    var out = Object.create(null);
    var keys = Object.keys(node);
    keys.forEach(function (key) {
      var value = node[key];

      if (key === 'loc') {
        return;
      } else if (value !== null && typeof value === 'object') {
        out[key] = deloc(value);
      } else {
        out[key] = value;
      }
    });
    return out;
  }
});
enifed("ember-testing/tests/acceptance_test", ["ember-babel", "internal-test-helpers", "@ember/runloop", "ember-testing/lib/test", "ember-testing/lib/adapters/qunit", "@ember/-internals/routing", "@ember/-internals/runtime", "@ember/-internals/views", "@ember/debug"], function (_emberBabel, _internalTestHelpers, _runloop, _test, _qunit, _routing, _runtime, _views, _debug) {
  "use strict";

  var originalDebug = (0, _debug.getDebugFunction)('debug');
  var originalConsoleError = console.error; // eslint-disable-line no-console

  var testContext;

  if (!_views.jQueryDisabled) {
    (0, _internalTestHelpers.moduleFor)('ember-testing Acceptance',
    /*#__PURE__*/
    function (_AutobootApplicationT) {
      (0, _emberBabel.inheritsLoose)(_class, _AutobootApplicationT);

      function _class() {
        var _this;

        (0, _debug.setDebugFunction)('debug', function () {});
        _this = _AutobootApplicationT.call(this) || this;
        _this._originalAdapter = _test.default.adapter;
        testContext = (0, _emberBabel.assertThisInitialized)(_this);
        (0, _internalTestHelpers.runTask)(function () {
          _this.createApplication();

          _this.router.map(function () {
            this.route('posts');
            this.route('comments');
            this.route('abort_transition');
            this.route('redirect');
          });

          _this.indexHitCount = 0;
          _this.currentRoute = 'index';

          _this.add('route:index', _routing.Route.extend({
            model: function () {
              testContext.indexHitCount += 1;
            }
          }));

          _this.add('route:posts', _routing.Route.extend({
            renderTemplate: function () {
              testContext.currentRoute = 'posts';

              this._super.apply(this, arguments);
            }
          }));

          _this.addTemplate('posts', "\n          <div class=\"posts-view\">\n            <a class=\"dummy-link\"></a>\n            <div id=\"comments-link\">\n              {{#link-to 'comments'}}Comments{{/link-to}}\n            </div>\n          </div>\n        ");

          _this.add('route:comments', _routing.Route.extend({
            renderTemplate: function () {
              testContext.currentRoute = 'comments';

              this._super.apply(this, arguments);
            }
          }));

          _this.addTemplate('comments', "<div>{{input type=\"text\"}}</div>");

          _this.add('route:abort_transition', _routing.Route.extend({
            beforeModel: function (transition) {
              transition.abort();
            }
          }));

          _this.add('route:redirect', _routing.Route.extend({
            beforeModel: function () {
              this.transitionTo('comments');
            }
          }));

          _this.application.setupForTesting();

          _test.default.registerAsyncHelper('slowHelper', function () {
            return new _runtime.RSVP.Promise(function (resolve) {
              return (0, _runloop.later)(resolve, 10);
            });
          });

          _this.application.injectTestHelpers();
        });
        return _this;
      }

      var _proto = _class.prototype;

      _proto.afterEach = function afterEach() {
        console.error = originalConsoleError; // eslint-disable-line no-console

        _AutobootApplicationT.prototype.afterEach.call(this);
      };

      _proto.teardown = function teardown() {
        (0, _debug.setDebugFunction)('debug', originalDebug);
        _test.default.adapter = this._originalAdapter;

        _test.default.unregisterHelper('slowHelper');

        window.slowHelper = undefined;
        testContext = undefined;

        _AutobootApplicationT.prototype.teardown.call(this);
      };

      _proto["@test helpers can be chained with then"] = function (assert) {
        var _this2 = this;

        assert.expect(6);
        window.visit('/posts').then(function () {
          assert.equal(_this2.currentRoute, 'posts', 'Successfully visited posts route');
          assert.equal(window.currentURL(), '/posts', 'posts URL is correct');
          return window.click('a:contains("Comments")');
        }).then(function () {
          assert.equal(_this2.currentRoute, 'comments', 'visit chained with click');
          return window.fillIn('.ember-text-field', 'yeah');
        }).then(function () {
          assert.equal(document.querySelector('.ember-text-field').value, 'yeah', 'chained with fillIn');
          return window.fillIn('.ember-text-field', '#qunit-fixture', 'context working');
        }).then(function () {
          assert.equal(document.querySelector('.ember-text-field').value, 'context working', 'chained with fillIn');
          return window.click('.does-not-exist');
        }).catch(function (e) {
          assert.equal(e.message, 'Element .does-not-exist not found.', 'Non-existent click exception caught');
        });
      };

      _proto["@test helpers can be chained to each other (legacy)"] = function (assert) {
        var _this3 = this;

        assert.expect(7);
        window.visit('/posts').click('a:first', '#comments-link').fillIn('.ember-text-field', 'hello').then(function () {
          assert.equal(_this3.currentRoute, 'comments', 'Successfully visited comments route');
          assert.equal(window.currentURL(), '/comments', 'Comments URL is correct');
          assert.equal(document.querySelector('.ember-text-field').value, 'hello', 'Fillin successfully works');
          window.find('.ember-text-field').one('keypress', function (e) {
            assert.equal(e.keyCode, 13, 'keyevent chained with correct keyCode.');
            assert.equal(e.which, 13, 'keyevent chained with correct which.');
          });
        }).keyEvent('.ember-text-field', 'keypress', 13).visit('/posts').then(function () {
          assert.equal(_this3.currentRoute, 'posts', 'Thens can also be chained to helpers');
          assert.equal(window.currentURL(), '/posts', 'URL is set correct on chained helpers');
        });
      };

      _proto["@test helpers don't need to be chained"] = function (assert) {
        var _this4 = this;

        assert.expect(5);
        window.visit('/posts');
        window.click('a:first', '#comments-link');
        window.fillIn('.ember-text-field', 'hello');
        window.andThen(function () {
          assert.equal(_this4.currentRoute, 'comments', 'Successfully visited comments route');
          assert.equal(window.currentURL(), '/comments', 'Comments URL is correct');
          assert.equal(window.find('.ember-text-field').val(), 'hello', 'Fillin successfully works');
        });
        window.visit('/posts');
        window.andThen(function () {
          assert.equal(_this4.currentRoute, 'posts');
          assert.equal(window.currentURL(), '/posts');
        });
      };

      _proto["@test Nested async helpers"] = function (assert) {
        var _this5 = this;

        assert.expect(5);
        window.visit('/posts');
        window.andThen(function () {
          window.click('a:first', '#comments-link');
          window.fillIn('.ember-text-field', 'hello');
        });
        window.andThen(function () {
          assert.equal(_this5.currentRoute, 'comments', 'Successfully visited comments route');
          assert.equal(window.currentURL(), '/comments', 'Comments URL is correct');
          assert.equal(window.find('.ember-text-field').val(), 'hello', 'Fillin successfully works');
        });
        window.visit('/posts');
        window.andThen(function () {
          assert.equal(_this5.currentRoute, 'posts');
          assert.equal(window.currentURL(), '/posts');
        });
      };

      _proto["@test Multiple nested async helpers"] = function (assert) {
        var _this6 = this;

        assert.expect(3);
        window.visit('/posts');
        window.andThen(function () {
          window.click('a:first', '#comments-link');
          window.fillIn('.ember-text-field', 'hello');
          window.fillIn('.ember-text-field', 'goodbye');
        });
        window.andThen(function () {
          assert.equal(window.find('.ember-text-field').val(), 'goodbye', 'Fillin successfully works');
          assert.equal(_this6.currentRoute, 'comments', 'Successfully visited comments route');
          assert.equal(window.currentURL(), '/comments', 'Comments URL is correct');
        });
      };

      _proto["@test Helpers nested in thens"] = function (assert) {
        var _this7 = this;

        assert.expect(5);
        window.visit('/posts').then(function () {
          window.click('a:first', '#comments-link');
        });
        window.andThen(function () {
          window.fillIn('.ember-text-field', 'hello');
        });
        window.andThen(function () {
          assert.equal(_this7.currentRoute, 'comments', 'Successfully visited comments route');
          assert.equal(window.currentURL(), '/comments', 'Comments URL is correct');
          assert.equal(window.find('.ember-text-field').val(), 'hello', 'Fillin successfully works');
        });
        window.visit('/posts');
        window.andThen(function () {
          assert.equal(_this7.currentRoute, 'posts');
          assert.equal(window.currentURL(), '/posts', 'Posts URL is correct');
        });
      };

      _proto["@test Aborted transitions are not logged via Ember.Test.adapter#exception"] = function (assert) {
        assert.expect(0);
        _test.default.adapter = _qunit.default.create({
          exception: function () {
            assert.ok(false, 'aborted transitions are not logged');
          }
        });
        window.visit('/abort_transition');
      };

      _proto["@test Unhandled exceptions are logged via Ember.Test.adapter#exception"] = function (assert) {
        assert.expect(2);

        console.error = function () {}; // eslint-disable-line no-console


        var asyncHandled;
        _test.default.adapter = _qunit.default.create({
          exception: function (error) {
            assert.equal(error.message, 'Element .does-not-exist not found.', 'Exception successfully caught and passed to Ember.Test.adapter.exception'); // handle the rejection so it doesn't leak later.

            asyncHandled.catch(function () {});
          }
        });
        window.visit('/posts');
        window.click('.invalid-element').catch(function (error) {
          assert.equal(error.message, 'Element .invalid-element not found.', 'Exception successfully handled in the rejection handler');
        });
        asyncHandled = window.click('.does-not-exist');
      };

      _proto["@test Unhandled exceptions in 'andThen' are logged via Ember.Test.adapter#exception"] = function (assert) {
        assert.expect(1);

        console.error = function () {}; // eslint-disable-line no-console


        _test.default.adapter = _qunit.default.create({
          exception: function (error) {
            assert.equal(error.message, 'Catch me', 'Exception successfully caught and passed to Ember.Test.adapter.exception');
          }
        });
        window.visit('/posts');
        window.andThen(function () {
          throw new Error('Catch me');
        });
      };

      _proto["@test should not start routing on the root URL when visiting another"] = function (assert) {
        var _this8 = this;

        assert.expect(4);
        window.visit('/posts');
        window.andThen(function () {
          assert.ok(window.find('#comments-link'), 'found comments-link');
          assert.equal(_this8.currentRoute, 'posts', 'Successfully visited posts route');
          assert.equal(window.currentURL(), '/posts', 'Posts URL is correct');
          assert.equal(_this8.indexHitCount, 0, 'should not hit index route when visiting another route');
        });
      };

      _proto["@test only enters the index route once when visiting "] = function (assert) {
        var _this9 = this;

        assert.expect(1);
        window.visit('/');
        window.andThen(function () {
          assert.equal(_this9.indexHitCount, 1, 'should hit index once when visiting /');
        });
      };

      _proto["@test test must not finish while asyncHelpers are pending"] = function (assert) {
        assert.expect(2);
        var async = 0;
        var innerRan = false;
        _test.default.adapter = _qunit.default.extend({
          asyncStart: function () {
            async++;

            this._super();
          },
          asyncEnd: function () {
            async--;

            this._super();
          }
        }).create();
        this.application.testHelpers.slowHelper();
        window.andThen(function () {
          innerRan = true;
        });
        assert.equal(innerRan, false, 'should not have run yet');
        assert.ok(async > 0, 'should have told the adapter to pause');

        if (async === 0) {
          // If we failed the test, prevent zalgo from escaping and breaking
          // our other tests.
          _test.default.adapter.asyncStart();

          _test.default.resolve().then(function () {
            _test.default.adapter.asyncEnd();
          });
        }
      };

      _proto["@test visiting a URL that causes another transition should yield the correct URL"] = function (assert) {
        assert.expect(1);
        window.visit('/redirect');
        window.andThen(function () {
          assert.equal(window.currentURL(), '/comments', 'Redirected to Comments URL');
        });
      };

      _proto["@test visiting a URL and then visiting a second URL with a transition should yield the correct URL"] = function (assert) {
        assert.expect(2);
        window.visit('/posts');
        window.andThen(function () {
          assert.equal(window.currentURL(), '/posts', 'First visited URL is correct');
        });
        window.visit('/redirect');
        window.andThen(function () {
          assert.equal(window.currentURL(), '/comments', 'Redirected to Comments URL');
        });
      };

      return _class;
    }(_internalTestHelpers.AutobootApplicationTestCase));
    (0, _internalTestHelpers.moduleFor)('ember-testing Acceptance - teardown',
    /*#__PURE__*/
    function (_AutobootApplicationT2) {
      (0, _emberBabel.inheritsLoose)(_class2, _AutobootApplicationT2);

      function _class2() {
        return _AutobootApplicationT2.apply(this, arguments) || this;
      }

      var _proto2 = _class2.prototype;

      _proto2["@test that the setup/teardown happens correctly"] = function (assert) {
        var _this10 = this;

        assert.expect(2);
        (0, _internalTestHelpers.runTask)(function () {
          _this10.createApplication();
        });
        this.application.injectTestHelpers();
        assert.ok(typeof _test.default.Promise.prototype.click === 'function');
        (0, _internalTestHelpers.runTask)(function () {
          _this10.application.destroy();
        });
        assert.equal(_test.default.Promise.prototype.click, undefined);
      };

      return _class2;
    }(_internalTestHelpers.AutobootApplicationTestCase));
  }
});
enifed("ember-testing/tests/adapters/adapter_test", ["ember-babel", "@ember/runloop", "ember-testing/lib/adapters/adapter", "internal-test-helpers"], function (_emberBabel, _runloop, _adapter, _internalTestHelpers) {
  "use strict";

  var adapter;
  (0, _internalTestHelpers.moduleFor)('ember-testing Adapter',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      adapter = _adapter.default.create();
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _runloop.run)(adapter, adapter.destroy);
    };

    _proto['@test exception throws'] = function testExceptionThrows(assert) {
      var error = 'Hai';
      var thrown;

      try {
        adapter.exception(error);
      } catch (e) {
        thrown = e;
      }

      assert.equal(thrown, error);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-testing/tests/adapters/qunit_test", ["ember-babel", "@ember/runloop", "ember-testing/lib/adapters/qunit", "internal-test-helpers"], function (_emberBabel, _runloop, _qunit, _internalTestHelpers) {
  "use strict";

  var adapter;
  (0, _internalTestHelpers.moduleFor)('ember-testing QUnitAdapter: QUnit 2.x',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      _this.originalStart = QUnit.start;
      _this.originalStop = QUnit.stop;
      delete QUnit.start;
      delete QUnit.stop;
      adapter = _qunit.default.create();
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _runloop.run)(adapter, adapter.destroy);
      QUnit.start = this.originalStart;
      QUnit.stop = this.originalStop;
    };

    _proto['@test asyncStart waits for asyncEnd to finish a test'] = function testAsyncStartWaitsForAsyncEndToFinishATest(assert) {
      adapter.asyncStart();
      setTimeout(function () {
        assert.ok(true);
        adapter.asyncEnd();
      }, 50);
    };

    _proto['@test asyncStart waits for equal numbers of asyncEnd to finish a test'] = function testAsyncStartWaitsForEqualNumbersOfAsyncEndToFinishATest(assert) {
      var adapter = _qunit.default.create();

      adapter.asyncStart();
      adapter.asyncStart();
      adapter.asyncEnd();
      setTimeout(function () {
        assert.ok(true);
        adapter.asyncEnd();
      }, 50);
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-testing/tests/adapters_test", ["ember-babel", "@ember/runloop", "@ember/-internals/error-handling", "ember-testing/lib/test", "ember-testing/lib/adapters/adapter", "ember-testing/lib/adapters/qunit", "@ember/application", "internal-test-helpers", "@ember/-internals/runtime", "@ember/debug"], function (_emberBabel, _runloop, _errorHandling, _test, _adapter, _qunit, _application, _internalTestHelpers, _runtime, _debug) {
  "use strict";

  var HAS_UNHANDLED_REJECTION_HANDLER = 'onunhandledrejection' in window;
  var originalDebug = (0, _debug.getDebugFunction)('debug');

  var noop = function () {};

  var App, originalAdapter, originalQUnit, originalWindowOnerror, originalQUnitUnhandledRejection;
  var originalConsoleError = console.error; // eslint-disable-line no-console

  function runThatThrowsSync() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Error for testing error handling';
    return (0, _runloop.run)(function () {
      throw new Error(message);
    });
  }

  function runThatThrowsAsync() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Error for testing error handling';
    return (0, _runloop.next)(function () {
      throw new Error(message);
    });
  }

  var AdapterSetupAndTearDown =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(AdapterSetupAndTearDown, _AbstractTestCase);

    function AdapterSetupAndTearDown() {
      var _this;

      (0, _debug.setDebugFunction)('debug', noop);
      _this = _AbstractTestCase.call(this) || this;
      originalAdapter = _test.default.adapter;
      originalQUnit = QUnit;
      originalWindowOnerror = window.onerror;
      originalQUnitUnhandledRejection = QUnit.onUnhandledRejection;
      return _this;
    }

    var _proto = AdapterSetupAndTearDown.prototype;

    _proto.afterEach = function afterEach() {
      _AbstractTestCase.prototype.afterEach.call(this);

      (0, _debug.setDebugFunction)('debug', originalDebug);

      if (App) {
        (0, _runloop.run)(App, App.destroy);
        App.removeTestHelpers();
        App = null;
      }

      _test.default.adapter = originalAdapter;
      window.QUnit = originalQUnit;
      window.onerror = originalWindowOnerror;
      (0, _errorHandling.setOnerror)(undefined);
      console.error = originalConsoleError; // eslint-disable-line no-console

      QUnit.onUnhandledRejection = originalQUnitUnhandledRejection;
    };

    return AdapterSetupAndTearDown;
  }(_internalTestHelpers.AbstractTestCase);

  (0, _internalTestHelpers.moduleFor)('ember-testing Adapters',
  /*#__PURE__*/
  function (_AdapterSetupAndTearD) {
    (0, _emberBabel.inheritsLoose)(_class, _AdapterSetupAndTearD);

    function _class() {
      return _AdapterSetupAndTearD.apply(this, arguments) || this;
    }

    var _proto2 = _class.prototype;

    _proto2['@test Setting a test adapter manually'] = function testSettingATestAdapterManually(assert) {
      assert.expect(1);
      var CustomAdapter;
      CustomAdapter = _adapter.default.extend({
        asyncStart: function () {
          assert.ok(true, 'Correct adapter was used');
        }
      });
      (0, _runloop.run)(function () {
        App = _application.default.create();
        _test.default.adapter = CustomAdapter.create();
        App.setupForTesting();
      });

      _test.default.adapter.asyncStart();
    };

    _proto2['@test QUnitAdapter is used by default (if QUnit is available)'] = function testQUnitAdapterIsUsedByDefaultIfQUnitIsAvailable(assert) {
      assert.expect(1);
      _test.default.adapter = null;
      (0, _runloop.run)(function () {
        App = _application.default.create();
        App.setupForTesting();
      });
      assert.ok(_test.default.adapter instanceof _qunit.default);
    };

    _proto2['@test Adapter is used by default (if QUnit is not available)'] = function testAdapterIsUsedByDefaultIfQUnitIsNotAvailable(assert) {
      assert.expect(2);
      delete window.QUnit;
      _test.default.adapter = null;
      (0, _runloop.run)(function () {
        App = _application.default.create();
        App.setupForTesting();
      });
      assert.ok(_test.default.adapter instanceof _adapter.default);
      assert.ok(!(_test.default.adapter instanceof _qunit.default));
    };

    _proto2['@test With Ember.Test.adapter set, errors in synchronous Ember.run are bubbled out'] = function testWithEmberTestAdapterSetErrorsInSynchronousEmberRunAreBubbledOut(assert) {
      var thrown = new Error('Boom!');
      var caughtInAdapter, caughtInCatch;
      _test.default.adapter = _qunit.default.create({
        exception: function (error) {
          caughtInAdapter = error;
        }
      });

      try {
        (0, _runloop.run)(function () {
          throw thrown;
        });
      } catch (e) {
        caughtInCatch = e;
      }

      assert.equal(caughtInAdapter, undefined, 'test adapter should never receive synchronous errors');
      assert.equal(caughtInCatch, thrown, 'a "normal" try/catch should catch errors in sync run');
    };

    _proto2['@test when both Ember.onerror (which rethrows) and TestAdapter are registered - sync run'] = function testWhenBothEmberOnerrorWhichRethrowsAndTestAdapterAreRegisteredSyncRun(assert) {
      assert.expect(2);
      _test.default.adapter = {
        exception: function () {
          assert.notOk(true, 'adapter is not called for errors thrown in sync run loops');
        }
      };
      (0, _errorHandling.setOnerror)(function (error) {
        assert.ok(true, 'onerror is called for sync errors even if TestAdapter is setup');
        throw error;
      });
      assert.throws(runThatThrowsSync, Error, 'error is thrown');
    };

    _proto2['@test when both Ember.onerror (which does not rethrow) and TestAdapter are registered - sync run'] = function testWhenBothEmberOnerrorWhichDoesNotRethrowAndTestAdapterAreRegisteredSyncRun(assert) {
      assert.expect(2);
      _test.default.adapter = {
        exception: function () {
          assert.notOk(true, 'adapter is not called for errors thrown in sync run loops');
        }
      };
      (0, _errorHandling.setOnerror)(function () {
        assert.ok(true, 'onerror is called for sync errors even if TestAdapter is setup');
      });
      runThatThrowsSync();
      assert.ok(true, 'no error was thrown, Ember.onerror can intercept errors');
    };

    _proto2['@test when TestAdapter is registered and error is thrown - async run'] = function testWhenTestAdapterIsRegisteredAndErrorIsThrownAsyncRun(assert) {
      assert.expect(3);
      var done = assert.async();
      var caughtInAdapter, caughtInCatch, caughtByWindowOnerror;
      _test.default.adapter = {
        exception: function (error) {
          caughtInAdapter = error;
        }
      };

      window.onerror = function (message) {
        caughtByWindowOnerror = message; // prevent "bubbling" and therefore failing the test

        return true;
      };

      try {
        runThatThrowsAsync();
      } catch (e) {
        caughtInCatch = e;
      }

      setTimeout(function () {
        assert.equal(caughtInAdapter, undefined, 'test adapter should never catch errors in run loops');
        assert.equal(caughtInCatch, undefined, 'a "normal" try/catch should never catch errors in an async run');
        assert.pushResult({
          result: /Error for testing error handling/.test(caughtByWindowOnerror),
          actual: caughtByWindowOnerror,
          expected: 'to include `Error for testing error handling`',
          message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
        });
        done();
      }, 20);
    };

    _proto2['@test when both Ember.onerror and TestAdapter are registered - async run'] = function testWhenBothEmberOnerrorAndTestAdapterAreRegisteredAsyncRun(assert) {
      assert.expect(1);
      var done = assert.async();
      _test.default.adapter = {
        exception: function () {
          assert.notOk(true, 'Adapter.exception is not called for errors thrown in next');
        }
      };
      (0, _errorHandling.setOnerror)(function () {
        assert.ok(true, 'onerror is invoked for errors thrown in next/later');
      });
      runThatThrowsAsync();
      setTimeout(done, 10);
    };

    return _class;
  }(AdapterSetupAndTearDown));

  function testAdapter(message, generatePromise) {
    var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
    return (
      /*#__PURE__*/
      function (_AdapterSetupAndTearD2) {
        (0, _emberBabel.inheritsLoose)(PromiseFailureTests, _AdapterSetupAndTearD2);

        function PromiseFailureTests() {
          return _AdapterSetupAndTearD2.apply(this, arguments) || this;
        }

        var _proto3 = PromiseFailureTests.prototype;

        _proto3["@test " + message + " when TestAdapter without `exception` method is present - rsvp"] = function (assert) {
          if (!HAS_UNHANDLED_REJECTION_HANDLER) {
            assert.expect(0);
            return;
          }

          assert.expect(1);
          var thrown = new Error('the error');
          _test.default.adapter = _qunit.default.create({
            exception: undefined
          }); // prevent QUnit handler from failing test

          QUnit.onUnhandledRejection = function () {};

          window.onunhandledrejection = function (rejection) {
            assert.pushResult({
              result: /the error/.test(rejection.reason),
              actual: rejection.reason,
              expected: 'to include `the error`',
              message: 'error should bubble out to window.onunhandledrejection, and therefore fail tests (due to QUnit implementing window.onunhandledrejection)'
            }); // prevent "bubbling" and therefore failing the test

            return true;
          };

          generatePromise(thrown); // RSVP.Promise's are configured to settle within the run loop, this
          // ensures that run loop has completed

          return new _runtime.RSVP.Promise(function (resolve) {
            return setTimeout(resolve, timeout);
          });
        };

        _proto3["@test " + message + " when both Ember.onerror and TestAdapter without `exception` method are present - rsvp"] = function (assert) {
          assert.expect(1);
          var thrown = new Error('the error');
          _test.default.adapter = _qunit.default.create({
            exception: undefined
          });
          (0, _errorHandling.setOnerror)(function (error) {
            assert.pushResult({
              result: /the error/.test(error.message),
              actual: error.message,
              expected: 'to include `the error`',
              message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
            });
          });
          generatePromise(thrown); // RSVP.Promise's are configured to settle within the run loop, this
          // ensures that run loop has completed

          return new _runtime.RSVP.Promise(function (resolve) {
            return setTimeout(resolve, timeout);
          });
        };

        _proto3["@test " + message + " when TestAdapter is present - rsvp"] = function (assert) {
          assert.expect(1);

          console.error = function () {}; // eslint-disable-line no-console


          var thrown = new Error('the error');
          _test.default.adapter = _qunit.default.create({
            exception: function (error) {
              assert.strictEqual(error, thrown, 'Adapter.exception is called for errors thrown in RSVP promises');
            }
          });
          generatePromise(thrown); // RSVP.Promise's are configured to settle within the run loop, this
          // ensures that run loop has completed

          return new _runtime.RSVP.Promise(function (resolve) {
            return setTimeout(resolve, timeout);
          });
        };

        _proto3["@test " + message + " when both Ember.onerror and TestAdapter are present - rsvp"] = function (assert) {
          assert.expect(1);
          var thrown = new Error('the error');
          _test.default.adapter = _qunit.default.create({
            exception: function (error) {
              assert.strictEqual(error, thrown, 'Adapter.exception is called for errors thrown in RSVP promises');
            }
          });
          (0, _errorHandling.setOnerror)(function () {
            assert.notOk(true, 'Ember.onerror is not called if Test.adapter does not rethrow');
          });
          generatePromise(thrown); // RSVP.Promise's are configured to settle within the run loop, this
          // ensures that run loop has completed

          return new _runtime.RSVP.Promise(function (resolve) {
            return setTimeout(resolve, timeout);
          });
        };

        _proto3["@test " + message + " when both Ember.onerror and TestAdapter are present - rsvp"] = function (assert) {
          assert.expect(2);
          var thrown = new Error('the error');
          _test.default.adapter = _qunit.default.create({
            exception: function (error) {
              assert.strictEqual(error, thrown, 'Adapter.exception is called for errors thrown in RSVP promises');
              throw error;
            }
          });
          (0, _errorHandling.setOnerror)(function (error) {
            assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises if Test.adapter rethrows');
          });
          generatePromise(thrown); // RSVP.Promise's are configured to settle within the run loop, this
          // ensures that run loop has completed

          return new _runtime.RSVP.Promise(function (resolve) {
            return setTimeout(resolve, timeout);
          });
        };

        return PromiseFailureTests;
      }(AdapterSetupAndTearDown)
    );
  }

  (0, _internalTestHelpers.moduleFor)('Adapter Errors: .then callback', testAdapter('errors in promise constructor', function (error) {
    new _runtime.RSVP.Promise(function () {
      throw error;
    });
  }));
  (0, _internalTestHelpers.moduleFor)('Adapter Errors: Promise Contructor', testAdapter('errors in promise constructor', function (error) {
    _runtime.RSVP.resolve().then(function () {
      throw error;
    });
  }));
  (0, _internalTestHelpers.moduleFor)('Adapter Errors: Promise chain .then callback', testAdapter('errors in promise constructor', function (error) {
    new _runtime.RSVP.Promise(function (resolve) {
      return setTimeout(resolve, 10);
    }).then(function () {
      throw error;
    });
  }, 20));
});
enifed("ember-testing/tests/ext/rsvp_test", ["ember-babel", "ember-testing/lib/ext/rsvp", "ember-testing/lib/test/adapter", "ember-testing/lib/test/promise", "@ember/runloop", "@ember/debug", "internal-test-helpers"], function (_emberBabel, _rsvp, _adapter, _promise, _runloop, _debug, _internalTestHelpers) {
  "use strict";

  var originalTestAdapter = (0, _adapter.getAdapter)();
  var originalTestingFlag = (0, _debug.isTesting)();
  var asyncStarted = 0;
  var asyncEnded = 0;
  (0, _internalTestHelpers.moduleFor)('ember-testing RSVP',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      (0, _debug.setTesting)(true);
      (0, _adapter.setAdapter)({
        asyncStart: function () {
          asyncStarted++;
        },
        asyncEnd: function () {
          asyncEnded++;
        }
      });
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      asyncStarted = 0;
      asyncEnded = 0;
      (0, _adapter.setAdapter)(originalTestAdapter);
      (0, _debug.setTesting)(originalTestingFlag);
    };

    _proto['@test given `Ember.testing = true`, correctly informs the test suite about async steps'] = function testGivenEmberTestingTrueCorrectlyInformsTheTestSuiteAboutAsyncSteps(assert) {
      var done = assert.async();
      assert.expect(19);
      assert.ok(!(0, _runloop.getCurrentRunLoop)(), 'expect no run-loop');
      (0, _debug.setTesting)(true);
      assert.equal(asyncStarted, 0);
      assert.equal(asyncEnded, 0);

      var user = _rsvp.default.Promise.resolve({
        name: 'tomster'
      });

      assert.equal(asyncStarted, 0);
      assert.equal(asyncEnded, 0);
      user.then(function (user) {
        assert.equal(asyncStarted, 1);
        assert.equal(asyncEnded, 1);
        assert.equal(user.name, 'tomster');
        return _rsvp.default.Promise.resolve(1).then(function () {
          assert.equal(asyncStarted, 1);
          assert.equal(asyncEnded, 1);
        });
      }).then(function () {
        assert.equal(asyncStarted, 1);
        assert.equal(asyncEnded, 1);
        return new _rsvp.default.Promise(function (resolve) {
          setTimeout(function () {
            assert.equal(asyncStarted, 1);
            assert.equal(asyncEnded, 1);
            resolve({
              name: 'async tomster'
            });
            assert.equal(asyncStarted, 2);
            assert.equal(asyncEnded, 1);
          }, 0);
        });
      }).then(function (user) {
        assert.equal(user.name, 'async tomster');
        assert.equal(asyncStarted, 2);
        assert.equal(asyncEnded, 2);
        done();
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
  (0, _internalTestHelpers.moduleFor)('TestPromise',
  /*#__PURE__*/
  function (_AbstractTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

    function _class2() {
      return _AbstractTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['does not throw error when falsy value passed to then'] = function doesNotThrowErrorWhenFalsyValuePassedToThen(assert) {
      assert.expect(1);
      return new _promise.default(function (resolve) {
        resolve();
      }).then(null).then(function () {
        assert.ok(true);
      });
    };

    _proto2['able to get last Promise'] = function ableToGetLastPromise(assert) {
      assert.expect(2);
      var p1 = new _promise.default(function (resolve) {
        resolve();
      }).then(function () {
        assert.ok(true);
      });
      var p2 = new _promise.default(function (resolve) {
        resolve();
      });
      assert.deepEqual((0, _promise.getLastPromise)(), p2);
      return p1;
    };

    return _class2;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-testing/tests/helper_registration_test", ["ember-babel", "@ember/runloop", "ember-testing/lib/test", "@ember/application", "internal-test-helpers"], function (_emberBabel, _runloop, _test, _application, _internalTestHelpers) {
  "use strict";

  var App, appBooted, helperContainer;

  function registerHelper() {
    _test.default.registerHelper('boot', function (app) {
      (0, _runloop.run)(app, app.advanceReadiness);
      appBooted = true;
      return app.testHelpers.wait();
    });
  }

  function unregisterHelper() {
    _test.default.unregisterHelper('boot');
  }

  var originalAdapter = _test.default.adapter;

  function setupApp() {
    appBooted = false;
    helperContainer = {};
    (0, _runloop.run)(function () {
      App = _application.default.create();
      App.setupForTesting();
      App.injectTestHelpers(helperContainer);
    });
  }

  function destroyApp() {
    if (App) {
      (0, _runloop.run)(App, 'destroy');
      App = null;
      helperContainer = null;
    }
  }

  (0, _internalTestHelpers.moduleFor)('Test - registerHelper/unregisterHelper',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _test.default.adapter = originalAdapter;
      destroyApp();
    };

    _proto['@test Helper gets registered'] = function testHelperGetsRegistered(assert) {
      assert.expect(2);
      registerHelper();
      setupApp();
      assert.ok(App.testHelpers.boot);
      assert.ok(helperContainer.boot);
    };

    _proto['@test Helper is ran when called'] = function testHelperIsRanWhenCalled(assert) {
      var done = assert.async();
      assert.expect(1);
      registerHelper();
      setupApp();
      App.testHelpers.boot().then(function () {
        assert.ok(appBooted);
      }).finally(done);
    };

    _proto['@test Helper can be unregistered'] = function testHelperCanBeUnregistered(assert) {
      assert.expect(4);
      registerHelper();
      setupApp();
      assert.ok(App.testHelpers.boot);
      assert.ok(helperContainer.boot);
      unregisterHelper();
      (0, _runloop.run)(App, 'destroy');
      setupApp();
      assert.ok(!App.testHelpers.boot, 'once unregistered the helper is not added to App.testHelpers');
      assert.ok(!helperContainer.boot, 'once unregistered the helper is not added to the helperContainer');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember-testing/tests/helpers_test", ["ember-babel", "internal-test-helpers", "@ember/-internals/routing", "@ember/controller", "@ember/-internals/runtime", "@ember/runloop", "@ember/-internals/glimmer", "@ember/-internals/views", "ember-testing/lib/test", "ember-testing/lib/setup_for_testing", "ember-testing/lib/test/pending_requests", "ember-testing/lib/test/adapter", "ember-testing/lib/test/waiters", "@ember/debug"], function (_emberBabel, _internalTestHelpers, _routing, _controller, _runtime, _runloop, _glimmer, _views, _test, _setup_for_testing, _pending_requests, _adapter, _waiters, _debug) {
  "use strict";

  var originalInfo = (0, _debug.getDebugFunction)('info');

  var noop = function () {};

  function registerHelper() {
    _test.default.registerHelper('LeakyMcLeakLeak', function () {});
  }

  function assertHelpers(assert, application, helperContainer, expected) {
    if (!helperContainer) {
      helperContainer = window;
    }

    if (expected === undefined) {
      expected = true;
    }

    function checkHelperPresent(helper, expected) {
      var presentInHelperContainer = Boolean(helperContainer[helper]);
      var presentInTestHelpers = Boolean(application.testHelpers[helper]);
      assert.ok(presentInHelperContainer === expected, "Expected '" + helper + "' to be present in the helper container (defaults to window).");
      assert.ok(presentInTestHelpers === expected, "Expected '" + helper + "' to be present in App.testHelpers.");
    }

    checkHelperPresent('visit', expected);
    checkHelperPresent('click', expected);
    checkHelperPresent('keyEvent', expected);
    checkHelperPresent('fillIn', expected);
    checkHelperPresent('wait', expected);
    checkHelperPresent('triggerEvent', expected);
  }

  function assertNoHelpers(assert, application, helperContainer) {
    assertHelpers(assert, application, helperContainer, false);
  }

  var HelpersTestCase =
  /*#__PURE__*/
  function (_AutobootApplicationT) {
    (0, _emberBabel.inheritsLoose)(HelpersTestCase, _AutobootApplicationT);

    function HelpersTestCase() {
      var _this;

      _this = _AutobootApplicationT.call(this) || this;
      _this._originalAdapter = (0, _adapter.getAdapter)();
      return _this;
    }

    var _proto = HelpersTestCase.prototype;

    _proto.teardown = function teardown() {
      (0, _adapter.setAdapter)(this._originalAdapter);
      document.removeEventListener('ajaxSend', _pending_requests.incrementPendingRequests);
      document.removeEventListener('ajaxComplete', _pending_requests.decrementPendingRequests);
      (0, _pending_requests.clearPendingRequests)();

      if (this.application) {
        this.application.removeTestHelpers();
      }

      _AutobootApplicationT.prototype.teardown.call(this);
    };

    return HelpersTestCase;
  }(_internalTestHelpers.AutobootApplicationTestCase);

  var HelpersApplicationTestCase =
  /*#__PURE__*/
  function (_HelpersTestCase) {
    (0, _emberBabel.inheritsLoose)(HelpersApplicationTestCase, _HelpersTestCase);

    function HelpersApplicationTestCase() {
      var _this2;

      _this2 = _HelpersTestCase.call(this) || this;
      (0, _internalTestHelpers.runTask)(function () {
        _this2.createApplication();

        _this2.application.setupForTesting();

        _this2.application.injectTestHelpers();
      });
      return _this2;
    }

    return HelpersApplicationTestCase;
  }(HelpersTestCase);

  if (!_views.jQueryDisabled) {
    (0, _internalTestHelpers.moduleFor)('ember-testing: Helper setup',
    /*#__PURE__*/
    function (_HelpersTestCase2) {
      (0, _emberBabel.inheritsLoose)(_class, _HelpersTestCase2);

      function _class() {
        return _HelpersTestCase2.apply(this, arguments) || this;
      }

      var _proto2 = _class.prototype;

      _proto2["@test Ember.Application#injectTestHelpers/#removeTestHelper"] = function (assert) {
        var _this3 = this;

        (0, _internalTestHelpers.runTask)(function () {
          _this3.createApplication();
        });
        assertNoHelpers(assert, this.application);
        registerHelper();
        this.application.injectTestHelpers();
        assertHelpers(assert, this.application);
        assert.ok(_test.default.Promise.prototype.LeakyMcLeakLeak, 'helper in question SHOULD be present');
        this.application.removeTestHelpers();
        assertNoHelpers(assert, this.application);
        assert.equal(_test.default.Promise.prototype.LeakyMcLeakLeak, undefined, 'should NOT leak test promise extensions');
      };

      _proto2["@test Ember.Application#setupForTesting"] = function (assert) {
        var _this4 = this;

        (0, _internalTestHelpers.runTask)(function () {
          _this4.createApplication();

          _this4.application.setupForTesting();
        });
        var routerInstance = this.applicationInstance.lookup('router:main');
        assert.equal(routerInstance.location, 'none');
      };

      _proto2["@test Ember.Application.setupForTesting sets the application to 'testing'"] = function (assert) {
        var _this5 = this;

        (0, _internalTestHelpers.runTask)(function () {
          _this5.createApplication();

          _this5.application.setupForTesting();
        });
        assert.equal(this.application.testing, true, 'Application instance is set to testing.');
      };

      _proto2["@test Ember.Application.setupForTesting leaves the system in a deferred state."] = function (assert) {
        var _this6 = this;

        (0, _internalTestHelpers.runTask)(function () {
          _this6.createApplication();

          _this6.application.setupForTesting();
        });
        assert.equal(this.application._readinessDeferrals, 1, 'App is in deferred state after setupForTesting.');
      };

      _proto2["@test App.reset() after Application.setupForTesting leaves the system in a deferred state."] = function (assert) {
        var _this7 = this;

        (0, _internalTestHelpers.runTask)(function () {
          _this7.createApplication();

          _this7.application.setupForTesting();
        });
        assert.equal(this.application._readinessDeferrals, 1, 'App is in deferred state after setupForTesting.');
        this.application.reset();
        assert.equal(this.application._readinessDeferrals, 1, 'App is in deferred state after setupForTesting.');
      };

      _proto2["@test Ember.Application#injectTestHelpers calls callbacks registered with onInjectHelpers"] = function (assert) {
        var injected = 0;

        _test.default.onInjectHelpers(function () {
          injected++;
        }); // bind(this) so Babel doesn't leak _this
        // into the context onInjectHelpers.


        (0, _internalTestHelpers.runTask)(function () {
          this.createApplication();
          this.application.setupForTesting();
        }.bind(this));
        assert.equal(injected, 0, 'onInjectHelpers are not called before injectTestHelpers');
        this.application.injectTestHelpers();
        assert.equal(injected, 1, 'onInjectHelpers are called after injectTestHelpers');
      };

      _proto2["@test Ember.Application#injectTestHelpers adds helpers to provided object."] = function (assert) {
        var _this8 = this;

        var helpers = {};
        (0, _internalTestHelpers.runTask)(function () {
          _this8.createApplication();

          _this8.application.setupForTesting();
        });
        this.application.injectTestHelpers(helpers);
        assertHelpers(assert, this.application, helpers);
        this.application.removeTestHelpers();
        assertNoHelpers(assert, this.application, helpers);
      };

      _proto2["@test Ember.Application#removeTestHelpers resets the helperContainer's original values"] = function (assert) {
        var _this9 = this;

        var helpers = {
          visit: 'snazzleflabber'
        };
        (0, _internalTestHelpers.runTask)(function () {
          _this9.createApplication();

          _this9.application.setupForTesting();
        });
        this.application.injectTestHelpers(helpers);
        assert.notEqual(helpers.visit, 'snazzleflabber', 'helper added to container');
        this.application.removeTestHelpers();
        assert.equal(helpers.visit, 'snazzleflabber', 'original value added back to container');
      };

      return _class;
    }(HelpersTestCase));
    (0, _internalTestHelpers.moduleFor)('ember-testing: Helper methods',
    /*#__PURE__*/
    function (_HelpersApplicationTe) {
      (0, _emberBabel.inheritsLoose)(_class2, _HelpersApplicationTe);

      function _class2() {
        return _HelpersApplicationTe.apply(this, arguments) || this;
      }

      var _proto3 = _class2.prototype;

      _proto3["@test 'wait' respects registerWaiters"] = function (assert) {
        var _this10 = this;

        assert.expect(3);
        var counter = 0;

        function waiter() {
          return ++counter > 2;
        }

        var other = 0;

        function otherWaiter() {
          return ++other > 2;
        }

        (0, _internalTestHelpers.runTask)(function () {
          _this10.application.advanceReadiness();
        });
        (0, _waiters.registerWaiter)(waiter);
        (0, _waiters.registerWaiter)(otherWaiter);
        var testHelpers = this.application.testHelpers;
        return testHelpers.wait().then(function () {
          assert.equal(waiter(), true, 'should not resolve until our waiter is ready');
          (0, _waiters.unregisterWaiter)(waiter);
          counter = 0;
          return testHelpers.wait();
        }).then(function () {
          assert.equal(counter, 0, 'unregistered waiter was not checked');
          assert.equal(otherWaiter(), true, 'other waiter is still registered');
        }).finally(function () {
          (0, _waiters.unregisterWaiter)(otherWaiter);
        });
      };

      _proto3["@test 'visit' advances readiness."] = function (assert) {
        var _this11 = this;

        assert.expect(2);
        assert.equal(this.application._readinessDeferrals, 1, 'App is in deferred state after setupForTesting.');
        return this.application.testHelpers.visit('/').then(function () {
          assert.equal(_this11.application._readinessDeferrals, 0, "App's readiness was advanced by visit.");
        });
      };

      _proto3["@test 'wait' helper can be passed a resolution value"] = function (assert) {
        var _this12 = this;

        assert.expect(4);
        (0, _internalTestHelpers.runTask)(function () {
          _this12.application.advanceReadiness();
        });
        var promiseObjectValue = {};
        var objectValue = {};
        var testHelpers = this.application.testHelpers;
        return testHelpers.wait('text').then(function (val) {
          assert.equal(val, 'text', 'can resolve to a string');
          return testHelpers.wait(1);
        }).then(function (val) {
          assert.equal(val, 1, 'can resolve to an integer');
          return testHelpers.wait(objectValue);
        }).then(function (val) {
          assert.equal(val, objectValue, 'can resolve to an object');
          return testHelpers.wait(_runtime.RSVP.resolve(promiseObjectValue));
        }).then(function (val) {
          assert.equal(val, promiseObjectValue, 'can resolve to a promise resolution value');
        });
      };

      _proto3["@test 'click' triggers appropriate events in order"] = function (assert) {
        var _this13 = this;

        assert.expect(5);
        this.add('component:index-wrapper', _glimmer.Component.extend({
          classNames: 'index-wrapper',
          didInsertElement: function () {
            var wrapper = document.querySelector('.index-wrapper');
            wrapper.addEventListener('mousedown', function (e) {
              return events.push(e.type);
            });
            wrapper.addEventListener('mouseup', function (e) {
              return events.push(e.type);
            });
            wrapper.addEventListener('click', function (e) {
              return events.push(e.type);
            });
            wrapper.addEventListener('focusin', function (e) {
              // IE11 _sometimes_ triggers focusin **twice** in a row
              // (we believe this is when it is under higher load)
              //
              // the goal here is to only push a single focusin when running on
              // IE11
              if (_internalTestHelpers.isIE11) {
                if (events[events.length - 1] !== 'focusin') {
                  events.push(e.type);
                }
              } else {
                events.push(e.type);
              }
            });
          }
        }));
        this.add('component:x-checkbox', _glimmer.Component.extend({
          tagName: 'input',
          attributeBindings: ['type'],
          type: 'checkbox',
          click: function () {
            events.push('click:' + this.get('checked'));
          },
          change: function () {
            events.push('change:' + this.get('checked'));
          }
        }));
        this.addTemplate('index', "\n        {{#index-wrapper}}\n          {{input type=\"text\"}}\n          {{x-checkbox type=\"checkbox\"}}\n          {{textarea}}\n          <div contenteditable=\"true\"> </div>\n        {{/index-wrapper}}'));\n      ");
        (0, _internalTestHelpers.runTask)(function () {
          _this13.application.advanceReadiness();
        });
        var events;
        var testHelpers = this.application.testHelpers;
        return testHelpers.wait().then(function () {
          events = [];
          return testHelpers.click('.index-wrapper');
        }).then(function () {
          assert.deepEqual(events, ['mousedown', 'mouseup', 'click'], 'fires events in order');
        }).then(function () {
          events = [];
          return testHelpers.click('.index-wrapper input[type=text]');
        }).then(function () {
          assert.deepEqual(events, ['mousedown', 'focusin', 'mouseup', 'click'], 'fires focus events on inputs');
        }).then(function () {
          events = [];
          return testHelpers.click('.index-wrapper textarea');
        }).then(function () {
          assert.deepEqual(events, ['mousedown', 'focusin', 'mouseup', 'click'], 'fires focus events on textareas');
        }).then(function () {
          events = [];
          return testHelpers.click('.index-wrapper div');
        }).then(function () {
          assert.deepEqual(events, ['mousedown', 'focusin', 'mouseup', 'click'], 'fires focus events on contenteditable');
        }).then(function () {
          events = [];
          return testHelpers.click('.index-wrapper input[type=checkbox]');
        }).then(function () {
          // i.e. mousedown, mouseup, change:true, click, click:true
          // Firefox differs so we can't assert the exact ordering here.
          // See https://bugzilla.mozilla.org/show_bug.cgi?id=843554.
          assert.equal(events.length, 5, 'fires click and change on checkboxes');
        });
      };

      _proto3["@test 'click' triggers native events with simulated X/Y coordinates"] = function (assert) {
        var _this14 = this;

        assert.expect(15);
        this.add('component:index-wrapper', _glimmer.Component.extend({
          classNames: 'index-wrapper',
          didInsertElement: function () {
            var pushEvent = function (e) {
              return events.push(e);
            };

            this.element.addEventListener('mousedown', pushEvent);
            this.element.addEventListener('mouseup', pushEvent);
            this.element.addEventListener('click', pushEvent);
          }
        }));
        this.addTemplate('index', "\n        {{#index-wrapper}}some text{{/index-wrapper}}\n      ");
        (0, _internalTestHelpers.runTask)(function () {
          _this14.application.advanceReadiness();
        });
        var events;
        var _this$application$tes = this.application.testHelpers,
            wait = _this$application$tes.wait,
            click = _this$application$tes.click;
        return wait().then(function () {
          events = [];
          return click('.index-wrapper');
        }).then(function () {
          events.forEach(function (e) {
            assert.ok(e instanceof window.Event, 'The event is an instance of MouseEvent');
            assert.ok(typeof e.screenX === 'number', 'screenX is correct');
            assert.ok(typeof e.screenY === 'number', 'screenY is correct');
            assert.ok(typeof e.clientX === 'number', 'clientX is correct');
            assert.ok(typeof e.clientY === 'number', 'clientY is correct');
          });
        });
      };

      _proto3["@test 'triggerEvent' with mouseenter triggers native events with simulated X/Y coordinates"] = function (assert) {
        var _this15 = this;

        assert.expect(5);
        var evt;
        this.add('component:index-wrapper', _glimmer.Component.extend({
          classNames: 'index-wrapper',
          didInsertElement: function () {
            this.element.addEventListener('mouseenter', function (e) {
              return evt = e;
            });
          }
        }));
        this.addTemplate('index', "{{#index-wrapper}}some text{{/index-wrapper}}");
        (0, _internalTestHelpers.runTask)(function () {
          _this15.application.advanceReadiness();
        });
        var _this$application$tes2 = this.application.testHelpers,
            wait = _this$application$tes2.wait,
            triggerEvent = _this$application$tes2.triggerEvent;
        return wait().then(function () {
          return triggerEvent('.index-wrapper', 'mouseenter');
        }).then(function () {
          assert.ok(evt instanceof window.Event, 'The event is an instance of MouseEvent');
          assert.ok(typeof evt.screenX === 'number', 'screenX is correct');
          assert.ok(typeof evt.screenY === 'number', 'screenY is correct');
          assert.ok(typeof evt.clientX === 'number', 'clientX is correct');
          assert.ok(typeof evt.clientY === 'number', 'clientY is correct');
        });
      };

      _proto3["@test 'wait' waits for outstanding timers"] = function (assert) {
        var _this16 = this;

        assert.expect(1);
        (0, _internalTestHelpers.runTask)(function () {
          _this16.application.advanceReadiness();
        });
        var waitDone = false;
        (0, _runloop.later)(function () {
          waitDone = true;
        }, 20);
        return this.application.testHelpers.wait().then(function () {
          assert.equal(waitDone, true, 'should wait for the timer to be fired.');
        });
      };

      _proto3["@test 'wait' respects registerWaiters with optional context"] = function (assert) {
        var _this17 = this;

        assert.expect(3);
        var obj = {
          counter: 0,
          ready: function () {
            return ++this.counter > 2;
          }
        };
        var other = 0;

        function otherWaiter() {
          return ++other > 2;
        }

        (0, _internalTestHelpers.runTask)(function () {
          _this17.application.advanceReadiness();
        });
        (0, _waiters.registerWaiter)(obj, obj.ready);
        (0, _waiters.registerWaiter)(otherWaiter);
        var wait = this.application.testHelpers.wait;
        return wait().then(function () {
          assert.equal(obj.ready(), true, 'should not resolve until our waiter is ready');
          (0, _waiters.unregisterWaiter)(obj, obj.ready);
          obj.counter = 0;
          return wait();
        }).then(function () {
          assert.equal(obj.counter, 0, 'the unregistered waiter should still be at 0');
          assert.equal(otherWaiter(), true, 'other waiter should still be registered');
        }).finally(function () {
          (0, _waiters.unregisterWaiter)(otherWaiter);
        });
      };

      _proto3["@test 'wait' does not error if routing has not begun"] = function (assert) {
        assert.expect(1);
        return this.application.testHelpers.wait().then(function () {
          assert.ok(true, 'should not error without `visit`');
        });
      };

      _proto3["@test 'triggerEvent' accepts an optional options hash without context"] = function (assert) {
        var _this18 = this;

        assert.expect(3);
        var event;
        this.add('component:index-wrapper', _glimmer.Component.extend({
          didInsertElement: function () {
            var domElem = document.querySelector('.input');
            domElem.addEventListener('change', function (e) {
              return event = e;
            });
            domElem.addEventListener('keydown', function (e) {
              return event = e;
            });
          }
        }));
        this.addTemplate('index', "{{index-wrapper}}");
        this.addTemplate('components/index-wrapper', "\n        {{input type=\"text\" id=\"scope\" class=\"input\"}}\n      ");
        (0, _internalTestHelpers.runTask)(function () {
          _this18.application.advanceReadiness();
        });
        var _this$application$tes3 = this.application.testHelpers,
            wait = _this$application$tes3.wait,
            triggerEvent = _this$application$tes3.triggerEvent;
        return wait().then(function () {
          return triggerEvent('.input', 'keydown', {
            keyCode: 13
          });
        }).then(function () {
          assert.equal(event.keyCode, 13, 'options were passed');
          assert.equal(event.type, 'keydown', 'correct event was triggered');
          assert.equal(event.target.getAttribute('id'), 'scope', 'triggered on the correct element');
        });
      };

      _proto3["@test 'triggerEvent' can limit searching for a selector to a scope"] = function (assert) {
        var _this19 = this;

        assert.expect(2);
        var event;
        this.add('component:index-wrapper', _glimmer.Component.extend({
          didInsertElement: function () {
            var firstInput = document.querySelector('.input');
            firstInput.addEventListener('blur', function (e) {
              return event = e;
            });
            firstInput.addEventListener('change', function (e) {
              return event = e;
            });
            var secondInput = document.querySelector('#limited .input');
            secondInput.addEventListener('blur', function (e) {
              return event = e;
            });
            secondInput.addEventListener('change', function (e) {
              return event = e;
            });
          }
        }));
        this.addTemplate('components/index-wrapper', "\n        {{input type=\"text\" id=\"outside-scope\" class=\"input\"}}\n        <div id=\"limited\">\n          {{input type=\"text\" id=\"inside-scope\" class=\"input\"}}\n        </div>\n      ");
        this.addTemplate('index', "{{index-wrapper}}");
        (0, _internalTestHelpers.runTask)(function () {
          _this19.application.advanceReadiness();
        });
        var _this$application$tes4 = this.application.testHelpers,
            wait = _this$application$tes4.wait,
            triggerEvent = _this$application$tes4.triggerEvent;
        return wait().then(function () {
          return triggerEvent('.input', '#limited', 'blur');
        }).then(function () {
          assert.equal(event.type, 'blur', 'correct event was triggered');
          assert.equal(event.target.getAttribute('id'), 'inside-scope', 'triggered on the correct element');
        });
      };

      _proto3["@test 'triggerEvent' can be used to trigger arbitrary events"] = function (assert) {
        var _this20 = this;

        assert.expect(2);
        var event;
        this.add('component:index-wrapper', _glimmer.Component.extend({
          didInsertElement: function () {
            var foo = document.getElementById('foo');
            foo.addEventListener('blur', function (e) {
              return event = e;
            });
            foo.addEventListener('change', function (e) {
              return event = e;
            });
          }
        }));
        this.addTemplate('components/index-wrapper', "\n        {{input type=\"text\" id=\"foo\"}}\n      ");
        this.addTemplate('index', "{{index-wrapper}}");
        (0, _internalTestHelpers.runTask)(function () {
          _this20.application.advanceReadiness();
        });
        var _this$application$tes5 = this.application.testHelpers,
            wait = _this$application$tes5.wait,
            triggerEvent = _this$application$tes5.triggerEvent;
        return wait().then(function () {
          return triggerEvent('#foo', 'blur');
        }).then(function () {
          assert.equal(event.type, 'blur', 'correct event was triggered');
          assert.equal(event.target.getAttribute('id'), 'foo', 'triggered on the correct element');
        });
      };

      _proto3["@test 'fillIn' takes context into consideration"] = function (assert) {
        var _this21 = this;

        assert.expect(2);
        this.addTemplate('index', "\n        <div id=\"parent\">\n          {{input type=\"text\" id=\"first\" class=\"current\"}}\n        </div>\n        {{input type=\"text\" id=\"second\" class=\"current\"}}\n      ");
        (0, _internalTestHelpers.runTask)(function () {
          _this21.application.advanceReadiness();
        });
        var _this$application$tes6 = this.application.testHelpers,
            visit = _this$application$tes6.visit,
            fillIn = _this$application$tes6.fillIn,
            andThen = _this$application$tes6.andThen,
            find = _this$application$tes6.find;
        visit('/');
        fillIn('.current', '#parent', 'current value');
        return andThen(function () {
          assert.equal(find('#first')[0].value, 'current value');
          assert.equal(find('#second')[0].value, '');
        });
      };

      _proto3["@test 'fillIn' focuses on the element"] = function (assert) {
        var _this22 = this;

        var wasFocused = false;
        this.add('controller:index', _controller.default.extend({
          actions: {
            wasFocused: function () {
              wasFocused = true;
            }
          }
        }));
        this.addTemplate('index', "\n        <div id=\"parent\">\n          {{input type=\"text\" id=\"first\" focus-in=(action \"wasFocused\")}}\n        </div>'\n      ");
        (0, _internalTestHelpers.runTask)(function () {
          _this22.application.advanceReadiness();
        });
        var _this$application$tes7 = this.application.testHelpers,
            visit = _this$application$tes7.visit,
            fillIn = _this$application$tes7.fillIn,
            andThen = _this$application$tes7.andThen,
            find = _this$application$tes7.find,
            wait = _this$application$tes7.wait;
        visit('/');
        fillIn('#first', 'current value');
        andThen(function () {
          assert.ok(wasFocused, 'focusIn event was triggered');
          assert.equal(find('#first')[0].value, 'current value');
        });
        return wait();
      };

      _proto3["@test 'fillIn' fires 'input' and 'change' events in the proper order"] = function (assert) {
        var _this23 = this;

        assert.expect(1);
        var events = [];
        this.add('controller:index', _controller.default.extend({
          actions: {
            oninputHandler: function (e) {
              events.push(e.type);
            },
            onchangeHandler: function (e) {
              events.push(e.type);
            }
          }
        }));
        this.addTemplate('index', "\n        <input type=\"text\" id=\"first\"\n            oninput={{action \"oninputHandler\"}}\n            onchange={{action \"onchangeHandler\"}}>\n      ");
        (0, _internalTestHelpers.runTask)(function () {
          _this23.application.advanceReadiness();
        });
        var _this$application$tes8 = this.application.testHelpers,
            visit = _this$application$tes8.visit,
            fillIn = _this$application$tes8.fillIn,
            andThen = _this$application$tes8.andThen,
            wait = _this$application$tes8.wait;
        visit('/');
        fillIn('#first', 'current value');
        andThen(function () {
          assert.deepEqual(events, ['input', 'change'], '`input` and `change` events are fired in the proper order');
        });
        return wait();
      };

      _proto3["@test 'fillIn' only sets the value in the first matched element"] = function (assert) {
        var _this24 = this;

        this.addTemplate('index', "\n        <input type=\"text\" id=\"first\" class=\"in-test\">\n        <input type=\"text\" id=\"second\" class=\"in-test\">\n      ");
        (0, _internalTestHelpers.runTask)(function () {
          _this24.application.advanceReadiness();
        });
        var _this$application$tes9 = this.application.testHelpers,
            visit = _this$application$tes9.visit,
            fillIn = _this$application$tes9.fillIn,
            find = _this$application$tes9.find,
            andThen = _this$application$tes9.andThen,
            wait = _this$application$tes9.wait;
        visit('/');
        fillIn('input.in-test', 'new value');
        andThen(function () {
          assert.equal(find('#first')[0].value, 'new value');
          assert.equal(find('#second')[0].value, '');
        });
        return wait();
      };

      _proto3["@test 'triggerEvent' accepts an optional options hash and context"] = function (assert) {
        var _this25 = this;

        assert.expect(3);
        var event;
        this.add('component:index-wrapper', _glimmer.Component.extend({
          didInsertElement: function () {
            var firstInput = document.querySelector('.input');
            firstInput.addEventListener('keydown', function (e) {
              return event = e;
            }, false);
            firstInput.addEventListener('change', function (e) {
              return event = e;
            }, false);
            var secondInput = document.querySelector('#limited .input');
            secondInput.addEventListener('keydown', function (e) {
              return event = e;
            }, false);
            secondInput.addEventListener('change', function (e) {
              return event = e;
            }, false);
          }
        }));
        this.addTemplate('components/index-wrapper', "\n        {{input type=\"text\" id=\"outside-scope\" class=\"input\"}}\n        <div id=\"limited\">\n          {{input type=\"text\" id=\"inside-scope\" class=\"input\"}}\n        </div>\n      ");
        this.addTemplate('index', "{{index-wrapper}}");
        (0, _internalTestHelpers.runTask)(function () {
          _this25.application.advanceReadiness();
        });
        var _this$application$tes10 = this.application.testHelpers,
            wait = _this$application$tes10.wait,
            triggerEvent = _this$application$tes10.triggerEvent;
        return wait().then(function () {
          return triggerEvent('.input', '#limited', 'keydown', {
            keyCode: 13
          });
        }).then(function () {
          assert.equal(event.keyCode, 13, 'options were passed');
          assert.equal(event.type, 'keydown', 'correct event was triggered');
          assert.equal(event.target.getAttribute('id'), 'inside-scope', 'triggered on the correct element');
        });
      };

      return _class2;
    }(HelpersApplicationTestCase));
    (0, _internalTestHelpers.moduleFor)('ember-testing: debugging helpers',
    /*#__PURE__*/
    function (_HelpersApplicationTe2) {
      (0, _emberBabel.inheritsLoose)(_class3, _HelpersApplicationTe2);
      var _proto4 = _class3.prototype;

      _proto4.afterEach = function afterEach() {
        _HelpersApplicationTe2.prototype.afterEach.call(this);

        (0, _debug.setDebugFunction)('info', originalInfo);
      };

      function _class3() {
        var _this26;

        _this26 = _HelpersApplicationTe2.call(this) || this;
        (0, _internalTestHelpers.runTask)(function () {
          _this26.application.advanceReadiness();
        });
        return _this26;
      }

      _proto4["@test pauseTest pauses"] = function (assert) {
        assert.expect(1); // overwrite info to supress the console output (see https://github.com/emberjs/ember.js/issues/16391)

        (0, _debug.setDebugFunction)('info', noop);
        var _this$application$tes11 = this.application.testHelpers,
            andThen = _this$application$tes11.andThen,
            pauseTest = _this$application$tes11.pauseTest;
        andThen(function () {
          _test.default.adapter.asyncStart = function () {
            assert.ok(true, 'Async start should be called after waiting for other helpers');
          };
        });
        pauseTest();
      };

      _proto4["@test resumeTest resumes paused tests"] = function (assert) {
        assert.expect(1); // overwrite info to supress the console output (see https://github.com/emberjs/ember.js/issues/16391)

        (0, _debug.setDebugFunction)('info', noop);
        var _this$application$tes12 = this.application.testHelpers,
            pauseTest = _this$application$tes12.pauseTest,
            resumeTest = _this$application$tes12.resumeTest;
        (0, _runloop.later)(function () {
          return resumeTest();
        }, 20);
        return pauseTest().then(function () {
          assert.ok(true, 'pauseTest promise was resolved');
        });
      };

      _proto4["@test resumeTest throws if nothing to resume"] = function (assert) {
        var _this27 = this;

        assert.expect(1);
        assert.throws(function () {
          _this27.application.testHelpers.resumeTest();
        }, /Testing has not been paused. There is nothing to resume./);
      };

      return _class3;
    }(HelpersApplicationTestCase));
    (0, _internalTestHelpers.moduleFor)('ember-testing: routing helpers',
    /*#__PURE__*/
    function (_HelpersTestCase3) {
      (0, _emberBabel.inheritsLoose)(_class4, _HelpersTestCase3);

      function _class4() {
        var _this28;

        _this28 = _HelpersTestCase3.call(this) || this;
        (0, _internalTestHelpers.runTask)(function () {
          _this28.createApplication();

          _this28.application.setupForTesting();

          _this28.application.injectTestHelpers();

          _this28.router.map(function () {
            this.route('posts', {
              resetNamespace: true
            }, function () {
              this.route('new');
              this.route('edit', {
                resetNamespace: true
              });
            });
          });
        });
        (0, _internalTestHelpers.runTask)(function () {
          _this28.application.advanceReadiness();
        });
        return _this28;
      }

      var _proto5 = _class4.prototype;

      _proto5["@test currentRouteName for '/'"] = function (assert) {
        assert.expect(3);
        var testHelpers = this.application.testHelpers;
        return testHelpers.visit('/').then(function () {
          assert.equal(testHelpers.currentRouteName(), 'index', "should equal 'index'.");
          assert.equal(testHelpers.currentPath(), 'index', "should equal 'index'.");
          assert.equal(testHelpers.currentURL(), '/', "should equal '/'.");
        });
      };

      _proto5["@test currentRouteName for '/posts'"] = function (assert) {
        assert.expect(3);
        var testHelpers = this.application.testHelpers;
        return testHelpers.visit('/posts').then(function () {
          assert.equal(testHelpers.currentRouteName(), 'posts.index', "should equal 'posts.index'.");
          assert.equal(testHelpers.currentPath(), 'posts.index', "should equal 'posts.index'.");
          assert.equal(testHelpers.currentURL(), '/posts', "should equal '/posts'.");
        });
      };

      _proto5["@test currentRouteName for '/posts/new'"] = function (assert) {
        assert.expect(3);
        var testHelpers = this.application.testHelpers;
        return testHelpers.visit('/posts/new').then(function () {
          assert.equal(testHelpers.currentRouteName(), 'posts.new', "should equal 'posts.new'.");
          assert.equal(testHelpers.currentPath(), 'posts.new', "should equal 'posts.new'.");
          assert.equal(testHelpers.currentURL(), '/posts/new', "should equal '/posts/new'.");
        });
      };

      _proto5["@test currentRouteName for '/posts/edit'"] = function (assert) {
        assert.expect(3);
        var testHelpers = this.application.testHelpers;
        return testHelpers.visit('/posts/edit').then(function () {
          assert.equal(testHelpers.currentRouteName(), 'edit', "should equal 'edit'.");
          assert.equal(testHelpers.currentPath(), 'posts.edit', "should equal 'posts.edit'.");
          assert.equal(testHelpers.currentURL(), '/posts/edit', "should equal '/posts/edit'.");
        });
      };

      return _class4;
    }(HelpersTestCase));
    (0, _internalTestHelpers.moduleFor)('ember-testing: pendingRequests',
    /*#__PURE__*/
    function (_HelpersApplicationTe3) {
      (0, _emberBabel.inheritsLoose)(_class5, _HelpersApplicationTe3);

      function _class5() {
        return _HelpersApplicationTe3.apply(this, arguments) || this;
      }

      var _proto6 = _class5.prototype;

      _proto6.trigger = function trigger(type, xhr) {
        (0, _views.jQuery)(document).trigger(type, xhr);
      };

      _proto6["@test pendingRequests is maintained for ajaxSend and ajaxComplete events"] = function (assert) {
        var done = assert.async();
        assert.equal((0, _pending_requests.pendingRequests)(), 0);
        var xhr = {
          some: 'xhr'
        };
        this.trigger('ajaxSend', xhr);
        assert.equal((0, _pending_requests.pendingRequests)(), 1, 'Ember.Test.pendingRequests was incremented');
        this.trigger('ajaxComplete', xhr);
        setTimeout(function () {
          assert.equal((0, _pending_requests.pendingRequests)(), 0, 'Ember.Test.pendingRequests was decremented');
          done();
        }, 0);
      };

      _proto6["@test pendingRequests is ignores ajaxComplete events from past setupForTesting calls"] = function (assert) {
        assert.equal((0, _pending_requests.pendingRequests)(), 0);
        var xhr = {
          some: 'xhr'
        };
        this.trigger('ajaxSend', xhr);
        assert.equal((0, _pending_requests.pendingRequests)(), 1, 'Ember.Test.pendingRequests was incremented');
        (0, _setup_for_testing.default)();
        assert.equal((0, _pending_requests.pendingRequests)(), 0, 'Ember.Test.pendingRequests was reset');
        var altXhr = {
          some: 'more xhr'
        };
        this.trigger('ajaxSend', altXhr);
        assert.equal((0, _pending_requests.pendingRequests)(), 1, 'Ember.Test.pendingRequests was incremented');
        this.trigger('ajaxComplete', xhr);
        assert.equal((0, _pending_requests.pendingRequests)(), 1, 'Ember.Test.pendingRequests is not impressed with your unexpected complete');
      };

      _proto6["@test pendingRequests is reset by setupForTesting"] = function (assert) {
        (0, _pending_requests.incrementPendingRequests)();
        (0, _setup_for_testing.default)();
        assert.equal((0, _pending_requests.pendingRequests)(), 0, 'pendingRequests is reset');
      };

      return _class5;
    }(HelpersApplicationTestCase));
    (0, _internalTestHelpers.moduleFor)('ember-testing: async router',
    /*#__PURE__*/
    function (_HelpersTestCase4) {
      (0, _emberBabel.inheritsLoose)(_class6, _HelpersTestCase4);

      function _class6() {
        var _this29;

        _this29 = _HelpersTestCase4.call(this) || this;
        (0, _internalTestHelpers.runTask)(function () {
          _this29.createApplication();

          _this29.router.map(function () {
            this.route('user', {
              resetNamespace: true
            }, function () {
              this.route('profile');
              this.route('edit');
            });
          }); // Emulate a long-running unscheduled async operation.


          var resolveLater = function () {
            return new _runtime.RSVP.Promise(function (resolve) {
              /*
               * The wait() helper has a 10ms tick. We should resolve() after
               * at least one tick to test whether wait() held off while the
               * async router was still loading. 20ms should be enough.
               */
              (0, _runloop.later)(resolve, {
                firstName: 'Tom'
              }, 20);
            });
          };

          _this29.add('route:user', _routing.Route.extend({
            model: function () {
              return resolveLater();
            }
          }));

          _this29.add('route:user.profile', _routing.Route.extend({
            beforeModel: function () {
              var _this30 = this;

              return resolveLater().then(function () {
                return _this30.transitionTo('user.edit');
              });
            }
          }));

          _this29.application.setupForTesting();
        });

        _this29.application.injectTestHelpers();

        (0, _internalTestHelpers.runTask)(function () {
          _this29.application.advanceReadiness();
        });
        return _this29;
      }

      var _proto7 = _class6.prototype;

      _proto7["@test currentRouteName for '/user'"] = function (assert) {
        var _this31 = this;

        assert.expect(4);
        var testHelpers = this.application.testHelpers;
        return testHelpers.visit('/user').then(function () {
          assert.equal(testHelpers.currentRouteName(), 'user.index', "should equal 'user.index'.");
          assert.equal(testHelpers.currentPath(), 'user.index', "should equal 'user.index'.");
          assert.equal(testHelpers.currentURL(), '/user', "should equal '/user'.");

          var userRoute = _this31.applicationInstance.lookup('route:user');

          assert.equal(userRoute.get('controller.model.firstName'), 'Tom', "should equal 'Tom'.");
        });
      };

      _proto7["@test currentRouteName for '/user/profile'"] = function (assert) {
        var _this32 = this;

        assert.expect(4);
        var testHelpers = this.application.testHelpers;
        return testHelpers.visit('/user/profile').then(function () {
          assert.equal(testHelpers.currentRouteName(), 'user.edit', "should equal 'user.edit'.");
          assert.equal(testHelpers.currentPath(), 'user.edit', "should equal 'user.edit'.");
          assert.equal(testHelpers.currentURL(), '/user/edit', "should equal '/user/edit'.");

          var userRoute = _this32.applicationInstance.lookup('route:user');

          assert.equal(userRoute.get('controller.model.firstName'), 'Tom', "should equal 'Tom'.");
        });
      };

      return _class6;
    }(HelpersTestCase));
    (0, _internalTestHelpers.moduleFor)('ember-testing: can override built-in helpers',
    /*#__PURE__*/
    function (_HelpersTestCase5) {
      (0, _emberBabel.inheritsLoose)(_class7, _HelpersTestCase5);

      function _class7() {
        var _this33;

        _this33 = _HelpersTestCase5.call(this) || this;
        (0, _internalTestHelpers.runTask)(function () {
          _this33.createApplication();

          _this33.application.setupForTesting();
        });
        _this33._originalVisitHelper = _test.default._helpers.visit;
        _this33._originalFindHelper = _test.default._helpers.find;
        return _this33;
      }

      var _proto8 = _class7.prototype;

      _proto8.teardown = function teardown() {
        _test.default._helpers.visit = this._originalVisitHelper;
        _test.default._helpers.find = this._originalFindHelper;

        _HelpersTestCase5.prototype.teardown.call(this);
      };

      _proto8["@test can override visit helper"] = function (assert) {
        assert.expect(1);

        _test.default.registerHelper('visit', function () {
          assert.ok(true, 'custom visit helper was called');
        });

        this.application.injectTestHelpers();
        return this.application.testHelpers.visit();
      };

      _proto8["@test can override find helper"] = function (assert) {
        assert.expect(1);

        _test.default.registerHelper('find', function () {
          assert.ok(true, 'custom find helper was called');
          return ['not empty array'];
        });

        this.application.injectTestHelpers();
        return this.application.testHelpers.findWithAssert('.who-cares');
      };

      return _class7;
    }(HelpersTestCase));
  }
});
enifed("ember-testing/tests/integration_test", ["ember-babel", "internal-test-helpers", "ember-testing/lib/test", "@ember/-internals/runtime", "@ember/-internals/routing", "@ember/-internals/views"], function (_emberBabel, _internalTestHelpers, _test, _runtime, _routing, _views) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember-testing Integration tests of acceptance',
  /*#__PURE__*/
  function (_AutobootApplicationT) {
    (0, _emberBabel.inheritsLoose)(_class, _AutobootApplicationT);

    function _class() {
      var _this;

      _this = _AutobootApplicationT.call(this) || this;
      _this.modelContent = [];
      _this._originalAdapter = _test.default.adapter;
      (0, _internalTestHelpers.runTask)(function () {
        _this.createApplication();

        _this.addTemplate('people', "\n        <div>\n          {{#each model as |person|}}\n            <div class=\"name\">{{person.firstName}}</div>\n          {{/each}}\n        </div>\n      ");

        _this.router.map(function () {
          this.route('people', {
            path: '/'
          });
        });

        _this.add('route:people', _routing.Route.extend({
          model: function () {
            return _this.modelContent;
          }
        }));

        _this.application.setupForTesting();
      });
      (0, _internalTestHelpers.runTask)(function () {
        _this.application.reset();
      });

      _this.application.injectTestHelpers();

      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _AutobootApplicationT.prototype.teardown.call(this);

      _test.default.adapter = this._originalAdapter;
    };

    _proto["@test template is bound to empty array of people"] = function (assert) {
      var _this2 = this;

      if (!_views.jQueryDisabled) {
        (0, _internalTestHelpers.runTask)(function () {
          return _this2.application.advanceReadiness();
        });
        window.visit('/').then(function () {
          var rows = window.find('.name').length;
          assert.equal(rows, 0, 'successfully stubbed an empty array of people');
        });
      } else {
        (0, _internalTestHelpers.runTask)(function () {
          return _this2.application.advanceReadiness();
        });
        window.visit('/').then(function () {
          expectAssertion(function () {
            return window.find('.name');
          }, 'If jQuery is disabled, please import and use helpers from @ember/test-helpers [https://github.com/emberjs/ember-test-helpers]. Note: `find` is not an available helper.');
        });
      }
    };

    _proto["@test template is bound to array of 2 people"] = function (assert) {
      var _this3 = this;

      if (!_views.jQueryDisabled) {
        this.modelContent = (0, _runtime.A)([]);
        this.modelContent.pushObject({
          firstName: 'x'
        });
        this.modelContent.pushObject({
          firstName: 'y'
        });
        (0, _internalTestHelpers.runTask)(function () {
          return _this3.application.advanceReadiness();
        });
        window.visit('/').then(function () {
          var rows = window.find('.name').length;
          assert.equal(rows, 2, 'successfully stubbed a non empty array of people');
        });
      } else {
        assert.expect(0);
      }
    };

    _proto["@test 'visit' can be called without advanceReadiness."] = function (assert) {
      if (!_views.jQueryDisabled) {
        window.visit('/').then(function () {
          var rows = window.find('.name').length;
          assert.equal(rows, 0, 'stubbed an empty array of people without calling advanceReadiness.');
        });
      } else {
        assert.expect(0);
      }
    };

    return _class;
  }(_internalTestHelpers.AutobootApplicationTestCase));
});
enifed("ember-testing/tests/reexports_test", ["ember-babel", "ember", "internal-test-helpers"], function (_emberBabel, _ember, _internalTestHelpers) {
  "use strict";

  var ReexportsTestCase =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(ReexportsTestCase, _AbstractTestCase);

    function ReexportsTestCase() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    return ReexportsTestCase;
  }(_internalTestHelpers.AbstractTestCase);

  [// ember-testing
  ['Test', 'ember-testing'], ['Test.Adapter', 'ember-testing', 'Adapter'], ['Test.QUnitAdapter', 'ember-testing', 'QUnitAdapter'], ['setupForTesting', 'ember-testing']].forEach(function (reexport) {
    var path = reexport[0],
        moduleId = reexport[1],
        exportName = reexport[2]; // default path === exportName if none present

    if (!exportName) {
      exportName = path;
    }

    ReexportsTestCase.prototype["@test Ember." + path + " exports correctly"] = function (assert) {
      (0, _internalTestHelpers.confirmExport)(_ember.default, assert, path, moduleId, exportName);
    };
  });
  (0, _internalTestHelpers.moduleFor)('ember-testing reexports', ReexportsTestCase);
});
enifed("ember-testing/tests/test/waiters-test", ["ember-babel", "ember-testing/lib/test/waiters", "internal-test-helpers"], function (_emberBabel, _waiters, _internalTestHelpers) {
  "use strict";

  var Waiters =
  /*#__PURE__*/
  function () {
    function Waiters() {
      this._waiters = [];
    }

    var _proto = Waiters.prototype;

    _proto.add = function add() {
      this._waiters.push(Array.prototype.slice.call(arguments));
    };

    _proto.register = function register() {
      this.forEach(function () {
        _waiters.registerWaiter.apply(void 0, arguments);
      });
    };

    _proto.unregister = function unregister() {
      this.forEach(function () {
        _waiters.unregisterWaiter.apply(void 0, arguments);
      });
    };

    _proto.forEach = function forEach(callback) {
      for (var i = 0; i < this._waiters.length; i++) {
        var args = this._waiters[i];
        callback.apply(void 0, args);
      }
    };

    _proto.check = function check() {
      this.register();
      var result = (0, _waiters.checkWaiters)();
      this.unregister();
      return result;
    };

    return Waiters;
  }();

  (0, _internalTestHelpers.moduleFor)('ember-testing: waiters',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      var _this;

      _this = _AbstractTestCase.call(this) || this;
      _this.waiters = new Waiters();
      return _this;
    }

    var _proto2 = _class.prototype;

    _proto2.teardown = function teardown() {
      this.waiters.unregister();
    };

    _proto2['@test registering a waiter'] = function testRegisteringAWaiter(assert) {
      assert.expect(2);
      var obj = {
        foo: true
      };
      this.waiters.add(obj, function () {
        assert.ok(this.foo, 'has proper `this` context');
        return true;
      });
      this.waiters.add(function () {
        assert.ok(true, 'is called');
        return true;
      });
      this.waiters.check();
    };

    _proto2['@test unregistering a waiter'] = function testUnregisteringAWaiter(assert) {
      assert.expect(2);
      var obj = {
        foo: true
      };
      this.waiters.add(obj, function () {
        assert.ok(true, 'precond - waiter with context is registered');
        return true;
      });
      this.waiters.add(function () {
        assert.ok(true, 'precond - waiter without context is registered');
        return true;
      });
      this.waiters.check();
      this.waiters.unregister();
      (0, _waiters.checkWaiters)();
    };

    _proto2['@test checkWaiters returns false if all waiters return true'] = function testCheckWaitersReturnsFalseIfAllWaitersReturnTrue(assert) {
      assert.expect(3);
      this.waiters.add(function () {
        assert.ok(true, 'precond - waiter is registered');
        return true;
      });
      this.waiters.add(function () {
        assert.ok(true, 'precond - waiter is registered');
        return true;
      });
      assert.notOk(this.waiters.check(), 'checkWaiters returns true if all waiters return true');
    };

    _proto2['@test checkWaiters returns true if any waiters return false'] = function testCheckWaitersReturnsTrueIfAnyWaitersReturnFalse(assert) {
      assert.expect(3);
      this.waiters.add(function () {
        assert.ok(true, 'precond - waiter is registered');
        return true;
      });
      this.waiters.add(function () {
        assert.ok(true, 'precond - waiter is registered');
        return false;
      });
      assert.ok(this.waiters.check(), 'checkWaiters returns false if any waiters return false');
    };

    _proto2['@test checkWaiters short circuits after first falsey waiter'] = function testCheckWaitersShortCircuitsAfterFirstFalseyWaiter(assert) {
      assert.expect(2);
      this.waiters.add(function () {
        assert.ok(true, 'precond - waiter is registered');
        return false;
      });
      this.waiters.add(function () {
        assert.notOk(true, 'waiter should not be called');
      });
      assert.ok(this.waiters.check(), 'checkWaiters returns false if any waiters return false');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember/tests/application_lifecycle_test", ["ember-babel", "internal-test-helpers", "@ember/application", "@ember/-internals/routing", "@ember/-internals/glimmer", "@ember/debug"], function (_emberBabel, _internalTestHelpers, _application, _routing, _glimmer, _debug) {
  "use strict";

  var originalDebug = (0, _debug.getDebugFunction)('debug');

  var noop = function () {};

  (0, _internalTestHelpers.moduleFor)('Application Lifecycle - route hooks',
  /*#__PURE__*/
  function (_AutobootApplicationT) {
    (0, _emberBabel.inheritsLoose)(_class, _AutobootApplicationT);
    var _proto = _class.prototype;

    _proto.createApplication = function createApplication() {
      var application = _AutobootApplicationT.prototype.createApplication.apply(this, arguments);

      this.add('router:main', _routing.Router.extend({
        location: 'none'
      }));
      return application;
    };

    function _class() {
      var _this;

      (0, _debug.setDebugFunction)('debug', noop);
      _this = _AutobootApplicationT.call(this) || this;
      var menuItem = _this.menuItem = {};
      (0, _internalTestHelpers.runTask)(function () {
        _this.createApplication();

        var SettingRoute = _routing.Route.extend({
          setupController: function () {
            this.controller.set('selectedMenuItem', menuItem);
          },
          deactivate: function () {
            this.controller.set('selectedMenuItem', null);
          }
        });

        _this.add('route:index', SettingRoute);

        _this.add('route:application', SettingRoute);
      });
      return _this;
    }

    _proto.teardown = function teardown() {
      (0, _debug.setDebugFunction)('debug', originalDebug);
    };

    _proto["@test Resetting the application allows controller properties to be set when a route deactivates"] = function (assert) {
      var indexController = this.indexController,
          applicationController = this.applicationController;
      assert.equal(indexController.get('selectedMenuItem'), this.menuItem);
      assert.equal(applicationController.get('selectedMenuItem'), this.menuItem);
      this.application.reset();
      assert.equal(indexController.get('selectedMenuItem'), null);
      assert.equal(applicationController.get('selectedMenuItem'), null);
    };

    _proto["@test Destroying the application resets the router before the appInstance is destroyed"] = function (assert) {
      var _this2 = this;

      var indexController = this.indexController,
          applicationController = this.applicationController;
      assert.equal(indexController.get('selectedMenuItem'), this.menuItem);
      assert.equal(applicationController.get('selectedMenuItem'), this.menuItem);
      (0, _internalTestHelpers.runTask)(function () {
        _this2.application.destroy();
      });
      assert.equal(indexController.get('selectedMenuItem'), null);
      assert.equal(applicationController.get('selectedMenuItem'), null);
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "indexController",
      get: function () {
        return this.applicationInstance.lookup('controller:index');
      }
    }, {
      key: "applicationController",
      get: function () {
        return this.applicationInstance.lookup('controller:application');
      }
    }]);
    return _class;
  }(_internalTestHelpers.AutobootApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Application Lifecycle',
  /*#__PURE__*/
  function (_AutobootApplicationT2) {
    (0, _emberBabel.inheritsLoose)(_class2, _AutobootApplicationT2);

    function _class2() {
      return _AutobootApplicationT2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2.createApplication = function createApplication() {
      var application = _AutobootApplicationT2.prototype.createApplication.apply(this, arguments);

      this.add('router:main', _routing.Router.extend({
        location: 'none'
      }));
      return application;
    };

    _proto2["@test Destroying a route after the router does create an undestroyed 'toplevelView'"] = function (assert) {
      var _this3 = this;

      (0, _internalTestHelpers.runTask)(function () {
        _this3.createApplication();

        _this3.addTemplate('index', "Index!");

        _this3.addTemplate('application', "Application! {{outlet}}");
      });
      var router = this.applicationInstance.lookup('router:main');
      var route = this.applicationInstance.lookup('route:index');
      (0, _internalTestHelpers.runTask)(function () {
        return router.destroy();
      });
      assert.equal(router._toplevelView, null, 'the toplevelView was cleared');
      (0, _internalTestHelpers.runTask)(function () {
        return route.destroy();
      });
      assert.equal(router._toplevelView, null, 'the toplevelView was not reinitialized');
      (0, _internalTestHelpers.runTask)(function () {
        return _this3.application.destroy();
      });
      assert.equal(router._toplevelView, null, 'the toplevelView was not reinitialized');
    };

    _proto2["@test initializers can augment an applications customEvents hash"] = function (assert) {
      var _this4 = this;

      assert.expect(1);

      var MyApplication = _application.default.extend();

      MyApplication.initializer({
        name: 'customize-things',
        initialize: function (application) {
          application.customEvents = {
            wowza: 'wowza'
          };
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        _this4.createApplication({}, MyApplication);

        _this4.add('component:foo-bar', _glimmer.Component.extend({
          wowza: function () {
            assert.ok(true, 'fired the event!');
          }
        }));

        _this4.addTemplate('application', "{{foo-bar}}");

        _this4.addTemplate('components/foo-bar', "<div id='wowza-thingy'></div>");
      });
      this.$('#wowza-thingy').trigger('wowza');
    };

    _proto2["@test instanceInitializers can augment an the customEvents hash"] = function (assert) {
      var _this5 = this;

      assert.expect(1);

      var MyApplication = _application.default.extend();

      MyApplication.instanceInitializer({
        name: 'customize-things',
        initialize: function (application) {
          application.customEvents = {
            herky: 'jerky'
          };
        }
      });
      (0, _internalTestHelpers.runTask)(function () {
        _this5.createApplication({}, MyApplication);

        _this5.add('component:foo-bar', _glimmer.Component.extend({
          jerky: function () {
            assert.ok(true, 'fired the event!');
          }
        }));

        _this5.addTemplate('application', "{{foo-bar}}");

        _this5.addTemplate('components/foo-bar', "<div id='herky-thingy'></div>");
      });
      this.$('#herky-thingy').trigger('herky');
    };

    return _class2;
  }(_internalTestHelpers.AutobootApplicationTestCase));
});
enifed("ember/tests/component_context_test", ["ember-babel", "@ember/controller", "@ember/-internals/glimmer", "internal-test-helpers"], function (_emberBabel, _controller, _glimmer, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Application Lifecycle - Component Context',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Components with a block should have the proper content when a template is provided'] = function testComponentsWithABlockShouldHaveTheProperContentWhenATemplateIsProvided(assert) {
      var _this = this;

      this.addTemplate('application', "\n      <div id='wrapper'>\n        {{#my-component}}{{text}}{{/my-component}}\n      </div>\n    ");
      this.add('controller:application', _controller.default.extend({
        text: 'outer'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          text: 'inner'
        }),
        template: "{{text}}-{{yield}}"
      });
      return this.visit('/').then(function () {
        var text = (0, _internalTestHelpers.getTextOf)(_this.element.querySelector('#wrapper'));
        assert.equal(text, 'inner-outer', 'The component is composed correctly');
      });
    };

    _proto['@test Components with a block should yield the proper content without a template provided'] = function testComponentsWithABlockShouldYieldTheProperContentWithoutATemplateProvided(assert) {
      var _this2 = this;

      this.addTemplate('application', "\n      <div id='wrapper'>\n        {{#my-component}}{{text}}{{/my-component}}\n      </div>\n    ");
      this.add('controller:application', _controller.default.extend({
        text: 'outer'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          text: 'inner'
        })
      });
      return this.visit('/').then(function () {
        var text = (0, _internalTestHelpers.getTextOf)(_this2.element.querySelector('#wrapper'));
        assert.equal(text, 'outer', 'The component is composed correctly');
      });
    };

    _proto['@test Components without a block should have the proper content when a template is provided'] = function testComponentsWithoutABlockShouldHaveTheProperContentWhenATemplateIsProvided(assert) {
      var _this3 = this;

      this.addTemplate('application', "\n      <div id='wrapper'>{{my-component}}</div>\n    ");
      this.add('controller:application', _controller.default.extend({
        text: 'outer'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          text: 'inner'
        }),
        template: '{{text}}'
      });
      return this.visit('/').then(function () {
        var text = (0, _internalTestHelpers.getTextOf)(_this3.element.querySelector('#wrapper'));
        assert.equal(text, 'inner', 'The component is composed correctly');
      });
    };

    _proto['@test Components without a block should have the proper content'] = function testComponentsWithoutABlockShouldHaveTheProperContent(assert) {
      var _this4 = this;

      this.addTemplate('application', "\n      <div id='wrapper'>{{my-component}}</div>\n    ");
      this.add('controller:application', _controller.default.extend({
        text: 'outer'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          didInsertElement: function () {
            this.element.innerHTML = 'Some text inserted';
          }
        })
      });
      return this.visit('/').then(function () {
        var text = (0, _internalTestHelpers.getTextOf)(_this4.element.querySelector('#wrapper'));
        assert.equal(text, 'Some text inserted', 'The component is composed correctly');
      });
    };

    _proto['@test properties of a component without a template should not collide with internal structures [DEPRECATED]'] = function testPropertiesOfAComponentWithoutATemplateShouldNotCollideWithInternalStructuresDEPRECATED(assert) {
      var _this5 = this;

      this.addTemplate('application', "\n      <div id='wrapper'>{{my-component data=foo}}</div>");
      this.add('controller:application', _controller.default.extend({
        text: 'outer',
        foo: 'Some text inserted'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          didInsertElement: function () {
            this.element.innerHTML = this.get('data');
          }
        })
      });
      return this.visit('/').then(function () {
        var text = (0, _internalTestHelpers.getTextOf)(_this5.element.querySelector('#wrapper'));
        assert.equal(text, 'Some text inserted', 'The component is composed correctly');
      });
    };

    _proto['@test attrs property of a component without a template should not collide with internal structures'] = function testAttrsPropertyOfAComponentWithoutATemplateShouldNotCollideWithInternalStructures(assert) {
      var _this6 = this;

      this.addTemplate('application', "\n      <div id='wrapper'>{{my-component attrs=foo}}</div>\n    ");
      this.add('controller:application', _controller.default.extend({
        text: 'outer',
        foo: 'Some text inserted'
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          didInsertElement: function () {
            this.element.innerHTML = this.get('attrs.attrs.value');
          }
        })
      });
      return this.visit('/').then(function () {
        var text = (0, _internalTestHelpers.getTextOf)(_this6.element.querySelector('#wrapper'));
        assert.equal(text, 'Some text inserted', 'The component is composed correctly');
      });
    };

    _proto['@test Components trigger actions in the parents context when called from within a block'] = function testComponentsTriggerActionsInTheParentsContextWhenCalledFromWithinABlock(assert) {
      var _this7 = this;

      this.addTemplate('application', "\n      <div id='wrapper'>\n        {{#my-component}}\n          <a href='#' id='fizzbuzz' {{action 'fizzbuzz'}}>Fizzbuzz</a>\n        {{/my-component}}\n      </div>\n    ");
      this.add('controller:application', _controller.default.extend({
        actions: {
          fizzbuzz: function () {
            assert.ok(true, 'action triggered on parent');
          }
        }
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({})
      });
      return this.visit('/').then(function () {
        _this7.$('#fizzbuzz', '#wrapper').click();
      });
    };

    _proto['@test Components trigger actions in the components context when called from within its template'] = function testComponentsTriggerActionsInTheComponentsContextWhenCalledFromWithinItsTemplate(assert) {
      var _this8 = this;

      this.addTemplate('application', "\n      <div id='wrapper'>{{#my-component}}{{text}}{{/my-component}}</div>\n    ");
      this.add('controller:application', _controller.default.extend({
        actions: {
          fizzbuzz: function () {
            assert.ok(false, 'action on the wrong context');
          }
        }
      }));
      this.addComponent('my-component', {
        ComponentClass: _glimmer.Component.extend({
          actions: {
            fizzbuzz: function () {
              assert.ok(true, 'action triggered on component');
            }
          }
        }),
        template: "<a href='#' id='fizzbuzz' {{action 'fizzbuzz'}}>Fizzbuzz</a>"
      });
      return this.visit('/').then(function () {
        _this8.$('#fizzbuzz', '#wrapper').click();
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/component_registration_test", ["ember-babel", "@ember/application", "@ember/controller", "@ember/-internals/glimmer", "ember-template-compiler", "internal-test-helpers", "@ember/-internals/environment"], function (_emberBabel, _application, _controller, _glimmer, _emberTemplateCompiler, _internalTestHelpers, _environment) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('Application Lifecycle - Component Registration',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype; // This is necessary for this.application.instanceInitializer to not leak between tests

    _proto.createApplication = function createApplication(options) {
      return _ApplicationTestCase.prototype.createApplication.call(this, options, _application.default.extend());
    };

    _proto['@test The helper becomes the body of the component'] = function testTheHelperBecomesTheBodyOfTheComponent() {
      var _this = this;

      this.addTemplate('components/expand-it', '<p>hello {{yield}}</p>');
      this.addTemplate('application', 'Hello world {{#expand-it}}world{{/expand-it}}');
      return this.visit('/').then(function () {
        _this.assertText('Hello world hello world');

        _this.assertComponentElement(_this.element.firstElementChild, {
          tagName: 'div',
          content: '<p>hello world</p>'
        });
      });
    };

    _proto['@test The helper becomes the body of the component (ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = true;)'] = function testTheHelperBecomesTheBodyOfTheComponentENV_TEMPLATE_ONLY_GLIMMER_COMPONENTSTrue() {
      var _this2 = this;

      _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = true;
      this.addTemplate('components/expand-it', '<p>hello {{yield}}</p>');
      this.addTemplate('application', 'Hello world {{#expand-it}}world{{/expand-it}}');
      return this.visit('/').then(function () {
        _this2.assertInnerHTML('Hello world <p>hello world</p>');

        _environment.ENV._TEMPLATE_ONLY_GLIMMER_COMPONENTS = false;
      });
    };

    _proto['@test If a component is registered, it is used'] = function testIfAComponentIsRegisteredItIsUsed(assert) {
      var _this3 = this;

      this.addTemplate('components/expand-it', '<p>hello {{yield}}</p>');
      this.addTemplate('application', "Hello world {{#expand-it}}world{{/expand-it}}");
      this.application.instanceInitializer({
        name: 'expand-it-component',
        initialize: function (applicationInstance) {
          applicationInstance.register('component:expand-it', _glimmer.Component.extend({
            classNames: 'testing123'
          }));
        }
      });
      return this.visit('/').then(function () {
        var text = _this3.$('div.testing123').text().trim();

        assert.equal(text, 'hello world', 'The component is composed correctly');
      });
    };

    _proto['@test Late-registered components can be rendered with custom `layout` property'] = function testLateRegisteredComponentsCanBeRenderedWithCustomLayoutProperty(assert) {
      var _this4 = this;

      this.addTemplate('application', "<div id='wrapper'>there goes {{my-hero}}</div>");
      this.application.instanceInitializer({
        name: 'my-hero-component',
        initialize: function (applicationInstance) {
          applicationInstance.register('component:my-hero', _glimmer.Component.extend({
            classNames: 'testing123',
            layout: (0, _emberTemplateCompiler.compile)('watch him as he GOES')
          }));
        }
      });
      return this.visit('/').then(function () {
        var text = _this4.$('#wrapper').text().trim();

        assert.equal(text, 'there goes watch him as he GOES', 'The component is composed correctly');
      });
    };

    _proto['@test Late-registered components can be rendered with template registered on the container'] = function testLateRegisteredComponentsCanBeRenderedWithTemplateRegisteredOnTheContainer(assert) {
      var _this5 = this;

      this.addTemplate('application', "<div id='wrapper'>hello world {{sally-rutherford}}-{{#sally-rutherford}}!!!{{/sally-rutherford}}</div>");
      this.application.instanceInitializer({
        name: 'sally-rutherford-component-template',
        initialize: function (applicationInstance) {
          applicationInstance.register('template:components/sally-rutherford', (0, _emberTemplateCompiler.compile)('funkytowny{{yield}}'));
        }
      });
      this.application.instanceInitializer({
        name: 'sally-rutherford-component',
        initialize: function (applicationInstance) {
          applicationInstance.register('component:sally-rutherford', _glimmer.Component);
        }
      });
      return this.visit('/').then(function () {
        var text = _this5.$('#wrapper').text().trim();

        assert.equal(text, 'hello world funkytowny-funkytowny!!!', 'The component is composed correctly');
      });
    };

    _proto['@test Late-registered components can be rendered with ONLY the template registered on the container'] = function testLateRegisteredComponentsCanBeRenderedWithONLYTheTemplateRegisteredOnTheContainer(assert) {
      var _this6 = this;

      this.addTemplate('application', "<div id='wrapper'>hello world {{borf-snorlax}}-{{#borf-snorlax}}!!!{{/borf-snorlax}}</div>");
      this.application.instanceInitializer({
        name: 'borf-snorlax-component-template',
        initialize: function (applicationInstance) {
          applicationInstance.register('template:components/borf-snorlax', (0, _emberTemplateCompiler.compile)('goodfreakingTIMES{{yield}}'));
        }
      });
      return this.visit('/').then(function () {
        var text = _this6.$('#wrapper').text().trim();

        assert.equal(text, 'hello world goodfreakingTIMES-goodfreakingTIMES!!!', 'The component is composed correctly');
      });
    };

    _proto['@test Assigning layoutName to a component should setup the template as a layout'] = function testAssigningLayoutNameToAComponentShouldSetupTheTemplateAsALayout(assert) {
      var _this7 = this;

      assert.expect(1);
      this.addTemplate('application', "<div id='wrapper'>{{#my-component}}{{text}}{{/my-component}}</div>");
      this.addTemplate('foo-bar-baz', '{{text}}-{{yield}}');
      this.application.instanceInitializer({
        name: 'application-controller',
        initialize: function (applicationInstance) {
          applicationInstance.register('controller:application', _controller.default.extend({
            text: 'outer'
          }));
        }
      });
      this.application.instanceInitializer({
        name: 'my-component-component',
        initialize: function (applicationInstance) {
          applicationInstance.register('component:my-component', _glimmer.Component.extend({
            text: 'inner',
            layoutName: 'foo-bar-baz'
          }));
        }
      });
      return this.visit('/').then(function () {
        var text = _this7.$('#wrapper').text().trim();

        assert.equal(text, 'inner-outer', 'The component is composed correctly');
      });
    };

    _proto['@test Assigning layoutName and layout to a component should use the `layout` value'] = function testAssigningLayoutNameAndLayoutToAComponentShouldUseTheLayoutValue(assert) {
      var _this8 = this;

      assert.expect(1);
      this.addTemplate('application', "<div id='wrapper'>{{#my-component}}{{text}}{{/my-component}}</div>");
      this.addTemplate('foo-bar-baz', 'No way!');
      this.application.instanceInitializer({
        name: 'application-controller-layout',
        initialize: function (applicationInstance) {
          applicationInstance.register('controller:application', _controller.default.extend({
            text: 'outer'
          }));
        }
      });
      this.application.instanceInitializer({
        name: 'my-component-component-layout',
        initialize: function (applicationInstance) {
          applicationInstance.register('component:my-component', _glimmer.Component.extend({
            text: 'inner',
            layoutName: 'foo-bar-baz',
            layout: (0, _emberTemplateCompiler.compile)('{{text}}-{{yield}}')
          }));
        }
      });
      return this.visit('/').then(function () {
        var text = _this8.$('#wrapper').text().trim();

        assert.equal(text, 'inner-outer', 'The component is composed correctly');
      });
    };

    _proto['@test Using name of component that does not exist'] =
    /*#__PURE__*/
    function () {
      var _testUsingNameOfComponentThatDoesNotExist = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.addTemplate('application', "<div id='wrapper'>{{#no-good}} {{/no-good}}</div>");
              _context.next = 3;
              return assert.rejectsAssertion(this.visit('/'), /.* named "no-good" .*/);

            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testUsingNameOfComponentThatDoesNotExist(_x) {
        return _testUsingNameOfComponentThatDoesNotExist.apply(this, arguments);
      }

      return testUsingNameOfComponentThatDoesNotExist;
    }();

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/controller_test", ["ember-babel", "@ember/controller", "internal-test-helpers", "@ember/-internals/glimmer"], function (_emberBabel, _controller, _internalTestHelpers, _glimmer) {
  "use strict";

  /*
   In Ember 1.x, controllers subtly affect things like template scope
   and action targets in exciting and often inscrutable ways. This test
   file contains integration tests that verify the correct behavior of
   the many parts of the system that change and rely upon controller scope,
   from the runtime up to the templating layer.
  */
  (0, _internalTestHelpers.moduleFor)('Template scoping examples',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Actions inside an outlet go to the associated controller'] = function testActionsInsideAnOutletGoToTheAssociatedController(assert) {
      var _this = this;

      this.add('controller:index', _controller.default.extend({
        actions: {
          componentAction: function () {
            assert.ok(true, 'controller received the action');
          }
        }
      }));
      this.addComponent('component-with-action', {
        ComponentClass: _glimmer.Component.extend({
          classNames: ['component-with-action'],
          click: function () {
            this.action();
          }
        })
      });
      this.addTemplate('index', '{{component-with-action action=(action "componentAction")}}');
      return this.visit('/').then(function () {
        (0, _internalTestHelpers.runTask)(function () {
          return _this.$('.component-with-action').click();
        });
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/error_handler_test", ["ember-babel", "@ember/debug", "@ember/runloop", "@ember/-internals/error-handling", "rsvp", "internal-test-helpers"], function (_emberBabel, _debug, _runloop, _errorHandling, _rsvp, _internalTestHelpers) {
  "use strict";

  var HAS_UNHANDLED_REJECTION_HANDLER = 'onunhandledrejection' in window;
  var QUNIT_ON_UNHANDLED_REJECTION = QUnit.onUnhandledRejection;
  var WINDOW_ONERROR;

  function runThatThrowsSync() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Error for testing error handling';
    return (0, _runloop.run)(function () {
      throw new Error(message);
    });
  }

  (0, _internalTestHelpers.moduleFor)('error_handler',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.beforeEach = function beforeEach() {
      // capturing this outside of module scope to ensure we grab
      // the test frameworks own window.onerror to reset it
      WINDOW_ONERROR = window.onerror;
    };

    _proto.afterEach = function afterEach() {
      (0, _debug.setTesting)(_debug.isTesting);
      window.onerror = WINDOW_ONERROR;
      (0, _errorHandling.setOnerror)(undefined);
      QUnit.onUnhandledRejection = QUNIT_ON_UNHANDLED_REJECTION;
    };

    _proto['@test by default there is no onerror - sync run'] = function testByDefaultThereIsNoOnerrorSyncRun(assert) {
      assert.strictEqual((0, _errorHandling.getOnerror)(), undefined, 'precond - there should be no Ember.onerror set by default');
      assert.throws(runThatThrowsSync, Error, 'errors thrown sync are catchable');
    };

    _proto['@test when Ember.onerror (which rethrows) is registered - sync run'] = function testWhenEmberOnerrorWhichRethrowsIsRegisteredSyncRun(assert) {
      assert.expect(2);
      (0, _errorHandling.setOnerror)(function (error) {
        assert.ok(true, 'onerror called');
        throw error;
      });
      assert.throws(runThatThrowsSync, Error, 'error is thrown');
    };

    _proto['@test when Ember.onerror (which does not rethrow) is registered - sync run'] = function testWhenEmberOnerrorWhichDoesNotRethrowIsRegisteredSyncRun(assert) {
      assert.expect(2);
      (0, _errorHandling.setOnerror)(function () {
        assert.ok(true, 'onerror called');
      });
      runThatThrowsSync();
      assert.ok(true, 'no error was thrown, Ember.onerror can intercept errors');
    };

    _proto['@test does not swallow exceptions by default (Ember.testing = true, no Ember.onerror) - sync run'] = function testDoesNotSwallowExceptionsByDefaultEmberTestingTrueNoEmberOnerrorSyncRun(assert) {
      (0, _debug.setTesting)(true);
      var error = new Error('the error');
      assert.throws(function () {
        (0, _runloop.run)(function () {
          throw error;
        });
      }, error);
    };

    _proto['@test does not swallow exceptions by default (Ember.testing = false, no Ember.onerror) - sync run'] = function testDoesNotSwallowExceptionsByDefaultEmberTestingFalseNoEmberOnerrorSyncRun(assert) {
      (0, _debug.setTesting)(false);
      var error = new Error('the error');
      assert.throws(function () {
        (0, _runloop.run)(function () {
          throw error;
        });
      }, error);
    };

    _proto['@test does not swallow exceptions (Ember.testing = false, Ember.onerror which rethrows) - sync run'] = function testDoesNotSwallowExceptionsEmberTestingFalseEmberOnerrorWhichRethrowsSyncRun(assert) {
      assert.expect(2);
      (0, _debug.setTesting)(false);
      (0, _errorHandling.setOnerror)(function (error) {
        assert.ok(true, 'Ember.onerror was called');
        throw error;
      });
      var error = new Error('the error');
      assert.throws(function () {
        (0, _runloop.run)(function () {
          throw error;
        });
      }, error);
    };

    _proto['@test Ember.onerror can intercept errors (aka swallow) by not rethrowing (Ember.testing = false) - sync run'] = function testEmberOnerrorCanInterceptErrorsAkaSwallowByNotRethrowingEmberTestingFalseSyncRun(assert) {
      assert.expect(1);
      (0, _debug.setTesting)(false);
      (0, _errorHandling.setOnerror)(function () {
        assert.ok(true, 'Ember.onerror was called');
      });
      var error = new Error('the error');

      try {
        (0, _runloop.run)(function () {
          throw error;
        });
      } catch (e) {
        assert.notOk(true, 'Ember.onerror that does not rethrow is intentionally swallowing errors, try / catch wrapping does not see error');
      }
    };

    _proto['@test does not swallow exceptions by default (Ember.testing = true, no Ember.onerror) - async run'] = function testDoesNotSwallowExceptionsByDefaultEmberTestingTrueNoEmberOnerrorAsyncRun(assert) {
      var done = assert.async();
      var caughtByWindowOnerror;
      (0, _debug.setTesting)(true);

      window.onerror = function (message) {
        caughtByWindowOnerror = message; // prevent "bubbling" and therefore failing the test

        return true;
      };

      (0, _runloop.later)(function () {
        throw new Error('the error');
      }, 10);
      setTimeout(function () {
        assert.pushResult({
          result: /the error/.test(caughtByWindowOnerror),
          actual: caughtByWindowOnerror,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
        });
        done();
      }, 20);
    };

    _proto['@test does not swallow exceptions by default (Ember.testing = false, no Ember.onerror) - async run'] = function testDoesNotSwallowExceptionsByDefaultEmberTestingFalseNoEmberOnerrorAsyncRun(assert) {
      var done = assert.async();
      var caughtByWindowOnerror;
      (0, _debug.setTesting)(false);

      window.onerror = function (message) {
        caughtByWindowOnerror = message; // prevent "bubbling" and therefore failing the test

        return true;
      };

      (0, _runloop.later)(function () {
        throw new Error('the error');
      }, 10);
      setTimeout(function () {
        assert.pushResult({
          result: /the error/.test(caughtByWindowOnerror),
          actual: caughtByWindowOnerror,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onerror, and therefore fail tests (due to QUnit implementing window.onerror)'
        });
        done();
      }, 20);
    };

    _proto['@test Ember.onerror can intercept errors (aka swallow) by not rethrowing (Ember.testing = false) - async run'] = function testEmberOnerrorCanInterceptErrorsAkaSwallowByNotRethrowingEmberTestingFalseAsyncRun(assert) {
      var done = assert.async();
      (0, _debug.setTesting)(false);

      window.onerror = function () {
        assert.notOk(true, 'window.onerror is never invoked when Ember.onerror intentionally swallows errors'); // prevent "bubbling" and therefore failing the test

        return true;
      };

      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called with the error');
      });
      (0, _runloop.later)(function () {
        throw thrown;
      }, 10);
      setTimeout(done, 20);
    };

    _proto["@test errors in promise constructor when Ember.onerror which does not rethrow is present - rsvp"] = function (assert) {
      assert.expect(1);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });
      new _rsvp.default.Promise(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed

      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      });
    };

    _proto["@test errors in promise constructor when Ember.onerror which does rethrow is present - rsvp"] = function (assert) {
      if (!HAS_UNHANDLED_REJECTION_HANDLER) {
        assert.expect(0);
        return;
      }

      assert.expect(2);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      }); // prevent QUnit handler from failing test

      QUnit.onUnhandledRejection = function () {};

      window.onunhandledrejection = function (event) {
        assert.pushResult({
          result: /the error/.test(event.reason),
          actual: event.reason,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onunhandledrejection, and therefore fail tests (due to QUnit implementing window.onunhandledrejection)'
        });
      };

      new _rsvp.default.Promise(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed

      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      });
    };

    _proto["@test errors in promise constructor when Ember.onerror which does not rethrow is present (Ember.testing = false) - rsvp"] = function (assert) {
      assert.expect(1);
      (0, _debug.setTesting)(false);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });
      new _rsvp.default.Promise(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed

      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      });
    };

    _proto["@test errors in promise constructor when Ember.onerror which does rethrow is present (Ember.testing = false) - rsvp"] = function (assert) {
      if (!HAS_UNHANDLED_REJECTION_HANDLER) {
        assert.expect(0);
        return;
      }

      assert.expect(2);
      (0, _debug.setTesting)(false);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      }); // prevent QUnit handler from failing test

      QUnit.onUnhandledRejection = function () {};

      window.onunhandledrejection = function (event) {
        assert.pushResult({
          result: /the error/.test(event.reason),
          actual: event.reason,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onunhandledrejection, and therefore fail tests (due to QUnit implementing window.onunhandledrejection)'
        });
      };

      new _rsvp.default.Promise(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed

      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      });
    };

    _proto["@test errors in promise .then callback when Ember.onerror which does not rethrow is present - rsvp"] = function (assert) {
      assert.expect(1);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });

      _rsvp.default.resolve().then(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed


      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      });
    };

    _proto["@test errors in promise .then callback when Ember.onerror which does rethrow is present - rsvp"] = function (assert) {
      if (!HAS_UNHANDLED_REJECTION_HANDLER) {
        assert.expect(0);
        return;
      }

      assert.expect(2);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      }); // prevent QUnit handler from failing test

      QUnit.onUnhandledRejection = function () {};

      window.onunhandledrejection = function (event) {
        assert.pushResult({
          result: /the error/.test(event.reason),
          actual: event.reason,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onunhandledrejection, and therefore fail tests (due to QUnit implementing window.onunhandledrejection)'
        });
      };

      _rsvp.default.resolve().then(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed


      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      });
    };

    _proto["@test errors in promise .then callback when Ember.onerror which does not rethrow is present (Ember.testing = false) - rsvp"] = function (assert) {
      assert.expect(1);
      (0, _debug.setTesting)(false);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });

      _rsvp.default.resolve().then(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed


      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      });
    };

    _proto["@test errors in promise .then callback when Ember.onerror which does rethrow is present (Ember.testing = false) - rsvp"] = function (assert) {
      if (!HAS_UNHANDLED_REJECTION_HANDLER) {
        assert.expect(0);
        return;
      }

      assert.expect(2);
      (0, _debug.setTesting)(false);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      }); // prevent QUnit handler from failing test

      QUnit.onUnhandledRejection = function () {};

      window.onunhandledrejection = function (event) {
        assert.pushResult({
          result: /the error/.test(event.reason),
          actual: event.reason,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onunhandledrejection, and therefore fail tests (due to QUnit implementing window.onunhandledrejection)'
        });
      };

      _rsvp.default.resolve().then(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed


      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      });
    };

    _proto["@test errors in async promise .then callback when Ember.onerror which does not rethrow is present - rsvp"] = function (assert) {
      assert.expect(1);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });
      new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      }).then(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed

      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 20);
      });
    };

    _proto["@test errors in async promise .then callback when Ember.onerror which does rethrow is present - rsvp"] = function (assert) {
      if (!HAS_UNHANDLED_REJECTION_HANDLER) {
        assert.expect(0);
        return;
      }

      assert.expect(2);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      }); // prevent QUnit handler from failing test

      QUnit.onUnhandledRejection = function () {};

      window.onunhandledrejection = function (event) {
        assert.pushResult({
          result: /the error/.test(event.reason),
          actual: event.reason,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onunhandledrejection, and therefore fail tests (due to QUnit implementing window.onunhandledrejection)'
        });
      };

      new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      }).then(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed

      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 20);
      });
    };

    _proto["@test errors in async promise .then callback when Ember.onerror which does not rethrow is present (Ember.testing = false) - rsvp"] = function (assert) {
      assert.expect(1);
      (0, _debug.setTesting)(false);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
      });
      new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      }).then(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed

      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 20);
      });
    };

    _proto["@test errors in async promise .then callback when Ember.onerror which does rethrow is present (Ember.testing = false) - rsvp"] = function (assert) {
      if (!HAS_UNHANDLED_REJECTION_HANDLER) {
        assert.expect(0);
        return;
      }

      assert.expect(2);
      (0, _debug.setTesting)(false);
      var thrown = new Error('the error');
      (0, _errorHandling.setOnerror)(function (error) {
        assert.strictEqual(error, thrown, 'Ember.onerror is called for errors thrown in RSVP promises');
        throw error;
      }); // prevent QUnit handler from failing test

      QUnit.onUnhandledRejection = function () {};

      window.onunhandledrejection = function (event) {
        assert.pushResult({
          result: /the error/.test(event.reason),
          actual: event.reason,
          expected: 'to include `the error`',
          message: 'error should bubble out to window.onunhandledrejection, and therefore fail tests (due to QUnit implementing window.onunhandledrejection)'
        });
      };

      new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 10);
      }).then(function () {
        throw thrown;
      }); // RSVP.Promise's are configured to settle within the run loop, this
      // ensures that run loop has completed

      return new _rsvp.default.Promise(function (resolve) {
        return setTimeout(resolve, 20);
      });
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember/tests/homepage_example_test", ["ember-babel", "@ember/-internals/routing", "@ember/-internals/metal", "@ember/-internals/runtime", "internal-test-helpers"], function (_emberBabel, _routing, _metal, _runtime, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('The example renders correctly',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Render index template into application outlet'] = function testRenderIndexTemplateIntoApplicationOutlet(assert) {
      var _this = this;

      this.addTemplate('application', '{{outlet}}');
      this.addTemplate('index', '<h1>People</h1><ul>{{#each model as |person|}}<li>Hello, <b>{{person.fullName}}</b>!</li>{{/each}}</ul>');

      var Person = _runtime.Object.extend({
        firstName: null,
        lastName: null,
        fullName: (0, _metal.computed)('firstName', 'lastName', function () {
          return this.get('firstName') + " " + this.get('lastName');
        })
      });

      this.add('route:index', _routing.Route.extend({
        model: function () {
          return (0, _runtime.A)([Person.create({
            firstName: 'Tom',
            lastName: 'Dale'
          }), Person.create({
            firstName: 'Yehuda',
            lastName: 'Katz'
          })]);
        }
      }));
      return this.visit('/').then(function () {
        var $ = _this.$();

        assert.equal($.findAll('h1').text(), 'People');
        assert.equal($.findAll('li').length, 2);
        assert.equal($.findAll('li:nth-of-type(1)').text(), 'Hello, Tom Dale!');
        assert.equal($.findAll('li:nth-of-type(2)').text(), 'Hello, Yehuda Katz!');
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/integration/multiple-app-test", ["ember-babel", "internal-test-helpers", "@ember/application", "@ember/-internals/glimmer", "@ember/-internals/owner", "@ember/polyfills", "rsvp"], function (_emberBabel, _internalTestHelpers, _application, _glimmer, _owner, _polyfills, _rsvp) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('View Integration',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      document.getElementById('qunit-fixture').innerHTML = "\n      <div id=\"one\"></div>\n      <div id=\"two\"></div>\n    ";
      _this = _ApplicationTestCase.call(this) || this;
      (0, _internalTestHelpers.runTask)(function () {
        _this.createSecondApplication();
      });
      return _this;
    }

    var _proto = _class.prototype;

    _proto.createSecondApplication = function createSecondApplication(options) {
      var applicationOptions = this.applicationOptions;
      var secondApplicationOptions = {
        rootElement: '#two'
      };
      var myOptions = (0, _polyfills.assign)(applicationOptions, secondApplicationOptions, options);
      this.secondApp = _application.default.create(myOptions);
      this.secondResolver = this.secondApp.__registry__.resolver;
      return this.secondApp;
    };

    _proto.teardown = function teardown() {
      var _this2 = this;

      _ApplicationTestCase.prototype.teardown.call(this);

      if (this.secondApp) {
        (0, _internalTestHelpers.runTask)(function () {
          _this2.secondApp.destroy();
        });
      }
    };

    _proto.addFactoriesToResolver = function addFactoriesToResolver(actions, resolver) {
      resolver.add('component:special-button', _glimmer.Component.extend({
        actions: {
          doStuff: function () {
            var rootElement = (0, _owner.getOwner)(this).application.rootElement;
            actions.push(rootElement);
          }
        }
      }));
      resolver.add('template:index', this.compile("\n        <h1>Node 1</h1>{{special-button}}\n      ", {
        moduleName: 'my-app/templates/index.hbs'
      }));
      resolver.add('template:components/special-button', this.compile("\n        <button class='do-stuff' {{action 'doStuff'}}>Button</button>\n      ", {
        moduleName: 'my-app/templates/components/special-button.hbs'
      }));
    };

    _proto["@test booting multiple applications can properly handle events"] = function (assert) {
      var _this3 = this;

      var actions = [];
      this.addFactoriesToResolver(actions, this.resolver);
      this.addFactoriesToResolver(actions, this.secondResolver);
      return (0, _rsvp.resolve)().then(function () {
        return _this3.application.visit('/');
      }).then(function () {
        return _this3.secondApp.visit('/');
      }).then(function () {
        document.querySelector('#two .do-stuff').click();
        document.querySelector('#one .do-stuff').click();
        assert.deepEqual(actions, ['#two', '#one']);
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_ApplicationTestCase.prototype.applicationOptions, {
          rootElement: '#one',
          router: null
        });
      }
    }]);
    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/production_build_test", ["ember-babel", "@ember/debug", "internal-test-helpers"], function (_emberBabel, _debug, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('production builds',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test assert does not throw in production builds'] = function testAssertDoesNotThrowInProductionBuilds(assert) {
      if (!true
      /* DEBUG */
      ) {
          assert.expect(1);

          try {
            true && !false && (0, _debug.assert)('Should not throw');
            assert.ok(true, 'Ember.assert did not throw');
          } catch (e) {
            assert.ok(false, "Expected assert not to throw but it did: " + e.message);
          }
        } else {
        assert.expect(0);
      }
    };

    _proto['@test runInDebug does not run the callback in production builds'] = function testRunInDebugDoesNotRunTheCallbackInProductionBuilds(assert) {
      if (!true
      /* DEBUG */
      ) {
          var fired = false;
          (0, _debug.runInDebug)(function () {
            return fired = true;
          });
          assert.equal(fired, false, 'runInDebug callback should not be ran');
        } else {
        assert.expect(0);
      }
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
enifed("ember/tests/reexports_test", ["ember-babel", "ember/index", "@ember/canary-features", "internal-test-helpers", "@ember/-internals/views"], function (_emberBabel, _index, _canaryFeatures, _internalTestHelpers, _views) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('ember reexports',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto["@test Ember exports correctly"] = function (assert) {
      allExports.forEach(function (reexport) {
        var path = reexport[0],
            moduleId = reexport[1],
            exportName = reexport[2]; // default path === exportName if none present

        if (!exportName) {
          exportName = path;
        }

        (0, _internalTestHelpers.confirmExport)(_index.default, assert, path, moduleId, exportName, "Ember." + path + " exports correctly");
      });
    };

    _proto['@test Ember.String.isHTMLSafe exports correctly'] = function testEmberStringIsHTMLSafeExportsCorrectly(assert) {
      (0, _internalTestHelpers.confirmExport)(_index.default, assert, 'String.isHTMLSafe', '@ember/-internals/glimmer', 'isHTMLSafe');
    };

    _proto['@test Ember.EXTEND_PROTOTYPES is present (but deprecated)'] = function testEmberEXTEND_PROTOTYPESIsPresentButDeprecated(assert) {
      expectDeprecation(function () {
        assert.strictEqual(_index.default.ENV.EXTEND_PROTOTYPES, _index.default.EXTEND_PROTOTYPES, 'Ember.EXTEND_PROTOTYPES exists');
      }, /EXTEND_PROTOTYPES is deprecated/);
    };

    _proto['@test Ember.NAME_KEY is deprecated'] = function testEmberNAME_KEYIsDeprecated() {
      expectDeprecation(function () {
        _index.default.NAME_KEY;
      }, 'Using `Ember.NAME_KEY` is deprecated, override `.toString` instead');
    };

    _proto['@test Ember.FEATURES is exported'] = function testEmberFEATURESIsExported(assert) {
      for (var feature in _canaryFeatures.FEATURES) {
        assert.equal(_index.default.FEATURES[feature], _canaryFeatures.FEATURES[feature], 'Ember.FEATURES contains ${feature} with correct value');
      }
    };

    _proto['@test Ember._setComputedDecorator is deprecated'] = function testEmber_setComputedDecoratorIsDeprecated() {
      expectDeprecation(function () {
        _index.default._setComputedDecorator;
      }, 'Please migrate from Ember._setComputedDecorator to Ember._setClassicDecorator');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));

  if (!_views.jQueryDisabled) {
    (0, _internalTestHelpers.moduleFor)('ember reexports: jQuery enabled',
    /*#__PURE__*/
    function (_AbstractTestCase2) {
      (0, _emberBabel.inheritsLoose)(_class2, _AbstractTestCase2);

      function _class2() {
        return _AbstractTestCase2.apply(this, arguments) || this;
      }

      var _proto2 = _class2.prototype;

      _proto2["@test Ember.$ is exported"] = function (assert) {
        expectDeprecation(function () {
          var body = _index.default.$('body').get(0);

          assert.equal(body, document.body, 'Ember.$ exports working jQuery instance');
        }, "Using Ember.$() has been deprecated, use `import jQuery from 'jquery';` instead");
      };

      _proto2['@test Ember.$ _**is**_ window.jQuery'] = function testEmber$_Is_WindowJQuery(assert) {
        expectDeprecation(function () {
          assert.strictEqual(_index.default.$, _views.jQuery);
        }, "Using Ember.$() has been deprecated, use `import jQuery from 'jquery';` instead");
      };

      return _class2;
    }(_internalTestHelpers.AbstractTestCase));
  }

  var allExports = [// @ember/-internals/environment
  ['ENV', '@ember/-internals/environment', {
    get: 'getENV'
  }], ['lookup', '@ember/-internals/environment', {
    get: 'getLookup',
    set: 'setLookup'
  }], ['getOwner', '@ember/application', 'getOwner'], ['setOwner', '@ember/application', 'setOwner'], ['assign', '@ember/polyfills'], // @ember/-internals/utils
  ['GUID_KEY', '@ember/-internals/utils'], ['uuid', '@ember/-internals/utils'], ['generateGuid', '@ember/-internals/utils'], ['guidFor', '@ember/-internals/utils'], ['inspect', '@ember/-internals/utils'], ['makeArray', '@ember/-internals/utils'], ['canInvoke', '@ember/-internals/utils'], ['tryInvoke', '@ember/-internals/utils'], ['wrap', '@ember/-internals/utils'], // @ember/-internals/container
  ['Registry', '@ember/-internals/container', 'Registry'], ['Container', '@ember/-internals/container', 'Container'], // @ember/debug
  ['deprecateFunc', '@ember/debug'], ['deprecate', '@ember/debug'], ['assert', '@ember/debug'], ['warn', '@ember/debug'], ['debug', '@ember/debug'], ['runInDebug', '@ember/debug'], ['Debug.registerDeprecationHandler', '@ember/debug', 'registerDeprecationHandler'], ['Debug.registerWarnHandler', '@ember/debug', 'registerWarnHandler'], ['Error', '@ember/error', 'default'], // @ember/-internals/metal
  ['computed', '@ember/-internals/metal', '_globalsComputed'], ['_descriptor', '@ember/-internals/metal', 'nativeDescDecorator'], ['_tracked', '@ember/-internals/metal', 'tracked'], ['computed.alias', '@ember/-internals/metal', 'alias'], ['ComputedProperty', '@ember/-internals/metal'], ['_setClassicDecorator', '@ember/-internals/metal', 'setClassicDecorator'], ['cacheFor', '@ember/-internals/metal', 'getCachedValueFor'], ['merge', '@ember/polyfills'], ['instrument', '@ember/instrumentation'], ['subscribe', '@ember/instrumentation', 'subscribe'], ['Instrumentation.instrument', '@ember/instrumentation', 'instrument'], ['Instrumentation.subscribe', '@ember/instrumentation', 'subscribe'], ['Instrumentation.unsubscribe', '@ember/instrumentation', 'unsubscribe'], ['Instrumentation.reset', '@ember/instrumentation', 'reset'], ['testing', '@ember/debug', {
    get: 'isTesting',
    set: 'setTesting'
  }], ['onerror', '@ember/-internals/error-handling', {
    get: 'getOnerror',
    set: 'setOnerror'
  }], ['FEATURES.isEnabled', '@ember/canary-features', 'isEnabled'], ['meta', '@ember/-internals/meta'], ['get', '@ember/-internals/metal'], ['set', '@ember/-internals/metal'], ['_getPath', '@ember/-internals/metal'], ['getWithDefault', '@ember/-internals/metal'], ['trySet', '@ember/-internals/metal'], ['_Cache', '@ember/-internals/utils', 'Cache'], ['on', '@ember/-internals/metal'], ['addListener', '@ember/-internals/metal'], ['removeListener', '@ember/-internals/metal'], ['sendEvent', '@ember/-internals/metal'], ['hasListeners', '@ember/-internals/metal'], ['isNone', '@ember/-internals/metal'], ['isEmpty', '@ember/-internals/metal'], ['isBlank', '@ember/-internals/metal'], ['isPresent', '@ember/-internals/metal'], ['_Backburner', 'backburner', 'default'], ['run', '@ember/runloop', '_globalsRun'], ['run.backburner', '@ember/runloop', 'backburner'], ['run.begin', '@ember/runloop', 'begin'], ['run.bind', '@ember/runloop', 'bind'], ['run.cancel', '@ember/runloop', 'cancel'], ['run.debounce', '@ember/runloop', 'debounce'], ['run.end', '@ember/runloop', 'end'], ['run.hasScheduledTimers', '@ember/runloop', 'hasScheduledTimers'], ['run.join', '@ember/runloop', 'join'], ['run.later', '@ember/runloop', 'later'], ['run.next', '@ember/runloop', 'next'], ['run.once', '@ember/runloop', 'once'], ['run.schedule', '@ember/runloop', 'schedule'], ['run.scheduleOnce', '@ember/runloop', 'scheduleOnce'], ['run.throttle', '@ember/runloop', 'throttle'], ['run.currentRunLoop', '@ember/runloop', {
    get: 'getCurrentRunLoop'
  }], ['run.cancelTimers', '@ember/runloop', 'cancelTimers'], ['notifyPropertyChange', '@ember/-internals/metal'], ['overrideChains', '@ember/-internals/metal'], ['beginPropertyChanges', '@ember/-internals/metal'], ['endPropertyChanges', '@ember/-internals/metal'], ['changeProperties', '@ember/-internals/metal'], ['platform.defineProperty', null, {
    value: true
  }], ['platform.hasPropertyAccessors', null, {
    value: true
  }], ['defineProperty', '@ember/-internals/metal'], ['watchKey', '@ember/-internals/metal'], ['unwatchKey', '@ember/-internals/metal'], ['removeChainWatcher', '@ember/-internals/metal'], ['_ChainNode', '@ember/-internals/metal', 'ChainNode'], ['finishChains', '@ember/-internals/metal'], ['watchPath', '@ember/-internals/metal'], ['unwatchPath', '@ember/-internals/metal'], ['watch', '@ember/-internals/metal'], ['isWatching', '@ember/-internals/metal'], ['unwatch', '@ember/-internals/metal'], ['destroy', '@ember/-internals/meta', 'deleteMeta'], ['libraries', '@ember/-internals/metal'], ['getProperties', '@ember/-internals/metal'], ['setProperties', '@ember/-internals/metal'], ['expandProperties', '@ember/-internals/metal'], ['addObserver', '@ember/-internals/metal'], ['removeObserver', '@ember/-internals/metal'], ['aliasMethod', '@ember/-internals/metal'], ['observer', '@ember/-internals/metal'], ['mixin', '@ember/-internals/metal'], ['Mixin', '@ember/-internals/metal'], // @ember/-internals/console
  ['Logger', '@ember/-internals/console', 'default'], // @ember/-internals/views
  ['ViewUtils.isSimpleClick', '@ember/-internals/views', 'isSimpleClick'], ['ViewUtils.getElementView', '@ember/-internals/views', 'getElementView'], ['ViewUtils.getViewElement', '@ember/-internals/views', 'getViewElement'], ['ViewUtils.getViewBounds', '@ember/-internals/views', 'getViewBounds'], ['ViewUtils.getViewClientRects', '@ember/-internals/views', 'getViewClientRects'], ['ViewUtils.getViewBoundingClientRect', '@ember/-internals/views', 'getViewBoundingClientRect'], ['ViewUtils.getRootViews', '@ember/-internals/views', 'getRootViews'], ['ViewUtils.getChildViews', '@ember/-internals/views', 'getChildViews'], ['ViewUtils.isSerializationFirstNode', '@ember/-internals/glimmer', 'isSerializationFirstNode'], ['TextSupport', '@ember/-internals/views'], ['ComponentLookup', '@ember/-internals/views'], ['EventDispatcher', '@ember/-internals/views'], // @ember/-internals/glimmer
  ['Component', '@ember/-internals/glimmer', 'Component'], ['Helper', '@ember/-internals/glimmer', 'Helper'], ['Helper.helper', '@ember/-internals/glimmer', 'helper'], ['Checkbox', '@ember/-internals/glimmer', 'Checkbox'], ['LinkComponent', '@ember/-internals/glimmer', 'LinkComponent'], ['TextArea', '@ember/-internals/glimmer', 'TextArea'], ['TextField', '@ember/-internals/glimmer', 'TextField'], ['TEMPLATES', '@ember/-internals/glimmer', {
    get: 'getTemplates',
    set: 'setTemplates'
  }], ['Handlebars.template', '@ember/-internals/glimmer', 'template'], ['HTMLBars.template', '@ember/-internals/glimmer', 'template'], ['Handlebars.Utils.escapeExpression', '@ember/-internals/glimmer', 'escapeExpression'], ['String.htmlSafe', '@ember/-internals/glimmer', 'htmlSafe'], ['_setComponentManager', '@ember/-internals/glimmer', 'setComponentManager'], ['_componentManagerCapabilities', '@ember/-internals/glimmer', 'capabilities'], // @ember/-internals/runtime
  ['A', '@ember/-internals/runtime'], ['_RegistryProxyMixin', '@ember/-internals/runtime', 'RegistryProxyMixin'], ['_ContainerProxyMixin', '@ember/-internals/runtime', 'ContainerProxyMixin'], ['Object', '@ember/-internals/runtime'], ['String.loc', '@ember/string', 'loc'], ['String.w', '@ember/string', 'w'], ['String.dasherize', '@ember/string', 'dasherize'], ['String.decamelize', '@ember/string', 'decamelize'], ['String.camelize', '@ember/string', 'camelize'], ['String.classify', '@ember/string', 'classify'], ['String.underscore', '@ember/string', 'underscore'], ['String.capitalize', '@ember/string', 'capitalize'], ['compare', '@ember/-internals/runtime'], ['copy', '@ember/-internals/runtime'], ['isEqual', '@ember/-internals/runtime'], ['inject.controller', '@ember/controller', 'inject'], ['inject.service', '@ember/service', 'inject'], ['Array', '@ember/-internals/runtime'], ['Comparable', '@ember/-internals/runtime'], ['Namespace', '@ember/-internals/runtime'], ['Enumerable', '@ember/-internals/runtime'], ['ArrayProxy', '@ember/-internals/runtime'], ['ObjectProxy', '@ember/-internals/runtime'], ['ActionHandler', '@ember/-internals/runtime'], ['CoreObject', '@ember/-internals/runtime'], ['NativeArray', '@ember/-internals/runtime'], ['Copyable', '@ember/-internals/runtime'], ['MutableEnumerable', '@ember/-internals/runtime'], ['MutableArray', '@ember/-internals/runtime'], ['TargetActionSupport', '@ember/-internals/runtime'], ['Evented', '@ember/-internals/runtime'], ['PromiseProxyMixin', '@ember/-internals/runtime'], ['Observable', '@ember/-internals/runtime'], ['typeOf', '@ember/-internals/runtime'], ['isArray', '@ember/-internals/runtime'], ['Object', '@ember/-internals/runtime'], ['onLoad', '@ember/application'], ['runLoadHooks', '@ember/application'], ['Controller', '@ember/controller', 'default'], ['ControllerMixin', '@ember/controller/lib/controller_mixin', 'default'], ['Service', '@ember/service', 'default'], ['_ProxyMixin', '@ember/-internals/runtime'], ['RSVP', '@ember/-internals/runtime'], ['STRINGS', '@ember/string', {
    get: '_getStrings',
    set: '_setStrings'
  }], ['BOOTED', '@ember/-internals/metal', {
    get: 'isNamespaceSearchDisabled',
    set: 'setNamespaceSearchDisabled'
  }], true
  /* EMBER_NATIVE_DECORATOR_SUPPORT */
  ? ['_action', '@ember/object', 'action'] : null, ['computed.empty', '@ember/object/computed', 'empty'], ['computed.notEmpty', '@ember/object/computed', 'notEmpty'], ['computed.none', '@ember/object/computed', 'none'], ['computed.not', '@ember/object/computed', 'not'], ['computed.bool', '@ember/object/computed', 'bool'], ['computed.match', '@ember/object/computed', 'match'], ['computed.equal', '@ember/object/computed', 'equal'], ['computed.gt', '@ember/object/computed', 'gt'], ['computed.gte', '@ember/object/computed', 'gte'], ['computed.lt', '@ember/object/computed', 'lt'], ['computed.lte', '@ember/object/computed', 'lte'], ['computed.oneWay', '@ember/object/computed', 'oneWay'], ['computed.reads', '@ember/object/computed', 'oneWay'], ['computed.readOnly', '@ember/object/computed', 'readOnly'], ['computed.deprecatingAlias', '@ember/object/computed', 'deprecatingAlias'], ['computed.and', '@ember/object/computed', 'and'], ['computed.or', '@ember/object/computed', 'or'], ['computed.sum', '@ember/object/computed', 'sum'], ['computed.min', '@ember/object/computed', 'min'], ['computed.max', '@ember/object/computed', 'max'], ['computed.map', '@ember/object/computed', 'map'], ['computed.sort', '@ember/object/computed', 'sort'], ['computed.setDiff', '@ember/object/computed', 'setDiff'], ['computed.mapBy', '@ember/object/computed', 'mapBy'], ['computed.filter', '@ember/object/computed', 'filter'], ['computed.filterBy', '@ember/object/computed', 'filterBy'], ['computed.uniq', '@ember/object/computed', 'uniq'], ['computed.uniqBy', '@ember/object/computed', 'uniqBy'], ['computed.union', '@ember/object/computed', 'union'], ['computed.intersect', '@ember/object/computed', 'intersect'], ['computed.collect', '@ember/object/computed', 'collect'], // @ember/-internals/routing
  ['Location', '@ember/-internals/routing'], ['AutoLocation', '@ember/-internals/routing'], ['HashLocation', '@ember/-internals/routing'], ['HistoryLocation', '@ember/-internals/routing'], ['NoneLocation', '@ember/-internals/routing'], ['controllerFor', '@ember/-internals/routing'], ['generateControllerFactory', '@ember/-internals/routing'], ['generateController', '@ember/-internals/routing'], ['RouterDSL', '@ember/-internals/routing'], ['Router', '@ember/-internals/routing'], ['Route', '@ember/-internals/routing'], // ember-application
  ['Application', '@ember/application', 'default'], ['ApplicationInstance', '@ember/application/instance', 'default'], ['Engine', '@ember/engine', 'default'], ['EngineInstance', '@ember/engine/instance', 'default'], ['Resolver', '@ember/application/globals-resolver', 'default'], ['DefaultResolver', '@ember/application/globals-resolver', 'default'], // @ember/-internals/extension-support
  ['DataAdapter', '@ember/-internals/extension-support'], ['ContainerDebugAdapter', '@ember/-internals/extension-support']].filter(Boolean);
});
enifed("ember/tests/routing/decoupled_basic_test", ["@ember/polyfills", "ember-babel", "@ember/-internals/owner", "rsvp", "ember-template-compiler", "@ember/-internals/routing", "@ember/controller", "@ember/-internals/runtime", "internal-test-helpers", "@ember/runloop", "@ember/-internals/metal", "@ember/-internals/glimmer", "@ember/engine", "router_js"], function (_polyfills, _emberBabel, _owner, _rsvp, _emberTemplateCompiler, _routing, _controller, _runtime, _internalTestHelpers, _runloop, _metal, _glimmer, _engine, _router_js) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var originalConsoleError;
  (0, _internalTestHelpers.moduleFor)('Basic Routing - Decoupled from global resolver',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.apply(this, arguments) || this;

      _this.addTemplate('home', '<h3 class="hours">Hours</h3>');

      _this.addTemplate('camelot', '<section id="camelot"><h3>Is a silly place</h3></section>');

      _this.addTemplate('homepage', '<h3 id="troll">Megatroll</h3><p>{{model.home}}</p>');

      _this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });

      originalConsoleError = console.error;
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _ApplicationTestCase.prototype.teardown.call(this);

      console.error = originalConsoleError;
    };

    _proto.getController = function getController(name) {
      return this.applicationInstance.lookup("controller:" + name);
    };

    _proto.handleURLAborts = function handleURLAborts(assert, path, deprecated) {
      var _this2 = this;

      (0, _runloop.run)(function () {
        var router = _this2.applicationInstance.lookup('router:main');

        var result;

        if (deprecated !== undefined) {
          expectDeprecation(function () {
            result = router.handleURL(path);
          });
        } else {
          result = router.handleURL(path);
        }

        result.then(function () {
          assert.ok(false, 'url: `' + path + '` was NOT to be handled');
        }, function (reason) {
          assert.ok(reason && reason.message === 'TransitionAborted', 'url: `' + path + '` was to be aborted');
        });
      });
    };

    _proto.handleURLRejectsWith = function handleURLRejectsWith(context, assert, path, expectedReason) {
      return context.visit(path).then(function () {
        assert.ok(false, 'expected handleURLing: `' + path + '` to fail');
      }).catch(function (reason) {
        assert.equal(reason.message, expectedReason);
      });
    };

    _proto['@test warn on URLs not included in the route set'] =
    /*#__PURE__*/
    function () {
      var _testWarnOnURLsNotIncludedInTheRouteSet = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.visit('/');

            case 2:
              _context.next = 4;
              return assert.rejects(this.visit('/what-is-this-i-dont-even'), /\/what-is-this-i-dont-even/);

            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testWarnOnURLsNotIncludedInTheRouteSet(_x) {
        return _testWarnOnURLsNotIncludedInTheRouteSet.apply(this, arguments);
      }

      return testWarnOnURLsNotIncludedInTheRouteSet;
    }();

    _proto['@test The Homepage'] = function testTheHomepage(assert) {
      var _this3 = this;

      return this.visit('/').then(function () {
        assert.equal(_this3.currentPath, 'home', 'currently on the home route');

        var text = _this3.$('.hours').text();

        assert.equal(text, 'Hours', 'the home template was rendered');
      });
    };

    _proto["@test The Homepage and the Camelot page with multiple Router.map calls"] = function (assert) {
      var _this4 = this;

      this.router.map(function () {
        this.route('camelot', {
          path: '/camelot'
        });
      });
      return this.visit('/camelot').then(function () {
        assert.equal(_this4.currentPath, 'camelot');

        var text = _this4.$('#camelot').text();

        assert.equal(text, 'Is a silly place', 'the camelot template was rendered');
        return _this4.visit('/');
      }).then(function () {
        assert.equal(_this4.currentPath, 'home');

        var text = _this4.$('.hours').text();

        assert.equal(text, 'Hours', 'the home template was rendered');
      });
    };

    _proto["@test The Homepage with explicit template name in renderTemplate"] = function (assert) {
      var _this5 = this;

      this.add('route:home', _routing.Route.extend({
        renderTemplate: function () {
          this.render('homepage');
        }
      }));
      return this.visit('/').then(function () {
        var text = _this5.$('#troll').text();

        assert.equal(text, 'Megatroll', 'the homepage template was rendered');
      });
    };

    _proto["@test an alternate template will pull in an alternate controller"] = function (assert) {
      var _this6 = this;

      this.add('route:home', _routing.Route.extend({
        renderTemplate: function () {
          this.render('homepage');
        }
      }));
      this.add('controller:homepage', _controller.default.extend({
        model: {
          home: 'Comes from homepage'
        }
      }));
      return this.visit('/').then(function () {
        var text = _this6.$('p').text();

        assert.equal(text, 'Comes from homepage', 'the homepage template was rendered');
      });
    };

    _proto["@test An alternate template will pull in an alternate controller instead of controllerName"] = function (assert) {
      var _this7 = this;

      this.add('route:home', _routing.Route.extend({
        controllerName: 'foo',
        renderTemplate: function () {
          this.render('homepage');
        }
      }));
      this.add('controller:foo', _controller.default.extend({
        model: {
          home: 'Comes from foo'
        }
      }));
      this.add('controller:homepage', _controller.default.extend({
        model: {
          home: 'Comes from homepage'
        }
      }));
      return this.visit('/').then(function () {
        var text = _this7.$('p').text();

        assert.equal(text, 'Comes from homepage', 'the homepage template was rendered');
      });
    };

    _proto["@test The template will pull in an alternate controller via key/value"] = function (assert) {
      var _this8 = this;

      this.router.map(function () {
        this.route('homepage', {
          path: '/'
        });
      });
      this.add('route:homepage', _routing.Route.extend({
        renderTemplate: function () {
          this.render({
            controller: 'home'
          });
        }
      }));
      this.add('controller:home', _controller.default.extend({
        model: {
          home: 'Comes from home.'
        }
      }));
      return this.visit('/').then(function () {
        var text = _this8.$('p').text();

        assert.equal(text, 'Comes from home.', 'the homepage template was rendered from data from the HomeController');
      });
    };

    _proto["@test The Homepage with explicit template name in renderTemplate and controller"] = function (assert) {
      var _this9 = this;

      this.add('controller:home', _controller.default.extend({
        model: {
          home: 'YES I AM HOME'
        }
      }));
      this.add('route:home', _routing.Route.extend({
        renderTemplate: function () {
          this.render('homepage');
        }
      }));
      return this.visit('/').then(function () {
        var text = _this9.$('p').text();

        assert.equal(text, 'YES I AM HOME', 'The homepage template was rendered');
      });
    };

    _proto["@test Model passed via renderTemplate model is set as controller's model"] = function (assert) {
      var _this10 = this;

      this.addTemplate('bio', '<p>{{model.name}}</p>');
      this.add('route:home', _routing.Route.extend({
        renderTemplate: function () {
          this.render('bio', {
            model: {
              name: 'emberjs'
            }
          });
        }
      }));
      return this.visit('/').then(function () {
        var text = _this10.$('p').text();

        assert.equal(text, 'emberjs', "Passed model was set as controller's model");
      });
    };

    _proto['@test render uses templateName from route'] = function testRenderUsesTemplateNameFromRoute(assert) {
      var _this11 = this;

      this.addTemplate('the_real_home_template', '<p>THIS IS THE REAL HOME</p>');
      this.add('route:home', _routing.Route.extend({
        templateName: 'the_real_home_template'
      }));
      return this.visit('/').then(function () {
        var text = _this11.$('p').text();

        assert.equal(text, 'THIS IS THE REAL HOME', 'the homepage template was rendered');
      });
    };

    _proto['@test defining templateName allows other templates to be rendered'] = function testDefiningTemplateNameAllowsOtherTemplatesToBeRendered(assert) {
      var _this12 = this;

      this.addTemplate('alert', "<div class='alert-box'>Invader!</div>");
      this.addTemplate('the_real_home_template', "<p>THIS IS THE REAL HOME</p>{{outlet 'alert'}}");
      this.add('route:home', _routing.Route.extend({
        templateName: 'the_real_home_template',
        actions: {
          showAlert: function () {
            this.render('alert', {
              into: 'home',
              outlet: 'alert'
            });
          }
        }
      }));
      return this.visit('/').then(function () {
        var text = _this12.$('p').text();

        assert.equal(text, 'THIS IS THE REAL HOME', 'the homepage template was rendered');
        return (0, _internalTestHelpers.runTask)(function () {
          return _this12.appRouter.send('showAlert');
        });
      }).then(function () {
        var text = _this12.$('.alert-box').text();

        assert.equal(text, 'Invader!', 'Template for alert was rendered into the outlet');
      });
    };

    _proto['@test templateName is still used when calling render with no name and options'] = function testTemplateNameIsStillUsedWhenCallingRenderWithNoNameAndOptions(assert) {
      var _this13 = this;

      this.addTemplate('alert', "<div class='alert-box'>Invader!</div>");
      this.addTemplate('home', "<p>THIS IS THE REAL HOME</p>{{outlet 'alert'}}");
      this.add('route:home', _routing.Route.extend({
        templateName: 'alert',
        renderTemplate: function () {
          this.render({});
        }
      }));
      return this.visit('/').then(function () {
        var text = _this13.$('.alert-box').text();

        assert.equal(text, 'Invader!', 'default templateName was rendered into outlet');
      });
    };

    _proto['@test The Homepage with a `setupController` hook'] = function testTheHomepageWithASetupControllerHook(assert) {
      var _this14 = this;

      this.addTemplate('home', "<ul>{{#each hours as |entry|}}\n        <li>{{entry}}</li>\n      {{/each}}\n      </ul>\n    ");
      this.add('route:home', _routing.Route.extend({
        setupController: function (controller) {
          controller.set('hours', ['Monday through Friday: 9am to 5pm', 'Saturday: Noon to Midnight', 'Sunday: Noon to 6pm']);
        }
      }));
      return this.visit('/').then(function () {
        var text = _this14.$('ul li:nth-child(3)').text();

        assert.equal(text, 'Sunday: Noon to 6pm', 'The template was rendered with the hours context');
      });
    };

    _proto["@test The route controller is still set when overriding the setupController hook"] = function (assert) {
      var _this15 = this;

      this.add('route:home', _routing.Route.extend({
        setupController: function () {// no-op
          // importantly, we are not calling this._super
        }
      }));
      this.add('controller:home', _controller.default.extend());
      return this.visit('/').then(function () {
        var homeRoute = _this15.applicationInstance.lookup('route:home');

        var homeController = _this15.applicationInstance.lookup('controller:home');

        assert.equal(homeRoute.controller, homeController, 'route controller is the home controller');
      });
    };

    _proto['@test the route controller can be specified via controllerName'] = function testTheRouteControllerCanBeSpecifiedViaControllerName(assert) {
      var _this16 = this;

      this.addTemplate('home', '<p>{{myValue}}</p>');
      this.add('route:home', _routing.Route.extend({
        controllerName: 'myController'
      }));
      this.add('controller:myController', _controller.default.extend({
        myValue: 'foo'
      }));
      return this.visit('/').then(function () {
        var homeRoute = _this16.applicationInstance.lookup('route:home');

        var myController = _this16.applicationInstance.lookup('controller:myController');

        var text = _this16.$('p').text();

        assert.equal(homeRoute.controller, myController, 'route controller is set by controllerName');
        assert.equal(text, 'foo', 'The homepage template was rendered with data from the custom controller');
      });
    };

    _proto["@test The route controller specified via controllerName is used in render"] = function (assert) {
      var _this17 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add('route:home', _routing.Route.extend({
        controllerName: 'myController',
        renderTemplate: function () {
          this.render('alternative_home');
        }
      }));
      this.add('controller:myController', _controller.default.extend({
        myValue: 'foo'
      }));
      this.addTemplate('alternative_home', '<p>alternative home: {{myValue}}</p>');
      return this.visit('/').then(function () {
        var homeRoute = _this17.applicationInstance.lookup('route:home');

        var myController = _this17.applicationInstance.lookup('controller:myController');

        var text = _this17.$('p').text();

        assert.equal(homeRoute.controller, myController, 'route controller is set by controllerName');
        assert.equal(text, 'alternative home: foo', 'The homepage template was rendered with data from the custom controller');
      });
    };

    _proto["@test The route controller specified via controllerName is used in render even when a controller with the routeName is available"] = function (assert) {
      var _this18 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.addTemplate('home', '<p>home: {{myValue}}</p>');
      this.add('route:home', _routing.Route.extend({
        controllerName: 'myController'
      }));
      this.add('controller:home', _controller.default.extend({
        myValue: 'home'
      }));
      this.add('controller:myController', _controller.default.extend({
        myValue: 'myController'
      }));
      return this.visit('/').then(function () {
        var homeRoute = _this18.applicationInstance.lookup('route:home');

        var myController = _this18.applicationInstance.lookup('controller:myController');

        var text = _this18.$('p').text();

        assert.equal(homeRoute.controller, myController, 'route controller is set by controllerName');
        assert.equal(text, 'home: myController', 'The homepage template was rendered with data from the custom controller');
      });
    };

    _proto["@test The Homepage with a 'setupController' hook modifying other controllers"] = function (assert) {
      var _this19 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add('route:home', _routing.Route.extend({
        setupController: function ()
        /* controller */
        {
          this.controllerFor('home').set('hours', ['Monday through Friday: 9am to 5pm', 'Saturday: Noon to Midnight', 'Sunday: Noon to 6pm']);
        }
      }));
      this.addTemplate('home', '<ul>{{#each hours as |entry|}}<li>{{entry}}</li>{{/each}}</ul>');
      return this.visit('/').then(function () {
        var text = _this19.$('ul li:nth-child(3)').text();

        assert.equal(text, 'Sunday: Noon to 6pm', 'The template was rendered with the hours context');
      });
    };

    _proto["@test The Homepage with a computed model that does not get overridden"] = function (assert) {
      var _this20 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add('controller:home', _controller.default.extend({
        model: (0, _metal.computed)(function () {
          return ['Monday through Friday: 9am to 5pm', 'Saturday: Noon to Midnight', 'Sunday: Noon to 6pm'];
        })
      }));
      this.addTemplate('home', '<ul>{{#each model as |passage|}}<li>{{passage}}</li>{{/each}}</ul>');
      return this.visit('/').then(function () {
        var text = _this20.$('ul li:nth-child(3)').text();

        assert.equal(text, 'Sunday: Noon to 6pm', 'The template was rendered with the context intact');
      });
    };

    _proto["@test The Homepage getting its controller context via model"] = function (assert) {
      var _this21 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add('route:home', _routing.Route.extend({
        model: function () {
          return ['Monday through Friday: 9am to 5pm', 'Saturday: Noon to Midnight', 'Sunday: Noon to 6pm'];
        },
        setupController: function (controller, model) {
          assert.equal(this.controllerFor('home'), controller);
          this.controllerFor('home').set('hours', model);
        }
      }));
      this.addTemplate('home', '<ul>{{#each hours as |entry|}}<li>{{entry}}</li>{{/each}}</ul>');
      return this.visit('/').then(function () {
        var text = _this21.$('ul li:nth-child(3)').text();

        assert.equal(text, 'Sunday: Noon to 6pm', 'The template was rendered with the hours context');
      });
    };

    _proto["@test The Specials Page getting its controller context by deserializing the params hash"] = function (assert) {
      var _this22 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      this.add('route:special', _routing.Route.extend({
        model: function (params) {
          return _runtime.Object.create({
            menuItemId: params.menu_item_id
          });
        }
      }));
      this.addTemplate('special', '<p>{{model.menuItemId}}</p>');
      return this.visit('/specials/1').then(function () {
        var text = _this22.$('p').text();

        assert.equal(text, '1', 'The model was used to render the template');
      });
    };

    _proto['@test The Specials Page defaults to looking models up via `find`'] = function testTheSpecialsPageDefaultsToLookingModelsUpViaFind() {
      var _this23 = this;

      var MenuItem = _runtime.Object.extend();

      MenuItem.reopenClass({
        find: function (id) {
          return MenuItem.create({
            id: id
          });
        }
      });
      this.add('model:menu_item', MenuItem);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      this.addTemplate('special', '{{model.id}}');
      return this.visit('/specials/1').then(function () {
        _this23.assertText('1', 'The model was used to render the template');
      });
    };

    _proto['@test The Special Page returning a promise puts the app into a loading state until the promise is resolved'] = function testTheSpecialPageReturningAPromisePutsTheAppIntoALoadingStateUntilThePromiseIsResolved() {
      var _this24 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      var menuItem, resolve;

      var MenuItem = _runtime.Object.extend();

      MenuItem.reopenClass({
        find: function (id) {
          menuItem = MenuItem.create({
            id: id
          });
          return new _rsvp.default.Promise(function (res) {
            resolve = res;
          });
        }
      });
      this.add('model:menu_item', MenuItem);
      this.addTemplate('special', '<p>{{model.id}}</p>');
      this.addTemplate('loading', '<p>LOADING!</p>');
      var visited = (0, _internalTestHelpers.runTask)(function () {
        return _this24.visit('/specials/1');
      });
      this.assertText('LOADING!', 'The app is in the loading state');
      resolve(menuItem);
      return visited.then(function () {
        _this24.assertText('1', 'The app is now in the specials state');
      });
    };

    _proto["@test The loading state doesn't get entered for promises that resolve on the same run loop"] = function (assert) {
      var _this25 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });

      var MenuItem = _runtime.Object.extend();

      MenuItem.reopenClass({
        find: function (id) {
          return {
            id: id
          };
        }
      });
      this.add('model:menu_item', MenuItem);
      this.add('route:loading', _routing.Route.extend({
        enter: function () {
          assert.ok(false, "LoadingRoute shouldn't have been entered.");
        }
      }));
      this.addTemplate('special', '<p>{{model.id}}</p>');
      this.addTemplate('loading', '<p>LOADING!</p>');
      return this.visit('/specials/1').then(function () {
        var text = _this25.$('p').text();

        assert.equal(text, '1', 'The app is now in the specials state');
      });
    };

    _proto["@test The Special page returning an error invokes SpecialRoute's error handler"] = function testTheSpecialPageReturningAnErrorInvokesSpecialRouteSErrorHandler(assert) {
      var _this26 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      var menuItem, promise, resolve;

      var MenuItem = _runtime.Object.extend();

      MenuItem.reopenClass({
        find: function (id) {
          menuItem = MenuItem.create({
            id: id
          });
          promise = new _rsvp.default.Promise(function (res) {
            return resolve = res;
          });
          return promise;
        }
      });
      this.add('model:menu_item', MenuItem);
      this.add('route:special', _routing.Route.extend({
        setup: function () {
          throw new Error('Setup error');
        },
        actions: {
          error: function (reason) {
            assert.equal(reason.message, 'Setup error', 'SpecialRoute#error received the error thrown from setup');
            return true;
          }
        }
      }));
      (0, _internalTestHelpers.runTask)(function () {
        return _this26.handleURLRejectsWith(_this26, assert, 'specials/1', 'Setup error');
      });
      resolve(menuItem);
    };

    _proto["@test ApplicationRoute's default error handler can be overridden"] = function testApplicationRouteSDefaultErrorHandlerCanBeOverridden(assert) {
      var _this27 = this;

      assert.expect(2);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });
      var menuItem, resolve;

      var MenuItem = _runtime.Object.extend();

      MenuItem.reopenClass({
        find: function (id) {
          menuItem = MenuItem.create({
            id: id
          });
          return new _rsvp.default.Promise(function (res) {
            return resolve = res;
          });
        }
      });
      this.add('model:menu_item', MenuItem);
      this.add('route:application', _routing.Route.extend({
        actions: {
          error: function (reason) {
            assert.equal(reason.message, 'Setup error', 'error was correctly passed to custom ApplicationRoute handler');
            return true;
          }
        }
      }));
      this.add('route:special', _routing.Route.extend({
        setup: function () {
          throw new Error('Setup error');
        }
      }));
      var promise = (0, _internalTestHelpers.runTask)(function () {
        return _this27.handleURLRejectsWith(_this27, assert, '/specials/1', 'Setup error');
      });
      resolve(menuItem);
      return promise;
    };

    _proto['@test Moving from one page to another triggers the correct callbacks'] = function testMovingFromOnePageToAnotherTriggersTheCorrectCallbacks(assert) {
      var _this28 = this;

      assert.expect(3);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('special', {
          path: '/specials/:menu_item_id'
        });
      });

      var MenuItem = _runtime.Object.extend();

      MenuItem.reopenClass({
        find: function (id) {
          return MenuItem.create({
            id: id
          });
        }
      });
      this.add('model:menu_item', MenuItem);
      this.addTemplate('home', '<h3>Home</h3>');
      this.addTemplate('special', '<p>{{model.id}}</p>');
      return this.visit('/').then(function () {
        _this28.assertText('Home', 'The app is now in the initial state');

        var promiseContext = MenuItem.create({
          id: 1
        });
        return _this28.visit('/specials/1', promiseContext);
      }).then(function () {
        assert.equal(_this28.currentURL, '/specials/1');

        _this28.assertText('1', 'The app is now transitioned');
      });
    };

    _proto['@test Nested callbacks are not exited when moving to siblings'] = function testNestedCallbacksAreNotExitedWhenMovingToSiblings(assert) {
      var _this29 = this;

      var rootSetup = 0;
      var rootRender = 0;
      var rootModel = 0;
      var rootSerialize = 0;
      var menuItem;
      var rootElement;

      var MenuItem = _runtime.Object.extend();

      MenuItem.reopenClass({
        find: function (id) {
          menuItem = MenuItem.create({
            id: id
          });
          return menuItem;
        }
      });
      this.router.map(function () {
        this.route('root', {
          path: '/'
        }, function () {
          this.route('special', {
            path: '/specials/:menu_item_id',
            resetNamespace: true
          });
        });
      });
      this.add('route:root', _routing.Route.extend({
        model: function () {
          rootModel++;
          return this._super.apply(this, arguments);
        },
        setupController: function () {
          rootSetup++;
        },
        renderTemplate: function () {
          rootRender++;
        },
        serialize: function () {
          rootSerialize++;
          return this._super.apply(this, arguments);
        }
      }));
      this.add('route:loading', _routing.Route.extend({}));
      this.add('route:home', _routing.Route.extend({}));
      this.add('route:special', _routing.Route.extend({
        model: function (_ref) {
          var menu_item_id = _ref.menu_item_id;
          return MenuItem.find(menu_item_id);
        },
        setupController: function (controller, model) {
          (0, _metal.set)(controller, 'model', model);
        }
      }));
      this.addTemplate('root.index', '<h3>Home</h3>');
      this.addTemplate('special', '<p>{{model.id}}</p>');
      this.addTemplate('loading', '<p>LOADING!</p>');
      return this.visit('/').then(function () {
        rootElement = document.getElementById('qunit-fixture');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('h3')), 'Home', 'The app is now in the initial state');
        assert.equal(rootSetup, 1, 'The root setup was triggered');
        assert.equal(rootRender, 1, 'The root render was triggered');
        assert.equal(rootSerialize, 0, 'The root serialize was not called');
        assert.equal(rootModel, 1, 'The root model was called');

        var router = _this29.applicationInstance.lookup('router:main');

        var menuItem = MenuItem.create({
          id: 1
        });
        return router.transitionTo('special', menuItem).then(function () {
          assert.equal(rootSetup, 1, 'The root setup was not triggered again');
          assert.equal(rootRender, 1, 'The root render was not triggered again');
          assert.equal(rootSerialize, 0, 'The root serialize was not called'); // TODO: Should this be changed?

          assert.equal(rootModel, 1, 'The root model was called again');
          assert.deepEqual(router.location.path, '/specials/1');
          assert.equal(router.currentPath, 'root.special');
        });
      });
    };

    _proto['@test Events are triggered on the controller if a matching action name is implemented'] =
    /*#__PURE__*/
    function () {
      var _testEventsAreTriggeredOnTheControllerIfAMatchingActionNameIsImplemented = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        var done, model, stateIsNotCalled;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              done = assert.async();
              this.router.map(function () {
                this.route('home', {
                  path: '/'
                });
              });
              model = {
                name: 'Tom Dale'
              };
              stateIsNotCalled = true;
              this.add('route:home', _routing.Route.extend({
                model: function () {
                  return model;
                },
                actions: {
                  showStuff: function () {
                    stateIsNotCalled = false;
                  }
                }
              }));
              this.addTemplate('home', '<a {{action "showStuff" model}}>{{name}}</a>');
              this.add('controller:home', _controller.default.extend({
                actions: {
                  showStuff: function (context) {
                    assert.ok(stateIsNotCalled, 'an event on the state is not triggered');
                    assert.deepEqual(context, {
                      name: 'Tom Dale'
                    }, 'an event with context is passed');
                    done();
                  }
                }
              }));
              _context2.next = 9;
              return this.visit('/');

            case 9:
              document.getElementById('qunit-fixture').querySelector('a').click();

            case 10:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testEventsAreTriggeredOnTheControllerIfAMatchingActionNameIsImplemented(_x2) {
        return _testEventsAreTriggeredOnTheControllerIfAMatchingActionNameIsImplemented.apply(this, arguments);
      }

      return testEventsAreTriggeredOnTheControllerIfAMatchingActionNameIsImplemented;
    }();

    _proto['@test Events are triggered on the current state when defined in `actions` object'] =
    /*#__PURE__*/
    function () {
      var _testEventsAreTriggeredOnTheCurrentStateWhenDefinedInActionsObject = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(assert) {
        var done, model, HomeRoute;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              done = assert.async();
              this.router.map(function () {
                this.route('home', {
                  path: '/'
                });
              });
              model = {
                name: 'Tom Dale'
              };
              HomeRoute = _routing.Route.extend({
                model: function () {
                  return model;
                },
                actions: {
                  showStuff: function (obj) {
                    assert.ok(this instanceof HomeRoute, 'the handler is an App.HomeRoute');
                    assert.deepEqual((0, _polyfills.assign)({}, obj), {
                      name: 'Tom Dale'
                    }, 'the context is correct');
                    done();
                  }
                }
              });
              this.add('route:home', HomeRoute);
              this.addTemplate('home', '<a {{action "showStuff" model}}>{{model.name}}</a>');
              _context3.next = 8;
              return this.visit('/');

            case 8:
              document.getElementById('qunit-fixture').querySelector('a').click();

            case 9:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function testEventsAreTriggeredOnTheCurrentStateWhenDefinedInActionsObject(_x3) {
        return _testEventsAreTriggeredOnTheCurrentStateWhenDefinedInActionsObject.apply(this, arguments);
      }

      return testEventsAreTriggeredOnTheCurrentStateWhenDefinedInActionsObject;
    }();

    _proto['@test Events defined in `actions` object are triggered on the current state when routes are nested'] =
    /*#__PURE__*/
    function () {
      var _testEventsDefinedInActionsObjectAreTriggeredOnTheCurrentStateWhenRoutesAreNested = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(assert) {
        var done, model, RootRoute;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              done = assert.async();
              this.router.map(function () {
                this.route('root', {
                  path: '/'
                }, function () {
                  this.route('index', {
                    path: '/'
                  });
                });
              });
              model = {
                name: 'Tom Dale'
              };
              RootRoute = _routing.Route.extend({
                actions: {
                  showStuff: function (obj) {
                    assert.ok(this instanceof RootRoute, 'the handler is an App.HomeRoute');
                    assert.deepEqual((0, _polyfills.assign)({}, obj), {
                      name: 'Tom Dale'
                    }, 'the context is correct');
                    done();
                  }
                }
              });
              this.add('route:root', RootRoute);
              this.add('route:root.index', _routing.Route.extend({
                model: function () {
                  return model;
                }
              }));
              this.addTemplate('root.index', '<a {{action "showStuff" model}}>{{model.name}}</a>');
              _context4.next = 9;
              return this.visit('/');

            case 9:
              document.getElementById('qunit-fixture').querySelector('a').click();

            case 10:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));

      function testEventsDefinedInActionsObjectAreTriggeredOnTheCurrentStateWhenRoutesAreNested(_x4) {
        return _testEventsDefinedInActionsObjectAreTriggeredOnTheCurrentStateWhenRoutesAreNested.apply(this, arguments);
      }

      return testEventsDefinedInActionsObjectAreTriggeredOnTheCurrentStateWhenRoutesAreNested;
    }();

    _proto['@test Events can be handled by inherited event handlers'] = function testEventsCanBeHandledByInheritedEventHandlers(assert) {
      assert.expect(4);

      var SuperRoute = _routing.Route.extend({
        actions: {
          foo: function () {
            assert.ok(true, 'foo');
          },
          bar: function (msg) {
            assert.equal(msg, 'HELLO', 'bar hander in super route');
          }
        }
      });

      var RouteMixin = _metal.Mixin.create({
        actions: {
          bar: function (msg) {
            assert.equal(msg, 'HELLO', 'bar handler in mixin');

            this._super(msg);
          }
        }
      });

      this.add('route:home', SuperRoute.extend(RouteMixin, {
        actions: {
          baz: function () {
            assert.ok(true, 'baz', 'baz hander in route');
          }
        }
      }));
      this.addTemplate('home', "\n      <a class=\"do-foo\" {{action \"foo\"}}>Do foo</a>\n      <a class=\"do-bar-with-arg\" {{action \"bar\" \"HELLO\"}}>Do bar with arg</a>\n      <a class=\"do-baz\" {{action \"baz\"}}>Do bar</a>\n    ");
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        rootElement.querySelector('.do-foo').click();
        rootElement.querySelector('.do-bar-with-arg').click();
        rootElement.querySelector('.do-baz').click();
      });
    };

    _proto['@test Actions are not triggered on the controller if a matching action name is implemented as a method'] =
    /*#__PURE__*/
    function () {
      var _testActionsAreNotTriggeredOnTheControllerIfAMatchingActionNameIsImplementedAsAMethod = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(assert) {
        var done, model, stateIsNotCalled;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              done = assert.async();
              this.router.map(function () {
                this.route('home', {
                  path: '/'
                });
              });
              model = {
                name: 'Tom Dale'
              };
              stateIsNotCalled = true;
              this.add('route:home', _routing.Route.extend({
                model: function () {
                  return model;
                },
                actions: {
                  showStuff: function (context) {
                    assert.ok(stateIsNotCalled, 'an event on the state is not triggered');
                    assert.deepEqual(context, {
                      name: 'Tom Dale'
                    }, 'an event with context is passed');
                    done();
                  }
                }
              }));
              this.addTemplate('home', '<a {{action "showStuff" model}}>{{name}}</a>');
              this.add('controller:home', _controller.default.extend({
                showStuff: function () {
                  stateIsNotCalled = false;
                  assert.ok(stateIsNotCalled, 'an event on the state is not triggered');
                }
              }));
              _context5.next = 9;
              return this.visit('/');

            case 9:
              document.getElementById('qunit-fixture').querySelector('a').click();

            case 10:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));

      function testActionsAreNotTriggeredOnTheControllerIfAMatchingActionNameIsImplementedAsAMethod(_x5) {
        return _testActionsAreNotTriggeredOnTheControllerIfAMatchingActionNameIsImplementedAsAMethod.apply(this, arguments);
      }

      return testActionsAreNotTriggeredOnTheControllerIfAMatchingActionNameIsImplementedAsAMethod;
    }();

    _proto['@test actions can be triggered with multiple arguments'] =
    /*#__PURE__*/
    function () {
      var _testActionsCanBeTriggeredWithMultipleArguments = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(assert) {
        var done, model1, model2, RootRoute;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              done = assert.async();
              this.router.map(function () {
                this.route('root', {
                  path: '/'
                }, function () {
                  this.route('index', {
                    path: '/'
                  });
                });
              });
              model1 = {
                name: 'Tilde'
              };
              model2 = {
                name: 'Tom Dale'
              };
              RootRoute = _routing.Route.extend({
                actions: {
                  showStuff: function (obj1, obj2) {
                    assert.ok(this instanceof RootRoute, 'the handler is an App.HomeRoute');
                    assert.deepEqual((0, _polyfills.assign)({}, obj1), {
                      name: 'Tilde'
                    }, 'the first context is correct');
                    assert.deepEqual((0, _polyfills.assign)({}, obj2), {
                      name: 'Tom Dale'
                    }, 'the second context is correct');
                    done();
                  }
                }
              });
              this.add('route:root', RootRoute);
              this.add('controller:root.index', _controller.default.extend({
                model1: model1,
                model2: model2
              }));
              this.addTemplate('root.index', '<a {{action "showStuff" model1 model2}}>{{model1.name}}</a>');
              _context6.next = 10;
              return this.visit('/');

            case 10:
              document.getElementById('qunit-fixture').querySelector('a').click();

            case 11:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));

      function testActionsCanBeTriggeredWithMultipleArguments(_x6) {
        return _testActionsCanBeTriggeredWithMultipleArguments.apply(this, arguments);
      }

      return testActionsCanBeTriggeredWithMultipleArguments;
    }();

    _proto['@test transitioning multiple times in a single run loop only sets the URL once'] = function testTransitioningMultipleTimesInASingleRunLoopOnlySetsTheURLOnce(assert) {
      var _this30 = this;

      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('foo');
        this.route('bar');
      });
      return this.visit('/').then(function () {
        var urlSetCount = 0;

        var router = _this30.applicationInstance.lookup('router:main');

        router.get('location').setURL = function (path) {
          urlSetCount++;
          (0, _metal.set)(this, 'path', path);
        };

        assert.equal(urlSetCount, 0);
        (0, _runloop.run)(function () {
          router.transitionTo('foo');
          router.transitionTo('bar');
        });
        assert.equal(urlSetCount, 1);
        assert.equal(router.get('location').getURL(), '/bar');
      });
    };

    _proto['@test navigating away triggers a url property change'] = function testNavigatingAwayTriggersAUrlPropertyChange(assert) {
      var _this31 = this;

      assert.expect(3);
      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('foo', {
          path: '/foo'
        });
        this.route('bar', {
          path: '/bar'
        });
      });
      return this.visit('/').then(function () {
        var router = _this31.applicationInstance.lookup('router:main');

        (0, _metal.addObserver)(router, 'url', function () {
          assert.ok(true, 'url change event was fired');
        });
        ['foo', 'bar', '/foo'].forEach(function (destination) {
          return (0, _runloop.run)(router, 'transitionTo', destination);
        });
      });
    };

    _proto['@test using replaceWith calls location.replaceURL if available'] = function testUsingReplaceWithCallsLocationReplaceURLIfAvailable(assert) {
      var _this32 = this;

      var setCount = 0;
      var replaceCount = 0;
      this.router.reopen({
        location: _routing.NoneLocation.create({
          setURL: function (path) {
            setCount++;
            (0, _metal.set)(this, 'path', path);
          },
          replaceURL: function (path) {
            replaceCount++;
            (0, _metal.set)(this, 'path', path);
          }
        })
      });
      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('foo');
      });
      return this.visit('/').then(function () {
        var router = _this32.applicationInstance.lookup('router:main');

        assert.equal(setCount, 1);
        assert.equal(replaceCount, 0);
        (0, _runloop.run)(function () {
          return router.replaceWith('foo');
        });
        assert.equal(setCount, 1, 'should not call setURL');
        assert.equal(replaceCount, 1, 'should call replaceURL once');
        assert.equal(router.get('location').getURL(), '/foo');
      });
    };

    _proto['@test using replaceWith calls setURL if location.replaceURL is not defined'] = function testUsingReplaceWithCallsSetURLIfLocationReplaceURLIsNotDefined(assert) {
      var _this33 = this;

      var setCount = 0;
      this.router.reopen({
        location: _routing.NoneLocation.create({
          setURL: function (path) {
            setCount++;
            (0, _metal.set)(this, 'path', path);
          }
        })
      });
      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('foo');
      });
      return this.visit('/').then(function () {
        var router = _this33.applicationInstance.lookup('router:main');

        assert.equal(setCount, 1);
        (0, _runloop.run)(function () {
          return router.replaceWith('foo');
        });
        assert.equal(setCount, 2, 'should call setURL once');
        assert.equal(router.get('location').getURL(), '/foo');
      });
    };

    _proto['@test Route inherits model from parent route'] = function testRouteInheritsModelFromParentRoute(assert) {
      var _this34 = this;

      assert.expect(9);
      this.router.map(function () {
        this.route('the-post', {
          path: '/posts/:post_id'
        }, function () {
          this.route('comments');
          this.route('shares', {
            path: '/shares/:share_id',
            resetNamespace: true
          }, function () {
            this.route('share');
          });
        });
      });
      var post1 = {};
      var post2 = {};
      var post3 = {};
      var share1 = {};
      var share2 = {};
      var share3 = {};
      var posts = {
        1: post1,
        2: post2,
        3: post3
      };
      var shares = {
        1: share1,
        2: share2,
        3: share3
      };
      this.add('route:the-post', _routing.Route.extend({
        model: function (params) {
          return posts[params.post_id];
        }
      }));
      this.add('route:the-post.comments', _routing.Route.extend({
        afterModel: function (post
        /*, transition */
        ) {
          var parent_model = this.modelFor('the-post');
          assert.equal(post, parent_model);
        }
      }));
      this.add('route:shares', _routing.Route.extend({
        model: function (params) {
          return shares[params.share_id];
        }
      }));
      this.add('route:shares.share', _routing.Route.extend({
        afterModel: function (share
        /*, transition */
        ) {
          var parent_model = this.modelFor('shares');
          assert.equal(share, parent_model);
        }
      }));
      return this.visit('/posts/1/comments').then(function () {
        assert.ok(true, 'url: /posts/1/comments was handled');
        return _this34.visit('/posts/1/shares/1');
      }).then(function () {
        assert.ok(true, 'url: /posts/1/shares/1 was handled');
        return _this34.visit('/posts/2/comments');
      }).then(function () {
        assert.ok(true, 'url: /posts/2/comments was handled');
        return _this34.visit('/posts/2/shares/2');
      }).then(function () {
        assert.ok(true, 'url: /posts/2/shares/2 was handled');
        return _this34.visit('/posts/3/comments');
      }).then(function () {
        assert.ok(true, 'url: /posts/3/shares was handled');
        return _this34.visit('/posts/3/shares/3');
      }).then(function () {
        assert.ok(true, 'url: /posts/3/shares/3 was handled');
      });
    };

    _proto['@test Routes with { resetNamespace: true } inherits model from parent route'] = function testRoutesWithResetNamespaceTrueInheritsModelFromParentRoute(assert) {
      var _this35 = this;

      assert.expect(6);
      this.router.map(function () {
        this.route('the-post', {
          path: '/posts/:post_id'
        }, function () {
          this.route('comments', {
            resetNamespace: true
          }, function () {});
        });
      });
      var post1 = {};
      var post2 = {};
      var post3 = {};
      var posts = {
        1: post1,
        2: post2,
        3: post3
      };
      this.add('route:the-post', _routing.Route.extend({
        model: function (params) {
          return posts[params.post_id];
        }
      }));
      this.add('route:comments', _routing.Route.extend({
        afterModel: function (post
        /*, transition */
        ) {
          var parent_model = this.modelFor('the-post');
          assert.equal(post, parent_model);
        }
      }));
      return this.visit('/posts/1/comments').then(function () {
        assert.ok(true, '/posts/1/comments');
        return _this35.visit('/posts/2/comments');
      }).then(function () {
        assert.ok(true, '/posts/2/comments');
        return _this35.visit('/posts/3/comments');
      }).then(function () {
        assert.ok(true, '/posts/3/comments');
      });
    };

    _proto['@test It is possible to get the model from a parent route'] = function testItIsPossibleToGetTheModelFromAParentRoute(assert) {
      var _this36 = this;

      assert.expect(6);
      this.router.map(function () {
        this.route('the-post', {
          path: '/posts/:post_id'
        }, function () {
          this.route('comments', {
            resetNamespace: true
          });
        });
      });
      var post1 = {};
      var post2 = {};
      var post3 = {};
      var currentPost;
      var posts = {
        1: post1,
        2: post2,
        3: post3
      };
      this.add('route:the-post', _routing.Route.extend({
        model: function (params) {
          return posts[params.post_id];
        }
      }));
      this.add('route:comments', _routing.Route.extend({
        model: function () {
          assert.equal(this.modelFor('the-post'), currentPost);
        }
      }));
      currentPost = post1;
      return this.visit('/posts/1/comments').then(function () {
        assert.ok(true, '/posts/1/comments has been handled');
        currentPost = post2;
        return _this36.visit('/posts/2/comments');
      }).then(function () {
        assert.ok(true, '/posts/2/comments has been handled');
        currentPost = post3;
        return _this36.visit('/posts/3/comments');
      }).then(function () {
        assert.ok(true, '/posts/3/comments has been handled');
      });
    };

    _proto['@test A redirection hook is provided'] = function testARedirectionHookIsProvided(assert) {
      var _this37 = this;

      this.router.map(function () {
        this.route('choose', {
          path: '/'
        });
        this.route('home');
      });
      var chooseFollowed = 0;
      var destination = 'home';
      this.add('route:choose', _routing.Route.extend({
        redirect: function () {
          if (destination) {
            this.transitionTo(destination);
          }
        },
        setupController: function () {
          chooseFollowed++;
        }
      }));
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(chooseFollowed, 0, "The choose route wasn't entered since a transition occurred");
        assert.equal(rootElement.querySelectorAll('h3.hours').length, 1, 'The home template was rendered');
        assert.equal(_this37.currentPath, 'home');
      });
    };

    _proto['@test Redirecting from the middle of a route aborts the remainder of the routes'] = function testRedirectingFromTheMiddleOfARouteAbortsTheRemainderOfTheRoutes(assert) {
      var _this38 = this;

      assert.expect(4);
      this.router.map(function () {
        this.route('home');
        this.route('foo', function () {
          this.route('bar', {
            resetNamespace: true
          }, function () {
            this.route('baz');
          });
        });
      });
      this.add('route:bar', _routing.Route.extend({
        redirect: function () {
          this.transitionTo('home');
        },
        setupController: function () {
          assert.ok(false, 'Should transition before setupController');
        }
      }));
      this.add('route:bar-baz', _routing.Route.extend({
        enter: function () {
          assert.ok(false, 'Should abort transition getting to next route');
        }
      }));
      return this.visit('/').then(function () {
        var router = _this38.applicationInstance.lookup('router:main');

        _this38.handleURLAborts(assert, '/foo/bar/baz');

        var currentPath;
        expectDeprecation(function () {
          currentPath = _this38.applicationInstance.lookup('controller:application').get('currentPath');
        }, 'Accessing `currentPath` on `controller:application` is deprecated, use the `currentPath` property on `service:router` instead.');
        assert.equal(currentPath, 'home');
        assert.equal(router.get('location').getURL(), '/home');
      });
    };

    _proto['@test Redirecting to the current target in the middle of a route does not abort initial routing'] = function testRedirectingToTheCurrentTargetInTheMiddleOfARouteDoesNotAbortInitialRouting(assert) {
      var _this39 = this;

      assert.expect(6);
      this.router.map(function () {
        this.route('home');
        this.route('foo', function () {
          this.route('bar', {
            resetNamespace: true
          }, function () {
            this.route('baz');
          });
        });
      });
      var successCount = 0;
      this.add('route:bar', _routing.Route.extend({
        redirect: function () {
          return this.transitionTo('bar.baz').then(function () {
            successCount++;
          });
        },
        setupController: function () {
          assert.ok(true, "Should still invoke bar's setupController");
        }
      }));
      this.add('route:bar.baz', _routing.Route.extend({
        setupController: function () {
          assert.ok(true, "Should still invoke bar.baz's setupController");
        }
      }));
      return this.visit('/foo/bar/baz').then(function () {
        assert.ok(true, '/foo/bar/baz has been handled');
        var currentPath;
        expectDeprecation(function () {
          currentPath = _this39.applicationInstance.lookup('controller:application').get('currentPath');
        }, 'Accessing `currentPath` on `controller:application` is deprecated, use the `currentPath` property on `service:router` instead.');
        assert.equal(currentPath, 'foo.bar.baz');
        assert.equal(successCount, 1, 'transitionTo success handler was called once');
      });
    };

    _proto['@test Redirecting to the current target with a different context aborts the remainder of the routes'] = function testRedirectingToTheCurrentTargetWithADifferentContextAbortsTheRemainderOfTheRoutes(assert) {
      var _this40 = this;

      assert.expect(5);
      this.router.map(function () {
        this.route('home');
        this.route('foo', function () {
          this.route('bar', {
            path: 'bar/:id',
            resetNamespace: true
          }, function () {
            this.route('baz');
          });
        });
      });
      var model = {
        id: 2
      };
      var count = 0;
      this.add('route:bar', _routing.Route.extend({
        afterModel: function () {
          if (count++ > 10) {
            assert.ok(false, 'infinite loop');
          } else {
            this.transitionTo('bar.baz', model);
          }
        }
      }));
      this.add('route:bar.baz', _routing.Route.extend({
        setupController: function () {
          assert.ok(true, 'Should still invoke setupController');
        }
      }));
      return this.visit('/').then(function () {
        _this40.handleURLAborts(assert, '/foo/bar/1/baz');

        var currentPath;
        expectDeprecation(function () {
          currentPath = _this40.applicationInstance.lookup('controller:application').get('currentPath');
        }, 'Accessing `currentPath` on `controller:application` is deprecated, use the `currentPath` property on `service:router` instead.');
        assert.equal(currentPath, 'foo.bar.baz');
        assert.equal(_this40.applicationInstance.lookup('router:main').get('location').getURL(), '/foo/bar/2/baz');
      });
    };

    _proto['@test Transitioning from a parent event does not prevent currentPath from being set'] = function testTransitioningFromAParentEventDoesNotPreventCurrentPathFromBeingSet(assert) {
      var _this41 = this;

      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar', {
            resetNamespace: true
          }, function () {
            this.route('baz');
          });
          this.route('qux');
        });
      });
      this.add('route:foo', _routing.Route.extend({
        actions: {
          goToQux: function () {
            this.transitionTo('foo.qux');
          }
        }
      }));
      return this.visit('/foo/bar/baz').then(function () {
        assert.ok(true, '/foo/bar/baz has been handled');

        var applicationController = _this41.applicationInstance.lookup('controller:application');

        var router = _this41.applicationInstance.lookup('router:main');

        var currentPath;
        expectDeprecation(function () {
          currentPath = applicationController.get('currentPath');
        }, 'Accessing `currentPath` on `controller:application` is deprecated, use the `currentPath` property on `service:router` instead.');
        assert.equal(currentPath, 'foo.bar.baz');
        (0, _runloop.run)(function () {
          return router.send('goToQux');
        });
        expectDeprecation(function () {
          currentPath = applicationController.get('currentPath');
        }, 'Accessing `currentPath` on `controller:application` is deprecated, use the `currentPath` property on `service:router` instead.');
        assert.equal(currentPath, 'foo.qux');
        assert.equal(router.get('location').getURL(), '/foo/qux');
      });
    };

    _proto['@test Generated names can be customized when providing routes with dot notation'] = function testGeneratedNamesCanBeCustomizedWhenProvidingRoutesWithDotNotation(assert) {
      assert.expect(4);
      this.addTemplate('index', '<div>Index</div>');
      this.addTemplate('application', "<h1>Home</h1><div class='main'>{{outlet}}</div>");
      this.addTemplate('foo', "<div class='middle'>{{outlet}}</div>");
      this.addTemplate('bar', "<div class='bottom'>{{outlet}}</div>");
      this.addTemplate('bar.baz', '<p>{{name}}Bottom!</p>');
      this.router.map(function () {
        this.route('foo', {
          path: '/top'
        }, function () {
          this.route('bar', {
            path: '/middle',
            resetNamespace: true
          }, function () {
            this.route('baz', {
              path: '/bottom'
            });
          });
        });
      });
      this.add('route:foo', _routing.Route.extend({
        renderTemplate: function () {
          assert.ok(true, 'FooBarRoute was called');
          return this._super.apply(this, arguments);
        }
      }));
      this.add('route:bar.baz', _routing.Route.extend({
        renderTemplate: function () {
          assert.ok(true, 'BarBazRoute was called');
          return this._super.apply(this, arguments);
        }
      }));
      this.add('controller:bar', _controller.default.extend({
        name: 'Bar'
      }));
      this.add('controller:bar.baz', _controller.default.extend({
        name: 'BarBaz'
      }));
      return this.visit('/top/middle/bottom').then(function () {
        assert.ok(true, '/top/middle/bottom has been handled');
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('.main .middle .bottom p')), 'BarBazBottom!', 'The templates were rendered into their appropriate parents');
      });
    };

    _proto["@test Child routes render into their parent route's template by default"] = function testChildRoutesRenderIntoTheirParentRouteSTemplateByDefault(assert) {
      this.addTemplate('index', '<div>Index</div>');
      this.addTemplate('application', "<h1>Home</h1><div class='main'>{{outlet}}</div>");
      this.addTemplate('top', "<div class='middle'>{{outlet}}</div>");
      this.addTemplate('middle', "<div class='bottom'>{{outlet}}</div>");
      this.addTemplate('middle.bottom', '<p>Bottom!</p>');
      this.router.map(function () {
        this.route('top', function () {
          this.route('middle', {
            resetNamespace: true
          }, function () {
            this.route('bottom');
          });
        });
      });
      return this.visit('/top/middle/bottom').then(function () {
        assert.ok(true, '/top/middle/bottom has been handled');
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('.main .middle .bottom p')), 'Bottom!', 'The templates were rendered into their appropriate parents');
      });
    };

    _proto['@test Child routes render into specified template'] = function testChildRoutesRenderIntoSpecifiedTemplate(assert) {
      this.addTemplate('index', '<div>Index</div>');
      this.addTemplate('application', "<h1>Home</h1><div class='main'>{{outlet}}</div>");
      this.addTemplate('top', "<div class='middle'>{{outlet}}</div>");
      this.addTemplate('middle', "<div class='bottom'>{{outlet}}</div>");
      this.addTemplate('middle.bottom', '<p>Bottom!</p>');
      this.router.map(function () {
        this.route('top', function () {
          this.route('middle', {
            resetNamespace: true
          }, function () {
            this.route('bottom');
          });
        });
      });
      this.add('route:middle.bottom', _routing.Route.extend({
        renderTemplate: function () {
          this.render('middle/bottom', {
            into: 'top'
          });
        }
      }));
      return this.visit('/top/middle/bottom').then(function () {
        assert.ok(true, '/top/middle/bottom has been handled');
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.querySelectorAll('.main .middle .bottom p').length, 0, 'should not render into the middle template');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('.main .middle > p')), 'Bottom!', 'The template was rendered into the top template');
      });
    };

    _proto['@test Rendering into specified template with slash notation'] = function testRenderingIntoSpecifiedTemplateWithSlashNotation(assert) {
      this.addTemplate('person.profile', 'profile {{outlet}}');
      this.addTemplate('person.details', 'details!');
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add('route:home', _routing.Route.extend({
        renderTemplate: function () {
          this.render('person/profile');
          this.render('person/details', {
            into: 'person/profile'
          });
        }
      }));
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.textContent.trim(), 'profile details!', 'The templates were rendered');
      });
    };

    _proto['@test Parent route context change'] = function testParentRouteContextChange(assert) {
      var _this42 = this;

      var editCount = 0;
      var editedPostIds = (0, _runtime.A)();
      this.addTemplate('application', '{{outlet}}');
      this.addTemplate('posts', '{{outlet}}');
      this.addTemplate('post', '{{outlet}}');
      this.addTemplate('post/index', 'showing');
      this.addTemplate('post/edit', 'editing');
      this.router.map(function () {
        this.route('posts', function () {
          this.route('post', {
            path: '/:postId',
            resetNamespace: true
          }, function () {
            this.route('edit');
          });
        });
      });
      this.add('route:posts', _routing.Route.extend({
        actions: {
          showPost: function (context) {
            this.transitionTo('post', context);
          }
        }
      }));
      this.add('route:post', _routing.Route.extend({
        model: function (params) {
          return {
            id: params.postId
          };
        },
        serialize: function (model) {
          return {
            postId: model.id
          };
        },
        actions: {
          editPost: function () {
            this.transitionTo('post.edit');
          }
        }
      }));
      this.add('route:post.edit', _routing.Route.extend({
        model: function () {
          var postId = this.modelFor('post').id;
          editedPostIds.push(postId);
          return null;
        },
        setup: function () {
          this._super.apply(this, arguments);

          editCount++;
        }
      }));
      return this.visit('/posts/1').then(function () {
        assert.ok(true, '/posts/1 has been handled');

        var router = _this42.applicationInstance.lookup('router:main');

        (0, _runloop.run)(function () {
          return router.send('editPost');
        });
        (0, _runloop.run)(function () {
          return router.send('showPost', {
            id: '2'
          });
        });
        (0, _runloop.run)(function () {
          return router.send('editPost');
        });
        assert.equal(editCount, 2, 'set up the edit route twice without failure');
        assert.deepEqual(editedPostIds, ['1', '2'], 'modelFor posts.post returns the right context');
      });
    };

    _proto['@test Router accounts for rootURL on page load when using history location'] = function testRouterAccountsForRootURLOnPageLoadWhenUsingHistoryLocation(assert) {
      var rootURL = window.location.pathname + '/app';
      var postsTemplateRendered = false;
      var setHistory;

      setHistory = function (obj, path) {
        obj.set('history', {
          state: {
            path: path
          }
        });
      };

      var location = _routing.HistoryLocation.create({
        initState: function () {
          var path = rootURL + '/posts';
          setHistory(this, path);
          this.set('location', {
            pathname: path,
            href: 'http://localhost/' + path
          });
        },
        replaceState: function (path) {
          setHistory(this, path);
        },
        pushState: function (path) {
          setHistory(this, path);
        }
      });

      this.router.reopen({
        // location: 'historyTest',
        location: location,
        rootURL: rootURL
      });
      this.router.map(function () {
        this.route('posts', {
          path: '/posts'
        });
      });
      this.add('route:posts', _routing.Route.extend({
        model: function () {},
        renderTemplate: function () {
          postsTemplateRendered = true;
        }
      }));
      return this.visit('/').then(function () {
        assert.ok(postsTemplateRendered, 'Posts route successfully stripped from rootURL');
        (0, _internalTestHelpers.runDestroy)(location);
        location = null;
      });
    };

    _proto['@test The rootURL is passed properly to the location implementation'] = function testTheRootURLIsPassedProperlyToTheLocationImplementation(assert) {
      assert.expect(1);
      var rootURL = '/blahzorz';
      this.add('location:history-test', _routing.HistoryLocation.extend({
        rootURL: 'this is not the URL you are looking for',
        history: {
          pushState: function () {}
        },
        initState: function () {
          assert.equal(this.get('rootURL'), rootURL);
        }
      }));
      this.router.reopen({
        location: 'history-test',
        rootURL: rootURL,
        // if we transition in this test we will receive failures
        // if the tests are run from a static file
        _doURLTransition: function () {
          return _rsvp.default.resolve('');
        }
      });
      return this.visit('/');
    };

    _proto['@test Only use route rendered into main outlet for default into property on child'] = function testOnlyUseRouteRenderedIntoMainOutletForDefaultIntoPropertyOnChild(assert) {
      this.addTemplate('application', "{{outlet 'menu'}}{{outlet}}");
      this.addTemplate('posts', '{{outlet}}');
      this.addTemplate('posts.index', '<p class="posts-index">postsIndex</p>');
      this.addTemplate('posts.menu', '<div class="posts-menu">postsMenu</div>');
      this.router.map(function () {
        this.route('posts', function () {});
      });
      this.add('route:posts', _routing.Route.extend({
        renderTemplate: function () {
          this.render();
          this.render('posts/menu', {
            into: 'application',
            outlet: 'menu'
          });
        }
      }));
      return this.visit('/posts').then(function () {
        assert.ok(true, '/posts has been handled');
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-menu')), 'postsMenu', 'The posts/menu template was rendered');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p.posts-index')), 'postsIndex', 'The posts/index template was rendered');
      });
    };

    _proto['@test Generating a URL should not affect currentModel'] = function testGeneratingAURLShouldNotAffectCurrentModel(assert) {
      var _this43 = this;

      this.router.map(function () {
        this.route('post', {
          path: '/posts/:post_id'
        });
      });
      var posts = {
        1: {
          id: 1
        },
        2: {
          id: 2
        }
      };
      this.add('route:post', _routing.Route.extend({
        model: function (params) {
          return posts[params.post_id];
        }
      }));
      return this.visit('/posts/1').then(function () {
        assert.ok(true, '/posts/1 has been handled');

        var route = _this43.applicationInstance.lookup('route:post');

        assert.equal(route.modelFor('post'), posts[1]);

        var url = _this43.applicationInstance.lookup('router:main').generate('post', posts[2]);

        assert.equal(url, '/posts/2');
        assert.equal(route.modelFor('post'), posts[1]);
      });
    };

    _proto["@test Nested index route is not overridden by parent's implicit index route"] = function testNestedIndexRouteIsNotOverriddenByParentSImplicitIndexRoute(assert) {
      var _this44 = this;

      this.router.map(function () {
        this.route('posts', function () {
          this.route('index', {
            path: ':category'
          });
        });
      });
      return this.visit('/').then(function () {
        var router = _this44.applicationInstance.lookup('router:main');

        return router.transitionTo('posts', {
          category: 'emberjs'
        });
      }).then(function () {
        var router = _this44.applicationInstance.lookup('router:main');

        assert.deepEqual(router.location.path, '/posts/emberjs');
      });
    };

    _proto['@test Application template does not duplicate when re-rendered'] = function testApplicationTemplateDoesNotDuplicateWhenReRendered(assert) {
      this.addTemplate('application', '<h3 class="render-once">I render once</h3>{{outlet}}');
      this.router.map(function () {
        this.route('posts');
      });
      this.add('route:application', _routing.Route.extend({
        model: function () {
          return (0, _runtime.A)();
        }
      }));
      return this.visit('/posts').then(function () {
        assert.ok(true, '/posts has been handled');
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('h3.render-once')), 'I render once');
      });
    };

    _proto['@test Child routes should render inside the application template if the application template causes a redirect'] = function testChildRoutesShouldRenderInsideTheApplicationTemplateIfTheApplicationTemplateCausesARedirect(assert) {
      this.addTemplate('application', '<h3>App</h3> {{outlet}}');
      this.addTemplate('posts', 'posts');
      this.router.map(function () {
        this.route('posts');
        this.route('photos');
      });
      this.add('route:application', _routing.Route.extend({
        afterModel: function () {
          this.transitionTo('posts');
        }
      }));
      return this.visit('/posts').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.textContent.trim(), 'App posts');
      });
    };

    _proto["@test The template is not re-rendered when the route's context changes"] = function testTheTemplateIsNotReRenderedWhenTheRouteSContextChanges(assert) {
      var _this45 = this;

      this.router.map(function () {
        this.route('page', {
          path: '/page/:name'
        });
      });
      this.add('route:page', _routing.Route.extend({
        model: function (params) {
          return _runtime.Object.create({
            name: params.name
          });
        }
      }));
      var insertionCount = 0;
      this.add('component:foo-bar', _glimmer.Component.extend({
        didInsertElement: function () {
          insertionCount += 1;
        }
      }));
      this.addTemplate('page', '<p>{{model.name}}{{foo-bar}}</p>');
      var rootElement = document.getElementById('qunit-fixture');
      return this.visit('/page/first').then(function () {
        assert.ok(true, '/page/first has been handled');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'first');
        assert.equal(insertionCount, 1);
        return _this45.visit('/page/second');
      }).then(function () {
        assert.ok(true, '/page/second has been handled');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'second');
        assert.equal(insertionCount, 1, 'view should have inserted only once');

        var router = _this45.applicationInstance.lookup('router:main');

        return (0, _runloop.run)(function () {
          return router.transitionTo('page', _runtime.Object.create({
            name: 'third'
          }));
        });
      }).then(function () {
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'third');
        assert.equal(insertionCount, 1, 'view should still have inserted only once');
      });
    };

    _proto['@test The template is not re-rendered when two routes present the exact same template & controller'] = function testTheTemplateIsNotReRenderedWhenTwoRoutesPresentTheExactSameTemplateController(assert) {
      var _this46 = this;

      this.router.map(function () {
        this.route('first');
        this.route('second');
        this.route('third');
        this.route('fourth');
      }); // Note add a component to test insertion

      var insertionCount = 0;
      this.add('component:x-input', _glimmer.Component.extend({
        didInsertElement: function () {
          insertionCount += 1;
        }
      }));

      var SharedRoute = _routing.Route.extend({
        setupController: function () {
          this.controllerFor('shared').set('message', 'This is the ' + this.routeName + ' message');
        },
        renderTemplate: function () {
          this.render('shared', {
            controller: 'shared'
          });
        }
      });

      this.add('route:shared', SharedRoute);
      this.add('route:first', SharedRoute.extend());
      this.add('route:second', SharedRoute.extend());
      this.add('route:third', SharedRoute.extend());
      this.add('route:fourth', SharedRoute.extend());
      this.add('controller:shared', _controller.default.extend());
      this.addTemplate('shared', '<p>{{message}}{{x-input}}</p>');
      var rootElement = document.getElementById('qunit-fixture');
      return this.visit('/first').then(function () {
        assert.ok(true, '/first has been handled');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'This is the first message');
        assert.equal(insertionCount, 1, 'expected one assertion');
        return _this46.visit('/second');
      }).then(function () {
        assert.ok(true, '/second has been handled');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'This is the second message');
        assert.equal(insertionCount, 1, 'expected one assertion');
        return (0, _runloop.run)(function () {
          _this46.applicationInstance.lookup('router:main').transitionTo('third').then(function () {
            assert.ok(true, 'expected transition');
          }, function (reason) {
            assert.ok(false, 'unexpected transition failure: ', QUnit.jsDump.parse(reason));
          });
        });
      }).then(function () {
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'This is the third message');
        assert.equal(insertionCount, 1, 'expected one assertion');
        return _this46.visit('fourth');
      }).then(function () {
        assert.ok(true, '/fourth has been handled');
        assert.equal(insertionCount, 1, 'expected one assertion');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'This is the fourth message');
      });
    };

    _proto['@test ApplicationRoute with model does not proxy the currentPath'] = function testApplicationRouteWithModelDoesNotProxyTheCurrentPath(assert) {
      var _this47 = this;

      var model = {};
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('route:application', _routing.Route.extend({
        model: function () {
          return model;
        }
      }));
      return this.visit('/').then(function () {
        var routerService = _this47.applicationInstance.lookup('service:router');

        assert.equal(routerService.currentRouteName, 'index', 'currentPath is index');
        assert.equal('currentPath' in model, false, 'should have defined currentPath on controller');
      });
    };

    _proto['@test Promises encountered on app load put app into loading state until resolved'] = function testPromisesEncounteredOnAppLoadPutAppIntoLoadingStateUntilResolved(assert) {
      var _this48 = this;

      assert.expect(2);

      var deferred = _rsvp.default.defer();

      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('route:index', _routing.Route.extend({
        model: function () {
          return deferred.promise;
        }
      }));
      this.addTemplate('index', '<p>INDEX</p>');
      this.addTemplate('loading', '<p>LOADING</p>');
      (0, _runloop.run)(function () {
        return _this48.visit('/');
      });
      var rootElement = document.getElementById('qunit-fixture');
      assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'LOADING', 'The loading state is displaying.');
      (0, _runloop.run)(deferred.resolve);
      assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p')), 'INDEX', 'The index route is display.');
    };

    _proto['@test Route should tear down multiple outlets'] = function testRouteShouldTearDownMultipleOutlets(assert) {
      var _this49 = this;

      this.addTemplate('application', "{{outlet 'menu'}}{{outlet}}{{outlet 'footer'}}");
      this.addTemplate('posts', '{{outlet}}');
      this.addTemplate('users', 'users');
      this.addTemplate('posts.index', '<p class="posts-index">postsIndex</p>');
      this.addTemplate('posts.menu', '<div class="posts-menu">postsMenu</div>');
      this.addTemplate('posts.footer', '<div class="posts-footer">postsFooter</div>');
      this.router.map(function () {
        this.route('posts', function () {});
        this.route('users', function () {});
      });
      this.add('route:posts', _routing.Route.extend({
        renderTemplate: function () {
          this.render('posts/menu', {
            into: 'application',
            outlet: 'menu'
          });
          this.render();
          this.render('posts/footer', {
            into: 'application',
            outlet: 'footer'
          });
        }
      }));
      var rootElement = document.getElementById('qunit-fixture');
      return this.visit('/posts').then(function () {
        assert.ok(true, '/posts has been handled');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-menu')), 'postsMenu', 'The posts/menu template was rendered');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('p.posts-index')), 'postsIndex', 'The posts/index template was rendered');
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-footer')), 'postsFooter', 'The posts/footer template was rendered');
        return _this49.visit('/users');
      }).then(function () {
        assert.ok(true, '/users has been handled');
        assert.equal(rootElement.querySelector('div.posts-menu'), null, 'The posts/menu template was removed');
        assert.equal(rootElement.querySelector('p.posts-index'), null, 'The posts/index template was removed');
        assert.equal(rootElement.querySelector('div.posts-footer'), null, 'The posts/footer template was removed');
      });
    };

    _proto['@test Route supports clearing outlet explicitly'] = function testRouteSupportsClearingOutletExplicitly(assert) {
      var _this50 = this;

      this.addTemplate('application', "{{outlet}}{{outlet 'modal'}}");
      this.addTemplate('posts', '{{outlet}}');
      this.addTemplate('users', 'users');
      this.addTemplate('posts.index', '<div class="posts-index">postsIndex {{outlet}}</div>');
      this.addTemplate('posts.modal', '<div class="posts-modal">postsModal</div>');
      this.addTemplate('posts.extra', '<div class="posts-extra">postsExtra</div>');
      this.router.map(function () {
        this.route('posts', function () {});
        this.route('users', function () {});
      });
      this.add('route:posts', _routing.Route.extend({
        actions: {
          showModal: function () {
            this.render('posts/modal', {
              into: 'application',
              outlet: 'modal'
            });
          },
          hideModal: function () {
            this.disconnectOutlet({
              outlet: 'modal',
              parentView: 'application'
            });
          }
        }
      }));
      this.add('route:posts.index', _routing.Route.extend({
        actions: {
          showExtra: function () {
            this.render('posts/extra', {
              into: 'posts/index'
            });
          },
          hideExtra: function () {
            this.disconnectOutlet({
              parentView: 'posts/index'
            });
          }
        }
      }));
      var rootElement = document.getElementById('qunit-fixture');
      return this.visit('/posts').then(function () {
        var router = _this50.applicationInstance.lookup('router:main');

        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-index')), 'postsIndex', 'The posts/index template was rendered');
        (0, _runloop.run)(function () {
          return router.send('showModal');
        });
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-modal')), 'postsModal', 'The posts/modal template was rendered');
        (0, _runloop.run)(function () {
          return router.send('showExtra');
        });
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-extra')), 'postsExtra', 'The posts/extra template was rendered');
        (0, _runloop.run)(function () {
          return router.send('hideModal');
        });
        assert.equal(rootElement.querySelector('div.posts-modal'), null, 'The posts/modal template was removed');
        (0, _runloop.run)(function () {
          return router.send('hideExtra');
        });
        assert.equal(rootElement.querySelector('div.posts-extra'), null, 'The posts/extra template was removed');
        (0, _runloop.run)(function () {
          router.send('showModal');
        });
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-modal')), 'postsModal', 'The posts/modal template was rendered');
        (0, _runloop.run)(function () {
          router.send('showExtra');
        });
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-extra')), 'postsExtra', 'The posts/extra template was rendered');
        return _this50.visit('/users');
      }).then(function () {
        assert.equal(rootElement.querySelector('div.posts-index'), null, 'The posts/index template was removed');
        assert.equal(rootElement.querySelector('div.posts-modal'), null, 'The posts/modal template was removed');
        assert.equal(rootElement.querySelector('div.posts-extra'), null, 'The posts/extra template was removed');
      });
    };

    _proto['@test Route supports clearing outlet using string parameter'] = function testRouteSupportsClearingOutletUsingStringParameter(assert) {
      var _this51 = this;

      this.addTemplate('application', "{{outlet}}{{outlet 'modal'}}");
      this.addTemplate('posts', '{{outlet}}');
      this.addTemplate('users', 'users');
      this.addTemplate('posts.index', '<div class="posts-index">postsIndex {{outlet}}</div>');
      this.addTemplate('posts.modal', '<div class="posts-modal">postsModal</div>');
      this.router.map(function () {
        this.route('posts', function () {});
        this.route('users', function () {});
      });
      this.add('route:posts', _routing.Route.extend({
        actions: {
          showModal: function () {
            this.render('posts/modal', {
              into: 'application',
              outlet: 'modal'
            });
          },
          hideModal: function () {
            this.disconnectOutlet('modal');
          }
        }
      }));
      var rootElement = document.getElementById('qunit-fixture');
      return this.visit('/posts').then(function () {
        var router = _this51.applicationInstance.lookup('router:main');

        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-index')), 'postsIndex', 'The posts/index template was rendered');
        (0, _runloop.run)(function () {
          return router.send('showModal');
        });
        assert.equal((0, _internalTestHelpers.getTextOf)(rootElement.querySelector('div.posts-modal')), 'postsModal', 'The posts/modal template was rendered');
        (0, _runloop.run)(function () {
          return router.send('hideModal');
        });
        assert.equal(rootElement.querySelector('div.posts-modal'), null, 'The posts/modal template was removed');
        return _this51.visit('/users');
      }).then(function () {
        assert.equal(rootElement.querySelector('div.posts-index'), null, 'The posts/index template was removed');
        assert.equal(rootElement.querySelector('div.posts-modal'), null, 'The posts/modal template was removed');
      });
    };

    _proto['@test Route silently fails when cleaning an outlet from an inactive view'] = function testRouteSilentlyFailsWhenCleaningAnOutletFromAnInactiveView(assert) {
      var _this52 = this;

      assert.expect(1); // handleURL

      this.addTemplate('application', '{{outlet}}');
      this.addTemplate('posts', "{{outlet 'modal'}}");
      this.addTemplate('modal', 'A Yo.');
      this.router.map(function () {
        this.route('posts');
      });
      this.add('route:posts', _routing.Route.extend({
        actions: {
          hideSelf: function () {
            this.disconnectOutlet({
              outlet: 'main',
              parentView: 'application'
            });
          },
          showModal: function () {
            this.render('modal', {
              into: 'posts',
              outlet: 'modal'
            });
          },
          hideModal: function () {
            this.disconnectOutlet({
              outlet: 'modal',
              parentView: 'posts'
            });
          }
        }
      }));
      return this.visit('/posts').then(function () {
        assert.ok(true, '/posts has been handled');

        var router = _this52.applicationInstance.lookup('router:main');

        (0, _runloop.run)(function () {
          return router.send('showModal');
        });
        (0, _runloop.run)(function () {
          return router.send('hideSelf');
        });
        (0, _runloop.run)(function () {
          return router.send('hideModal');
        });
      });
    };

    _proto['@test Router `willTransition` hook passes in cancellable transition'] = function testRouterWillTransitionHookPassesInCancellableTransition(assert) {
      var _this53 = this;

      assert.expect(8);
      this.router.reopen({
        willTransition: function (_, _2, transition) {
          assert.ok(true, 'willTransition was called');

          if (transition.intent.url !== '/') {
            transition.abort();
          }
        }
      });
      this.router.map(function () {
        this.route('nork');
        this.route('about');
      });
      this.add('route:loading', _routing.Route.extend({
        activate: function () {
          assert.ok(false, 'LoadingRoute was not entered');
        }
      }));
      this.add('route:nork', _routing.Route.extend({
        activate: function () {
          assert.ok(false, 'NorkRoute was not entered');
        }
      }));
      this.add('route:about', _routing.Route.extend({
        activate: function () {
          assert.ok(false, 'AboutRoute was not entered');
        }
      }));
      var deprecation = /You attempted to override the "willTransition" method which is deprecated\./;
      return expectDeprecationAsync(function () {
        return _this53.visit('/').then(function () {
          _this53.handleURLAborts(assert, '/nork', deprecation);

          _this53.handleURLAborts(assert, '/about', deprecation);
        });
      }, deprecation);
    };

    _proto['@test Aborting/redirecting the transition in `willTransition` prevents LoadingRoute from being entered'] = function testAbortingRedirectingTheTransitionInWillTransitionPreventsLoadingRouteFromBeingEntered(assert) {
      var _this54 = this;

      assert.expect(5);
      this.router.map(function () {
        this.route('index');
        this.route('nork');
        this.route('about');
      });
      var redirect = false;
      this.add('route:index', _routing.Route.extend({
        actions: {
          willTransition: function (transition) {
            assert.ok(true, 'willTransition was called');

            if (redirect) {
              // router.js won't refire `willTransition` for this redirect
              this.transitionTo('about');
            } else {
              transition.abort();
            }
          }
        }
      }));
      var deferred = null;
      this.add('route:loading', _routing.Route.extend({
        activate: function () {
          assert.ok(deferred, 'LoadingRoute should be entered at this time');
        },
        deactivate: function () {
          assert.ok(true, 'LoadingRoute was exited');
        }
      }));
      this.add('route:nork', _routing.Route.extend({
        activate: function () {
          assert.ok(true, 'NorkRoute was entered');
        }
      }));
      this.add('route:about', _routing.Route.extend({
        activate: function () {
          assert.ok(true, 'AboutRoute was entered');
        },
        model: function () {
          if (deferred) {
            return deferred.promise;
          }
        }
      }));
      return this.visit('/').then(function () {
        var router = _this54.applicationInstance.lookup('router:main'); // Attempted transitions out of index should abort.


        (0, _runloop.run)(router, 'transitionTo', 'nork');
        (0, _runloop.run)(router, 'handleURL', '/nork'); // Attempted transitions out of index should redirect to about

        redirect = true;
        (0, _runloop.run)(router, 'transitionTo', 'nork');
        (0, _runloop.run)(router, 'transitionTo', 'index'); // Redirected transitions out of index to a route with a
        // promise model should pause the transition and
        // activate LoadingRoute

        deferred = _rsvp.default.defer();
        (0, _runloop.run)(router, 'transitionTo', 'nork');
        (0, _runloop.run)(deferred.resolve);
      });
    };

    _proto['@test `didTransition` event fires on the router'] =
    /*#__PURE__*/
    function () {
      var _testDidTransitionEventFiresOnTheRouter = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(assert) {
        var router;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              assert.expect(3);
              this.router.map(function () {
                this.route('nork');
              });
              _context7.next = 4;
              return this.visit('/');

            case 4:
              router = this.applicationInstance.lookup('router:main');
              router.one('didTransition', function () {
                assert.ok(true, 'didTransition fired on initial routing');
              });
              _context7.next = 8;
              return this.visit('/');

            case 8:
              router.one('didTransition', function () {
                assert.ok(true, 'didTransition fired on the router');
                assert.equal(router.get('url'), '/nork', 'The url property is updated by the time didTransition fires');
              });
              _context7.next = 11;
              return this.visit('/nork');

            case 11:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));

      function testDidTransitionEventFiresOnTheRouter(_x7) {
        return _testDidTransitionEventFiresOnTheRouter.apply(this, arguments);
      }

      return testDidTransitionEventFiresOnTheRouter;
    }();

    _proto['@test `activate` event fires on the route'] = function testActivateEventFiresOnTheRoute(assert) {
      assert.expect(2);
      var eventFired = 0;
      this.router.map(function () {
        this.route('nork');
      });
      this.add('route:nork', _routing.Route.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.on('activate', function () {
            assert.equal(++eventFired, 1, 'activate event is fired once');
          });
        },
        activate: function () {
          assert.ok(true, 'activate hook is called');
        }
      }));
      return this.visit('/nork');
    };

    _proto['@test `deactivate` event fires on the route'] = function testDeactivateEventFiresOnTheRoute(assert) {
      var _this55 = this;

      assert.expect(2);
      var eventFired = 0;
      this.router.map(function () {
        this.route('nork');
        this.route('dork');
      });
      this.add('route:nork', _routing.Route.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.on('deactivate', function () {
            assert.equal(++eventFired, 1, 'deactivate event is fired once');
          });
        },
        deactivate: function () {
          assert.ok(true, 'deactivate hook is called');
        }
      }));
      return this.visit('/nork').then(function () {
        return _this55.visit('/dork');
      });
    };

    _proto['@test Actions can be handled by inherited action handlers'] = function testActionsCanBeHandledByInheritedActionHandlers(assert) {
      assert.expect(4);

      var SuperRoute = _routing.Route.extend({
        actions: {
          foo: function () {
            assert.ok(true, 'foo');
          },
          bar: function (msg) {
            assert.equal(msg, 'HELLO');
          }
        }
      });

      var RouteMixin = _metal.Mixin.create({
        actions: {
          bar: function (msg) {
            assert.equal(msg, 'HELLO');

            this._super(msg);
          }
        }
      });

      this.add('route:home', SuperRoute.extend(RouteMixin, {
        actions: {
          baz: function () {
            assert.ok(true, 'baz');
          }
        }
      }));
      this.addTemplate('home', "\n      <a class=\"do-foo\" {{action \"foo\"}}>Do foo</a>\n      <a class=\"do-bar-with-arg\" {{action \"bar\" \"HELLO\"}}>Do bar with arg</a>\n      <a class=\"do-baz\" {{action \"baz\"}}>Do bar</a>\n    ");
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        rootElement.querySelector('.do-foo').click();
        rootElement.querySelector('.do-bar-with-arg').click();
        rootElement.querySelector('.do-baz').click();
      });
    };

    _proto['@test transitionTo returns Transition when passed a route name'] = function testTransitionToReturnsTransitionWhenPassedARouteName(assert) {
      var _this56 = this;

      assert.expect(1);
      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('bar');
      });
      return this.visit('/').then(function () {
        var router = _this56.applicationInstance.lookup('router:main');

        var transition = (0, _runloop.run)(function () {
          return router.transitionTo('bar');
        });
        assert.equal(transition instanceof _router_js.InternalTransition, true);
      });
    };

    _proto['@test transitionTo returns Transition when passed a url'] = function testTransitionToReturnsTransitionWhenPassedAUrl(assert) {
      var _this57 = this;

      assert.expect(1);
      this.router.map(function () {
        this.route('root', {
          path: '/'
        });
        this.route('bar', function () {
          this.route('baz');
        });
      });
      return this.visit('/').then(function () {
        var router = _this57.applicationInstance.lookup('router:main');

        var transition = (0, _runloop.run)(function () {
          return router.transitionTo('/bar/baz');
        });
        assert.equal(transition instanceof _router_js.InternalTransition, true);
      });
    };

    _proto['@test currentRouteName is a property installed on ApplicationController that can be used in transitionTo'] = function testCurrentRouteNameIsAPropertyInstalledOnApplicationControllerThatCanBeUsedInTransitionTo(assert) {
      var _this58 = this;

      assert.expect(36);
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
        this.route('be', function () {
          this.route('excellent', {
            resetNamespace: true
          }, function () {
            this.route('to', {
              resetNamespace: true
            }, function () {
              this.route('each', {
                resetNamespace: true
              }, function () {
                this.route('other');
              });
            });
          });
        });
      });
      return this.visit('/').then(function () {
        var appController = _this58.applicationInstance.lookup('controller:application');

        var router = _this58.applicationInstance.lookup('router:main');

        function transitionAndCheck(path, expectedPath, expectedRouteName) {
          if (path) {
            (0, _runloop.run)(router, 'transitionTo', path);
          }

          expectDeprecation(function () {
            assert.equal(appController.get('currentPath'), expectedPath);
            assert.equal(appController.get('currentRouteName'), expectedRouteName);
          }, 'Accessing `currentPath` on `controller:application` is deprecated, use the `currentPath` property on `service:router` instead.');
        }

        transitionAndCheck(null, 'index', 'index');
        transitionAndCheck('/be', 'be.index', 'be.index');
        transitionAndCheck('/be/excellent', 'be.excellent.index', 'excellent.index');
        transitionAndCheck('/be/excellent/to', 'be.excellent.to.index', 'to.index');
        transitionAndCheck('/be/excellent/to/each', 'be.excellent.to.each.index', 'each.index');
        transitionAndCheck('/be/excellent/to/each/other', 'be.excellent.to.each.other', 'each.other');
        transitionAndCheck('index', 'index', 'index');
        transitionAndCheck('be', 'be.index', 'be.index');
        transitionAndCheck('excellent', 'be.excellent.index', 'excellent.index');
        transitionAndCheck('to.index', 'be.excellent.to.index', 'to.index');
        transitionAndCheck('each', 'be.excellent.to.each.index', 'each.index');
        transitionAndCheck('each.other', 'be.excellent.to.each.other', 'each.other');
      });
    };

    _proto['@test Route model hook finds the same model as a manual find'] = function testRouteModelHookFindsTheSameModelAsAManualFind(assert) {
      var post;

      var Post = _runtime.Object.extend();

      this.add('model:post', Post);
      Post.reopenClass({
        find: function () {
          post = this;
          return {};
        }
      });
      this.router.map(function () {
        this.route('post', {
          path: '/post/:post_id'
        });
      });
      return this.visit('/post/1').then(function () {
        assert.equal(Post, post);
      });
    };

    _proto['@test Routes can refresh themselves causing their model hooks to be re-run'] = function testRoutesCanRefreshThemselvesCausingTheirModelHooksToBeReRun(assert) {
      var _this59 = this;

      this.router.map(function () {
        this.route('parent', {
          path: '/parent/:parent_id'
        }, function () {
          this.route('child');
        });
      });
      var appcount = 0;
      this.add('route:application', _routing.Route.extend({
        model: function () {
          ++appcount;
        }
      }));
      var parentcount = 0;
      this.add('route:parent', _routing.Route.extend({
        model: function (params) {
          assert.equal(params.parent_id, '123');
          ++parentcount;
        },
        actions: {
          refreshParent: function () {
            this.refresh();
          }
        }
      }));
      var childcount = 0;
      this.add('route:parent.child', _routing.Route.extend({
        model: function () {
          ++childcount;
        }
      }));
      var router;
      return this.visit('/').then(function () {
        router = _this59.applicationInstance.lookup('router:main');
        assert.equal(appcount, 1);
        assert.equal(parentcount, 0);
        assert.equal(childcount, 0);
        return (0, _runloop.run)(router, 'transitionTo', 'parent.child', '123');
      }).then(function () {
        assert.equal(appcount, 1);
        assert.equal(parentcount, 1);
        assert.equal(childcount, 1);
        return (0, _runloop.run)(router, 'send', 'refreshParent');
      }).then(function () {
        assert.equal(appcount, 1);
        assert.equal(parentcount, 2);
        assert.equal(childcount, 2);
      });
    };

    _proto['@test Specifying non-existent controller name in route#render throws'] = function testSpecifyingNonExistentControllerNameInRouteRenderThrows(assert) {
      assert.expect(1);
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
      });
      this.add('route:home', _routing.Route.extend({
        renderTemplate: function () {
          var _this60 = this;

          expectAssertion(function () {
            _this60.render('homepage', {
              controller: 'stefanpenneristhemanforme'
            });
          }, "You passed `controller: 'stefanpenneristhemanforme'` into the `render` method, but no such controller could be found.");
        }
      }));
      return this.visit('/');
    };

    _proto["@test Redirecting with null model doesn't error out"] = function testRedirectingWithNullModelDoesnTErrorOut(assert) {
      var _this61 = this;

      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('about', {
          path: '/about/:hurhurhur'
        });
      });
      this.add('route:about', _routing.Route.extend({
        serialize: function (model) {
          if (model === null) {
            return {
              hurhurhur: 'TreeklesMcGeekles'
            };
          }
        }
      }));
      this.add('route:home', _routing.Route.extend({
        beforeModel: function () {
          this.transitionTo('about', null);
        }
      }));
      return this.visit('/').then(function () {
        var router = _this61.applicationInstance.lookup('router:main');

        assert.equal(router.get('location.path'), '/about/TreeklesMcGeekles');
      });
    };

    _proto['@test rejecting the model hooks promise with a non-error prints the `message` property'] =
    /*#__PURE__*/
    function () {
      var _testRejectingTheModelHooksPromiseWithANonErrorPrintsTheMessageProperty = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(assert) {
        var rejectedMessage, rejectedStack;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              assert.expect(5);
              rejectedMessage = 'OMG!! SOOOOOO BAD!!!!';
              rejectedStack = 'Yeah, buddy: stack gets printed too.';
              this.router.map(function () {
                this.route('yippie', {
                  path: '/'
                });
              });

              console.error = function (initialMessage, errorMessage, errorStack) {
                assert.equal(initialMessage, 'Error while processing route: yippie', 'a message with the current route name is printed');
                assert.equal(errorMessage, rejectedMessage, "the rejected reason's message property is logged");
                assert.equal(errorStack, rejectedStack, "the rejected reason's stack property is logged");
              };

              this.add('route:yippie', _routing.Route.extend({
                model: function () {
                  return _rsvp.default.reject({
                    message: rejectedMessage,
                    stack: rejectedStack
                  });
                }
              }));
              _context8.next = 8;
              return assert.rejects(this.visit('/'), function (err) {
                assert.equal(err.message, rejectedMessage);
                return true;
              }, 'expected an exception');

            case 8:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));

      function testRejectingTheModelHooksPromiseWithANonErrorPrintsTheMessageProperty(_x8) {
        return _testRejectingTheModelHooksPromiseWithANonErrorPrintsTheMessageProperty.apply(this, arguments);
      }

      return testRejectingTheModelHooksPromiseWithANonErrorPrintsTheMessageProperty;
    }();

    _proto['@test rejecting the model hooks promise with an error with `errorThrown` property prints `errorThrown.message` property'] =
    /*#__PURE__*/
    function () {
      var _testRejectingTheModelHooksPromiseWithAnErrorWithErrorThrownPropertyPrintsErrorThrownMessageProperty = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee9(assert) {
        var rejectedMessage, rejectedStack;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              assert.expect(5);
              rejectedMessage = 'OMG!! SOOOOOO BAD!!!!';
              rejectedStack = 'Yeah, buddy: stack gets printed too.';
              this.router.map(function () {
                this.route('yippie', {
                  path: '/'
                });
              });

              console.error = function (initialMessage, errorMessage, errorStack) {
                assert.equal(initialMessage, 'Error while processing route: yippie', 'a message with the current route name is printed');
                assert.equal(errorMessage, rejectedMessage, "the rejected reason's message property is logged");
                assert.equal(errorStack, rejectedStack, "the rejected reason's stack property is logged");
              };

              this.add('route:yippie', _routing.Route.extend({
                model: function () {
                  return _rsvp.default.reject({
                    errorThrown: {
                      message: rejectedMessage,
                      stack: rejectedStack
                    }
                  });
                }
              }));
              _context9.next = 8;
              return assert.rejects(this.visit('/'), function (_ref2) {
                var err = _ref2.errorThrown;
                assert.equal(err.message, rejectedMessage);
                return true;
              }, 'expected an exception');

            case 8:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));

      function testRejectingTheModelHooksPromiseWithAnErrorWithErrorThrownPropertyPrintsErrorThrownMessageProperty(_x9) {
        return _testRejectingTheModelHooksPromiseWithAnErrorWithErrorThrownPropertyPrintsErrorThrownMessageProperty.apply(this, arguments);
      }

      return testRejectingTheModelHooksPromiseWithAnErrorWithErrorThrownPropertyPrintsErrorThrownMessageProperty;
    }();

    _proto['@test rejecting the model hooks promise with no reason still logs error'] =
    /*#__PURE__*/
    function () {
      var _testRejectingTheModelHooksPromiseWithNoReasonStillLogsError = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee10(assert) {
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              assert.expect(2);
              this.router.map(function () {
                this.route('wowzers', {
                  path: '/'
                });
              });

              console.error = function (initialMessage) {
                assert.equal(initialMessage, 'Error while processing route: wowzers', 'a message with the current route name is printed');
              };

              this.add('route:wowzers', _routing.Route.extend({
                model: function () {
                  return _rsvp.default.reject();
                }
              }));
              _context10.next = 6;
              return assert.rejects(this.visit('/'));

            case 6:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));

      function testRejectingTheModelHooksPromiseWithNoReasonStillLogsError(_x10) {
        return _testRejectingTheModelHooksPromiseWithNoReasonStillLogsError.apply(this, arguments);
      }

      return testRejectingTheModelHooksPromiseWithNoReasonStillLogsError;
    }();

    _proto['@test rejecting the model hooks promise with a string shows a good error'] =
    /*#__PURE__*/
    function () {
      var _testRejectingTheModelHooksPromiseWithAStringShowsAGoodError = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee11(assert) {
        var rejectedMessage;
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              assert.expect(3);
              rejectedMessage = 'Supercalifragilisticexpialidocious';
              this.router.map(function () {
                this.route('yondo', {
                  path: '/'
                });
              });

              console.error = function (initialMessage, errorMessage) {
                assert.equal(initialMessage, 'Error while processing route: yondo', 'a message with the current route name is printed');
                assert.equal(errorMessage, rejectedMessage, "the rejected reason's message property is logged");
              };

              this.add('route:yondo', _routing.Route.extend({
                model: function () {
                  return _rsvp.default.reject(rejectedMessage);
                }
              }));
              _context11.next = 7;
              return assert.rejects(this.visit('/'), new RegExp(rejectedMessage), 'expected an exception');

            case 7:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));

      function testRejectingTheModelHooksPromiseWithAStringShowsAGoodError(_x11) {
        return _testRejectingTheModelHooksPromiseWithAStringShowsAGoodError.apply(this, arguments);
      }

      return testRejectingTheModelHooksPromiseWithAStringShowsAGoodError;
    }();

    _proto["@test willLeave, willChangeContext, willChangeModel actions don't fire unless feature flag enabled"] = function testWillLeaveWillChangeContextWillChangeModelActionsDonTFireUnlessFeatureFlagEnabled(assert) {
      assert.expect(1);
      this.router.map(function () {
        this.route('about');
      });

      function shouldNotFire() {
        assert.ok(false, "this action shouldn't have been received");
      }

      this.add('route:index', _routing.Route.extend({
        actions: {
          willChangeModel: shouldNotFire,
          willChangeContext: shouldNotFire,
          willLeave: shouldNotFire
        }
      }));
      this.add('route:about', _routing.Route.extend({
        setupController: function () {
          assert.ok(true, 'about route was entered');
        }
      }));
      return this.visit('/about');
    };

    _proto['@test Errors in transitionTo within redirect hook are logged'] =
    /*#__PURE__*/
    function () {
      var _testErrorsInTransitionToWithinRedirectHookAreLogged = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee12(assert) {
        var actual;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              assert.expect(4);
              actual = [];
              this.router.map(function () {
                this.route('yondo', {
                  path: '/'
                });
                this.route('stink-bomb');
              });
              this.add('route:yondo', _routing.Route.extend({
                redirect: function () {
                  this.transitionTo('stink-bomb', {
                    something: 'goes boom'
                  });
                }
              }));

              console.error = function () {
                // push the arguments onto an array so we can detect if the error gets logged twice
                actual.push(arguments);
              };

              _context12.next = 7;
              return assert.rejects(this.visit('/'), /More context objects were passed/);

            case 7:
              assert.equal(actual.length, 1, 'the error is only logged once');
              assert.equal(actual[0][0], 'Error while processing route: yondo', 'source route is printed');
              assert.ok(actual[0][1].match(/More context objects were passed than there are dynamic segments for the route: stink-bomb/), 'the error is printed');

            case 10:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));

      function testErrorsInTransitionToWithinRedirectHookAreLogged(_x12) {
        return _testErrorsInTransitionToWithinRedirectHookAreLogged.apply(this, arguments);
      }

      return testErrorsInTransitionToWithinRedirectHookAreLogged;
    }();

    _proto['@test Errors in transition show error template if available'] = function testErrorsInTransitionShowErrorTemplateIfAvailable(assert) {
      this.addTemplate('error', "<div id='error'>Error!</div>");
      this.router.map(function () {
        this.route('yondo', {
          path: '/'
        });
        this.route('stink-bomb');
      });
      this.add('route:yondo', _routing.Route.extend({
        redirect: function () {
          this.transitionTo('stink-bomb', {
            something: 'goes boom'
          });
        }
      }));

      console.error = function () {};

      return this.visit('/').then(function () {
        var rootElement = document.querySelector('#qunit-fixture');
        assert.equal(rootElement.querySelectorAll('#error').length, 1, 'Error template was rendered.');
      });
    };

    _proto['@test Route#resetController gets fired when changing models and exiting routes'] = function testRouteResetControllerGetsFiredWhenChangingModelsAndExitingRoutes(assert) {
      var _this62 = this;

      assert.expect(4);
      this.router.map(function () {
        this.route('a', function () {
          this.route('b', {
            path: '/b/:id',
            resetNamespace: true
          }, function () {});
          this.route('c', {
            path: '/c/:id',
            resetNamespace: true
          }, function () {});
        });
        this.route('out');
      });
      var calls = [];

      var SpyRoute = _routing.Route.extend({
        setupController: function ()
        /* controller, model, transition */
        {
          calls.push(['setup', this.routeName]);
        },
        resetController: function ()
        /* controller */
        {
          calls.push(['reset', this.routeName]);
        }
      });

      this.add('route:a', SpyRoute.extend());
      this.add('route:b', SpyRoute.extend());
      this.add('route:c', SpyRoute.extend());
      this.add('route:out', SpyRoute.extend());
      var router;
      return this.visit('/').then(function () {
        router = _this62.applicationInstance.lookup('router:main');
        assert.deepEqual(calls, []);
        return (0, _runloop.run)(router, 'transitionTo', 'b', 'b-1');
      }).then(function () {
        assert.deepEqual(calls, [['setup', 'a'], ['setup', 'b']]);
        calls.length = 0;
        return (0, _runloop.run)(router, 'transitionTo', 'c', 'c-1');
      }).then(function () {
        assert.deepEqual(calls, [['reset', 'b'], ['setup', 'c']]);
        calls.length = 0;
        return (0, _runloop.run)(router, 'transitionTo', 'out');
      }).then(function () {
        assert.deepEqual(calls, [['reset', 'c'], ['reset', 'a'], ['setup', 'out']]);
      });
    };

    _proto['@test Exception during initialization of non-initial route is not swallowed'] =
    /*#__PURE__*/
    function () {
      var _testExceptionDuringInitializationOfNonInitialRouteIsNotSwallowed = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee13(assert) {
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              this.router.map(function () {
                this.route('boom');
              });
              this.add('route:boom', _routing.Route.extend({
                init: function () {
                  throw new Error('boom!');
                }
              }));
              _context13.next = 4;
              return assert.rejects(this.visit('/boom'), /\bboom\b/);

            case 4:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));

      function testExceptionDuringInitializationOfNonInitialRouteIsNotSwallowed(_x13) {
        return _testExceptionDuringInitializationOfNonInitialRouteIsNotSwallowed.apply(this, arguments);
      }

      return testExceptionDuringInitializationOfNonInitialRouteIsNotSwallowed;
    }();

    _proto['@test Exception during initialization of initial route is not swallowed'] =
    /*#__PURE__*/
    function () {
      var _testExceptionDuringInitializationOfInitialRouteIsNotSwallowed = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee14(assert) {
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              this.router.map(function () {
                this.route('boom', {
                  path: '/'
                });
              });
              this.add('route:boom', _routing.Route.extend({
                init: function () {
                  throw new Error('boom!');
                }
              }));
              _context14.next = 4;
              return assert.rejects(this.visit('/'), /\bboom\b/);

            case 4:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));

      function testExceptionDuringInitializationOfInitialRouteIsNotSwallowed(_x14) {
        return _testExceptionDuringInitializationOfInitialRouteIsNotSwallowed.apply(this, arguments);
      }

      return testExceptionDuringInitializationOfInitialRouteIsNotSwallowed;
    }();

    _proto['@test {{outlet}} works when created after initial render'] = function testOutletWorksWhenCreatedAfterInitialRender(assert) {
      var _this63 = this;

      this.addTemplate('sample', 'Hi{{#if showTheThing}}{{outlet}}{{/if}}Bye');
      this.addTemplate('sample.inner', 'Yay');
      this.addTemplate('sample.inner2', 'Boo');
      this.router.map(function () {
        this.route('sample', {
          path: '/'
        }, function () {
          this.route('inner', {
            path: '/'
          });
          this.route('inner2', {
            path: '/2'
          });
        });
      });
      var rootElement;
      return this.visit('/').then(function () {
        rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.textContent.trim(), 'HiBye', 'initial render');
        (0, _runloop.run)(function () {
          return _this63.applicationInstance.lookup('controller:sample').set('showTheThing', true);
        });
        assert.equal(rootElement.textContent.trim(), 'HiYayBye', 'second render');
        return _this63.visit('/2');
      }).then(function () {
        assert.equal(rootElement.textContent.trim(), 'HiBooBye', 'third render');
      });
    };

    _proto['@test Can render into a named outlet at the top level'] = function testCanRenderIntoANamedOutletAtTheTopLevel(assert) {
      this.addTemplate('application', 'A-{{outlet}}-B-{{outlet "other"}}-C');
      this.addTemplate('modal', 'Hello world');
      this.addTemplate('index', 'The index');
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('route:application', _routing.Route.extend({
        renderTemplate: function () {
          this.render();
          this.render('modal', {
            into: 'application',
            outlet: 'other'
          });
        }
      }));
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.textContent.trim(), 'A-The index-B-Hello world-C', 'initial render');
      });
    };

    _proto['@test Can disconnect a named outlet at the top level'] = function testCanDisconnectANamedOutletAtTheTopLevel(assert) {
      var _this64 = this;

      this.addTemplate('application', 'A-{{outlet}}-B-{{outlet "other"}}-C');
      this.addTemplate('modal', 'Hello world');
      this.addTemplate('index', 'The index');
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('route:application', _routing.Route.extend({
        renderTemplate: function () {
          this.render();
          this.render('modal', {
            into: 'application',
            outlet: 'other'
          });
        },
        actions: {
          banish: function () {
            this.disconnectOutlet({
              parentView: 'application',
              outlet: 'other'
            });
          }
        }
      }));
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.textContent.trim(), 'A-The index-B-Hello world-C', 'initial render');
        (0, _runloop.run)(_this64.applicationInstance.lookup('router:main'), 'send', 'banish');
        assert.equal(rootElement.textContent.trim(), 'A-The index-B--C', 'second render');
      });
    };

    _proto['@test Can render into a named outlet at the top level, with empty main outlet'] = function testCanRenderIntoANamedOutletAtTheTopLevelWithEmptyMainOutlet(assert) {
      this.addTemplate('application', 'A-{{outlet}}-B-{{outlet "other"}}-C');
      this.addTemplate('modal', 'Hello world');
      this.router.map(function () {
        this.route('hasNoTemplate', {
          path: '/'
        });
      });
      this.add('route:application', _routing.Route.extend({
        renderTemplate: function () {
          this.render();
          this.render('modal', {
            into: 'application',
            outlet: 'other'
          });
        }
      }));
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.textContent.trim(), 'A--B-Hello world-C', 'initial render');
      });
    };

    _proto['@test Can render into a named outlet at the top level, later'] = function testCanRenderIntoANamedOutletAtTheTopLevelLater(assert) {
      var _this65 = this;

      this.addTemplate('application', 'A-{{outlet}}-B-{{outlet "other"}}-C');
      this.addTemplate('modal', 'Hello world');
      this.addTemplate('index', 'The index');
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('route:application', _routing.Route.extend({
        actions: {
          launch: function () {
            this.render('modal', {
              into: 'application',
              outlet: 'other'
            });
          }
        }
      }));
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.textContent.trim(), 'A-The index-B--C', 'initial render');
        (0, _runloop.run)(_this65.applicationInstance.lookup('router:main'), 'send', 'launch');
        assert.equal(rootElement.textContent.trim(), 'A-The index-B-Hello world-C', 'second render');
      });
    };

    _proto["@test Can render routes with no 'main' outlet and their children"] = function testCanRenderRoutesWithNoMainOutletAndTheirChildren(assert) {
      var _this66 = this;

      this.addTemplate('application', '<div id="application">{{outlet "app"}}</div>');
      this.addTemplate('app', '<div id="app-common">{{outlet "common"}}</div><div id="app-sub">{{outlet "sub"}}</div>');
      this.addTemplate('common', '<div id="common"></div>');
      this.addTemplate('sub', '<div id="sub"></div>');
      this.router.map(function () {
        this.route('app', {
          path: '/app'
        }, function () {
          this.route('sub', {
            path: '/sub',
            resetNamespace: true
          });
        });
      });
      this.add('route:app', _routing.Route.extend({
        renderTemplate: function () {
          this.render('app', {
            outlet: 'app',
            into: 'application'
          });
          this.render('common', {
            outlet: 'common',
            into: 'app'
          });
        }
      }));
      this.add('route:sub', _routing.Route.extend({
        renderTemplate: function () {
          this.render('sub', {
            outlet: 'sub',
            into: 'app'
          });
        }
      }));
      var rootElement;
      return this.visit('/app').then(function () {
        rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.querySelectorAll('#app-common #common').length, 1, 'Finds common while viewing /app');
        return _this66.visit('/app/sub');
      }).then(function () {
        assert.equal(rootElement.querySelectorAll('#app-common #common').length, 1, 'Finds common while viewing /app/sub');
        assert.equal(rootElement.querySelectorAll('#app-sub #sub').length, 1, 'Finds sub while viewing /app/sub');
      });
    };

    _proto['@test Tolerates stacked renders'] = function testToleratesStackedRenders(assert) {
      var _this67 = this;

      this.addTemplate('application', '{{outlet}}{{outlet "modal"}}');
      this.addTemplate('index', 'hi');
      this.addTemplate('layer', 'layer');
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('route:application', _routing.Route.extend({
        actions: {
          openLayer: function () {
            this.render('layer', {
              into: 'application',
              outlet: 'modal'
            });
          },
          close: function () {
            this.disconnectOutlet({
              outlet: 'modal',
              parentView: 'application'
            });
          }
        }
      }));
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');

        var router = _this67.applicationInstance.lookup('router:main');

        assert.equal(rootElement.textContent.trim(), 'hi');
        (0, _runloop.run)(router, 'send', 'openLayer');
        assert.equal(rootElement.textContent.trim(), 'hilayer');
        (0, _runloop.run)(router, 'send', 'openLayer');
        assert.equal(rootElement.textContent.trim(), 'hilayer');
        (0, _runloop.run)(router, 'send', 'close');
        assert.equal(rootElement.textContent.trim(), 'hi');
      });
    };

    _proto['@test Renders child into parent with non-default template name'] = function testRendersChildIntoParentWithNonDefaultTemplateName(assert) {
      this.addTemplate('application', '<div class="a">{{outlet}}</div>');
      this.addTemplate('exports.root', '<div class="b">{{outlet}}</div>');
      this.addTemplate('exports.index', '<div class="c"></div>');
      this.router.map(function () {
        this.route('root', function () {});
      });
      this.add('route:root', _routing.Route.extend({
        renderTemplate: function () {
          this.render('exports/root');
        }
      }));
      this.add('route:root.index', _routing.Route.extend({
        renderTemplate: function () {
          this.render('exports/index');
        }
      }));
      return this.visit('/root').then(function () {
        var rootElement = document.getElementById('qunit-fixture');
        assert.equal(rootElement.querySelectorAll('.a .b .c').length, 1);
      });
    };

    _proto["@test Allows any route to disconnectOutlet another route's templates"] = function testAllowsAnyRouteToDisconnectOutletAnotherRouteSTemplates(assert) {
      var _this68 = this;

      this.addTemplate('application', '{{outlet}}{{outlet "modal"}}');
      this.addTemplate('index', 'hi');
      this.addTemplate('layer', 'layer');
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('route:application', _routing.Route.extend({
        actions: {
          openLayer: function () {
            this.render('layer', {
              into: 'application',
              outlet: 'modal'
            });
          }
        }
      }));
      this.add('route:index', _routing.Route.extend({
        actions: {
          close: function () {
            this.disconnectOutlet({
              parentView: 'application',
              outlet: 'modal'
            });
          }
        }
      }));
      return this.visit('/').then(function () {
        var rootElement = document.getElementById('qunit-fixture');

        var router = _this68.applicationInstance.lookup('router:main');

        assert.equal(rootElement.textContent.trim(), 'hi');
        (0, _runloop.run)(router, 'send', 'openLayer');
        assert.equal(rootElement.textContent.trim(), 'hilayer');
        (0, _runloop.run)(router, 'send', 'close');
        assert.equal(rootElement.textContent.trim(), 'hi');
      });
    };

    _proto['@test Components inside an outlet have their didInsertElement hook invoked when the route is displayed'] = function testComponentsInsideAnOutletHaveTheirDidInsertElementHookInvokedWhenTheRouteIsDisplayed(assert) {
      this.addTemplate('index', '{{#if showFirst}}{{my-component}}{{else}}{{other-component}}{{/if}}');
      var myComponentCounter = 0;
      var otherComponentCounter = 0;
      var indexController;
      this.router.map(function () {
        this.route('index', {
          path: '/'
        });
      });
      this.add('controller:index', _controller.default.extend({
        showFirst: true
      }));
      this.add('route:index', _routing.Route.extend({
        setupController: function (controller) {
          indexController = controller;
        }
      }));
      this.add('component:my-component', _glimmer.Component.extend({
        didInsertElement: function () {
          myComponentCounter++;
        }
      }));
      this.add('component:other-component', _glimmer.Component.extend({
        didInsertElement: function () {
          otherComponentCounter++;
        }
      }));
      return this.visit('/').then(function () {
        assert.strictEqual(myComponentCounter, 1, 'didInsertElement invoked on displayed component');
        assert.strictEqual(otherComponentCounter, 0, 'didInsertElement not invoked on displayed component');
        (0, _runloop.run)(function () {
          return indexController.set('showFirst', false);
        });
        assert.strictEqual(myComponentCounter, 1, 'didInsertElement not invoked on displayed component');
        assert.strictEqual(otherComponentCounter, 1, 'didInsertElement invoked on displayed component');
      });
    };

    _proto['@test Doesnt swallow exception thrown from willTransition'] =
    /*#__PURE__*/
    function () {
      var _testDoesntSwallowExceptionThrownFromWillTransition = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee15(assert) {
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              assert.expect(1);
              this.addTemplate('application', '{{outlet}}');
              this.addTemplate('index', 'index');
              this.addTemplate('other', 'other');
              this.router.map(function () {
                this.route('index', {
                  path: '/'
                });
                this.route('other', function () {});
              });
              this.add('route:index', _routing.Route.extend({
                actions: {
                  willTransition: function () {
                    throw new Error('boom');
                  }
                }
              }));
              _context15.next = 8;
              return this.visit('/');

            case 8:
              _context15.next = 10;
              return assert.rejects(this.visit('/other'), /boom/, 'expected an exception but none was thrown');

            case 10:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));

      function testDoesntSwallowExceptionThrownFromWillTransition(_x15) {
        return _testDoesntSwallowExceptionThrownFromWillTransition.apply(this, arguments);
      }

      return testDoesntSwallowExceptionThrownFromWillTransition;
    }();

    _proto['@test Exception if outlet name is undefined in render and disconnectOutlet'] = function testExceptionIfOutletNameIsUndefinedInRenderAndDisconnectOutlet() {
      var _this69 = this;

      this.add('route:application', _routing.Route.extend({
        actions: {
          showModal: function () {
            this.render({
              outlet: undefined,
              parentView: 'application'
            });
          },
          hideModal: function () {
            this.disconnectOutlet({
              outlet: undefined,
              parentView: 'application'
            });
          }
        }
      }));
      return this.visit('/').then(function () {
        var router = _this69.applicationInstance.lookup('router:main');

        expectAssertion(function () {
          (0, _runloop.run)(function () {
            return router.send('showModal');
          });
        }, /You passed undefined as the outlet name/);
        expectAssertion(function () {
          (0, _runloop.run)(function () {
            return router.send('hideModal');
          });
        }, /You passed undefined as the outlet name/);
      });
    };

    _proto['@test Route serializers work for Engines'] = function testRouteSerializersWorkForEngines(assert) {
      var _this70 = this;

      assert.expect(2); // Register engine

      var BlogEngine = _engine.default.extend();

      this.add('engine:blog', BlogEngine); // Register engine route map

      var postSerialize = function (params) {
        assert.ok(true, 'serialize hook runs');
        return {
          post_id: params.id
        };
      };

      var BlogMap = function () {
        this.route('post', {
          path: '/post/:post_id',
          serialize: postSerialize
        });
      };

      this.add('route-map:blog', BlogMap);
      this.router.map(function () {
        this.mount('blog');
      });
      return this.visit('/').then(function () {
        var router = _this70.applicationInstance.lookup('router:main');

        assert.equal(router._routerMicrolib.generate('blog.post', {
          id: '13'
        }), '/blog/post/13', 'url is generated properly');
      });
    };

    _proto['@test Defining a Route#serialize method in an Engine throws an error'] =
    /*#__PURE__*/
    function () {
      var _testDefiningARouteSerializeMethodInAnEngineThrowsAnError = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee16(assert) {
        var BlogEngine, BlogMap, router, PostRoute;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              assert.expect(1); // Register engine

              BlogEngine = _engine.default.extend();
              this.add('engine:blog', BlogEngine); // Register engine route map

              BlogMap = function () {
                this.route('post');
              };

              this.add('route-map:blog', BlogMap);
              this.router.map(function () {
                this.mount('blog');
              });
              _context16.next = 8;
              return this.visit('/');

            case 8:
              router = this.applicationInstance.lookup('router:main');
              PostRoute = _routing.Route.extend({
                serialize: function () {}
              });
              this.applicationInstance.lookup('engine:blog').register('route:post', PostRoute);
              _context16.prev = 11;
              _context16.next = 14;
              return router.transitionTo('blog.post');

            case 14:
              _context16.next = 19;
              break;

            case 16:
              _context16.prev = 16;
              _context16.t0 = _context16["catch"](11);
              assert.ok(_context16.t0.message.match(/Defining a custom serialize method on an Engine route is not supported/));

            case 19:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this, [[11, 16]]);
      }));

      function testDefiningARouteSerializeMethodInAnEngineThrowsAnError(_x16) {
        return _testDefiningARouteSerializeMethodInAnEngineThrowsAnError.apply(this, arguments);
      }

      return testDefiningARouteSerializeMethodInAnEngineThrowsAnError;
    }();

    _proto['@test App.destroy does not leave undestroyed views after clearing engines'] = function testAppDestroyDoesNotLeaveUndestroyedViewsAfterClearingEngines(assert) {
      var _this71 = this;

      assert.expect(4);
      var engineInstance; // Register engine

      var BlogEngine = _engine.default.extend();

      this.add('engine:blog', BlogEngine);

      var EngineIndexRoute = _routing.Route.extend({
        init: function () {
          this._super.apply(this, arguments);

          engineInstance = (0, _owner.getOwner)(this);
        }
      }); // Register engine route map


      var BlogMap = function () {
        this.route('post');
      };

      this.add('route-map:blog', BlogMap);
      this.router.map(function () {
        this.mount('blog');
      });
      return this.visit('/').then(function () {
        var engine = _this71.applicationInstance.lookup('engine:blog');

        engine.register('route:index', EngineIndexRoute);
        engine.register('template:index', (0, _emberTemplateCompiler.compile)('Engine Post!'));
        return _this71.visit('/blog');
      }).then(function () {
        assert.ok(true, '/blog has been handled');
        var route = engineInstance.lookup('route:index');

        var router = _this71.applicationInstance.lookup('router:main');

        (0, _runloop.run)(router, 'destroy');
        assert.equal(router._toplevelView, null, 'the toplevelView was cleared');
        (0, _runloop.run)(route, 'destroy');
        assert.equal(router._toplevelView, null, 'the toplevelView was not reinitialized');
        (0, _runloop.run)(_this71.applicationInstance, 'destroy');
        assert.equal(router._toplevelView, null, 'the toplevelView was not reinitialized');
      });
    };

    _proto["@test Generated route should be an instance of App's default route if provided"] = function testGeneratedRouteShouldBeAnInstanceOfAppSDefaultRouteIfProvided(assert) {
      var _this72 = this;

      var generatedRoute;
      this.router.map(function () {
        this.route('posts');
      });

      var AppRoute = _routing.Route.extend();

      this.add('route:basic', AppRoute);
      return this.visit('/posts').then(function () {
        generatedRoute = _this72.applicationInstance.lookup('route:posts');
        assert.ok(generatedRoute instanceof AppRoute, 'should extend the correct route');
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "currentPath",
      get: function () {
        var _this73 = this;

        var currentPath;
        expectDeprecation(function () {
          currentPath = _this73.getController('application').get('currentPath');
        }, 'Accessing `currentPath` on `controller:application` is deprecated, use the `currentPath` property on `service:router` instead.');
        return currentPath;
      }
    }, {
      key: "currentURL",
      get: function () {
        return this.appRouter.get('currentURL');
      }
    }]);
    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/routing/query_params_test", ["ember-babel", "@ember/controller", "@ember/string", "@ember/-internals/runtime", "@ember/runloop", "@ember/-internals/meta", "@ember/-internals/metal", "@ember/-internals/routing", "router_js", "internal-test-helpers"], function (_emberBabel, _controller, _string, _runtime, _runloop, _meta, _metal, _routing, _router_js, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('Query Params - main',
  /*#__PURE__*/
  function (_QueryParamTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _QueryParamTestCase);

    function _class() {
      return _QueryParamTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.refreshModelWhileLoadingTest =
    /*#__PURE__*/
    function () {
      var _refreshModelWhileLoadingTest = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(loadingReturn) {
        var _actions, assert, appModelCount, promiseResolve, actionName, indexModelCount, indexController;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              assert = this.assert;
              assert.expect(9);
              appModelCount = 0;
              this.add('route:application', _routing.Route.extend({
                queryParams: {
                  appomg: {
                    defaultValue: 'applol'
                  }
                },
                model: function ()
                /* params */
                {
                  appModelCount++;
                }
              }));
              this.setSingleQPController('index', 'omg', undefined, {
                omg: undefined
              });
              actionName = typeof loadingReturn !== 'undefined' ? 'loading' : 'ignore';
              indexModelCount = 0;
              this.add('route:index', _routing.Route.extend({
                queryParams: {
                  omg: {
                    refreshModel: true
                  }
                },
                actions: (_actions = {}, _actions[actionName] = function () {
                  return loadingReturn;
                }, _actions),
                model: function (params) {
                  indexModelCount++;

                  if (indexModelCount === 2) {
                    assert.deepEqual(params, {
                      omg: 'lex'
                    });
                    return new _runtime.RSVP.Promise(function (resolve) {
                      promiseResolve = resolve;
                      return;
                    });
                  } else if (indexModelCount === 3) {
                    assert.deepEqual(params, {
                      omg: 'hello'
                    }, "Model hook reruns even if the previous one didn't finish");
                  }
                }
              }));
              _context.next = 10;
              return this.visit('/');

            case 10:
              assert.equal(appModelCount, 1, 'appModelCount is 1');
              assert.equal(indexModelCount, 1);
              indexController = this.getController('index');
              _context.next = 15;
              return this.setAndFlush(indexController, 'omg', 'lex');

            case 15:
              assert.equal(appModelCount, 1, 'appModelCount is 1');
              assert.equal(indexModelCount, 2);
              _context.next = 19;
              return this.setAndFlush(indexController, 'omg', 'hello');

            case 19:
              assert.equal(appModelCount, 1, 'appModelCount is 1');
              assert.equal(indexModelCount, 3);
              (0, _runloop.run)(function () {
                promiseResolve();
              });
              assert.equal((0, _metal.get)(indexController, 'omg'), 'hello', 'At the end last value prevails');

            case 23:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function refreshModelWhileLoadingTest(_x) {
        return _refreshModelWhileLoadingTest.apply(this, arguments);
      }

      return refreshModelWhileLoadingTest;
    }();

    _proto["@test No replaceURL occurs on startup because default values don't show up in URL"] = function testNoReplaceURLOccursOnStartupBecauseDefaultValuesDonTShowUpInURL(assert) {
      assert.expect(1);
      this.setSingleQPController('index');
      return this.visitAndAssert('/');
    };

    _proto['@test Calling transitionTo does not lose query params already on the activeTransition'] = function testCallingTransitionToDoesNotLoseQueryParamsAlreadyOnTheActiveTransition(assert) {
      var _this = this;

      assert.expect(2);
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
          this.route('sibling');
        });
      });
      this.add('route:parent.child', _routing.Route.extend({
        afterModel: function () {
          this.transitionTo('parent.sibling');
        }
      }));
      this.setSingleQPController('parent');
      return this.visit('/parent/child?foo=lol').then(function () {
        _this.assertCurrentPath('/parent/sibling?foo=lol', 'redirected to the sibling route, instead of child route');

        assert.equal(_this.getController('parent').get('foo'), 'lol', 'controller has value from the active transition');
      });
    };

    _proto['@test Single query params can be set on the controller and reflected in the url'] =
    /*#__PURE__*/
    function () {
      var _testSingleQueryParamsCanBeSetOnTheControllerAndReflectedInTheUrl = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        var controller;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              assert.expect(3);
              this.router.map(function () {
                this.route('home', {
                  path: '/'
                });
              });
              this.setSingleQPController('home');
              _context2.next = 5;
              return this.visitAndAssert('/');

            case 5:
              controller = this.getController('home');
              _context2.next = 8;
              return this.setAndFlush(controller, 'foo', '456');

            case 8:
              this.assertCurrentPath('/?foo=456');
              _context2.next = 11;
              return this.setAndFlush(controller, 'foo', '987');

            case 11:
              this.assertCurrentPath('/?foo=987');

            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testSingleQueryParamsCanBeSetOnTheControllerAndReflectedInTheUrl(_x2) {
        return _testSingleQueryParamsCanBeSetOnTheControllerAndReflectedInTheUrl.apply(this, arguments);
      }

      return testSingleQueryParamsCanBeSetOnTheControllerAndReflectedInTheUrl;
    }();

    _proto['@test Query params can map to different url keys configured on the controller'] =
    /*#__PURE__*/
    function () {
      var _testQueryParamsCanMapToDifferentUrlKeysConfiguredOnTheController = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(assert) {
        var controller;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              assert.expect(6);
              this.add('controller:index', _controller.default.extend({
                queryParams: [{
                  foo: 'other_foo',
                  bar: {
                    as: 'other_bar'
                  }
                }],
                foo: 'FOO',
                bar: 'BAR'
              }));
              _context3.next = 4;
              return this.visitAndAssert('/');

            case 4:
              controller = this.getController('index');
              _context3.next = 7;
              return this.setAndFlush(controller, 'foo', 'LEX');

            case 7:
              this.assertCurrentPath('/?other_foo=LEX', "QP mapped correctly without 'as'");
              _context3.next = 10;
              return this.setAndFlush(controller, 'foo', 'WOO');

            case 10:
              this.assertCurrentPath('/?other_foo=WOO', "QP updated correctly without 'as'");
              this.transitionTo('/?other_foo=NAW');
              assert.equal(controller.get('foo'), 'NAW', 'QP managed correctly on URL transition');
              _context3.next = 15;
              return this.setAndFlush(controller, 'bar', 'NERK');

            case 15:
              this.assertCurrentPath('/?other_bar=NERK&other_foo=NAW', "QP mapped correctly with 'as'");
              _context3.next = 18;
              return this.setAndFlush(controller, 'bar', 'NUKE');

            case 18:
              this.assertCurrentPath('/?other_bar=NUKE&other_foo=NAW', "QP updated correctly with 'as'");

            case 19:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function testQueryParamsCanMapToDifferentUrlKeysConfiguredOnTheController(_x3) {
        return _testQueryParamsCanMapToDifferentUrlKeysConfiguredOnTheController.apply(this, arguments);
      }

      return testQueryParamsCanMapToDifferentUrlKeysConfiguredOnTheController;
    }();

    _proto['@test Routes have a private overridable serializeQueryParamKey hook'] =
    /*#__PURE__*/
    function () {
      var _testRoutesHaveAPrivateOverridableSerializeQueryParamKeyHook = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(assert) {
        var controller;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              assert.expect(2);
              this.add('route:index', _routing.Route.extend({
                serializeQueryParamKey: _string.dasherize
              }));
              this.setSingleQPController('index', 'funTimes', '');
              _context4.next = 5;
              return this.visitAndAssert('/');

            case 5:
              controller = this.getController('index');
              _context4.next = 8;
              return this.setAndFlush(controller, 'funTimes', 'woot');

            case 8:
              this.assertCurrentPath('/?fun-times=woot');

            case 9:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));

      function testRoutesHaveAPrivateOverridableSerializeQueryParamKeyHook(_x4) {
        return _testRoutesHaveAPrivateOverridableSerializeQueryParamKeyHook.apply(this, arguments);
      }

      return testRoutesHaveAPrivateOverridableSerializeQueryParamKeyHook;
    }();

    _proto['@test Can override inherited QP behavior by specifying queryParams as a computed property'] =
    /*#__PURE__*/
    function () {
      var _testCanOverrideInheritedQPBehaviorBySpecifyingQueryParamsAsAComputedProperty = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(assert) {
        var indexController;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              assert.expect(3);
              this.setSingleQPController('index', 'a', 0, {
                queryParams: (0, _metal.computed)(function () {
                  return ['c'];
                }),
                c: true
              });
              _context5.next = 4;
              return this.visitAndAssert('/');

            case 4:
              indexController = this.getController('index');
              _context5.next = 7;
              return this.setAndFlush(indexController, 'a', 1);

            case 7:
              this.assertCurrentPath('/', 'QP did not update due to being overriden');
              _context5.next = 10;
              return this.setAndFlush(indexController, 'c', false);

            case 10:
              this.assertCurrentPath('/?c=false', 'QP updated with overridden param');

            case 11:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));

      function testCanOverrideInheritedQPBehaviorBySpecifyingQueryParamsAsAComputedProperty(_x5) {
        return _testCanOverrideInheritedQPBehaviorBySpecifyingQueryParamsAsAComputedProperty.apply(this, arguments);
      }

      return testCanOverrideInheritedQPBehaviorBySpecifyingQueryParamsAsAComputedProperty;
    }();

    _proto['@test Can concatenate inherited QP behavior by specifying queryParams as an array'] =
    /*#__PURE__*/
    function () {
      var _testCanConcatenateInheritedQPBehaviorBySpecifyingQueryParamsAsAnArray = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(assert) {
        var indexController;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              assert.expect(3);
              this.setSingleQPController('index', 'a', 0, {
                queryParams: ['c'],
                c: true
              });
              _context6.next = 4;
              return this.visitAndAssert('/');

            case 4:
              indexController = this.getController('index');
              _context6.next = 7;
              return this.setAndFlush(indexController, 'a', 1);

            case 7:
              this.assertCurrentPath('/?a=1', 'Inherited QP did update');
              _context6.next = 10;
              return this.setAndFlush(indexController, 'c', false);

            case 10:
              this.assertCurrentPath('/?a=1&c=false', 'New QP did update');

            case 11:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));

      function testCanConcatenateInheritedQPBehaviorBySpecifyingQueryParamsAsAnArray(_x6) {
        return _testCanConcatenateInheritedQPBehaviorBySpecifyingQueryParamsAsAnArray.apply(this, arguments);
      }

      return testCanConcatenateInheritedQPBehaviorBySpecifyingQueryParamsAsAnArray;
    }();

    _proto['@test model hooks receives query params'] = function testModelHooksReceivesQueryParams(assert) {
      assert.expect(2);
      this.setSingleQPController('index');
      this.add('route:index', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            foo: 'bar'
          });
        }
      }));
      return this.visitAndAssert('/');
    };

    _proto['@test model hooks receives query params with dynamic segment params'] = function testModelHooksReceivesQueryParamsWithDynamicSegmentParams(assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:id'
        });
      });
      this.setSingleQPController('index');
      this.add('route:index', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            foo: 'bar',
            id: 'baz'
          });
        }
      }));
      return this.visitAndAssert('/baz');
    };

    _proto['@test model hooks receives query params (overridden by incoming url value)'] = function testModelHooksReceivesQueryParamsOverriddenByIncomingUrlValue(assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:id'
        });
      });
      this.setSingleQPController('index');
      this.add('route:index', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            foo: 'baz',
            id: 'boo'
          });
        }
      }));
      return this.visitAndAssert('/boo?foo=baz');
    };

    _proto['@test error is thrown if dynamic segment and query param have same name'] =
    /*#__PURE__*/
    function () {
      var _testErrorIsThrownIfDynamicSegmentAndQueryParamHaveSameName = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(assert) {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              this.router.map(function () {
                this.route('index', {
                  path: '/:foo'
                });
              });
              this.setSingleQPController('index');
              _context7.next = 4;
              return assert.rejectsAssertion(this.visitAndAssert('/boo?foo=baz'), "The route 'index' has both a dynamic segment and query param with name 'foo'. Please rename one to avoid collisions.");

            case 4:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));

      function testErrorIsThrownIfDynamicSegmentAndQueryParamHaveSameName(_x7) {
        return _testErrorIsThrownIfDynamicSegmentAndQueryParamHaveSameName.apply(this, arguments);
      }

      return testErrorIsThrownIfDynamicSegmentAndQueryParamHaveSameName;
    }();

    _proto['@test query params have been set by the time setupController is called'] = function testQueryParamsHaveBeenSetByTheTimeSetupControllerIsCalled(assert) {
      assert.expect(2);
      this.setSingleQPController('application');
      this.add('route:application', _routing.Route.extend({
        setupController: function (controller) {
          assert.equal(controller.get('foo'), 'YEAH', "controller's foo QP property set before setupController called");
        }
      }));
      return this.visitAndAssert('/?foo=YEAH');
    };

    _proto['@test mapped query params have been set by the time setupController is called'] = function testMappedQueryParamsHaveBeenSetByTheTimeSetupControllerIsCalled(assert) {
      assert.expect(2);
      this.setSingleQPController('application', {
        faz: 'foo'
      });
      this.add('route:application', _routing.Route.extend({
        setupController: function (controller) {
          assert.equal(controller.get('faz'), 'YEAH', "controller's foo QP property set before setupController called");
        }
      }));
      return this.visitAndAssert('/?foo=YEAH');
    };

    _proto['@test Route#paramsFor fetches query params with default value'] = function testRouteParamsForFetchesQueryParamsWithDefaultValue(assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:something'
        });
      });
      this.setSingleQPController('index');
      this.add('route:index', _routing.Route.extend({
        model: function ()
        /* params, transition */
        {
          assert.deepEqual(this.paramsFor('index'), {
            something: 'baz',
            foo: 'bar'
          }, 'could retrieve params for index');
        }
      }));
      return this.visitAndAssert('/baz');
    };

    _proto['@test Route#paramsFor fetches query params with non-default value'] = function testRouteParamsForFetchesQueryParamsWithNonDefaultValue(assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:something'
        });
      });
      this.setSingleQPController('index');
      this.add('route:index', _routing.Route.extend({
        model: function ()
        /* params, transition */
        {
          assert.deepEqual(this.paramsFor('index'), {
            something: 'baz',
            foo: 'boo'
          }, 'could retrieve params for index');
        }
      }));
      return this.visitAndAssert('/baz?foo=boo');
    };

    _proto['@test Route#paramsFor fetches default falsy query params'] = function testRouteParamsForFetchesDefaultFalsyQueryParams(assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:something'
        });
      });
      this.setSingleQPController('index', 'foo', false);
      this.add('route:index', _routing.Route.extend({
        model: function ()
        /* params, transition */
        {
          assert.deepEqual(this.paramsFor('index'), {
            something: 'baz',
            foo: false
          }, 'could retrieve params for index');
        }
      }));
      return this.visitAndAssert('/baz');
    };

    _proto['@test Route#paramsFor fetches non-default falsy query params'] = function testRouteParamsForFetchesNonDefaultFalsyQueryParams(assert) {
      assert.expect(2);
      this.router.map(function () {
        this.route('index', {
          path: '/:something'
        });
      });
      this.setSingleQPController('index', 'foo', true);
      this.add('route:index', _routing.Route.extend({
        model: function ()
        /* params, transition */
        {
          assert.deepEqual(this.paramsFor('index'), {
            something: 'baz',
            foo: false
          }, 'could retrieve params for index');
        }
      }));
      return this.visitAndAssert('/baz?foo=false');
    };

    _proto['@test model hook can query prefix-less application params'] = function testModelHookCanQueryPrefixLessApplicationParams(assert) {
      assert.expect(4);
      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');
      this.add('route:application', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            appomg: 'applol'
          });
        }
      }));
      this.add('route:index', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            omg: 'lol'
          });
          assert.deepEqual(this.paramsFor('application'), {
            appomg: 'applol'
          });
        }
      }));
      return this.visitAndAssert('/');
    };

    _proto['@test model hook can query prefix-less application params (overridden by incoming url value)'] = function testModelHookCanQueryPrefixLessApplicationParamsOverriddenByIncomingUrlValue(assert) {
      assert.expect(4);
      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');
      this.add('route:application', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            appomg: 'appyes'
          });
        }
      }));
      this.add('route:index', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            omg: 'yes'
          });
          assert.deepEqual(this.paramsFor('application'), {
            appomg: 'appyes'
          });
        }
      }));
      return this.visitAndAssert('/?appomg=appyes&omg=yes');
    };

    _proto['@test can opt into full transition by setting refreshModel in route queryParams'] =
    /*#__PURE__*/
    function () {
      var _testCanOptIntoFullTransitionBySettingRefreshModelInRouteQueryParams = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(assert) {
        var appModelCount, indexModelCount, indexController;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              assert.expect(7);
              this.setSingleQPController('application', 'appomg', 'applol');
              this.setSingleQPController('index', 'omg', 'lol');
              appModelCount = 0;
              this.add('route:application', _routing.Route.extend({
                model: function ()
                /* params, transition */
                {
                  appModelCount++;
                }
              }));
              indexModelCount = 0;
              this.add('route:index', _routing.Route.extend({
                queryParams: {
                  omg: {
                    refreshModel: true
                  }
                },
                model: function (params) {
                  indexModelCount++;

                  if (indexModelCount === 1) {
                    assert.deepEqual(params, {
                      omg: 'lol'
                    }, 'params are correct on first pass');
                  } else if (indexModelCount === 2) {
                    assert.deepEqual(params, {
                      omg: 'lex'
                    }, 'params are correct on second pass');
                  }
                }
              }));
              _context8.next = 9;
              return this.visitAndAssert('/');

            case 9:
              assert.equal(appModelCount, 1, 'app model hook ran');
              assert.equal(indexModelCount, 1, 'index model hook ran');
              indexController = this.getController('index');
              _context8.next = 14;
              return this.setAndFlush(indexController, 'omg', 'lex');

            case 14:
              assert.equal(appModelCount, 1, 'app model hook did not run again');
              assert.equal(indexModelCount, 2, 'index model hook ran again due to refreshModel');

            case 16:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));

      function testCanOptIntoFullTransitionBySettingRefreshModelInRouteQueryParams(_x8) {
        return _testCanOptIntoFullTransitionBySettingRefreshModelInRouteQueryParams.apply(this, arguments);
      }

      return testCanOptIntoFullTransitionBySettingRefreshModelInRouteQueryParams;
    }();

    _proto['@test refreshModel and replace work together'] =
    /*#__PURE__*/
    function () {
      var _testRefreshModelAndReplaceWorkTogether = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee9(assert) {
        var appModelCount, indexModelCount, indexController;
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              assert.expect(8);
              this.setSingleQPController('application', 'appomg', 'applol');
              this.setSingleQPController('index', 'omg', 'lol');
              appModelCount = 0;
              this.add('route:application', _routing.Route.extend({
                model: function ()
                /* params */
                {
                  appModelCount++;
                }
              }));
              indexModelCount = 0;
              this.add('route:index', _routing.Route.extend({
                queryParams: {
                  omg: {
                    refreshModel: true,
                    replace: true
                  }
                },
                model: function (params) {
                  indexModelCount++;

                  if (indexModelCount === 1) {
                    assert.deepEqual(params, {
                      omg: 'lol'
                    }, 'params are correct on first pass');
                  } else if (indexModelCount === 2) {
                    assert.deepEqual(params, {
                      omg: 'lex'
                    }, 'params are correct on second pass');
                  }
                }
              }));
              _context9.next = 9;
              return this.visitAndAssert('/');

            case 9:
              assert.equal(appModelCount, 1, 'app model hook ran');
              assert.equal(indexModelCount, 1, 'index model hook ran');
              indexController = this.getController('index');
              this.expectedReplaceURL = '/?omg=lex';
              _context9.next = 15;
              return this.setAndFlush(indexController, 'omg', 'lex');

            case 15:
              assert.equal(appModelCount, 1, 'app model hook did not run again');
              assert.equal(indexModelCount, 2, 'index model hook ran again due to refreshModel');

            case 17:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));

      function testRefreshModelAndReplaceWorkTogether(_x9) {
        return _testRefreshModelAndReplaceWorkTogether.apply(this, arguments);
      }

      return testRefreshModelAndReplaceWorkTogether;
    }();

    _proto['@test multiple QP value changes only cause a single model refresh'] =
    /*#__PURE__*/
    function () {
      var _testMultipleQPValueChangesOnlyCauseASingleModelRefresh = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee10(assert) {
        var refreshCount, indexController;
        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              assert.expect(2);
              this.setSingleQPController('index', 'alex', 'lol');
              this.setSingleQPController('index', 'steely', 'lel');
              refreshCount = 0;
              this.add('route:index', _routing.Route.extend({
                queryParams: {
                  alex: {
                    refreshModel: true
                  },
                  steely: {
                    refreshModel: true
                  }
                },
                refresh: function () {
                  refreshCount++;
                }
              }));
              _context10.next = 7;
              return this.visitAndAssert('/');

            case 7:
              indexController = this.getController('index');
              _context10.next = 10;
              return this.setAndFlush(indexController, {
                alex: 'fran',
                steely: 'david'
              });

            case 10:
              assert.equal(refreshCount, 1, 'index refresh hook only run once');

            case 11:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));

      function testMultipleQPValueChangesOnlyCauseASingleModelRefresh(_x10) {
        return _testMultipleQPValueChangesOnlyCauseASingleModelRefresh.apply(this, arguments);
      }

      return testMultipleQPValueChangesOnlyCauseASingleModelRefresh;
    }();

    _proto['@test refreshModel does not cause a second transition during app boot '] = function testRefreshModelDoesNotCauseASecondTransitionDuringAppBoot(assert) {
      assert.expect(1);
      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');
      this.add('route:index', _routing.Route.extend({
        queryParams: {
          omg: {
            refreshModel: true
          }
        },
        refresh: function () {
          assert.ok(false);
        }
      }));
      return this.visitAndAssert('/?appomg=hello&omg=world');
    };

    _proto['@test queryParams are updated when a controller property is set and the route is refreshed. Issue #13263  '] =
    /*#__PURE__*/
    function () {
      var _testQueryParamsAreUpdatedWhenAControllerPropertyIsSetAndTheRouteIsRefreshedIssue = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee11(assert) {
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              this.addTemplate('application', '<button id="test-button" {{action \'increment\'}}>Increment</button><span id="test-value">{{foo}}</span>{{outlet}}');
              this.setSingleQPController('application', 'foo', 1, {
                actions: {
                  increment: function () {
                    this.incrementProperty('foo');
                    this.send('refreshRoute');
                  }
                }
              });
              this.add('route:application', _routing.Route.extend({
                actions: {
                  refreshRoute: function () {
                    this.refresh();
                  }
                }
              }));
              _context11.next = 5;
              return this.visitAndAssert('/');

            case 5:
              assert.equal((0, _internalTestHelpers.getTextOf)(document.getElementById('test-value')), '1');
              document.getElementById('test-button').click();
              _context11.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              assert.equal((0, _internalTestHelpers.getTextOf)(document.getElementById('test-value')), '2');
              this.assertCurrentPath('/?foo=2');
              document.getElementById('test-button').click();
              _context11.next = 14;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 14:
              assert.equal((0, _internalTestHelpers.getTextOf)(document.getElementById('test-value')), '3');
              this.assertCurrentPath('/?foo=3');

            case 16:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));

      function testQueryParamsAreUpdatedWhenAControllerPropertyIsSetAndTheRouteIsRefreshedIssue13263(_x11) {
        return _testQueryParamsAreUpdatedWhenAControllerPropertyIsSetAndTheRouteIsRefreshedIssue.apply(this, arguments);
      }

      return testQueryParamsAreUpdatedWhenAControllerPropertyIsSetAndTheRouteIsRefreshedIssue13263;
    }();

    _proto["@test Use Ember.get to retrieve query params 'refreshModel' configuration"] =
    /*#__PURE__*/
    function () {
      var _testUseEmberGetToRetrieveQueryParamsRefreshModelConfiguration = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee12(assert) {
        var appModelCount, indexModelCount, indexController;
        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              assert.expect(7);
              this.setSingleQPController('application', 'appomg', 'applol');
              this.setSingleQPController('index', 'omg', 'lol');
              appModelCount = 0;
              this.add('route:application', _routing.Route.extend({
                model: function ()
                /* params */
                {
                  appModelCount++;
                }
              }));
              indexModelCount = 0;
              this.add('route:index', _routing.Route.extend({
                queryParams: _runtime.Object.create({
                  unknownProperty: function () {
                    return {
                      refreshModel: true
                    };
                  }
                }),
                model: function (params) {
                  indexModelCount++;

                  if (indexModelCount === 1) {
                    assert.deepEqual(params, {
                      omg: 'lol'
                    });
                  } else if (indexModelCount === 2) {
                    assert.deepEqual(params, {
                      omg: 'lex'
                    });
                  }
                }
              }));
              _context12.next = 9;
              return this.visitAndAssert('/');

            case 9:
              assert.equal(appModelCount, 1);
              assert.equal(indexModelCount, 1);
              indexController = this.getController('index');
              _context12.next = 14;
              return this.setAndFlush(indexController, 'omg', 'lex');

            case 14:
              assert.equal(appModelCount, 1);
              assert.equal(indexModelCount, 2);

            case 16:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));

      function testUseEmberGetToRetrieveQueryParamsRefreshModelConfiguration(_x12) {
        return _testUseEmberGetToRetrieveQueryParamsRefreshModelConfiguration.apply(this, arguments);
      }

      return testUseEmberGetToRetrieveQueryParamsRefreshModelConfiguration;
    }();

    _proto['@test can use refreshModel even with URL changes that remove QPs from address bar'] =
    /*#__PURE__*/
    function () {
      var _testCanUseRefreshModelEvenWithURLChangesThatRemoveQPsFromAddressBar = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee13(assert) {
        var indexModelCount, indexController;
        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              assert.expect(4);
              this.setSingleQPController('index', 'omg', 'lol');
              indexModelCount = 0;
              this.add('route:index', _routing.Route.extend({
                queryParams: {
                  omg: {
                    refreshModel: true
                  }
                },
                model: function (params) {
                  indexModelCount++;
                  var data;

                  if (indexModelCount === 1) {
                    data = 'foo';
                  } else if (indexModelCount === 2) {
                    data = 'lol';
                  }

                  assert.deepEqual(params, {
                    omg: data
                  }, 'index#model receives right data');
                }
              }));
              _context13.next = 6;
              return this.visitAndAssert('/?omg=foo');

            case 6:
              _context13.next = 8;
              return this.transitionTo('/');

            case 8:
              indexController = this.getController('index');
              assert.equal(indexController.get('omg'), 'lol');

            case 10:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));

      function testCanUseRefreshModelEvenWithURLChangesThatRemoveQPsFromAddressBar(_x13) {
        return _testCanUseRefreshModelEvenWithURLChangesThatRemoveQPsFromAddressBar.apply(this, arguments);
      }

      return testCanUseRefreshModelEvenWithURLChangesThatRemoveQPsFromAddressBar;
    }();

    _proto['@test can opt into a replace query by specifying replace:true in the Route config hash'] =
    /*#__PURE__*/
    function () {
      var _testCanOptIntoAReplaceQueryBySpecifyingReplaceTrueInTheRouteConfigHash = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee14(assert) {
        var appController;
        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              assert.expect(2);
              this.setSingleQPController('application', 'alex', 'matchneer');
              this.add('route:application', _routing.Route.extend({
                queryParams: {
                  alex: {
                    replace: true
                  }
                }
              }));
              _context14.next = 5;
              return this.visitAndAssert('/');

            case 5:
              appController = this.getController('application');
              this.expectedReplaceURL = '/?alex=wallace';
              _context14.next = 9;
              return this.setAndFlush(appController, 'alex', 'wallace');

            case 9:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));

      function testCanOptIntoAReplaceQueryBySpecifyingReplaceTrueInTheRouteConfigHash(_x14) {
        return _testCanOptIntoAReplaceQueryBySpecifyingReplaceTrueInTheRouteConfigHash.apply(this, arguments);
      }

      return testCanOptIntoAReplaceQueryBySpecifyingReplaceTrueInTheRouteConfigHash;
    }();

    _proto['@test Route query params config can be configured using property name instead of URL key'] =
    /*#__PURE__*/
    function () {
      var _testRouteQueryParamsConfigCanBeConfiguredUsingPropertyNameInsteadOfURLKey = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee15(assert) {
        var appController;
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              assert.expect(2);
              this.add('controller:application', _controller.default.extend({
                queryParams: [{
                  commitBy: 'commit_by'
                }]
              }));
              this.add('route:application', _routing.Route.extend({
                queryParams: {
                  commitBy: {
                    replace: true
                  }
                }
              }));
              _context15.next = 5;
              return this.visitAndAssert('/');

            case 5:
              appController = this.getController('application');
              this.expectedReplaceURL = '/?commit_by=igor_seb';
              _context15.next = 9;
              return this.setAndFlush(appController, 'commitBy', 'igor_seb');

            case 9:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));

      function testRouteQueryParamsConfigCanBeConfiguredUsingPropertyNameInsteadOfURLKey(_x15) {
        return _testRouteQueryParamsConfigCanBeConfiguredUsingPropertyNameInsteadOfURLKey.apply(this, arguments);
      }

      return testRouteQueryParamsConfigCanBeConfiguredUsingPropertyNameInsteadOfURLKey;
    }();

    _proto['@test An explicit replace:false on a changed QP always wins and causes a pushState'] =
    /*#__PURE__*/
    function () {
      var _testAnExplicitReplaceFalseOnAChangedQPAlwaysWinsAndCausesAPushState = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee16(assert) {
        var appController;
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              assert.expect(3);
              this.add('controller:application', _controller.default.extend({
                queryParams: ['alex', 'steely'],
                alex: 'matchneer',
                steely: 'dan'
              }));
              this.add('route:application', _routing.Route.extend({
                queryParams: {
                  alex: {
                    replace: true
                  },
                  steely: {
                    replace: false
                  }
                }
              }));
              _context16.next = 5;
              return this.visit('/');

            case 5:
              appController = this.getController('application');
              this.expectedPushURL = '/?alex=wallace&steely=jan';
              _context16.next = 9;
              return this.setAndFlush(appController, {
                alex: 'wallace',
                steely: 'jan'
              });

            case 9:
              this.expectedPushURL = '/?alex=wallace&steely=fran';
              _context16.next = 12;
              return this.setAndFlush(appController, {
                steely: 'fran'
              });

            case 12:
              this.expectedReplaceURL = '/?alex=sriracha&steely=fran';
              _context16.next = 15;
              return this.setAndFlush(appController, 'alex', 'sriracha');

            case 15:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this);
      }));

      function testAnExplicitReplaceFalseOnAChangedQPAlwaysWinsAndCausesAPushState(_x16) {
        return _testAnExplicitReplaceFalseOnAChangedQPAlwaysWinsAndCausesAPushState.apply(this, arguments);
      }

      return testAnExplicitReplaceFalseOnAChangedQPAlwaysWinsAndCausesAPushState;
    }();

    _proto['@test can opt into full transition by setting refreshModel in route queryParams when transitioning from child to parent'] = function testCanOptIntoFullTransitionBySettingRefreshModelInRouteQueryParamsWhenTransitioningFromChildToParent(assert) {
      this.addTemplate('parent', '{{outlet}}');
      this.addTemplate('parent.child', "{{link-to 'Parent' 'parent' (query-params foo='change') id='parent-link'}}");
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });
      var parentModelCount = 0;
      this.add('route:parent', _routing.Route.extend({
        model: function () {
          parentModelCount++;
        },
        queryParams: {
          foo: {
            refreshModel: true
          }
        }
      }));
      this.setSingleQPController('parent', 'foo', 'abc');
      return this.visit('/parent/child?foo=lol').then(function () {
        assert.equal(parentModelCount, 1);
        (0, _runloop.run)(document.getElementById('parent-link'), 'click');
        assert.equal(parentModelCount, 2);
      });
    };

    _proto["@test Use Ember.get to retrieve query params 'replace' configuration"] =
    /*#__PURE__*/
    function () {
      var _testUseEmberGetToRetrieveQueryParamsReplaceConfiguration = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee17(assert) {
        var appController;
        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              assert.expect(2);
              this.setSingleQPController('application', 'alex', 'matchneer');
              this.add('route:application', _routing.Route.extend({
                queryParams: _runtime.Object.create({
                  unknownProperty: function ()
                  /* keyName */
                  {
                    // We are simulating all qps requiring refresh
                    return {
                      replace: true
                    };
                  }
                })
              }));
              _context17.next = 5;
              return this.visitAndAssert('/');

            case 5:
              appController = this.getController('application');
              this.expectedReplaceURL = '/?alex=wallace';
              _context17.next = 9;
              return this.setAndFlush(appController, 'alex', 'wallace');

            case 9:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this);
      }));

      function testUseEmberGetToRetrieveQueryParamsReplaceConfiguration(_x17) {
        return _testUseEmberGetToRetrieveQueryParamsReplaceConfiguration.apply(this, arguments);
      }

      return testUseEmberGetToRetrieveQueryParamsReplaceConfiguration;
    }();

    _proto['@test can override incoming QP values in setupController'] =
    /*#__PURE__*/
    function () {
      var _testCanOverrideIncomingQPValuesInSetupController = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee18(assert) {
        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              assert.expect(3);
              this.router.map(function () {
                this.route('about');
              });
              this.setSingleQPController('index', 'omg', 'lol');
              this.add('route:index', _routing.Route.extend({
                setupController: function (controller) {
                  assert.ok(true, 'setupController called');
                  controller.set('omg', 'OVERRIDE');
                },
                actions: {
                  queryParamsDidChange: function () {
                    assert.ok(false, "queryParamsDidChange shouldn't fire");
                  }
                }
              }));
              _context18.next = 6;
              return this.visitAndAssert('/about');

            case 6:
              _context18.next = 8;
              return this.transitionTo('index');

            case 8:
              this.assertCurrentPath('/?omg=OVERRIDE');

            case 9:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));

      function testCanOverrideIncomingQPValuesInSetupController(_x18) {
        return _testCanOverrideIncomingQPValuesInSetupController.apply(this, arguments);
      }

      return testCanOverrideIncomingQPValuesInSetupController;
    }();

    _proto['@test can override incoming QP array values in setupController'] =
    /*#__PURE__*/
    function () {
      var _testCanOverrideIncomingQPArrayValuesInSetupController = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee19(assert) {
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              assert.expect(3);
              this.router.map(function () {
                this.route('about');
              });
              this.setSingleQPController('index', 'omg', ['lol']);
              this.add('route:index', _routing.Route.extend({
                setupController: function (controller) {
                  assert.ok(true, 'setupController called');
                  controller.set('omg', ['OVERRIDE']);
                },
                actions: {
                  queryParamsDidChange: function () {
                    assert.ok(false, "queryParamsDidChange shouldn't fire");
                  }
                }
              }));
              _context19.next = 6;
              return this.visitAndAssert('/about');

            case 6:
              _context19.next = 8;
              return this.transitionTo('index');

            case 8:
              this.assertCurrentPath('/?omg=' + encodeURIComponent(JSON.stringify(['OVERRIDE'])));

            case 9:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this);
      }));

      function testCanOverrideIncomingQPArrayValuesInSetupController(_x19) {
        return _testCanOverrideIncomingQPArrayValuesInSetupController.apply(this, arguments);
      }

      return testCanOverrideIncomingQPArrayValuesInSetupController;
    }();

    _proto['@test URL transitions that remove QPs still register as QP changes'] = function testURLTransitionsThatRemoveQPsStillRegisterAsQPChanges(assert) {
      var _this2 = this;

      assert.expect(2);
      this.setSingleQPController('index', 'omg', 'lol');
      return this.visit('/?omg=borf').then(function () {
        var indexController = _this2.getController('index');

        assert.equal(indexController.get('omg'), 'borf');

        _this2.transitionTo('/');

        assert.equal(indexController.get('omg'), 'lol');
      });
    };

    _proto['@test Subresource naming style is supported'] = function testSubresourceNamingStyleIsSupported(assert) {
      var _this3 = this;

      assert.expect(5);
      this.router.map(function () {
        this.route('abc.def', {
          path: '/abcdef'
        }, function () {
          this.route('zoo');
        });
      });
      this.addTemplate('application', "{{link-to 'A' 'abc.def' (query-params foo='123') id='one'}}{{link-to 'B' 'abc.def.zoo' (query-params foo='123' bar='456') id='two'}}{{outlet}}");
      this.setSingleQPController('abc.def', 'foo', 'lol');
      this.setSingleQPController('abc.def.zoo', 'bar', 'haha');
      return this.visitAndAssert('/').then(function () {
        assert.equal(_this3.$('#one').attr('href'), '/abcdef?foo=123');
        assert.equal(_this3.$('#two').attr('href'), '/abcdef/zoo?bar=456&foo=123');
        (0, _runloop.run)(_this3.$('#one'), 'click');

        _this3.assertCurrentPath('/abcdef?foo=123');

        (0, _runloop.run)(_this3.$('#two'), 'click');

        _this3.assertCurrentPath('/abcdef/zoo?bar=456&foo=123');
      });
    };

    _proto['@test transitionTo supports query params'] =
    /*#__PURE__*/
    function () {
      var _testTransitionToSupportsQueryParams = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee20() {
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              this.setSingleQPController('index', 'foo', 'lol');
              _context20.next = 3;
              return this.visitAndAssert('/');

            case 3:
              _context20.next = 5;
              return this.transitionTo({
                queryParams: {
                  foo: 'borf'
                }
              });

            case 5:
              this.assertCurrentPath('/?foo=borf', 'shorthand supported');
              _context20.next = 8;
              return this.transitionTo({
                queryParams: {
                  'index:foo': 'blaf'
                }
              });

            case 8:
              this.assertCurrentPath('/?foo=blaf', 'longform supported');
              _context20.next = 11;
              return this.transitionTo({
                queryParams: {
                  'index:foo': false
                }
              });

            case 11:
              this.assertCurrentPath('/?foo=false', 'longform supported (bool)');
              _context20.next = 14;
              return this.transitionTo({
                queryParams: {
                  foo: false
                }
              });

            case 14:
              this.assertCurrentPath('/?foo=false', 'shorhand supported (bool)');

            case 15:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));

      function testTransitionToSupportsQueryParams() {
        return _testTransitionToSupportsQueryParams.apply(this, arguments);
      }

      return testTransitionToSupportsQueryParams;
    }();

    _proto['@test transitionTo supports query params (multiple)'] =
    /*#__PURE__*/
    function () {
      var _testTransitionToSupportsQueryParamsMultiple = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee21() {
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              this.add('controller:index', _controller.default.extend({
                queryParams: ['foo', 'bar'],
                foo: 'lol',
                bar: 'wat'
              }));
              _context21.next = 3;
              return this.visitAndAssert('/');

            case 3:
              _context21.next = 5;
              return this.transitionTo({
                queryParams: {
                  foo: 'borf'
                }
              });

            case 5:
              this.assertCurrentPath('/?foo=borf', 'shorthand supported');
              _context21.next = 8;
              return this.transitionTo({
                queryParams: {
                  'index:foo': 'blaf'
                }
              });

            case 8:
              this.assertCurrentPath('/?foo=blaf', 'longform supported');
              _context21.next = 11;
              return this.transitionTo({
                queryParams: {
                  'index:foo': false
                }
              });

            case 11:
              this.assertCurrentPath('/?foo=false', 'longform supported (bool)');
              _context21.next = 14;
              return this.transitionTo({
                queryParams: {
                  foo: false
                }
              });

            case 14:
              this.assertCurrentPath('/?foo=false', 'shorhand supported (bool)');

            case 15:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this);
      }));

      function testTransitionToSupportsQueryParamsMultiple() {
        return _testTransitionToSupportsQueryParamsMultiple.apply(this, arguments);
      }

      return testTransitionToSupportsQueryParamsMultiple;
    }();

    _proto["@test setting controller QP to empty string doesn't generate null in URL"] =
    /*#__PURE__*/
    function () {
      var _testSettingControllerQPToEmptyStringDoesnTGenerateNullInURL = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee22(assert) {
        var controller;
        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              assert.expect(1);
              this.setSingleQPController('index', 'foo', '123');
              _context22.next = 4;
              return this.visit('/');

            case 4:
              controller = this.getController('index');
              this.expectedPushURL = '/?foo=';
              _context22.next = 8;
              return this.setAndFlush(controller, 'foo', '');

            case 8:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this);
      }));

      function testSettingControllerQPToEmptyStringDoesnTGenerateNullInURL(_x20) {
        return _testSettingControllerQPToEmptyStringDoesnTGenerateNullInURL.apply(this, arguments);
      }

      return testSettingControllerQPToEmptyStringDoesnTGenerateNullInURL;
    }();

    _proto["@test setting QP to empty string doesn't generate null in URL"] =
    /*#__PURE__*/
    function () {
      var _testSettingQPToEmptyStringDoesnTGenerateNullInURL = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee23(assert) {
        var controller;
        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              assert.expect(1);
              this.add('route:index', _routing.Route.extend({
                queryParams: {
                  foo: {
                    defaultValue: '123'
                  }
                }
              }));
              _context23.next = 4;
              return this.visit('/');

            case 4:
              controller = this.getController('index');
              this.expectedPushURL = '/?foo=';
              _context23.next = 8;
              return this.setAndFlush(controller, 'foo', '');

            case 8:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this);
      }));

      function testSettingQPToEmptyStringDoesnTGenerateNullInURL(_x21) {
        return _testSettingQPToEmptyStringDoesnTGenerateNullInURL.apply(this, arguments);
      }

      return testSettingQPToEmptyStringDoesnTGenerateNullInURL;
    }();

    _proto['@test A default boolean value deserializes QPs as booleans rather than strings'] = function testADefaultBooleanValueDeserializesQPsAsBooleansRatherThanStrings(assert) {
      var _this4 = this;

      assert.expect(3);
      this.setSingleQPController('index', 'foo', false);
      this.add('route:index', _routing.Route.extend({
        model: function (params) {
          assert.equal(params.foo, true, 'model hook received foo as boolean true');
        }
      }));
      return this.visit('/?foo=true').then(function () {
        var controller = _this4.getController('index');

        assert.equal(controller.get('foo'), true);

        _this4.transitionTo('/?foo=false');

        assert.equal(controller.get('foo'), false);
      });
    };

    _proto['@test Query param without value are empty string'] = function testQueryParamWithoutValueAreEmptyString(assert) {
      var _this5 = this;

      assert.expect(1);
      this.add('controller:index', _controller.default.extend({
        queryParams: ['foo'],
        foo: ''
      }));
      return this.visit('/?foo=').then(function () {
        var controller = _this5.getController('index');

        assert.equal(controller.get('foo'), '');
      });
    };

    _proto['@test Array query params can be set'] =
    /*#__PURE__*/
    function () {
      var _testArrayQueryParamsCanBeSet = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee24(assert) {
        var controller;
        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              assert.expect(2);
              this.router.map(function () {
                this.route('home', {
                  path: '/'
                });
              });
              this.setSingleQPController('home', 'foo', []);
              _context24.next = 5;
              return this.visit('/');

            case 5:
              controller = this.getController('home');
              _context24.next = 8;
              return this.setAndFlush(controller, 'foo', [1, 2]);

            case 8:
              this.assertCurrentPath('/?foo=%5B1%2C2%5D');
              _context24.next = 11;
              return this.setAndFlush(controller, 'foo', [3, 4]);

            case 11:
              this.assertCurrentPath('/?foo=%5B3%2C4%5D');

            case 12:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));

      function testArrayQueryParamsCanBeSet(_x22) {
        return _testArrayQueryParamsCanBeSet.apply(this, arguments);
      }

      return testArrayQueryParamsCanBeSet;
    }();

    _proto['@test (de)serialization: arrays'] =
    /*#__PURE__*/
    function () {
      var _testDeSerializationArrays = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee25(assert) {
        return regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) switch (_context25.prev = _context25.next) {
            case 0:
              assert.expect(4);
              this.setSingleQPController('index', 'foo', [1]);
              _context25.next = 4;
              return this.visitAndAssert('/');

            case 4:
              _context25.next = 6;
              return this.transitionTo({
                queryParams: {
                  foo: [2, 3]
                }
              });

            case 6:
              this.assertCurrentPath('/?foo=%5B2%2C3%5D', 'shorthand supported');
              _context25.next = 9;
              return this.transitionTo({
                queryParams: {
                  'index:foo': [4, 5]
                }
              });

            case 9:
              this.assertCurrentPath('/?foo=%5B4%2C5%5D', 'longform supported');
              _context25.next = 12;
              return this.transitionTo({
                queryParams: {
                  foo: []
                }
              });

            case 12:
              this.assertCurrentPath('/?foo=%5B%5D', 'longform supported');

            case 13:
            case "end":
              return _context25.stop();
          }
        }, _callee25, this);
      }));

      function testDeSerializationArrays(_x23) {
        return _testDeSerializationArrays.apply(this, arguments);
      }

      return testDeSerializationArrays;
    }();

    _proto['@test Url with array query param sets controller property to array'] = function testUrlWithArrayQueryParamSetsControllerPropertyToArray(assert) {
      var _this6 = this;

      assert.expect(1);
      this.setSingleQPController('index', 'foo', '');
      return this.visit('/?foo[]=1&foo[]=2&foo[]=3').then(function () {
        var controller = _this6.getController('index');

        assert.deepEqual(controller.get('foo'), ['1', '2', '3']);
      });
    };

    _proto['@test Array query params can be pushed/popped'] =
    /*#__PURE__*/
    function () {
      var _testArrayQueryParamsCanBePushedPopped = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee26(assert) {
        var controller;
        return regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              assert.expect(17);
              this.router.map(function () {
                this.route('home', {
                  path: '/'
                });
              });
              this.setSingleQPController('home', 'foo', (0, _runtime.A)());
              _context26.next = 5;
              return this.visitAndAssert('/');

            case 5:
              controller = this.getController('home');
              controller.foo.pushObject(1);
              _context26.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assertCurrentPath('/?foo=%5B1%5D');
              assert.deepEqual(controller.foo, [1]);
              controller.foo.popObject();
              _context26.next = 14;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 14:
              this.assertCurrentPath('/');
              assert.deepEqual(controller.foo, []);
              controller.foo.pushObject(1);
              _context26.next = 19;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 19:
              this.assertCurrentPath('/?foo=%5B1%5D');
              assert.deepEqual(controller.foo, [1]);
              controller.foo.popObject();
              _context26.next = 24;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 24:
              this.assertCurrentPath('/');
              assert.deepEqual(controller.foo, []);
              controller.foo.pushObject(1);
              _context26.next = 29;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 29:
              this.assertCurrentPath('/?foo=%5B1%5D');
              assert.deepEqual(controller.foo, [1]);
              controller.foo.pushObject(2);
              _context26.next = 34;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 34:
              this.assertCurrentPath('/?foo=%5B1%2C2%5D');
              assert.deepEqual(controller.foo, [1, 2]);
              controller.foo.popObject();
              _context26.next = 39;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 39:
              this.assertCurrentPath('/?foo=%5B1%5D');
              assert.deepEqual(controller.foo, [1]);
              controller.foo.unshiftObject('lol');
              _context26.next = 44;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 44:
              this.assertCurrentPath('/?foo=%5B%22lol%22%2C1%5D');
              assert.deepEqual(controller.foo, ['lol', 1]);

            case 46:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this);
      }));

      function testArrayQueryParamsCanBePushedPopped(_x24) {
        return _testArrayQueryParamsCanBePushedPopped.apply(this, arguments);
      }

      return testArrayQueryParamsCanBePushedPopped;
    }();

    _proto["@test Overwriting with array with same content shouldn't refire update"] =
    /*#__PURE__*/
    function () {
      var _testOverwritingWithArrayWithSameContentShouldnTRefireUpdate = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee27(assert) {
        var modelCount, controller;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              assert.expect(4);
              this.router.map(function () {
                this.route('home', {
                  path: '/'
                });
              });
              modelCount = 0;
              this.add('route:home', _routing.Route.extend({
                model: function () {
                  modelCount++;
                }
              }));
              this.setSingleQPController('home', 'foo', (0, _runtime.A)([1]));
              _context27.next = 7;
              return this.visitAndAssert('/');

            case 7:
              assert.equal(modelCount, 1);
              controller = this.getController('home');
              _context27.next = 11;
              return this.setAndFlush(controller, 'model', (0, _runtime.A)([1]));

            case 11:
              assert.equal(modelCount, 1);
              this.assertCurrentPath('/');

            case 13:
            case "end":
              return _context27.stop();
          }
        }, _callee27, this);
      }));

      function testOverwritingWithArrayWithSameContentShouldnTRefireUpdate(_x25) {
        return _testOverwritingWithArrayWithSameContentShouldnTRefireUpdate.apply(this, arguments);
      }

      return testOverwritingWithArrayWithSameContentShouldnTRefireUpdate;
    }();

    _proto['@test Defaulting to params hash as the model should not result in that params object being watched'] = function testDefaultingToParamsHashAsTheModelShouldNotResultInThatParamsObjectBeingWatched(assert) {
      var _this7 = this;

      assert.expect(1);
      this.router.map(function () {
        this.route('other');
      }); // This causes the params hash, which is returned as a route's
      // model if no other model could be resolved given the provided
      // params (and no custom model hook was defined), to be watched,
      // unless we return a copy of the params hash.

      this.setSingleQPController('application', 'woot', 'wat');
      this.add('route:other', _routing.Route.extend({
        model: function (p, trans) {
          var m = (0, _meta.peekMeta)(trans[_router_js.PARAMS_SYMBOL].application);
          assert.ok(m === null, "A meta object isn't constructed for this params POJO");
        }
      }));
      return this.visit('/').then(function () {
        _this7.transitionTo('other');
      });
    };

    _proto['@test Setting bound query param property to null or undefined does not serialize to url'] =
    /*#__PURE__*/
    function () {
      var _testSettingBoundQueryParamPropertyToNullOrUndefinedDoesNotSerializeToUrl = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee28(assert) {
        var controller;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) switch (_context28.prev = _context28.next) {
            case 0:
              assert.expect(9);
              this.router.map(function () {
                this.route('home');
              });
              this.setSingleQPController('home', 'foo', [1, 2]);
              _context28.next = 5;
              return this.visitAndAssert('/home');

            case 5:
              controller = this.getController('home');
              assert.deepEqual(controller.get('foo'), [1, 2]);
              this.assertCurrentPath('/home');
              _context28.next = 10;
              return this.setAndFlush(controller, 'foo', (0, _runtime.A)([1, 3]));

            case 10:
              this.assertCurrentPath('/home?foo=%5B1%2C3%5D');
              _context28.next = 13;
              return this.transitionTo('/home');

            case 13:
              assert.deepEqual(controller.get('foo'), [1, 2]);
              this.assertCurrentPath('/home');
              _context28.next = 17;
              return this.setAndFlush(controller, 'foo', null);

            case 17:
              this.assertCurrentPath('/home', 'Setting property to null');
              _context28.next = 20;
              return this.setAndFlush(controller, 'foo', (0, _runtime.A)([1, 3]));

            case 20:
              this.assertCurrentPath('/home?foo=%5B1%2C3%5D');
              _context28.next = 23;
              return this.setAndFlush(controller, 'foo', undefined);

            case 23:
              this.assertCurrentPath('/home', 'Setting property to undefined');

            case 24:
            case "end":
              return _context28.stop();
          }
        }, _callee28, this);
      }));

      function testSettingBoundQueryParamPropertyToNullOrUndefinedDoesNotSerializeToUrl(_x26) {
        return _testSettingBoundQueryParamPropertyToNullOrUndefinedDoesNotSerializeToUrl.apply(this, arguments);
      }

      return testSettingBoundQueryParamPropertyToNullOrUndefinedDoesNotSerializeToUrl;
    }();

    _proto['@test {{link-to}} with null or undefined QPs does not get serialized into url'] = function testLinkToWithNullOrUndefinedQPsDoesNotGetSerializedIntoUrl(assert) {
      var _this8 = this;

      assert.expect(3);
      this.addTemplate('home', "{{link-to 'Home' 'home' (query-params foo=nullValue) id='null-link'}}{{link-to 'Home' 'home' (query-params foo=undefinedValue) id='undefined-link'}}");
      this.router.map(function () {
        this.route('home');
      });
      this.setSingleQPController('home', 'foo', [], {
        nullValue: null,
        undefinedValue: undefined
      });
      return this.visitAndAssert('/home').then(function () {
        assert.equal(_this8.$('#null-link').attr('href'), '/home');
        assert.equal(_this8.$('#undefined-link').attr('href'), '/home');
      });
    };

    _proto["@test A child of a resource route still defaults to parent route's model even if the child route has a query param"] = function testAChildOfAResourceRouteStillDefaultsToParentRouteSModelEvenIfTheChildRouteHasAQueryParam(assert) {
      assert.expect(2);
      this.setSingleQPController('index', 'woot', undefined, {
        woot: undefined
      });
      this.add('route:application', _routing.Route.extend({
        model: function ()
        /* p, trans */
        {
          return {
            woot: true
          };
        }
      }));
      this.add('route:index', _routing.Route.extend({
        setupController: function (controller, model) {
          assert.deepEqual(model, {
            woot: true
          }, 'index route inherited model route from parent route');
        }
      }));
      return this.visitAndAssert('/');
    };

    _proto['@test opting into replace does not affect transitions between routes'] =
    /*#__PURE__*/
    function () {
      var _testOptingIntoReplaceDoesNotAffectTransitionsBetweenRoutes = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee29(assert) {
        var controller;
        return regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) switch (_context29.prev = _context29.next) {
            case 0:
              assert.expect(5);
              this.addTemplate('application', "{{link-to 'Foo' 'foo' id='foo-link'}}{{link-to 'Bar' 'bar' id='bar-no-qp-link'}}{{link-to 'Bar' 'bar' (query-params raytiley='isthebest') id='bar-link'}}{{outlet}}");
              this.router.map(function () {
                this.route('foo');
                this.route('bar');
              });
              this.setSingleQPController('bar', 'raytiley', 'israd');
              this.add('route:bar', _routing.Route.extend({
                queryParams: {
                  raytiley: {
                    replace: true
                  }
                }
              }));
              _context29.next = 7;
              return this.visit('/');

            case 7:
              controller = this.getController('bar');
              this.expectedPushURL = '/foo';
              (0, _runloop.run)(document.getElementById('foo-link'), 'click');
              this.expectedPushURL = '/bar';
              (0, _runloop.run)(document.getElementById('bar-no-qp-link'), 'click');
              this.expectedReplaceURL = '/bar?raytiley=woot';
              _context29.next = 15;
              return this.setAndFlush(controller, 'raytiley', 'woot');

            case 15:
              this.expectedPushURL = '/foo';
              (0, _runloop.run)(document.getElementById('foo-link'), 'click');
              this.expectedPushURL = '/bar?raytiley=isthebest';
              (0, _runloop.run)(document.getElementById('bar-link'), 'click');

            case 19:
            case "end":
              return _context29.stop();
          }
        }, _callee29, this);
      }));

      function testOptingIntoReplaceDoesNotAffectTransitionsBetweenRoutes(_x27) {
        return _testOptingIntoReplaceDoesNotAffectTransitionsBetweenRoutes.apply(this, arguments);
      }

      return testOptingIntoReplaceDoesNotAffectTransitionsBetweenRoutes;
    }();

    _proto["@test undefined isn't serialized or deserialized into a string"] = function testUndefinedIsnTSerializedOrDeserializedIntoAString(assert) {
      var _this9 = this;

      assert.expect(4);
      this.router.map(function () {
        this.route('example');
      });
      this.addTemplate('application', "{{link-to 'Example' 'example' (query-params foo=undefined) id='the-link'}}");
      this.setSingleQPController('example', 'foo', undefined, {
        foo: undefined
      });
      this.add('route:example', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            foo: undefined
          });
        }
      }));
      return this.visitAndAssert('/').then(function () {
        assert.equal(_this9.$('#the-link').attr('href'), '/example', 'renders without undefined qp serialized');
        return _this9.transitionTo('example', {
          queryParams: {
            foo: undefined
          }
        }).then(function () {
          _this9.assertCurrentPath('/example');
        });
      });
    };

    _proto['@test when refreshModel is true and loading hook is undefined, model hook will rerun when QPs change even if previous did not finish'] = function testWhenRefreshModelIsTrueAndLoadingHookIsUndefinedModelHookWillRerunWhenQPsChangeEvenIfPreviousDidNotFinish() {
      return this.refreshModelWhileLoadingTest();
    };

    _proto['@test when refreshModel is true and loading hook returns false, model hook will rerun when QPs change even if previous did not finish'] = function testWhenRefreshModelIsTrueAndLoadingHookReturnsFalseModelHookWillRerunWhenQPsChangeEvenIfPreviousDidNotFinish() {
      return this.refreshModelWhileLoadingTest(false);
    };

    _proto['@test when refreshModel is true and loading hook returns true, model hook will rerun when QPs change even if previous did not finish'] = function testWhenRefreshModelIsTrueAndLoadingHookReturnsTrueModelHookWillRerunWhenQPsChangeEvenIfPreviousDidNotFinish() {
      return this.refreshModelWhileLoadingTest(true);
    };

    _proto["@test warn user that Route's queryParams configuration must be an Object, not an Array"] =
    /*#__PURE__*/
    function () {
      var _testWarnUserThatRouteSQueryParamsConfigurationMustBeAnObjectNotAnArray = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee30(assert) {
        return regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) switch (_context30.prev = _context30.next) {
            case 0:
              assert.expect(1);
              this.add('route:application', _routing.Route.extend({
                queryParams: [{
                  commitBy: {
                    replace: true
                  }
                }]
              }));
              _context30.next = 4;
              return assert.rejectsAssertion(this.visit('/'), 'You passed in `[{"commitBy":{"replace":true}}]` as the value for `queryParams` but `queryParams` cannot be an Array');

            case 4:
            case "end":
              return _context30.stop();
          }
        }, _callee30, this);
      }));

      function testWarnUserThatRouteSQueryParamsConfigurationMustBeAnObjectNotAnArray(_x28) {
        return _testWarnUserThatRouteSQueryParamsConfigurationMustBeAnObjectNotAnArray.apply(this, arguments);
      }

      return testWarnUserThatRouteSQueryParamsConfigurationMustBeAnObjectNotAnArray;
    }();

    _proto['@test handle route names that clash with Object.prototype properties'] =
    /*#__PURE__*/
    function () {
      var _testHandleRouteNamesThatClashWithObjectPrototypeProperties = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee31(assert) {
        var controller;
        return regeneratorRuntime.wrap(function _callee31$(_context31) {
          while (1) switch (_context31.prev = _context31.next) {
            case 0:
              assert.expect(1);
              this.router.map(function () {
                this.route('constructor');
              });
              this.add('route:constructor', _routing.Route.extend({
                queryParams: {
                  foo: {
                    defaultValue: '123'
                  }
                }
              }));
              _context31.next = 5;
              return this.visit('/');

            case 5:
              _context31.next = 7;
              return this.transitionTo('constructor', {
                queryParams: {
                  foo: '999'
                }
              });

            case 7:
              controller = this.getController('constructor');
              assert.equal((0, _metal.get)(controller, 'foo'), '999');

            case 9:
            case "end":
              return _context31.stop();
          }
        }, _callee31, this);
      }));

      function testHandleRouteNamesThatClashWithObjectPrototypeProperties(_x29) {
        return _testHandleRouteNamesThatClashWithObjectPrototypeProperties.apply(this, arguments);
      }

      return testHandleRouteNamesThatClashWithObjectPrototypeProperties;
    }();

    return _class;
  }(_internalTestHelpers.QueryParamTestCase));
});
enifed("ember/tests/routing/query_params_test/model_dependent_state_with_query_params_test", ["ember-babel", "@ember/controller", "@ember/-internals/runtime", "@ember/-internals/routing", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _controller, _runtime, _routing, _metal, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var ModelDependentQPTestCase =
  /*#__PURE__*/
  function (_QueryParamTestCase) {
    (0, _emberBabel.inheritsLoose)(ModelDependentQPTestCase, _QueryParamTestCase);

    function ModelDependentQPTestCase() {
      return _QueryParamTestCase.apply(this, arguments) || this;
    }

    var _proto = ModelDependentQPTestCase.prototype;

    _proto.boot = function boot() {
      this.setupApplication();
      return this.visitApplication();
    };

    _proto.teardown = function teardown() {
      _QueryParamTestCase.prototype.teardown.apply(this, arguments);

      this.assert.ok(!this.expectedModelHookParams, 'there should be no pending expectation of expected model hook params');
    };

    _proto.reopenController = function reopenController(name, options) {
      this.application.resolveRegistration("controller:" + name).reopen(options);
    };

    _proto.reopenRoute = function reopenRoute(name, options) {
      this.application.resolveRegistration("route:" + name).reopen(options);
    };

    _proto.queryParamsStickyTest1 =
    /*#__PURE__*/
    function () {
      var _queryParamsStickyTest = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(urlPrefix) {
        var assert;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              assert = this.assert;
              assert.expect(14);
              _context.next = 4;
              return this.boot();

            case 4:
              this.$link1.click();
              _context.next = 7;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 7:
              this.assertCurrentPath(urlPrefix + "/a-1");
              _context.next = 10;
              return this.setAndFlush(this.controller, 'q', 'lol');

            case 10:
              assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
              assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2");
              assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3");
              this.$link2.click();
              _context.next = 16;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 16:
              assert.equal(this.controller.get('q'), 'wat');
              assert.equal(this.controller.get('z'), 0);
              assert.deepEqual(this.controller.get('model'), {
                id: 'a-2'
              });
              assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
              assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2");
              assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3");

            case 22:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function queryParamsStickyTest1(_x) {
        return _queryParamsStickyTest.apply(this, arguments);
      }

      return queryParamsStickyTest1;
    }();

    _proto.queryParamsStickyTest2 =
    /*#__PURE__*/
    function () {
      var _queryParamsStickyTest2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(urlPrefix) {
        var assert;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              assert = this.assert;
              assert.expect(24);
              _context2.next = 4;
              return this.boot();

            case 4:
              this.expectedModelHookParams = {
                id: 'a-1',
                q: 'lol',
                z: 0
              };
              _context2.next = 7;
              return this.transitionTo(urlPrefix + "/a-1?q=lol");

            case 7:
              assert.deepEqual(this.controller.get('model'), {
                id: 'a-1'
              });
              assert.equal(this.controller.get('q'), 'lol');
              assert.equal(this.controller.get('z'), 0);
              assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
              assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2");
              assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3");
              this.expectedModelHookParams = {
                id: 'a-2',
                q: 'lol',
                z: 0
              };
              _context2.next = 16;
              return this.transitionTo(urlPrefix + "/a-2?q=lol");

            case 16:
              assert.deepEqual(this.controller.get('model'), {
                id: 'a-2'
              }, "controller's model changed to a-2");
              assert.equal(this.controller.get('q'), 'lol');
              assert.equal(this.controller.get('z'), 0);
              assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
              assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
              assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3");
              this.expectedModelHookParams = {
                id: 'a-3',
                q: 'lol',
                z: 123
              };
              _context2.next = 25;
              return this.transitionTo(urlPrefix + "/a-3?q=lol&z=123");

            case 25:
              assert.equal(this.controller.get('q'), 'lol');
              assert.equal(this.controller.get('z'), 123);
              assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
              assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
              assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3?q=lol&z=123");

            case 30:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function queryParamsStickyTest2(_x2) {
        return _queryParamsStickyTest2.apply(this, arguments);
      }

      return queryParamsStickyTest2;
    }();

    _proto.queryParamsStickyTest3 =
    /*#__PURE__*/
    function () {
      var _queryParamsStickyTest3 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(urlPrefix, articleLookup) {
        var assert;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              assert = this.assert;
              assert.expect(32);
              this.addTemplate('application', "{{#each articles as |a|}} {{link-to 'Article' '" + articleLookup + "' a.id id=a.id}} {{/each}}");
              _context3.next = 5;
              return this.boot();

            case 5:
              this.expectedModelHookParams = {
                id: 'a-1',
                q: 'wat',
                z: 0
              };
              _context3.next = 8;
              return this.transitionTo(articleLookup, 'a-1');

            case 8:
              assert.deepEqual(this.controller.get('model'), {
                id: 'a-1'
              });
              assert.equal(this.controller.get('q'), 'wat');
              assert.equal(this.controller.get('z'), 0);
              assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1");
              assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2");
              assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3");
              this.expectedModelHookParams = {
                id: 'a-2',
                q: 'lol',
                z: 0
              };
              _context3.next = 17;
              return this.transitionTo(articleLookup, 'a-2', {
                queryParams: {
                  q: 'lol'
                }
              });

            case 17:
              assert.deepEqual(this.controller.get('model'), {
                id: 'a-2'
              });
              assert.equal(this.controller.get('q'), 'lol');
              assert.equal(this.controller.get('z'), 0);
              assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1");
              assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
              assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3");
              this.expectedModelHookParams = {
                id: 'a-3',
                q: 'hay',
                z: 0
              };
              _context3.next = 26;
              return this.transitionTo(articleLookup, 'a-3', {
                queryParams: {
                  q: 'hay'
                }
              });

            case 26:
              assert.deepEqual(this.controller.get('model'), {
                id: 'a-3'
              });
              assert.equal(this.controller.get('q'), 'hay');
              assert.equal(this.controller.get('z'), 0);
              assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1");
              assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
              assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3?q=hay");
              this.expectedModelHookParams = {
                id: 'a-2',
                q: 'lol',
                z: 1
              };
              _context3.next = 35;
              return this.transitionTo(articleLookup, 'a-2', {
                queryParams: {
                  z: 1
                }
              });

            case 35:
              assert.deepEqual(this.controller.get('model'), {
                id: 'a-2'
              });
              assert.equal(this.controller.get('q'), 'lol');
              assert.equal(this.controller.get('z'), 1);
              assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1");
              assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol&z=1");
              assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3?q=hay");

            case 41:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function queryParamsStickyTest3(_x3, _x4) {
        return _queryParamsStickyTest3.apply(this, arguments);
      }

      return queryParamsStickyTest3;
    }();

    _proto.queryParamsStickyTest4 =
    /*#__PURE__*/
    function () {
      var _queryParamsStickyTest4 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(urlPrefix, articleLookup) {
        var assert;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              assert = this.assert;
              assert.expect(24);
              this.setupApplication();
              this.reopenController(articleLookup, {
                queryParams: {
                  q: {
                    scope: 'controller'
                  }
                }
              });
              _context4.next = 6;
              return this.visitApplication();

            case 6:
              this.$link1.click();
              _context4.next = 9;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 9:
              this.assertCurrentPath(urlPrefix + "/a-1");
              _context4.next = 12;
              return this.setAndFlush(this.controller, 'q', 'lol');

            case 12:
              assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
              assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
              assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3?q=lol");
              this.$link2.click();
              _context4.next = 18;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 18:
              assert.equal(this.controller.get('q'), 'lol');
              assert.equal(this.controller.get('z'), 0);
              assert.deepEqual(this.controller.get('model'), {
                id: 'a-2'
              });
              assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=lol");
              assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=lol");
              assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3?q=lol");
              this.expectedModelHookParams = {
                id: 'a-3',
                q: 'haha',
                z: 123
              };
              _context4.next = 27;
              return this.transitionTo(urlPrefix + "/a-3?q=haha&z=123");

            case 27:
              assert.deepEqual(this.controller.get('model'), {
                id: 'a-3'
              });
              assert.equal(this.controller.get('q'), 'haha');
              assert.equal(this.controller.get('z'), 123);
              assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=haha");
              assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=haha");
              assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3?q=haha&z=123");
              _context4.next = 35;
              return this.setAndFlush(this.controller, 'q', 'woot');

            case 35:
              assert.equal(this.$link1.getAttribute('href'), urlPrefix + "/a-1?q=woot");
              assert.equal(this.$link2.getAttribute('href'), urlPrefix + "/a-2?q=woot");
              assert.equal(this.$link3.getAttribute('href'), urlPrefix + "/a-3?q=woot&z=123");

            case 38:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));

      function queryParamsStickyTest4(_x5, _x6) {
        return _queryParamsStickyTest4.apply(this, arguments);
      }

      return queryParamsStickyTest4;
    }();

    _proto.queryParamsStickyTest5 =
    /*#__PURE__*/
    function () {
      var _queryParamsStickyTest5 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(urlPrefix, commentsLookupKey) {
        var assert, commentsCtrl;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              assert = this.assert;
              assert.expect(12);
              _context5.next = 4;
              return this.boot();

            case 4:
              _context5.next = 6;
              return this.transitionTo(commentsLookupKey, 'a-1');

            case 6:
              commentsCtrl = this.getController(commentsLookupKey);
              assert.equal(commentsCtrl.get('page'), 1);
              this.assertCurrentPath(urlPrefix + "/a-1/comments");
              _context5.next = 11;
              return this.setAndFlush(commentsCtrl, 'page', 2);

            case 11:
              this.assertCurrentPath(urlPrefix + "/a-1/comments?page=2");
              _context5.next = 14;
              return this.setAndFlush(commentsCtrl, 'page', 3);

            case 14:
              this.assertCurrentPath(urlPrefix + "/a-1/comments?page=3");
              _context5.next = 17;
              return this.transitionTo(commentsLookupKey, 'a-2');

            case 17:
              assert.equal(commentsCtrl.get('page'), 1);
              this.assertCurrentPath(urlPrefix + "/a-2/comments");
              _context5.next = 21;
              return this.transitionTo(commentsLookupKey, 'a-1');

            case 21:
              assert.equal(commentsCtrl.get('page'), 3);
              this.assertCurrentPath(urlPrefix + "/a-1/comments?page=3");

            case 23:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));

      function queryParamsStickyTest5(_x7, _x8) {
        return _queryParamsStickyTest5.apply(this, arguments);
      }

      return queryParamsStickyTest5;
    }();

    _proto.queryParamsStickyTest6 =
    /*#__PURE__*/
    function () {
      var _queryParamsStickyTest6 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(urlPrefix, articleLookup, commentsLookup) {
        var assert, commentsCtrl;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              assert = this.assert;
              assert.expect(13);
              this.setupApplication();
              this.reopenRoute(articleLookup, {
                resetController: function (controller, isExiting) {
                  this.controllerFor(commentsLookup).set('page', 1);

                  if (isExiting) {
                    controller.set('q', 'imdone');
                  }
                }
              });
              this.addTemplate('about', "{{link-to 'A' '" + commentsLookup + "' 'a-1' id='one'}} {{link-to 'B' '" + commentsLookup + "' 'a-2' id='two'}}");
              _context6.next = 7;
              return this.visitApplication();

            case 7:
              _context6.next = 9;
              return this.transitionTo(commentsLookup, 'a-1');

            case 9:
              commentsCtrl = this.getController(commentsLookup);
              assert.equal(commentsCtrl.get('page'), 1);
              this.assertCurrentPath(urlPrefix + "/a-1/comments");
              _context6.next = 14;
              return this.setAndFlush(commentsCtrl, 'page', 2);

            case 14:
              this.assertCurrentPath(urlPrefix + "/a-1/comments?page=2");
              _context6.next = 17;
              return this.transitionTo(commentsLookup, 'a-2');

            case 17:
              assert.equal(commentsCtrl.get('page'), 1);
              assert.equal(this.controller.get('q'), 'wat');
              _context6.next = 21;
              return this.transitionTo(commentsLookup, 'a-1');

            case 21:
              this.assertCurrentPath(urlPrefix + "/a-1/comments");
              assert.equal(commentsCtrl.get('page'), 1);
              _context6.next = 25;
              return this.transitionTo('about');

            case 25:
              assert.equal(document.getElementById('one').getAttribute('href'), urlPrefix + "/a-1/comments?q=imdone");
              assert.equal(document.getElementById('two').getAttribute('href'), urlPrefix + "/a-2/comments");

            case 27:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));

      function queryParamsStickyTest6(_x9, _x10, _x11) {
        return _queryParamsStickyTest6.apply(this, arguments);
      }

      return queryParamsStickyTest6;
    }();

    return ModelDependentQPTestCase;
  }(_internalTestHelpers.QueryParamTestCase);

  (0, _internalTestHelpers.moduleFor)('Query Params - model-dependent state',
  /*#__PURE__*/
  function (_ModelDependentQPTest) {
    (0, _emberBabel.inheritsLoose)(_class, _ModelDependentQPTest);

    function _class() {
      return _ModelDependentQPTest.apply(this, arguments) || this;
    }

    var _proto2 = _class.prototype;

    _proto2.setupApplication = function setupApplication() {
      this.router.map(function () {
        this.route('article', {
          path: '/a/:id'
        }, function () {
          this.route('comments', {
            resetNamespace: true
          });
        });
        this.route('about');
      });
      var articles = (0, _runtime.A)([{
        id: 'a-1'
      }, {
        id: 'a-2'
      }, {
        id: 'a-3'
      }]);
      this.add('controller:application', _controller.default.extend({
        articles: articles
      }));
      var self = this;
      var assert = this.assert;
      this.add('route:article', _routing.Route.extend({
        model: function (params) {
          if (self.expectedModelHookParams) {
            assert.deepEqual(params, self.expectedModelHookParams, 'the ArticleRoute model hook received the expected merged dynamic segment + query params hash');
            self.expectedModelHookParams = null;
          }

          return articles.findBy('id', params.id);
        }
      }));
      this.add('controller:article', _controller.default.extend({
        queryParams: ['q', 'z'],
        q: 'wat',
        z: 0
      }));
      this.add('controller:comments', _controller.default.extend({
        queryParams: 'page',
        page: 1
      }));
      this.addTemplate('application', "{{#each articles as |a|}} 1{{link-to 'Article' 'article' a id=a.id}} {{/each}} {{outlet}}");
    };

    _proto2.visitApplication = function visitApplication() {
      var _this = this;

      return this.visit('/').then(function () {
        var assert = _this.assert;
        _this.$link1 = document.getElementById('a-1');
        _this.$link2 = document.getElementById('a-2');
        _this.$link3 = document.getElementById('a-3');
        assert.equal(_this.$link1.getAttribute('href'), '/a/a-1');
        assert.equal(_this.$link2.getAttribute('href'), '/a/a-2');
        assert.equal(_this.$link3.getAttribute('href'), '/a/a-3');
        _this.controller = _this.getController('article');
      });
    };

    _proto2["@test query params have 'model' stickiness by default"] = function testQueryParamsHaveModelStickinessByDefault() {
      return this.queryParamsStickyTest1('/a');
    };

    _proto2["@test query params have 'model' stickiness by default (url changes)"] = function testQueryParamsHaveModelStickinessByDefaultUrlChanges() {
      return this.queryParamsStickyTest2('/a');
    };

    _proto2["@test query params have 'model' stickiness by default (params-based transitions)"] = function testQueryParamsHaveModelStickinessByDefaultParamsBasedTransitions() {
      return this.queryParamsStickyTest3('/a', 'article');
    };

    _proto2["@test 'controller' stickiness shares QP state between models"] = function testControllerStickinessSharesQPStateBetweenModels() {
      return this.queryParamsStickyTest4('/a', 'article');
    };

    _proto2["@test 'model' stickiness is scoped to current or first dynamic parent route"] = function testModelStickinessIsScopedToCurrentOrFirstDynamicParentRoute() {
      return this.queryParamsStickyTest5('/a', 'comments');
    };

    _proto2['@test can reset query params using the resetController hook'] = function testCanResetQueryParamsUsingTheResetControllerHook() {
      return this.queryParamsStickyTest6('/a', 'article', 'comments');
    };

    return _class;
  }(ModelDependentQPTestCase));
  (0, _internalTestHelpers.moduleFor)('Query Params - model-dependent state (nested)',
  /*#__PURE__*/
  function (_ModelDependentQPTest2) {
    (0, _emberBabel.inheritsLoose)(_class2, _ModelDependentQPTest2);

    function _class2() {
      return _ModelDependentQPTest2.apply(this, arguments) || this;
    }

    var _proto3 = _class2.prototype;

    _proto3.setupApplication = function setupApplication() {
      this.router.map(function () {
        this.route('site', function () {
          this.route('article', {
            path: '/a/:id'
          }, function () {
            this.route('comments');
          });
        });
        this.route('about');
      });
      var site_articles = (0, _runtime.A)([{
        id: 'a-1'
      }, {
        id: 'a-2'
      }, {
        id: 'a-3'
      }]);
      this.add('controller:application', _controller.default.extend({
        articles: site_articles
      }));
      var self = this;
      var assert = this.assert;
      this.add('route:site.article', _routing.Route.extend({
        model: function (params) {
          if (self.expectedModelHookParams) {
            assert.deepEqual(params, self.expectedModelHookParams, 'the ArticleRoute model hook received the expected merged dynamic segment + query params hash');
            self.expectedModelHookParams = null;
          }

          return site_articles.findBy('id', params.id);
        }
      }));
      this.add('controller:site.article', _controller.default.extend({
        queryParams: ['q', 'z'],
        q: 'wat',
        z: 0
      }));
      this.add('controller:site.article.comments', _controller.default.extend({
        queryParams: 'page',
        page: 1
      }));
      this.addTemplate('application', "{{#each articles as |a|}} {{link-to 'Article' 'site.article' a id=a.id}} {{/each}} {{outlet}}");
    };

    _proto3.visitApplication = function visitApplication() {
      var _this2 = this;

      return this.visit('/').then(function () {
        var assert = _this2.assert;
        _this2.$link1 = document.getElementById('a-1');
        _this2.$link2 = document.getElementById('a-2');
        _this2.$link3 = document.getElementById('a-3');
        assert.equal(_this2.$link1.getAttribute('href'), '/site/a/a-1');
        assert.equal(_this2.$link2.getAttribute('href'), '/site/a/a-2');
        assert.equal(_this2.$link3.getAttribute('href'), '/site/a/a-3');
        _this2.controller = _this2.getController('site.article');
      });
    };

    _proto3["@test query params have 'model' stickiness by default"] = function testQueryParamsHaveModelStickinessByDefault() {
      return this.queryParamsStickyTest1('/site/a');
    };

    _proto3["@test query params have 'model' stickiness by default (url changes)"] = function testQueryParamsHaveModelStickinessByDefaultUrlChanges() {
      return this.queryParamsStickyTest2('/site/a');
    };

    _proto3["@test query params have 'model' stickiness by default (params-based transitions)"] = function testQueryParamsHaveModelStickinessByDefaultParamsBasedTransitions() {
      return this.queryParamsStickyTest3('/site/a', 'site.article');
    };

    _proto3["@test 'controller' stickiness shares QP state between models"] = function testControllerStickinessSharesQPStateBetweenModels() {
      return this.queryParamsStickyTest4('/site/a', 'site.article');
    };

    _proto3["@test 'model' stickiness is scoped to current or first dynamic parent route"] = function testModelStickinessIsScopedToCurrentOrFirstDynamicParentRoute() {
      return this.queryParamsStickyTest5('/site/a', 'site.article.comments');
    };

    _proto3['@test can reset query params using the resetController hook'] = function testCanResetQueryParamsUsingTheResetControllerHook() {
      return this.queryParamsStickyTest6('/site/a', 'site.article', 'site.article.comments');
    };

    return _class2;
  }(ModelDependentQPTestCase));
  (0, _internalTestHelpers.moduleFor)('Query Params - model-dependent state (nested & more than 1 dynamic segment)',
  /*#__PURE__*/
  function (_ModelDependentQPTest3) {
    (0, _emberBabel.inheritsLoose)(_class3, _ModelDependentQPTest3);

    function _class3() {
      return _ModelDependentQPTest3.apply(this, arguments) || this;
    }

    var _proto4 = _class3.prototype;

    _proto4.setupApplication = function setupApplication() {
      this.router.map(function () {
        this.route('site', {
          path: '/site/:site_id'
        }, function () {
          this.route('article', {
            path: '/a/:article_id'
          }, function () {
            this.route('comments');
          });
        });
      });
      var sites = (0, _runtime.A)([{
        id: 's-1'
      }, {
        id: 's-2'
      }, {
        id: 's-3'
      }]);
      var site_articles = (0, _runtime.A)([{
        id: 'a-1'
      }, {
        id: 'a-2'
      }, {
        id: 'a-3'
      }]);
      this.add('controller:application', _controller.default.extend({
        siteArticles: site_articles,
        sites: sites,
        allSitesAllArticles: (0, _metal.computed)({
          get: function () {
            var ret = [];
            var siteArticles = this.siteArticles;
            var sites = this.sites;
            sites.forEach(function (site) {
              ret = ret.concat(siteArticles.map(function (article) {
                return {
                  id: site.id + "-" + article.id,
                  site_id: site.id,
                  article_id: article.id
                };
              }));
            });
            return ret;
          }
        })
      }));
      var self = this;
      var assert = this.assert;
      this.add('route:site', _routing.Route.extend({
        model: function (params) {
          if (self.expectedSiteModelHookParams) {
            assert.deepEqual(params, self.expectedSiteModelHookParams, 'the SiteRoute model hook received the expected merged dynamic segment + query params hash');
            self.expectedSiteModelHookParams = null;
          }

          return sites.findBy('id', params.site_id);
        }
      }));
      this.add('route:site.article', _routing.Route.extend({
        model: function (params) {
          if (self.expectedArticleModelHookParams) {
            assert.deepEqual(params, self.expectedArticleModelHookParams, 'the SiteArticleRoute model hook received the expected merged dynamic segment + query params hash');
            self.expectedArticleModelHookParams = null;
          }

          return site_articles.findBy('id', params.article_id);
        }
      }));
      this.add('controller:site', _controller.default.extend({
        queryParams: ['country'],
        country: 'au'
      }));
      this.add('controller:site.article', _controller.default.extend({
        queryParams: ['q', 'z'],
        q: 'wat',
        z: 0
      }));
      this.add('controller:site.article.comments', _controller.default.extend({
        queryParams: ['page'],
        page: 1
      }));
      this.addTemplate('application', "{{#each allSitesAllArticles as |a|}} {{#link-to 'site.article' a.site_id a.article_id id=a.id}}Article [{{a.site_id}}] [{{a.article_id}}]{{/link-to}} {{/each}} {{outlet}}");
    };

    _proto4.visitApplication = function visitApplication() {
      var _this3 = this;

      return this.visit('/').then(function () {
        var assert = _this3.assert;
        _this3.links = {};
        _this3.links['s-1-a-1'] = document.getElementById('s-1-a-1');
        _this3.links['s-1-a-2'] = document.getElementById('s-1-a-2');
        _this3.links['s-1-a-3'] = document.getElementById('s-1-a-3');
        _this3.links['s-2-a-1'] = document.getElementById('s-2-a-1');
        _this3.links['s-2-a-2'] = document.getElementById('s-2-a-2');
        _this3.links['s-2-a-3'] = document.getElementById('s-2-a-3');
        _this3.links['s-3-a-1'] = document.getElementById('s-3-a-1');
        _this3.links['s-3-a-2'] = document.getElementById('s-3-a-2');
        _this3.links['s-3-a-3'] = document.getElementById('s-3-a-3');
        assert.equal(_this3.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
        assert.equal(_this3.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2');
        assert.equal(_this3.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
        assert.equal(_this3.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1');
        assert.equal(_this3.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
        assert.equal(_this3.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
        assert.equal(_this3.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
        assert.equal(_this3.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
        assert.equal(_this3.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
        _this3.site_controller = _this3.getController('site');
        _this3.article_controller = _this3.getController('site.article');
      });
    };

    _proto4["@test query params have 'model' stickiness by default"] =
    /*#__PURE__*/
    function () {
      var _testQueryParamsHaveModelStickinessByDefault = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(assert) {
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              assert.expect(59);
              _context7.next = 3;
              return this.boot();

            case 3:
              this.links['s-1-a-1'].click();
              _context7.next = 6;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 6:
              assert.deepEqual(this.site_controller.get('model'), {
                id: 's-1'
              });
              assert.deepEqual(this.article_controller.get('model'), {
                id: 'a-1'
              });
              this.assertCurrentPath('/site/s-1/a/a-1');
              _context7.next = 11;
              return this.setAndFlush(this.article_controller, 'q', 'lol');

            case 11:
              assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
              assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2');
              assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
              assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?q=lol');
              assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
              assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
              assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
              assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
              assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
              _context7.next = 22;
              return this.setAndFlush(this.site_controller, 'country', 'us');

            case 22:
              assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?country=us&q=lol');
              assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?country=us');
              assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?country=us');
              assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?q=lol');
              assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
              assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
              assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
              assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
              assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
              this.links['s-1-a-2'].click();
              _context7.next = 34;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 34:
              assert.equal(this.site_controller.get('country'), 'us');
              assert.equal(this.article_controller.get('q'), 'wat');
              assert.equal(this.article_controller.get('z'), 0);
              assert.deepEqual(this.site_controller.get('model'), {
                id: 's-1'
              });
              assert.deepEqual(this.article_controller.get('model'), {
                id: 'a-2'
              });
              assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?country=us&q=lol');
              assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?country=us');
              assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?country=us');
              assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?q=lol');
              assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
              assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
              assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
              assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
              assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
              this.links['s-2-a-2'].click();
              _context7.next = 51;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 51:
              assert.equal(this.site_controller.get('country'), 'au');
              assert.equal(this.article_controller.get('q'), 'wat');
              assert.equal(this.article_controller.get('z'), 0);
              assert.deepEqual(this.site_controller.get('model'), {
                id: 's-2'
              });
              assert.deepEqual(this.article_controller.get('model'), {
                id: 'a-2'
              });
              assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?country=us&q=lol');
              assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?country=us');
              assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?country=us');
              assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?q=lol');
              assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
              assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
              assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
              assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
              assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');

            case 65:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));

      function testQueryParamsHaveModelStickinessByDefault(_x12) {
        return _testQueryParamsHaveModelStickinessByDefault.apply(this, arguments);
      }

      return testQueryParamsHaveModelStickinessByDefault;
    }();

    _proto4["@test query params have 'model' stickiness by default (url changes)"] =
    /*#__PURE__*/
    function () {
      var _testQueryParamsHaveModelStickinessByDefaultUrlChanges = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(assert) {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              assert.expect(88);
              _context8.next = 3;
              return this.boot();

            case 3:
              this.expectedSiteModelHookParams = {
                site_id: 's-1',
                country: 'au'
              };
              this.expectedArticleModelHookParams = {
                article_id: 'a-1',
                q: 'lol',
                z: 0
              };
              _context8.next = 7;
              return this.transitionTo('/site/s-1/a/a-1?q=lol');

            case 7:
              assert.deepEqual(this.site_controller.get('model'), {
                id: 's-1'
              }, "site controller's model is s-1");
              assert.deepEqual(this.article_controller.get('model'), {
                id: 'a-1'
              }, "article controller's model is a-1");
              assert.equal(this.site_controller.get('country'), 'au');
              assert.equal(this.article_controller.get('q'), 'lol');
              assert.equal(this.article_controller.get('z'), 0);
              assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
              assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2');
              assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
              assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?q=lol');
              assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
              assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
              assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
              assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
              assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
              this.expectedSiteModelHookParams = {
                site_id: 's-2',
                country: 'us'
              };
              this.expectedArticleModelHookParams = {
                article_id: 'a-1',
                q: 'lol',
                z: 0
              };
              _context8.next = 25;
              return this.transitionTo('/site/s-2/a/a-1?country=us&q=lol');

            case 25:
              assert.deepEqual(this.site_controller.get('model'), {
                id: 's-2'
              }, "site controller's model is s-2");
              assert.deepEqual(this.article_controller.get('model'), {
                id: 'a-1'
              }, "article controller's model is a-1");
              assert.equal(this.site_controller.get('country'), 'us');
              assert.equal(this.article_controller.get('q'), 'lol');
              assert.equal(this.article_controller.get('z'), 0);
              assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
              assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2');
              assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
              assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=lol');
              assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us');
              assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us');
              assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
              assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
              assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
              this.expectedSiteModelHookParams = {
                site_id: 's-2',
                country: 'us'
              };
              this.expectedArticleModelHookParams = {
                article_id: 'a-2',
                q: 'lol',
                z: 0
              };
              _context8.next = 43;
              return this.transitionTo('/site/s-2/a/a-2?country=us&q=lol');

            case 43:
              assert.deepEqual(this.site_controller.get('model'), {
                id: 's-2'
              }, "site controller's model is s-2");
              assert.deepEqual(this.article_controller.get('model'), {
                id: 'a-2'
              }, "article controller's model is a-2");
              assert.equal(this.site_controller.get('country'), 'us');
              assert.equal(this.article_controller.get('q'), 'lol');
              assert.equal(this.article_controller.get('z'), 0);
              assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
              assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol');
              assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
              assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=lol');
              assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol');
              assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us');
              assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
              assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol');
              assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
              this.expectedSiteModelHookParams = {
                site_id: 's-2',
                country: 'us'
              };
              this.expectedArticleModelHookParams = {
                article_id: 'a-3',
                q: 'lol',
                z: 123
              };
              _context8.next = 61;
              return this.transitionTo('/site/s-2/a/a-3?country=us&q=lol&z=123');

            case 61:
              assert.deepEqual(this.site_controller.get('model'), {
                id: 's-2'
              }, "site controller's model is s-2");
              assert.deepEqual(this.article_controller.get('model'), {
                id: 'a-3'
              }, "article controller's model is a-3");
              assert.equal(this.site_controller.get('country'), 'us');
              assert.equal(this.article_controller.get('q'), 'lol');
              assert.equal(this.article_controller.get('z'), 123);
              assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
              assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol');
              assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=lol&z=123');
              assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=lol');
              assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol');
              assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us&q=lol&z=123');
              assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=lol');
              assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol');
              assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?q=lol&z=123');
              this.expectedSiteModelHookParams = {
                site_id: 's-3',
                country: 'nz'
              };
              this.expectedArticleModelHookParams = {
                article_id: 'a-3',
                q: 'lol',
                z: 123
              };
              _context8.next = 79;
              return this.transitionTo('/site/s-3/a/a-3?country=nz&q=lol&z=123');

            case 79:
              assert.deepEqual(this.site_controller.get('model'), {
                id: 's-3'
              }, "site controller's model is s-3");
              assert.deepEqual(this.article_controller.get('model'), {
                id: 'a-3'
              }, "article controller's model is a-3");
              assert.equal(this.site_controller.get('country'), 'nz');
              assert.equal(this.article_controller.get('q'), 'lol');
              assert.equal(this.article_controller.get('z'), 123);
              assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=lol');
              assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol');
              assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=lol&z=123');
              assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=lol');
              assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol');
              assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us&q=lol&z=123');
              assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?country=nz&q=lol');
              assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?country=nz&q=lol');
              assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?country=nz&q=lol&z=123');

            case 93:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));

      function testQueryParamsHaveModelStickinessByDefaultUrlChanges(_x13) {
        return _testQueryParamsHaveModelStickinessByDefaultUrlChanges.apply(this, arguments);
      }

      return testQueryParamsHaveModelStickinessByDefaultUrlChanges;
    }();

    _proto4["@test query params have 'model' stickiness by default (params-based transitions)"] =
    /*#__PURE__*/
    function () {
      var _testQueryParamsHaveModelStickinessByDefaultParamsBasedTransitions = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee9(assert) {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              assert.expect(118);
              _context9.next = 3;
              return this.boot();

            case 3:
              this.expectedSiteModelHookParams = {
                site_id: 's-1',
                country: 'au'
              };
              this.expectedArticleModelHookParams = {
                article_id: 'a-1',
                q: 'wat',
                z: 0
              };
              _context9.next = 7;
              return this.transitionTo('site.article', 's-1', 'a-1');

            case 7:
              assert.deepEqual(this.site_controller.get('model'), {
                id: 's-1'
              });
              assert.deepEqual(this.article_controller.get('model'), {
                id: 'a-1'
              });
              assert.equal(this.site_controller.get('country'), 'au');
              assert.equal(this.article_controller.get('q'), 'wat');
              assert.equal(this.article_controller.get('z'), 0);
              assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
              assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2');
              assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
              assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1');
              assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2');
              assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
              assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
              assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2');
              assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
              this.expectedSiteModelHookParams = {
                site_id: 's-1',
                country: 'au'
              };
              this.expectedArticleModelHookParams = {
                article_id: 'a-2',
                q: 'lol',
                z: 0
              };
              _context9.next = 25;
              return this.transitionTo('site.article', 's-1', 'a-2', {
                queryParams: {
                  q: 'lol'
                }
              });

            case 25:
              assert.deepEqual(this.site_controller.get('model'), {
                id: 's-1'
              });
              assert.deepEqual(this.article_controller.get('model'), {
                id: 'a-2'
              });
              assert.equal(this.site_controller.get('country'), 'au');
              assert.equal(this.article_controller.get('q'), 'lol');
              assert.equal(this.article_controller.get('z'), 0);
              assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
              assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol');
              assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3');
              assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1');
              assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?q=lol');
              assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3');
              assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
              assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol');
              assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3');
              this.expectedSiteModelHookParams = {
                site_id: 's-1',
                country: 'au'
              };
              this.expectedArticleModelHookParams = {
                article_id: 'a-3',
                q: 'hay',
                z: 0
              };
              _context9.next = 43;
              return this.transitionTo('site.article', 's-1', 'a-3', {
                queryParams: {
                  q: 'hay'
                }
              });

            case 43:
              assert.deepEqual(this.site_controller.get('model'), {
                id: 's-1'
              });
              assert.deepEqual(this.article_controller.get('model'), {
                id: 'a-3'
              });
              assert.equal(this.site_controller.get('country'), 'au');
              assert.equal(this.article_controller.get('q'), 'hay');
              assert.equal(this.article_controller.get('z'), 0);
              assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
              assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol');
              assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=hay');
              assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1');
              assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?q=lol');
              assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?q=hay');
              assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
              assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol');
              assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?q=hay');
              this.expectedSiteModelHookParams = {
                site_id: 's-1',
                country: 'au'
              };
              this.expectedArticleModelHookParams = {
                article_id: 'a-2',
                q: 'lol',
                z: 1
              };
              _context9.next = 61;
              return this.transitionTo('site.article', 's-1', 'a-2', {
                queryParams: {
                  z: 1
                }
              });

            case 61:
              assert.deepEqual(this.site_controller.get('model'), {
                id: 's-1'
              });
              assert.deepEqual(this.article_controller.get('model'), {
                id: 'a-2'
              });
              assert.equal(this.site_controller.get('country'), 'au');
              assert.equal(this.article_controller.get('q'), 'lol');
              assert.equal(this.article_controller.get('z'), 1);
              assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
              assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol&z=1');
              assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=hay');
              assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1');
              assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?q=lol&z=1');
              assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?q=hay');
              assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
              assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol&z=1');
              assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?q=hay');
              this.expectedSiteModelHookParams = {
                site_id: 's-2',
                country: 'us'
              };
              this.expectedArticleModelHookParams = {
                article_id: 'a-2',
                q: 'lol',
                z: 1
              };
              _context9.next = 79;
              return this.transitionTo('site.article', 's-2', 'a-2', {
                queryParams: {
                  country: 'us'
                }
              });

            case 79:
              assert.deepEqual(this.site_controller.get('model'), {
                id: 's-2'
              });
              assert.deepEqual(this.article_controller.get('model'), {
                id: 'a-2'
              });
              assert.equal(this.site_controller.get('country'), 'us');
              assert.equal(this.article_controller.get('q'), 'lol');
              assert.equal(this.article_controller.get('z'), 1);
              assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1');
              assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol&z=1');
              assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=hay');
              assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us');
              assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol&z=1');
              assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us&q=hay');
              assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1');
              assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol&z=1');
              assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?q=hay');
              this.expectedSiteModelHookParams = {
                site_id: 's-2',
                country: 'us'
              };
              this.expectedArticleModelHookParams = {
                article_id: 'a-1',
                q: 'yeah',
                z: 0
              };
              _context9.next = 97;
              return this.transitionTo('site.article', 's-2', 'a-1', {
                queryParams: {
                  q: 'yeah'
                }
              });

            case 97:
              assert.deepEqual(this.site_controller.get('model'), {
                id: 's-2'
              });
              assert.deepEqual(this.article_controller.get('model'), {
                id: 'a-1'
              });
              assert.equal(this.site_controller.get('country'), 'us');
              assert.equal(this.article_controller.get('q'), 'yeah');
              assert.equal(this.article_controller.get('z'), 0);
              assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=yeah');
              assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol&z=1');
              assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=hay');
              assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=yeah');
              assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol&z=1');
              assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us&q=hay');
              assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?q=yeah');
              assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?q=lol&z=1');
              assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?q=hay');
              this.expectedSiteModelHookParams = {
                site_id: 's-3',
                country: 'nz'
              };
              this.expectedArticleModelHookParams = {
                article_id: 'a-3',
                q: 'hay',
                z: 3
              };
              _context9.next = 115;
              return this.transitionTo('site.article', 's-3', 'a-3', {
                queryParams: {
                  country: 'nz',
                  z: 3
                }
              });

            case 115:
              assert.deepEqual(this.site_controller.get('model'), {
                id: 's-3'
              });
              assert.deepEqual(this.article_controller.get('model'), {
                id: 'a-3'
              });
              assert.equal(this.site_controller.get('country'), 'nz');
              assert.equal(this.article_controller.get('q'), 'hay');
              assert.equal(this.article_controller.get('z'), 3);
              assert.equal(this.links['s-1-a-1'].getAttribute('href'), '/site/s-1/a/a-1?q=yeah');
              assert.equal(this.links['s-1-a-2'].getAttribute('href'), '/site/s-1/a/a-2?q=lol&z=1');
              assert.equal(this.links['s-1-a-3'].getAttribute('href'), '/site/s-1/a/a-3?q=hay&z=3');
              assert.equal(this.links['s-2-a-1'].getAttribute('href'), '/site/s-2/a/a-1?country=us&q=yeah');
              assert.equal(this.links['s-2-a-2'].getAttribute('href'), '/site/s-2/a/a-2?country=us&q=lol&z=1');
              assert.equal(this.links['s-2-a-3'].getAttribute('href'), '/site/s-2/a/a-3?country=us&q=hay&z=3');
              assert.equal(this.links['s-3-a-1'].getAttribute('href'), '/site/s-3/a/a-1?country=nz&q=yeah');
              assert.equal(this.links['s-3-a-2'].getAttribute('href'), '/site/s-3/a/a-2?country=nz&q=lol&z=1');
              assert.equal(this.links['s-3-a-3'].getAttribute('href'), '/site/s-3/a/a-3?country=nz&q=hay&z=3');

            case 129:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));

      function testQueryParamsHaveModelStickinessByDefaultParamsBasedTransitions(_x14) {
        return _testQueryParamsHaveModelStickinessByDefaultParamsBasedTransitions.apply(this, arguments);
      }

      return testQueryParamsHaveModelStickinessByDefaultParamsBasedTransitions;
    }();

    return _class3;
  }(ModelDependentQPTestCase));
});
enifed("ember/tests/routing/query_params_test/overlapping_query_params_test", ["ember-babel", "@ember/controller", "@ember/-internals/routing", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _controller, _routing, _metal, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('Query Params - overlapping query param property names',
  /*#__PURE__*/
  function (_QueryParamTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _QueryParamTestCase);

    function _class() {
      return _QueryParamTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.setupBase = function setupBase() {
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });
      return this.visit('/parent/child');
    };

    _proto['@test can remap same-named qp props'] =
    /*#__PURE__*/
    function () {
      var _testCanRemapSameNamedQpProps = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var parentController, parentChildController;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              assert.expect(7);
              this.setMappedQPController('parent');
              this.setMappedQPController('parent.child', 'page', 'childPage');
              _context.next = 5;
              return this.setupBase();

            case 5:
              this.assertCurrentPath('/parent/child');
              parentController = this.getController('parent');
              parentChildController = this.getController('parent.child');
              _context.next = 10;
              return this.setAndFlush(parentController, 'page', 2);

            case 10:
              this.assertCurrentPath('/parent/child?parentPage=2');
              _context.next = 13;
              return this.setAndFlush(parentController, 'page', 1);

            case 13:
              this.assertCurrentPath('/parent/child');
              _context.next = 16;
              return this.setAndFlush(parentChildController, 'page', 2);

            case 16:
              this.assertCurrentPath('/parent/child?childPage=2');
              _context.next = 19;
              return this.setAndFlush(parentChildController, 'page', 1);

            case 19:
              this.assertCurrentPath('/parent/child');
              parentController.set('page', 2);
              parentChildController.set('page', 2);
              _context.next = 24;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 24:
              this.assertCurrentPath('/parent/child?childPage=2&parentPage=2');
              parentController.set('page', 1);
              parentChildController.set('page', 1);
              _context.next = 29;
              return (0, _internalTestHelpers.runLoopSettled)();

            case 29:
              this.assertCurrentPath('/parent/child');

            case 30:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testCanRemapSameNamedQpProps(_x) {
        return _testCanRemapSameNamedQpProps.apply(this, arguments);
      }

      return testCanRemapSameNamedQpProps;
    }();

    _proto['@test query params can be either controller property or url key'] =
    /*#__PURE__*/
    function () {
      var _testQueryParamsCanBeEitherControllerPropertyOrUrlKey = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              assert.expect(3);
              this.setMappedQPController('parent');
              _context2.next = 4;
              return this.setupBase();

            case 4:
              this.assertCurrentPath('/parent/child');
              _context2.next = 7;
              return this.transitionTo('parent.child', {
                queryParams: {
                  page: 2
                }
              });

            case 7:
              this.assertCurrentPath('/parent/child?parentPage=2');
              _context2.next = 10;
              return this.transitionTo('parent.child', {
                queryParams: {
                  parentPage: 3
                }
              });

            case 10:
              this.assertCurrentPath('/parent/child?parentPage=3');

            case 11:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testQueryParamsCanBeEitherControllerPropertyOrUrlKey(_x2) {
        return _testQueryParamsCanBeEitherControllerPropertyOrUrlKey.apply(this, arguments);
      }

      return testQueryParamsCanBeEitherControllerPropertyOrUrlKey;
    }();

    _proto['@test query param matching a url key and controller property'] =
    /*#__PURE__*/
    function () {
      var _testQueryParamMatchingAUrlKeyAndControllerProperty = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(assert) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              assert.expect(3);
              this.setMappedQPController('parent', 'page', 'parentPage');
              this.setMappedQPController('parent.child', 'index', 'page');
              _context3.next = 5;
              return this.setupBase();

            case 5:
              _context3.next = 7;
              return this.transitionTo('parent.child', {
                queryParams: {
                  page: 2
                }
              });

            case 7:
              this.assertCurrentPath('/parent/child?parentPage=2');
              _context3.next = 10;
              return this.transitionTo('parent.child', {
                queryParams: {
                  parentPage: 3
                }
              });

            case 10:
              this.assertCurrentPath('/parent/child?parentPage=3');
              _context3.next = 13;
              return this.transitionTo('parent.child', {
                queryParams: {
                  index: 2,
                  page: 2
                }
              });

            case 13:
              this.assertCurrentPath('/parent/child?page=2&parentPage=2');

            case 14:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function testQueryParamMatchingAUrlKeyAndControllerProperty(_x3) {
        return _testQueryParamMatchingAUrlKeyAndControllerProperty.apply(this, arguments);
      }

      return testQueryParamMatchingAUrlKeyAndControllerProperty;
    }();

    _proto['@test query param matching same property on two controllers use the urlKey higher in the chain'] =
    /*#__PURE__*/
    function () {
      var _testQueryParamMatchingSamePropertyOnTwoControllersUseTheUrlKeyHigherInTheChain = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(assert) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              assert.expect(4);
              this.setMappedQPController('parent', 'page', 'parentPage');
              this.setMappedQPController('parent.child', 'page', 'childPage');
              _context4.next = 5;
              return this.setupBase();

            case 5:
              _context4.next = 7;
              return this.transitionTo('parent.child', {
                queryParams: {
                  page: 2
                }
              });

            case 7:
              this.assertCurrentPath('/parent/child?parentPage=2');
              _context4.next = 10;
              return this.transitionTo('parent.child', {
                queryParams: {
                  parentPage: 3
                }
              });

            case 10:
              this.assertCurrentPath('/parent/child?parentPage=3');
              _context4.next = 13;
              return this.transitionTo('parent.child', {
                queryParams: {
                  childPage: 2,
                  page: 2
                }
              });

            case 13:
              this.assertCurrentPath('/parent/child?childPage=2&parentPage=2');
              _context4.next = 16;
              return this.transitionTo('parent.child', {
                queryParams: {
                  childPage: 3,
                  parentPage: 4
                }
              });

            case 16:
              this.assertCurrentPath('/parent/child?childPage=3&parentPage=4');

            case 17:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));

      function testQueryParamMatchingSamePropertyOnTwoControllersUseTheUrlKeyHigherInTheChain(_x4) {
        return _testQueryParamMatchingSamePropertyOnTwoControllersUseTheUrlKeyHigherInTheChain.apply(this, arguments);
      }

      return testQueryParamMatchingSamePropertyOnTwoControllersUseTheUrlKeyHigherInTheChain;
    }();

    _proto['@test query params does not error when a query parameter exists for route instances that share a controller'] =
    /*#__PURE__*/
    function () {
      var _testQueryParamsDoesNotErrorWhenAQueryParameterExistsForRouteInstancesThatShareAController = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(assert) {
        var parentController;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              assert.expect(1);
              parentController = _controller.default.extend({
                queryParams: {
                  page: 'page'
                }
              });
              this.add('controller:parent', parentController);
              this.add('route:parent.child', _routing.Route.extend({
                controllerName: 'parent'
              }));
              _context5.next = 6;
              return this.setupBase('/parent');

            case 6:
              _context5.next = 8;
              return this.transitionTo('parent.child', {
                queryParams: {
                  page: 2
                }
              });

            case 8:
              this.assertCurrentPath('/parent/child?page=2');

            case 9:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));

      function testQueryParamsDoesNotErrorWhenAQueryParameterExistsForRouteInstancesThatShareAController(_x5) {
        return _testQueryParamsDoesNotErrorWhenAQueryParameterExistsForRouteInstancesThatShareAController.apply(this, arguments);
      }

      return testQueryParamsDoesNotErrorWhenAQueryParameterExistsForRouteInstancesThatShareAController;
    }();

    _proto['@test query params in the same route hierarchy with the same url key get auto-scoped'] =
    /*#__PURE__*/
    function () {
      var _testQueryParamsInTheSameRouteHierarchyWithTheSameUrlKeyGetAutoScoped = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(assert) {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              assert.expect(1);
              this.setMappedQPController('parent');
              this.setMappedQPController('parent.child');
              _context6.next = 5;
              return assert.rejectsAssertion(this.setupBase(), "You're not allowed to have more than one controller property map to the same query param key, but both `parent:page` and `parent.child:page` map to `parentPage`. You can fix this by mapping one of the controller properties to a different query param key via the `as` config option, e.g. `page: { as: 'other-page' }`");

            case 5:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));

      function testQueryParamsInTheSameRouteHierarchyWithTheSameUrlKeyGetAutoScoped(_x6) {
        return _testQueryParamsInTheSameRouteHierarchyWithTheSameUrlKeyGetAutoScoped.apply(this, arguments);
      }

      return testQueryParamsInTheSameRouteHierarchyWithTheSameUrlKeyGetAutoScoped;
    }();

    _proto['@test Support shared but overridable mixin pattern'] =
    /*#__PURE__*/
    function () {
      var _testSupportSharedButOverridableMixinPattern = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(assert) {
        var HasPage, parentController, parentChildController;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              assert.expect(7);
              HasPage = _metal.Mixin.create({
                queryParams: 'page',
                page: 1
              });
              this.add('controller:parent', _controller.default.extend(HasPage, {
                queryParams: {
                  page: 'yespage'
                }
              }));
              this.add('controller:parent.child', _controller.default.extend(HasPage));
              _context7.next = 6;
              return this.setupBase();

            case 6:
              this.assertCurrentPath('/parent/child');
              parentController = this.getController('parent');
              parentChildController = this.getController('parent.child');
              _context7.next = 11;
              return this.setAndFlush(parentChildController, 'page', 2);

            case 11:
              this.assertCurrentPath('/parent/child?page=2');
              assert.equal(parentController.get('page'), 1);
              assert.equal(parentChildController.get('page'), 2);
              _context7.next = 16;
              return this.setAndFlush(parentController, 'page', 2);

            case 16:
              this.assertCurrentPath('/parent/child?page=2&yespage=2');
              assert.equal(parentController.get('page'), 2);
              assert.equal(parentChildController.get('page'), 2);

            case 19:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));

      function testSupportSharedButOverridableMixinPattern(_x7) {
        return _testSupportSharedButOverridableMixinPattern.apply(this, arguments);
      }

      return testSupportSharedButOverridableMixinPattern;
    }();

    return _class;
  }(_internalTestHelpers.QueryParamTestCase));
});
enifed("ember/tests/routing/query_params_test/query_param_async_get_handler_test", ["ember-babel", "@ember/-internals/metal", "@ember/-internals/runtime", "@ember/-internals/routing", "internal-test-helpers"], function (_emberBabel, _metal, _runtime, _routing, _internalTestHelpers) {
  "use strict";

  // These tests mimic what happens with lazily loaded Engines.
  (0, _internalTestHelpers.moduleFor)('Query Params - async get handler',
  /*#__PURE__*/
  function (_QueryParamTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _QueryParamTestCase);

    function _class() {
      return _QueryParamTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test can render a link to an asynchronously loaded route without fetching the route'] = function testCanRenderALinkToAnAsynchronouslyLoadedRouteWithoutFetchingTheRoute(assert) {
      var _this = this;

      assert.expect(4);
      this.router.map(function () {
        this.route('post', {
          path: '/post/:id'
        });
      });
      this.setSingleQPController('post');

      var setupAppTemplate = function () {
        _this.addTemplate('application', "\n        {{link-to 'Post' 'post' 1337 (query-params foo='bar') class='post-link is-1337'}}\n        {{link-to 'Post' 'post' 7331 (query-params foo='boo') class='post-link is-7331'}}\n        {{outlet}}\n      ");
      };

      setupAppTemplate();
      return this.visitAndAssert('/').then(function () {
        assert.equal(_this.$('.post-link.is-1337').attr('href'), '/post/1337?foo=bar', 'renders correctly with default QP value');
        assert.equal(_this.$('.post-link.is-7331').attr('href'), '/post/7331?foo=boo', 'renders correctly with non-default QP value');
        assert.deepEqual(_this.fetchedHandlers, ['application', 'index'], "only fetched the handlers for the route we're on");
      });
    };

    _proto['@test can transitionTo to an asynchronously loaded route with simple query params'] = function testCanTransitionToToAnAsynchronouslyLoadedRouteWithSimpleQueryParams(assert) {
      var _this2 = this;

      assert.expect(6);
      this.router.map(function () {
        this.route('post', {
          path: '/post/:id'
        });
        this.route('posts');
      });
      this.setSingleQPController('post');
      var postController;
      return this.visitAndAssert('/').then(function () {
        postController = _this2.getController('post');
        return _this2.transitionTo('posts').then(function () {
          _this2.assertCurrentPath('/posts');
        });
      }).then(function () {
        return _this2.transitionTo('post', 1337, {
          queryParams: {
            foo: 'boo'
          }
        }).then(function () {
          assert.equal(postController.get('foo'), 'boo', 'simple QP is correctly set on controller');

          _this2.assertCurrentPath('/post/1337?foo=boo');
        });
      }).then(function () {
        return _this2.transitionTo('post', 1337, {
          queryParams: {
            foo: 'bar'
          }
        }).then(function () {
          assert.equal(postController.get('foo'), 'bar', 'simple QP is correctly set with default value');

          _this2.assertCurrentPath('/post/1337');
        });
      });
    };

    _proto['@test can transitionTo to an asynchronously loaded route with array query params'] = function testCanTransitionToToAnAsynchronouslyLoadedRouteWithArrayQueryParams(assert) {
      var _this3 = this;

      assert.expect(5);
      this.router.map(function () {
        this.route('post', {
          path: '/post/:id'
        });
      });
      this.setSingleQPController('post', 'comments', []);
      var postController;
      return this.visitAndAssert('/').then(function () {
        postController = _this3.getController('post');
        return _this3.transitionTo('post', 1337, {
          queryParams: {
            comments: [1, 2]
          }
        }).then(function () {
          assert.deepEqual(postController.get('comments'), [1, 2], 'array QP is correctly set with default value');

          _this3.assertCurrentPath('/post/1337?comments=%5B1%2C2%5D');
        });
      }).then(function () {
        return _this3.transitionTo('post', 1338).then(function () {
          assert.deepEqual(postController.get('comments'), [], 'array QP is correctly set on controller');

          _this3.assertCurrentPath('/post/1338');
        });
      });
    };

    _proto['@test can transitionTo to an asynchronously loaded route with mapped query params'] = function testCanTransitionToToAnAsynchronouslyLoadedRouteWithMappedQueryParams(assert) {
      var _this4 = this;

      assert.expect(7);
      this.router.map(function () {
        this.route('post', {
          path: '/post/:id'
        }, function () {
          this.route('index', {
            path: '/'
          });
        });
      });
      this.setSingleQPController('post');
      this.setMappedQPController('post.index', 'comment', 'note');
      var postController;
      var postIndexController;
      return this.visitAndAssert('/').then(function () {
        postController = _this4.getController('post');
        postIndexController = _this4.getController('post.index');
        return _this4.transitionTo('post.index', 1337, {
          queryParams: {
            note: 6,
            foo: 'boo'
          }
        }).then(function () {
          assert.equal(postController.get('foo'), 'boo', 'simple QP is correctly set on controller');
          assert.equal(postIndexController.get('comment'), 6, 'mapped QP is correctly set on controller');

          _this4.assertCurrentPath('/post/1337?foo=boo&note=6');
        });
      }).then(function () {
        return _this4.transitionTo('post', 1337, {
          queryParams: {
            foo: 'bar'
          }
        }).then(function () {
          assert.equal(postController.get('foo'), 'bar', 'simple QP is correctly set with default value');
          assert.equal(postIndexController.get('comment'), 6, 'mapped QP retains value scoped to model');

          _this4.assertCurrentPath('/post/1337?note=6');
        });
      });
    };

    _proto['@test can transitionTo with a URL'] = function testCanTransitionToWithAURL(assert) {
      var _this5 = this;

      assert.expect(7);
      this.router.map(function () {
        this.route('post', {
          path: '/post/:id'
        }, function () {
          this.route('index', {
            path: '/'
          });
        });
      });
      this.setSingleQPController('post');
      this.setMappedQPController('post.index', 'comment', 'note');
      var postController;
      var postIndexController;
      return this.visitAndAssert('/').then(function () {
        postController = _this5.getController('post');
        postIndexController = _this5.getController('post.index');
        return _this5.transitionTo('/post/1337?foo=boo&note=6').then(function () {
          assert.equal(postController.get('foo'), 'boo', 'simple QP is correctly deserialized on controller');
          assert.equal(postIndexController.get('comment'), 6, 'mapped QP is correctly deserialized on controller');

          _this5.assertCurrentPath('/post/1337?foo=boo&note=6');
        });
      }).then(function () {
        return _this5.transitionTo('/post/1337?note=6').then(function () {
          assert.equal(postController.get('foo'), 'bar', 'simple QP is correctly deserialized with default value');
          assert.equal(postIndexController.get('comment'), 6, 'mapped QP retains value scoped to model');

          _this5.assertCurrentPath('/post/1337?note=6');
        });
      });
    };

    _proto["@test undefined isn't serialized or deserialized into a string"] = function testUndefinedIsnTSerializedOrDeserializedIntoAString(assert) {
      var _this6 = this;

      assert.expect(4);
      this.router.map(function () {
        this.route('example');
      });
      this.addTemplate('application', "{{link-to 'Example' 'example' (query-params foo=undefined) id='the-link'}}");
      this.setSingleQPController('example', 'foo', undefined, {
        foo: undefined
      });
      this.add('route:example', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            foo: undefined
          });
        }
      }));
      return this.visitAndAssert('/').then(function () {
        assert.equal(_this6.$('#the-link').attr('href'), '/example', 'renders without undefined qp serialized');
        return _this6.transitionTo('example', {
          queryParams: {
            foo: undefined
          }
        }).then(function () {
          _this6.assertCurrentPath('/example');
        });
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "routerOptions",
      get: function () {
        var fetchedHandlers = this.fetchedHandlers = [];
        return {
          location: 'test',
          init: function () {
            this._super.apply(this, arguments);

            this._seenHandlers = Object.create(null);
            this._handlerPromises = Object.create(null);
          },
          setupRouter: function () {
            this._super.apply(this, arguments);

            var handlerPromises = this._handlerPromises,
                seenHandlers = this._seenHandlers;
            var getRoute = this._routerMicrolib.getRoute;

            this._routerMicrolib.getRoute = function (routeName) {
              fetchedHandlers.push(routeName); // Cache the returns so we don't have more than one Promise for a
              // given handler.

              return handlerPromises[routeName] || (handlerPromises[routeName] = new _runtime.RSVP.Promise(function (resolve) {
                setTimeout(function () {
                  var handler = getRoute(routeName);
                  seenHandlers[routeName] = handler;
                  resolve(handler);
                }, 10);
              }));
            };
          },
          _getQPMeta: function (routeInfo) {
            var handler = this._seenHandlers[routeInfo.name];

            if (handler) {
              return (0, _metal.get)(handler, '_qp');
            }
          }
        };
      }
    }]);
    return _class;
  }(_internalTestHelpers.QueryParamTestCase));
});
enifed("ember/tests/routing/query_params_test/query_params_paramless_link_to_test", ["ember-babel", "@ember/controller", "internal-test-helpers"], function (_emberBabel, _controller, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Query Params - paramless link-to',
  /*#__PURE__*/
  function (_QueryParamTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _QueryParamTestCase);

    function _class() {
      return _QueryParamTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.testParamlessLinks = function testParamlessLinks(assert, routeName) {
      assert.expect(1);
      this.addTemplate(routeName, "{{link-to 'index' 'index' id='index-link'}}");
      this.add("controller:" + routeName, _controller.default.extend({
        queryParams: ['foo'],
        foo: 'wat'
      }));
      return this.visit('/?foo=YEAH').then(function () {
        assert.equal(document.getElementById('index-link').getAttribute('href'), '/?foo=YEAH');
      });
    };

    _proto["@test param-less links in an app booted with query params in the URL don't reset the query params: application"] = function testParamLessLinksInAnAppBootedWithQueryParamsInTheURLDonTResetTheQueryParamsApplication(assert) {
      return this.testParamlessLinks(assert, 'application');
    };

    _proto["@test param-less links in an app booted with query params in the URL don't reset the query params: index"] = function testParamLessLinksInAnAppBootedWithQueryParamsInTheURLDonTResetTheQueryParamsIndex(assert) {
      return this.testParamlessLinks(assert, 'index');
    };

    return _class;
  }(_internalTestHelpers.QueryParamTestCase));
});
enifed("ember/tests/routing/query_params_test/shared_state_test", ["ember-babel", "@ember/controller", "@ember/service", "@ember/runloop", "internal-test-helpers"], function (_emberBabel, _controller, _service, _runloop, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Query Params - shared service state',
  /*#__PURE__*/
  function (_QueryParamTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _QueryParamTestCase);

    function _class() {
      return _QueryParamTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto.boot = function boot() {
      this.setupApplication();
      return this.visitApplication();
    };

    _proto.setupApplication = function setupApplication() {
      this.router.map(function () {
        this.route('home', {
          path: '/'
        });
        this.route('dashboard');
      });
      this.add('service:filters', _service.default.extend({
        shared: true
      }));
      this.add('controller:home', _controller.default.extend({
        filters: (0, _service.inject)()
      }));
      this.add('controller:dashboard', _controller.default.extend({
        filters: (0, _service.inject)(),
        queryParams: [{
          'filters.shared': 'shared'
        }]
      }));
      this.addTemplate('application', "{{link-to 'Home' 'home' }} <div> {{outlet}} </div>");
      this.addTemplate('home', "{{link-to 'Dashboard' 'dashboard' }}{{input type=\"checkbox\" id='filters-checkbox' checked=(mut filters.shared) }}");
      this.addTemplate('dashboard', "{{link-to 'Home' 'home' }}");
    };

    _proto.visitApplication = function visitApplication() {
      return this.visit('/');
    };

    _proto['@test can modify shared state before transition'] = function testCanModifySharedStateBeforeTransition(assert) {
      var _this = this;

      assert.expect(1);
      return this.boot().then(function () {
        _this.$input = document.getElementById('filters-checkbox'); // click the checkbox once to set filters.shared to false

        (0, _runloop.run)(_this.$input, 'click');
        return _this.visit('/dashboard').then(function () {
          assert.ok(true, 'expecting navigating to dashboard to succeed');
        });
      });
    };

    _proto['@test can modify shared state back to the default value before transition'] = function testCanModifySharedStateBackToTheDefaultValueBeforeTransition(assert) {
      var _this2 = this;

      assert.expect(1);
      return this.boot().then(function () {
        _this2.$input = document.getElementById('filters-checkbox'); // click the checkbox twice to set filters.shared to false and back to true

        (0, _runloop.run)(_this2.$input, 'click');
        (0, _runloop.run)(_this2.$input, 'click');
        return _this2.visit('/dashboard').then(function () {
          assert.ok(true, 'expecting navigating to dashboard to succeed');
        });
      });
    };

    return _class;
  }(_internalTestHelpers.QueryParamTestCase));
});
enifed("ember/tests/routing/router_map_test", ["ember-babel", "internal-test-helpers", "@ember/runloop", "@ember/-internals/routing"], function (_emberBabel, _internalTestHelpers, _runloop, _routing) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router.map',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Router.map returns an Ember Router class'] = function testRouterMapReturnsAnEmberRouterClass(assert) {
      assert.expect(1);
      var ret = this.router.map(function () {
        this.route('hello');
      });
      assert.ok(_routing.Router.detect(ret));
    };

    _proto['@test Router.map can be called multiple times'] = function testRouterMapCanBeCalledMultipleTimes(assert) {
      var _this = this;

      assert.expect(2);
      this.addTemplate('hello', 'Hello!');
      this.addTemplate('goodbye', 'Goodbye!');
      this.router.map(function () {
        this.route('hello');
      });
      this.router.map(function () {
        this.route('goodbye');
      });
      return (0, _runloop.run)(function () {
        return _this.visit('/hello').then(function () {
          _this.assertText('Hello!');
        }).then(function () {
          return _this.visit('/goodbye');
        }).then(function () {
          _this.assertText('Goodbye!');
        });
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/routing/router_service_test/basic_test", ["ember-babel", "@ember/-internals/routing", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _routing, _metal, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router Service - main',
  /*#__PURE__*/
  function (_RouterTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

    function _class() {
      return _RouterTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test RouterService#currentRouteName is correctly set for top level route'] = function testRouterServiceCurrentRouteNameIsCorrectlySetForTopLevelRoute(assert) {
      var _this = this;

      assert.expect(6);
      return this.visit('/').then(function () {
        var currentRoute = _this.routerService.currentRoute;
        var name = currentRoute.name,
            localName = currentRoute.localName,
            params = currentRoute.params,
            paramNames = currentRoute.paramNames,
            queryParams = currentRoute.queryParams;
        assert.equal(name, 'parent.index');
        assert.equal(localName, 'index');
        assert.deepEqual(params, {});
        assert.deepEqual(queryParams, {});
        assert.deepEqual(paramNames, []);
        assert.equal(_this.routerService.get('currentRouteName'), 'parent.index');
      });
    };

    _proto['@test RouterService#currentRouteName is correctly set for child route'] = function testRouterServiceCurrentRouteNameIsCorrectlySetForChildRoute(assert) {
      var _this2 = this;

      assert.expect(6);
      return this.visit('/child').then(function () {
        var currentRoute = _this2.routerService.currentRoute;
        var name = currentRoute.name,
            localName = currentRoute.localName,
            params = currentRoute.params,
            paramNames = currentRoute.paramNames,
            queryParams = currentRoute.queryParams;
        assert.equal(name, 'parent.child');
        assert.equal(localName, 'child');
        assert.deepEqual(params, {});
        assert.deepEqual(queryParams, {});
        assert.deepEqual(paramNames, []);
        assert.equal(_this2.routerService.get('currentRouteName'), 'parent.child');
      });
    };

    _proto['@test RouterService#currentRouteName is correctly set after transition'] = function testRouterServiceCurrentRouteNameIsCorrectlySetAfterTransition(assert) {
      var _this3 = this;

      assert.expect(5);
      return this.visit('/child').then(function () {
        var currentRoute = _this3.routerService.currentRoute;
        var name = currentRoute.name,
            localName = currentRoute.localName;
        assert.equal(name, 'parent.child');
        assert.equal(localName, 'child');
        return _this3.routerService.transitionTo('parent.sister');
      }).then(function () {
        var currentRoute = _this3.routerService.currentRoute;
        var name = currentRoute.name,
            localName = currentRoute.localName;
        assert.equal(name, 'parent.sister');
        assert.equal(localName, 'sister');
        assert.equal(_this3.routerService.get('currentRouteName'), 'parent.sister');
      });
    };

    _proto['@test substates survive aborts GH#17430'] = function testSubstatesSurviveAbortsGH17430(assert) {
      var _this4 = this;

      assert.expect(2);
      this.add("route:parent.child", _routing.Route.extend({
        beforeModel: function (transition) {
          transition.abort();
          this.intermediateTransitionTo('parent.sister');
        }
      }));
      return this.visit('/').then(function () {
        return _this4.routerService.transitionTo('/child');
      }).catch(function (e) {
        assert.equal(_this4.routerService.currentRouteName, 'parent.sister');
        assert.equal(e.message, 'TransitionAborted');
      });
    };

    _proto['@test RouterService#currentRouteName is correctly set on each transition'] = function testRouterServiceCurrentRouteNameIsCorrectlySetOnEachTransition(assert) {
      var _this5 = this;

      assert.expect(9);
      return this.visit('/child').then(function () {
        var currentRoute = _this5.routerService.currentRoute;
        var name = currentRoute.name,
            localName = currentRoute.localName;
        assert.equal(name, 'parent.child');
        assert.equal(localName, 'child');
        assert.equal(_this5.routerService.get('currentRouteName'), 'parent.child');
        return _this5.visit('/sister');
      }).then(function () {
        var currentRoute = _this5.routerService.currentRoute;
        var name = currentRoute.name,
            localName = currentRoute.localName;
        assert.equal(name, 'parent.sister');
        assert.equal(localName, 'sister');
        assert.equal(_this5.routerService.get('currentRouteName'), 'parent.sister');
        return _this5.visit('/brother');
      }).then(function () {
        var currentRoute = _this5.routerService.currentRoute;
        var name = currentRoute.name,
            localName = currentRoute.localName;
        assert.equal(name, 'parent.brother');
        assert.equal(localName, 'brother');
        assert.equal(_this5.routerService.get('currentRouteName'), 'parent.brother');
      });
    };

    _proto['@test RouterService#rootURL is correctly set to the default value'] = function testRouterServiceRootURLIsCorrectlySetToTheDefaultValue(assert) {
      var _this6 = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        assert.equal(_this6.routerService.get('rootURL'), '/');
      });
    };

    _proto['@test RouterService#rootURL is correctly set to a custom value'] = function testRouterServiceRootURLIsCorrectlySetToACustomValue(assert) {
      var _this7 = this;

      assert.expect(1);
      this.add('route:parent.index', _routing.Route.extend({
        init: function () {
          this._super();

          (0, _metal.set)(this._router, 'rootURL', '/homepage');
        }
      }));
      return this.visit('/').then(function () {
        assert.equal(_this7.routerService.get('rootURL'), '/homepage');
      });
    };

    _proto['@test RouterService#location is correctly delegated from router:main'] = function testRouterServiceLocationIsCorrectlyDelegatedFromRouterMain(assert) {
      var _this8 = this;

      assert.expect(2);
      return this.visit('/').then(function () {
        var location = _this8.routerService.get('location');

        assert.ok(location);
        assert.ok(location instanceof _routing.NoneLocation);
      });
    };

    return _class;
  }(_internalTestHelpers.RouterTestCase));
});
enifed("ember/tests/routing/router_service_test/build_routeinfo_metadata_test", ["ember-babel", "internal-test-helpers", "@ember/service", "@ember/-internals/routing"], function (_emberBabel, _internalTestHelpers, _service, _routing) {
  "use strict";

  if (true
  /* EMBER_ROUTING_BUILD_ROUTEINFO_METADATA */
  ) {
      (0, _internalTestHelpers.moduleFor)('buildRouteInfoMetadata',
      /*#__PURE__*/
      function (_RouterTestCase) {
        (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

        function _class() {
          return _RouterTestCase.apply(this, arguments) || this;
        }

        var _proto = _class.prototype;

        _proto['@test basic metadata'] = function testBasicMetadata(assert) {
          assert.expect(4);
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                assert.equal(transition.to.name, 'parent.index');
                assert.equal(transition.to.metadata, 'parent-index-page');
              });
              this.router.on('routeDidChange', function (transition) {
                assert.equal(transition.to.name, 'parent.index');
                assert.equal(transition.to.metadata, 'parent-index-page');
              });
            }
          }));
          this.add("route:parent.index", _routing.Route.extend({
            buildRouteInfoMetadata: function () {
              return 'parent-index-page';
            }
          }));
          return this.visit('/');
        };

        _proto['@test hierarchical metadata'] = function testHierarchicalMetadata(assert) {
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            buildRouteInfoMetadata: function () {
              return 'application-shell';
            },
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                assert.equal(transition.to.name, 'parent.index');
                assert.equal(transition.to.metadata, 'parent-index-page');
                assert.equal(transition.to.parent.name, 'parent');
                assert.equal(transition.to.parent.metadata, 'parent-page');
                assert.equal(transition.to.parent.parent.name, 'application');
                assert.equal(transition.to.parent.parent.metadata, 'application-shell');
              });
              this.router.on('routeDidChange', function (transition) {
                assert.equal(transition.to.name, 'parent.index');
                assert.equal(transition.to.metadata, 'parent-index-page');
                assert.equal(transition.to.parent.name, 'parent');
                assert.equal(transition.to.parent.metadata, 'parent-page');
                assert.equal(transition.to.parent.parent.name, 'application');
                assert.equal(transition.to.parent.parent.metadata, 'application-shell');
              });
            }
          }));
          this.add("route:parent", _routing.Route.extend({
            buildRouteInfoMetadata: function () {
              return 'parent-page';
            }
          }));
          this.add("route:parent.index", _routing.Route.extend({
            buildRouteInfoMetadata: function () {
              return 'parent-index-page';
            }
          }));
          return this.visit('/');
        };

        _proto['@test metadata can be complex objects'] = function testMetadataCanBeComplexObjects(assert) {
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                assert.equal(transition.to.name, 'parent.index');
                assert.equal(transition.to.metadata.name, 'parent-index-page');
                assert.equal(transition.to.metadata.title('PARENT'), 'My Name is PARENT');
              });
              this.router.on('routeDidChange', function (transition) {
                assert.equal(transition.to.name, 'parent.index');
                assert.equal(transition.to.metadata.name, 'parent-index-page');
                assert.equal(transition.to.metadata.title('PARENT'), 'My Name is PARENT');
              });
            }
          }));
          this.add("route:parent", _routing.Route.extend({}));
          this.add("route:parent.index", _routing.Route.extend({
            buildRouteInfoMetadata: function () {
              return {
                name: 'parent-index-page',
                title: function (name) {
                  return "My Name is " + name;
                }
              };
            }
          }));
          return this.visit('/');
        };

        _proto['@test metadata is placed on the `from`'] = function testMetadataIsPlacedOnTheFrom(assert) {
          var _this = this;

          assert.expect(12);
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeWillChange', function (transition) {
                if (transition.to.name === 'parent.index') {
                  assert.equal(transition.to.metadata.name, 'parent-index-page');
                  assert.equal(transition.to.metadata.title('INDEX'), 'My Name is INDEX');
                } else {
                  assert.equal(transition.from.metadata.name, 'parent-index-page');
                  assert.equal(transition.from.metadata.title('INDEX'), 'My Name is INDEX');
                  assert.equal(transition.to.metadata.name, 'parent-child-page');
                  assert.equal(transition.to.metadata.title('CHILD'), 'My Name is CHILD!!');
                }
              });
              this.router.on('routeDidChange', function (transition) {
                if (transition.to.name === 'parent.index') {
                  assert.equal(transition.to.metadata.name, 'parent-index-page');
                  assert.equal(transition.to.metadata.title('INDEX'), 'My Name is INDEX');
                } else {
                  assert.equal(transition.from.metadata.name, 'parent-index-page');
                  assert.equal(transition.from.metadata.title('INDEX'), 'My Name is INDEX');
                  assert.equal(transition.to.metadata.name, 'parent-child-page');
                  assert.equal(transition.to.metadata.title('CHILD'), 'My Name is CHILD!!');
                }
              });
            }
          }));
          this.add("route:parent", _routing.Route.extend({}));
          this.add("route:parent.index", _routing.Route.extend({
            buildRouteInfoMetadata: function () {
              return {
                name: 'parent-index-page',
                title: function (name) {
                  return "My Name is " + name;
                }
              };
            }
          }));
          this.add("route:parent.child", _routing.Route.extend({
            buildRouteInfoMetadata: function () {
              return {
                name: 'parent-child-page',
                title: function (name) {
                  return "My Name is " + name + "!!";
                }
              };
            }
          }));
          return this.visit('/').then(function () {
            return _this.visit('/child');
          });
        };

        _proto['@test can be used with model data from `attributes`'] = function testCanBeUsedWithModelDataFromAttributes(assert) {
          var _this2 = this;

          assert.expect(6);
          this.add("route:application", _routing.Route.extend({
            router: (0, _service.inject)('router'),
            init: function () {
              this._super.apply(this, arguments);

              this.router.on('routeDidChange', function (transition) {
                if (transition.to.name === 'parent.index') {
                  assert.equal(transition.to.metadata.name, 'parent-index-page');
                  assert.equal(transition.to.metadata.title(transition.to.attributes), 'My Name is INDEX');
                } else {
                  assert.equal(transition.from.metadata.name, 'parent-index-page');
                  assert.equal(transition.from.metadata.title(transition.from.attributes), 'My Name is INDEX');
                  assert.equal(transition.to.metadata.name, 'parent-child-page');
                  assert.equal(transition.to.metadata.title(transition.to.attributes), 'My Name is CHILD!!');
                }
              });
            }
          }));
          this.add("route:parent", _routing.Route.extend({}));
          this.add("route:parent.index", _routing.Route.extend({
            model: function () {
              return {
                name: 'INDEX'
              };
            },
            buildRouteInfoMetadata: function () {
              return {
                name: 'parent-index-page',
                title: function (model) {
                  return "My Name is " + model.name;
                }
              };
            }
          }));
          this.add("route:parent.child", _routing.Route.extend({
            model: function () {
              return {
                name: 'CHILD'
              };
            },
            buildRouteInfoMetadata: function () {
              return {
                name: 'parent-child-page',
                title: function (model) {
                  return "My Name is " + model.name + "!!";
                }
              };
            }
          }));
          return this.visit('/').then(function () {
            return _this2.visit('/child');
          });
        };

        return _class;
      }(_internalTestHelpers.RouterTestCase));
    }
});
enifed("ember/tests/routing/router_service_test/currenturl_lifecycle_test", ["ember-babel", "@ember/service", "@ember/object/computed", "@ember/-internals/glimmer", "@ember/-internals/routing", "@ember/-internals/metal", "internal-test-helpers", "@ember/-internals/runtime"], function (_emberBabel, _service, _computed, _glimmer, _routing, _metal, _internalTestHelpers, _runtime) {
  "use strict";

  var results = [];
  var ROUTE_NAMES = ['index', 'child', 'sister', 'brother', 'loading'];

  var InstrumentedRoute = _routing.Route.extend({
    routerService: (0, _service.inject)('router'),
    beforeModel: function () {
      var service = (0, _metal.get)(this, 'routerService');
      results.push([service.get('currentRouteName'), 'beforeModel', service.get('currentURL')]);
    },
    model: function () {
      var service = (0, _metal.get)(this, 'routerService');
      results.push([service.get('currentRouteName'), 'model', service.get('currentURL')]);
      return new _runtime.RSVP.Promise(function (resolve) {
        setTimeout(resolve, 200);
      });
    },
    afterModel: function () {
      var service = (0, _metal.get)(this, 'routerService');
      results.push([service.get('currentRouteName'), 'afterModel', service.get('currentURL')]);
    }
  });

  (0, _internalTestHelpers.moduleFor)('Router Service - currentURL | currentRouteName',
  /*#__PURE__*/
  function (_RouterTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

    function _class() {
      var _this;

      _this = _RouterTestCase.apply(this, arguments) || this;
      results = [];
      ROUTE_NAMES.forEach(function (name) {
        var routeName = "parent." + name;

        _this.add("route:" + routeName, InstrumentedRoute.extend());

        _this.addTemplate(routeName, '{{current-url}}');
      });

      var CurrenURLComponent = _glimmer.Component.extend({
        routerService: (0, _service.inject)('router'),
        currentURL: (0, _computed.readOnly)('routerService.currentURL'),
        currentRouteName: (0, _computed.readOnly)('routerService.currentRouteName'),
        currentRoute: (0, _computed.readOnly)('routerService.currentRoute')
      });

      _this.addComponent('current-url', {
        ComponentClass: CurrenURLComponent,
        template: '{{currentURL}}-{{currentRouteName}}-{{currentRoute.name}}'
      });

      return _this;
    }

    var _proto = _class.prototype;

    _proto['@test RouterService#currentURL is correctly set for top level route'] = function testRouterServiceCurrentURLIsCorrectlySetForTopLevelRoute(assert) {
      var _this2 = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        assert.equal(_this2.routerService.get('currentURL'), '/');
      });
    };

    _proto['@test RouterService#currentURL is correctly set for child route'] = function testRouterServiceCurrentURLIsCorrectlySetForChildRoute(assert) {
      var _this3 = this;

      assert.expect(1);
      return this.visit('/child').then(function () {
        assert.equal(_this3.routerService.get('currentURL'), '/child');
      });
    };

    _proto['@test RouterService#currentURL is correctly set after transition'] = function testRouterServiceCurrentURLIsCorrectlySetAfterTransition(assert) {
      var _this4 = this;

      assert.expect(1);
      return this.visit('/child').then(function () {
        return _this4.routerService.transitionTo('parent.sister');
      }).then(function () {
        assert.equal(_this4.routerService.get('currentURL'), '/sister');
      });
    };

    _proto['@test RouterService#currentURL is correctly set on each transition'] = function testRouterServiceCurrentURLIsCorrectlySetOnEachTransition(assert) {
      var _this5 = this;

      assert.expect(3);
      return this.visit('/child').then(function () {
        assert.equal(_this5.routerService.get('currentURL'), '/child');
        return _this5.visit('/sister');
      }).then(function () {
        assert.equal(_this5.routerService.get('currentURL'), '/sister');
        return _this5.visit('/brother');
      }).then(function () {
        assert.equal(_this5.routerService.get('currentURL'), '/brother');
      });
    };

    _proto['@test RouterService#currentURL is not set during lifecycle hooks'] = function testRouterServiceCurrentURLIsNotSetDuringLifecycleHooks(assert) {
      var _this6 = this;

      assert.expect(2);
      return this.visit('/').then(function () {
        assert.deepEqual(results, [[null, 'beforeModel', null], [null, 'model', null], ['parent.loading', 'afterModel', '/']]);
        results = [];
        return _this6.visit('/child');
      }).then(function () {
        assert.deepEqual(results, [['parent.index', 'beforeModel', '/'], ['parent.index', 'model', '/'], ['parent.loading', 'afterModel', '/child']]);
      });
    };

    _proto['@test RouterService#currentURL is correctly set with component after consecutive visits'] = function testRouterServiceCurrentURLIsCorrectlySetWithComponentAfterConsecutiveVisits(assert) {
      var _this7 = this;

      assert.expect(3);
      return this.visit('/').then(function () {
        _this7.assertText('/-parent.index-parent.index');

        return _this7.visit('/child');
      }).then(function () {
        _this7.assertText('/child-parent.child-parent.child');

        return _this7.visit('/');
      }).then(function () {
        _this7.assertText('/-parent.index-parent.index');
      });
    };

    return _class;
  }(_internalTestHelpers.RouterTestCase));
});
enifed("ember/tests/routing/router_service_test/events_test", ["ember-babel", "internal-test-helpers", "@ember/service", "@ember/-internals/routing", "@ember/runloop"], function (_emberBabel, _internalTestHelpers, _service, _routing, _runloop) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('Router Service - events',
  /*#__PURE__*/
  function (_RouterTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

    function _class() {
      return _RouterTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test initial render'] = function testInitialRender(assert) {
      assert.expect(12);
      this.add("route:application", _routing.Route.extend({
        router: (0, _service.inject)('router'),
        init: function () {
          var _this = this;

          this._super.apply(this, arguments);

          this.router.on('routeWillChange', function (transition) {
            assert.ok(transition);
            assert.equal(transition.from, undefined);
            assert.equal(transition.to.name, 'parent.index');
            assert.equal(transition.to.localName, 'index');
          });
          this.router.on('routeDidChange', function (transition) {
            assert.ok(transition);
            assert.ok(_this.router.currentURL, "has URL " + _this.router.currentURL);
            assert.equal(_this.router.currentURL, '/');
            assert.ok(_this.router.currentRouteName, "has route name " + _this.router.currentRouteName);
            assert.equal(_this.router.currentRouteName, 'parent.index');
            assert.equal(transition.from, undefined);
            assert.equal(transition.to.name, 'parent.index');
            assert.equal(transition.to.localName, 'index');
          });
        }
      }));
      return this.visit('/');
    };

    _proto['@test subsequent visits'] = function testSubsequentVisits(assert) {
      var _this3 = this;

      assert.expect(24);
      var toParent = true;
      this.add("route:application", _routing.Route.extend({
        router: (0, _service.inject)('router'),
        init: function () {
          var _this2 = this;

          this._super.apply(this, arguments);

          this.router.on('routeWillChange', function (transition) {
            if (toParent) {
              assert.equal(_this2.router.currentURL, null, 'starts as null');
              assert.equal(transition.from, undefined);
              assert.equal(transition.to.name, 'parent.child');
              assert.equal(transition.to.localName, 'child');
              assert.equal(transition.to.parent.name, 'parent', 'parent node');
              assert.equal(transition.to.parent.child, transition.to, 'parents child node is the `to`');
              assert.equal(transition.to.parent.parent.name, 'application', 'top level');
              assert.equal(transition.to.parent.parent.parent, null, 'top level');
            } else {
              assert.equal(_this2.router.currentURL, '/child', 'not changed until transition');
              assert.notEqual(transition.from, undefined);
              assert.equal(transition.from.name, 'parent.child');
              assert.equal(transition.from.localName, 'child');
              assert.equal(transition.to.localName, 'sister');
              assert.equal(transition.to.name, 'parent.sister');
            }
          });
          this.router.on('routeDidChange', function (transition) {
            if (toParent) {
              assert.equal(_this2.router.currentURL, '/child');
              assert.equal(transition.from, undefined);
              assert.equal(transition.to.name, 'parent.child');
              assert.equal(transition.to.localName, 'child');
            } else {
              assert.equal(_this2.router.currentURL, '/sister');
              assert.notEqual(transition.from, undefined);
              assert.equal(transition.from.name, 'parent.child');
              assert.equal(transition.from.localName, 'child');
              assert.equal(transition.to.localName, 'sister');
              assert.equal(transition.to.name, 'parent.sister');
            }
          });
        }
      }));
      return this.visit('/child').then(function () {
        toParent = false;
        return _this3.routerService.transitionTo('parent.sister');
      });
    };

    _proto['@test transitions can be retried async'] = function testTransitionsCanBeRetriedAsync(assert) {
      var _this4 = this;

      var done = assert.async();
      this.add("route:parent.child", _routing.Route.extend({
        actions: {
          willTransition: function (transition) {
            transition.abort();
            this.intermediateTransitionTo('parent.sister');
            (0, _runloop.later)(function () {
              transition.retry();
              done();
            }, 500);
          }
        }
      }));
      return this.visit('/child').then(function () {
        return _this4.visit('/');
      }).catch(function (e) {
        assert.equal(e.message, 'TransitionAborted');
      });
    };

    _proto['@test redirection with `transitionTo`'] = function testRedirectionWithTransitionTo(assert) {
      assert.expect(8);
      var toChild = false;
      var toSister = false;
      this.add("route:parent", _routing.Route.extend({
        model: function () {
          this.transitionTo('parent.child');
        }
      }));
      this.add("route:parent.child", _routing.Route.extend({
        model: function () {
          this.transitionTo('parent.sister');
        }
      }));
      this.add("route:application", _routing.Route.extend({
        router: (0, _service.inject)('router'),
        init: function () {
          this._super.apply(this, arguments);

          this.router.on('routeWillChange', function (transition) {
            assert.equal(transition.from, undefined, 'initial');

            if (toChild) {
              if (toSister) {
                assert.equal(transition.to.name, 'parent.sister', 'going to /sister');
              } else {
                assert.equal(transition.to.name, 'parent.child', 'going to /child');
                toSister = true;
              }
            } else {
              // Going to `/`
              assert.equal(transition.to.name, 'parent.index', 'going to /');
              toChild = true;
            }
          });
          this.router.on('routeDidChange', function (transition) {
            assert.equal(transition.from, undefined, 'initial');
            assert.equal(transition.to.name, 'parent.sister', 'landed on /sister');
          });
        }
      }));
      return this.visit('/');
    };

    _proto['@test redirection with `replaceWith`'] = function testRedirectionWithReplaceWith(assert) {
      assert.expect(8);
      var toChild = false;
      var toSister = false;
      this.add("route:parent", _routing.Route.extend({
        model: function () {
          this.replaceWith('parent.child');
        }
      }));
      this.add("route:parent.child", _routing.Route.extend({
        model: function () {
          this.replaceWith('parent.sister');
        }
      }));
      this.add("route:application", _routing.Route.extend({
        router: (0, _service.inject)('router'),
        init: function () {
          this._super.apply(this, arguments);

          this.router.on('routeWillChange', function (transition) {
            assert.equal(transition.from, undefined, 'initial');

            if (toChild) {
              if (toSister) {
                assert.equal(transition.to.name, 'parent.sister', 'going to /sister');
              } else {
                assert.equal(transition.to.name, 'parent.child', 'going to /child');
                toSister = true;
              }
            } else {
              // Going to `/`
              assert.equal(transition.to.name, 'parent.index', 'going to /');
              toChild = true;
            }
          });
          this.router.on('routeDidChange', function (transition) {
            assert.equal(transition.from, undefined, 'initial');
            assert.equal(transition.to.name, 'parent.sister', 'landed on /sister');
          });
        }
      }));
      return this.visit('/');
    };

    _proto['@test nested redirection with `transitionTo`'] = function testNestedRedirectionWithTransitionTo(assert) {
      var _this5 = this;

      assert.expect(11);
      var toChild = false;
      var toSister = false;
      this.add("route:parent.child", _routing.Route.extend({
        model: function () {
          this.transitionTo('parent.sister');
        }
      }));
      this.add("route:application", _routing.Route.extend({
        router: (0, _service.inject)('router'),
        init: function () {
          this._super.apply(this, arguments);

          this.router.on('routeWillChange', function (transition) {
            if (toChild) {
              assert.equal(transition.from.name, 'parent.index');

              if (toSister) {
                assert.equal(transition.to.name, 'parent.sister', 'going to /sister');
              } else {
                assert.equal(transition.to.name, 'parent.child', 'going to /child');
                toSister = true;
              }
            } else {
              // Going to `/`
              assert.equal(transition.to.name, 'parent.index', 'going to /');
              assert.equal(transition.from, undefined, 'initial');
            }
          });
          this.router.on('routeDidChange', function (transition) {
            if (toSister) {
              assert.equal(transition.from.name, 'parent.index', 'initial');
              assert.equal(transition.to.name, 'parent.sister', 'landed on /sister');
            } else {
              assert.equal(transition.from, undefined, 'initial');
              assert.equal(transition.to.name, 'parent.index', 'landed on /');
            }
          });
        }
      }));
      return this.visit('/').then(function () {
        toChild = true;
        return _this5.routerService.transitionTo('/child').catch(function (e) {
          assert.equal(e.name, 'TransitionAborted', 'Transition aborted');
        });
      });
    };

    _proto['@test nested redirection with `replaceWith`'] = function testNestedRedirectionWithReplaceWith(assert) {
      var _this6 = this;

      assert.expect(11);
      var toChild = false;
      var toSister = false;
      this.add("route:parent.child", _routing.Route.extend({
        model: function () {
          this.replaceWith('parent.sister');
        }
      }));
      this.add("route:application", _routing.Route.extend({
        router: (0, _service.inject)('router'),
        init: function () {
          this._super.apply(this, arguments);

          this.router.on('routeWillChange', function (transition) {
            if (toChild) {
              assert.equal(transition.from.name, 'parent.index');

              if (toSister) {
                assert.equal(transition.to.name, 'parent.sister', 'going to /sister');
              } else {
                assert.equal(transition.to.name, 'parent.child', 'going to /child');
                toSister = true;
              }
            } else {
              // Going to `/`
              assert.equal(transition.to.name, 'parent.index', 'going to /');
              assert.equal(transition.from, undefined, 'initial');
            }
          });
          this.router.on('routeDidChange', function (transition) {
            if (toSister) {
              assert.equal(transition.from.name, 'parent.index', 'initial');
              assert.equal(transition.to.name, 'parent.sister', 'landed on /sister');
            } else {
              assert.equal(transition.from, undefined, 'initial');
              assert.equal(transition.to.name, 'parent.index', 'landed on /');
            }
          });
        }
      }));
      return this.visit('/').then(function () {
        toChild = true;
        return _this6.routerService.transitionTo('/child').catch(function (e) {
          assert.equal(e.name, 'TransitionAborted', 'Transition aborted');
        });
      });
    };

    _proto['@test aborted transition'] = function testAbortedTransition(assert) {
      var _this7 = this;

      assert.expect(11);
      var didAbort = false;
      var toChild = false;
      this.add("route:parent.child", _routing.Route.extend({
        model: function (_model, transition) {
          didAbort = true;
          transition.abort();
        }
      }));
      this.add("route:application", _routing.Route.extend({
        router: (0, _service.inject)('router'),
        init: function () {
          this._super.apply(this, arguments);

          this.router.on('routeWillChange', function (transition) {
            if (didAbort) {
              assert.equal(transition.to.name, 'parent.index', 'transition aborted');
              assert.equal(transition.from.name, 'parent.index', 'transition aborted');
            } else if (toChild) {
              assert.equal(transition.from.name, 'parent.index', 'from /');
              assert.equal(transition.to.name, 'parent.child', 'to /child');
            } else {
              assert.equal(transition.to.name, 'parent.index', 'going to /');
              assert.equal(transition.from, undefined, 'initial');
            }
          });
          this.router.on('routeDidChange', function (transition) {
            if (didAbort) {
              assert.equal(transition.to.name, 'parent.index', 'landed on /');
              assert.equal(transition.from.name, 'parent.index', 'initial');
            } else {
              assert.equal(transition.to.name, 'parent.index', 'transition aborted');
              assert.equal(transition.from, undefined, 'transition aborted');
            }
          });
        }
      }));
      return this.visit('/').then(function () {
        toChild = true;
        return _this7.routerService.transitionTo('/child').catch(function (e) {
          assert.equal(e.name, 'TransitionAborted', 'Transition aborted');
        });
      });
    };

    _proto['@test query param transitions'] = function testQueryParamTransitions(assert) {
      var _this8 = this;

      assert.expect(15);
      var initial = true;
      var addQP = false;
      var removeQP = false;
      this.add("route:application", _routing.Route.extend({
        router: (0, _service.inject)('router'),
        init: function () {
          this._super.apply(this, arguments);

          this.router.on('routeWillChange', function (transition) {
            assert.equal(transition.to.name, 'parent.index');

            if (initial) {
              assert.equal(transition.from, null);
              assert.deepEqual(transition.to.queryParams, {
                a: 'true'
              });
            } else if (addQP) {
              assert.deepEqual(transition.from.queryParams, {
                a: 'true'
              });
              assert.deepEqual(transition.to.queryParams, {
                a: 'false',
                b: 'b'
              });
            } else if (removeQP) {
              assert.deepEqual(transition.from.queryParams, {
                a: 'false',
                b: 'b'
              });
              assert.deepEqual(transition.to.queryParams, {
                a: 'false'
              });
            } else {
              assert.ok(false, 'never');
            }
          });
          this.router.on('routeDidChange', function (transition) {
            if (initial) {
              assert.equal(transition.from, null);
              assert.deepEqual(transition.to.queryParams, {
                a: 'true'
              });
            } else if (addQP) {
              assert.deepEqual(transition.from.queryParams, {
                a: 'true'
              });
              assert.deepEqual(transition.to.queryParams, {
                a: 'false',
                b: 'b'
              });
            } else if (removeQP) {
              assert.deepEqual(transition.from.queryParams, {
                a: 'false',
                b: 'b'
              });
              assert.deepEqual(transition.to.queryParams, {
                a: 'false'
              });
            } else {
              assert.ok(false, 'never');
            }
          });
        }
      }));
      return this.visit('/?a=true').then(function () {
        addQP = true;
        initial = false;
        return _this8.routerService.transitionTo('/?a=false&b=b');
      }).then(function () {
        removeQP = true;
        addQP = false;
        return _this8.routerService.transitionTo('/?a=false');
      });
    };

    _proto['@test query param redirects with `transitionTo`'] = function testQueryParamRedirectsWithTransitionTo(assert) {
      assert.expect(6);
      var toSister = false;
      this.add("route:parent.child", _routing.Route.extend({
        model: function () {
          toSister = true;
          this.transitionTo('/sister?a=a');
        }
      }));
      this.add("route:application", _routing.Route.extend({
        router: (0, _service.inject)('router'),
        init: function () {
          this._super.apply(this, arguments);

          this.router.on('routeWillChange', function (transition) {
            if (toSister) {
              assert.equal(transition.to.name, 'parent.sister');
              assert.deepEqual(transition.to.queryParams, {
                a: 'a'
              });
            } else {
              assert.equal(transition.to.name, 'parent.child');
              assert.deepEqual(transition.to.queryParams, {});
            }
          });
          this.router.on('routeDidChange', function (transition) {
            assert.equal(transition.to.name, 'parent.sister');
            assert.deepEqual(transition.to.queryParams, {
              a: 'a'
            });
          });
        }
      }));
      return this.visit('/child');
    };

    _proto['@test query param redirects with `replaceWith`'] = function testQueryParamRedirectsWithReplaceWith(assert) {
      assert.expect(6);
      var toSister = false;
      this.add("route:parent.child", _routing.Route.extend({
        model: function () {
          toSister = true;
          this.replaceWith('/sister?a=a');
        }
      }));
      this.add("route:application", _routing.Route.extend({
        router: (0, _service.inject)('router'),
        init: function () {
          this._super.apply(this, arguments);

          this.router.on('routeWillChange', function (transition) {
            if (toSister) {
              assert.equal(transition.to.name, 'parent.sister');
              assert.deepEqual(transition.to.queryParams, {
                a: 'a'
              });
            } else {
              assert.equal(transition.to.name, 'parent.child');
              assert.deepEqual(transition.to.queryParams, {});
            }
          });
          this.router.on('routeDidChange', function (transition) {
            assert.equal(transition.to.name, 'parent.sister');
            assert.deepEqual(transition.to.queryParams, {
              a: 'a'
            });
          });
        }
      }));
      return this.visit('/child');
    };

    _proto['@test params'] = function testParams(assert) {
      var _this9 = this;

      assert.expect(14);
      var inital = true;
      this.add('route:dynamic', _routing.Route.extend({
        model: function (params) {
          if (inital) {
            assert.deepEqual(params, {
              dynamic_id: '123'
            });
          } else {
            assert.deepEqual(params, {
              dynamic_id: '1'
            });
          }

          return params;
        }
      }));
      this.add("route:application", _routing.Route.extend({
        router: (0, _service.inject)('router'),
        init: function () {
          this._super.apply(this, arguments);

          this.router.on('routeWillChange', function (transition) {
            assert.equal(transition.to.name, 'dynamic');

            if (inital) {
              assert.deepEqual(transition.to.paramNames, ['dynamic_id']);
              assert.deepEqual(transition.to.params, {
                dynamic_id: '123'
              });
            } else {
              assert.deepEqual(transition.to.paramNames, ['dynamic_id']);
              assert.deepEqual(transition.to.params, {
                dynamic_id: '1'
              });
            }
          });
          this.router.on('routeDidChange', function (transition) {
            assert.equal(transition.to.name, 'dynamic');
            assert.deepEqual(transition.to.paramNames, ['dynamic_id']);

            if (inital) {
              assert.deepEqual(transition.to.params, {
                dynamic_id: '123'
              });
            } else {
              assert.deepEqual(transition.to.params, {
                dynamic_id: '1'
              });
            }
          });
        }
      }));
      return this.visit('/dynamic/123').then(function () {
        inital = false;
        return _this9.routerService.transitionTo('dynamic', 1);
      });
    };

    _proto['@test nested params'] = function testNestedParams(assert) {
      var _this10 = this;

      assert.expect(30);
      var initial = true;
      this.add('route:dynamicWithChild', _routing.Route.extend({
        model: function (params) {
          if (initial) {
            assert.deepEqual(params, {
              dynamic_id: '123'
            });
          } else {
            assert.deepEqual(params, {
              dynamic_id: '456'
            });
          }

          return params.dynamic_id;
        }
      }));
      this.add('route:dynamicWithChild.child', _routing.Route.extend({
        model: function (params) {
          assert.deepEqual(params, {
            child_id: '456'
          });
          return params.child_id;
        }
      }));
      this.add("route:application", _routing.Route.extend({
        router: (0, _service.inject)('router'),
        init: function () {
          this._super.apply(this, arguments);

          this.router.on('routeWillChange', function (transition) {
            assert.equal(transition.to.name, 'dynamicWithChild.child');
            assert.deepEqual(transition.to.paramNames, ['child_id']);
            assert.deepEqual(transition.to.params, {
              child_id: '456'
            });
            assert.deepEqual(transition.to.parent.paramNames, ['dynamic_id']);

            if (initial) {
              assert.deepEqual(transition.to.parent.params, {
                dynamic_id: '123'
              });
            } else {
              assert.deepEqual(transition.from.attributes, '456');
              assert.deepEqual(transition.from.parent.attributes, '123');
              assert.deepEqual(transition.to.parent.params, {
                dynamic_id: '456'
              });
            }
          });
          this.router.on('routeDidChange', function (transition) {
            assert.equal(transition.to.name, 'dynamicWithChild.child');
            assert.deepEqual(transition.to.paramNames, ['child_id']);
            assert.deepEqual(transition.to.params, {
              child_id: '456'
            });
            assert.deepEqual(transition.to.parent.paramNames, ['dynamic_id']);

            if (initial) {
              assert.deepEqual(transition.to.parent.params, {
                dynamic_id: '123'
              });
            } else {
              assert.deepEqual(transition.from.attributes, '456');
              assert.deepEqual(transition.from.parent.attributes, '123');
              assert.deepEqual(transition.to.attributes, '456');
              assert.deepEqual(transition.to.parent.attributes, '456');
              assert.deepEqual(transition.to.parent.params, {
                dynamic_id: '456'
              });
            }
          });
        }
      }));
      return this.visit('/dynamic-with-child/123/456').then(function () {
        initial = false;
        return _this10.routerService.transitionTo('/dynamic-with-child/456/456');
      });
    };

    return _class;
  }(_internalTestHelpers.RouterTestCase));
  (0, _internalTestHelpers.moduleFor)('Router Service - deprecated events',
  /*#__PURE__*/
  function (_RouterTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _RouterTestCase2);

    function _class2() {
      return _RouterTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test willTransition events are deprecated'] = function testWillTransitionEventsAreDeprecated() {
      var _this11 = this;

      return this.visit('/').then(function () {
        expectDeprecation(function () {
          _this11.routerService['_router'].on('willTransition', function () {});
        }, 'You attempted to listen to the "willTransition" event which is deprecated. Please inject the router service and listen to the "routeWillChange" event.');
      });
    };

    _proto2['@test willTransition events are deprecated on routes'] =
    /*#__PURE__*/
    function () {
      var _testWillTransitionEventsAreDeprecatedOnRoutes = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var _this12;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _this12 = this;
              this.add('route:application', _routing.Route.extend({
                init: function () {
                  this._super.apply(this, arguments);

                  this.on('willTransition', function () {});
                }
              }));
              _context.next = 4;
              return expectDeprecationAsync(function () {
                return _this12.visit('/');
              }, 'You attempted to listen to the "willTransition" event which is deprecated. Please inject the router service and listen to the "routeWillChange" event.');

            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testWillTransitionEventsAreDeprecatedOnRoutes() {
        return _testWillTransitionEventsAreDeprecatedOnRoutes.apply(this, arguments);
      }

      return testWillTransitionEventsAreDeprecatedOnRoutes;
    }();

    _proto2['@test didTransition events are deprecated on routes'] =
    /*#__PURE__*/
    function () {
      var _testDidTransitionEventsAreDeprecatedOnRoutes = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var _this13;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _this13 = this;
              this.add('route:application', _routing.Route.extend({
                init: function () {
                  this._super.apply(this, arguments);

                  this.on('didTransition', function () {});
                }
              }));
              _context2.next = 4;
              return expectDeprecationAsync(function () {
                return _this13.visit('/');
              }, 'You attempted to listen to the "didTransition" event which is deprecated. Please inject the router service and listen to the "routeDidChange" event.');

            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testDidTransitionEventsAreDeprecatedOnRoutes() {
        return _testDidTransitionEventsAreDeprecatedOnRoutes.apply(this, arguments);
      }

      return testDidTransitionEventsAreDeprecatedOnRoutes;
    }();

    _proto2['@test other events are not deprecated on routes'] = function testOtherEventsAreNotDeprecatedOnRoutes() {
      var _this14 = this;

      this.add('route:application', _routing.Route.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.on('fixx', function () {});
        }
      }));
      expectNoDeprecation(function () {
        return _this14.visit('/');
      });
    };

    _proto2['@test didTransition events are deprecated'] = function testDidTransitionEventsAreDeprecated() {
      var _this15 = this;

      return this.visit('/').then(function () {
        expectDeprecation(function () {
          _this15.routerService['_router'].on('didTransition', function () {});
        }, 'You attempted to listen to the "didTransition" event which is deprecated. Please inject the router service and listen to the "routeDidChange" event.');
      });
    };

    _proto2['@test other events are not deprecated'] = function testOtherEventsAreNotDeprecated() {
      var _this16 = this;

      return this.visit('/').then(function () {
        expectNoDeprecation(function () {
          _this16.routerService['_router'].on('wat', function () {});
        });
      });
    };

    return _class2;
  }(_internalTestHelpers.RouterTestCase));
  (0, _internalTestHelpers.moduleFor)('Router Service: deprecated willTransition hook',
  /*#__PURE__*/
  function (_RouterTestCase3) {
    (0, _emberBabel.inheritsLoose)(_class3, _RouterTestCase3);

    function _class3() {
      return _RouterTestCase3.apply(this, arguments) || this;
    }

    var _proto3 = _class3.prototype;

    _proto3['@test willTransition hook is deprecated'] =
    /*#__PURE__*/
    function () {
      var _testWillTransitionHookIsDeprecated = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3() {
        var _this17;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _this17 = this;
              _context3.next = 3;
              return expectDeprecationAsync(function () {
                return _this17.visit('/');
              }, 'You attempted to override the "willTransition" method which is deprecated. Please inject the router service and listen to the "routeWillChange" event.');

            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function testWillTransitionHookIsDeprecated() {
        return _testWillTransitionHookIsDeprecated.apply(this, arguments);
      }

      return testWillTransitionHookIsDeprecated;
    }();

    (0, _emberBabel.createClass)(_class3, [{
      key: "routerOptions",
      get: function () {
        return {
          willTransition: function () {
            this._super.apply(this, arguments); // Overrides

          }
        };
      }
    }]);
    return _class3;
  }(_internalTestHelpers.RouterTestCase));
  (0, _internalTestHelpers.moduleFor)('Router Service: deprecated didTransition hook',
  /*#__PURE__*/
  function (_RouterTestCase4) {
    (0, _emberBabel.inheritsLoose)(_class4, _RouterTestCase4);

    function _class4() {
      return _RouterTestCase4.apply(this, arguments) || this;
    }

    var _proto4 = _class4.prototype;

    _proto4['@test didTransition hook is deprecated'] =
    /*#__PURE__*/
    function () {
      var _testDidTransitionHookIsDeprecated = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4() {
        var _this18;

        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _this18 = this;
              _context4.next = 3;
              return expectDeprecationAsync(function () {
                return _this18.visit('/');
              }, 'You attempted to override the "didTransition" method which is deprecated. Please inject the router service and listen to the "routeDidChange" event.');

            case 3:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));

      function testDidTransitionHookIsDeprecated() {
        return _testDidTransitionHookIsDeprecated.apply(this, arguments);
      }

      return testDidTransitionHookIsDeprecated;
    }();

    (0, _emberBabel.createClass)(_class4, [{
      key: "routerOptions",
      get: function () {
        return {
          didTransition: function () {
            this._super.apply(this, arguments); // Overrides

          }
        };
      }
    }]);
    return _class4;
  }(_internalTestHelpers.RouterTestCase));
});
enifed("ember/tests/routing/router_service_test/isActive_test", ["ember-babel", "@ember/controller", "internal-test-helpers"], function (_emberBabel, _controller, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router Service - isActive',
  /*#__PURE__*/
  function (_RouterTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

    function _class() {
      return _RouterTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test RouterService#isActive returns true for simple route'] = function testRouterServiceIsActiveReturnsTrueForSimpleRoute(assert) {
      var _this = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        return _this.routerService.transitionTo('parent.child');
      }).then(function () {
        return _this.routerService.transitionTo('parent.sister');
      }).then(function () {
        assert.ok(_this.routerService.isActive('parent.sister'));
      });
    };

    _proto['@test RouterService#isActive returns true for simple route with dynamic segments'] = function testRouterServiceIsActiveReturnsTrueForSimpleRouteWithDynamicSegments(assert) {
      var _this2 = this;

      assert.expect(1);
      var dynamicModel = {
        id: 1
      };
      return this.visit('/').then(function () {
        return _this2.routerService.transitionTo('dynamic', dynamicModel);
      }).then(function () {
        assert.ok(_this2.routerService.isActive('dynamic', dynamicModel));
      });
    };

    _proto['@test RouterService#isActive does not eagerly instantiate controller for query params'] = function testRouterServiceIsActiveDoesNotEagerlyInstantiateControllerForQueryParams(assert) {
      var _this3 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      this.add('controller:parent.sister', _controller.default.extend({
        queryParams: ['sort'],
        sort: 'ASC',
        init: function () {
          assert.ok(false, 'should never create');

          this._super.apply(this, arguments);
        }
      }));
      return this.visit('/').then(function () {
        return _this3.routerService.transitionTo('parent.brother');
      }).then(function () {
        assert.notOk(_this3.routerService.isActive('parent.sister', queryParams));
      });
    };

    _proto['@test RouterService#isActive is correct for simple route with basic query params'] = function testRouterServiceIsActiveIsCorrectForSimpleRouteWithBasicQueryParams(assert) {
      var _this4 = this;

      assert.expect(2);
      var queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort'],
        sort: 'ASC'
      }));
      return this.visit('/').then(function () {
        return _this4.routerService.transitionTo('parent.child', queryParams);
      }).then(function () {
        assert.ok(_this4.routerService.isActive('parent.child', queryParams));
        assert.notOk(_this4.routerService.isActive('parent.child', _this4.buildQueryParams({
          sort: 'DESC'
        })));
      });
    };

    _proto['@test RouterService#isActive for simple route with array as query params'] = function testRouterServiceIsActiveForSimpleRouteWithArrayAsQueryParams(assert) {
      var _this5 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        sort: ['ascending']
      });
      return this.visit('/').then(function () {
        return _this5.routerService.transitionTo('parent.child', queryParams);
      }).then(function () {
        assert.notOk(_this5.routerService.isActive('parent.child', _this5.buildQueryParams({
          sort: 'descending'
        })));
      });
    };

    return _class;
  }(_internalTestHelpers.RouterTestCase));
});
enifed("ember/tests/routing/router_service_test/recognize_test", ["ember-babel", "internal-test-helpers", "@ember/-internals/routing"], function (_emberBabel, _internalTestHelpers, _routing) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router Service - recognize',
  /*#__PURE__*/
  function (_RouterTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

    function _class() {
      return _RouterTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test returns a RouteInfo for recognized URL'] = function testReturnsARouteInfoForRecognizedURL(assert) {
      var _this = this;

      return this.visit('/').then(function () {
        var routeInfo = _this.routerService.recognize('/dynamic-with-child/123/1?a=b');

        assert.ok(routeInfo);
        var name = routeInfo.name,
            localName = routeInfo.localName,
            parent = routeInfo.parent,
            child = routeInfo.child,
            params = routeInfo.params,
            queryParams = routeInfo.queryParams,
            paramNames = routeInfo.paramNames;
        assert.equal(name, 'dynamicWithChild.child');
        assert.equal(localName, 'child');
        assert.ok(parent);
        assert.equal(parent.name, 'dynamicWithChild');
        assert.notOk(child);
        assert.deepEqual(params, {
          child_id: '1'
        });
        assert.deepEqual(queryParams, {
          a: 'b'
        });
        assert.deepEqual(paramNames, ['child_id']);
      });
    };

    _proto['@test does not transition'] = function testDoesNotTransition(assert) {
      var _this2 = this;

      this.addTemplate('parent', 'Parent');
      this.addTemplate('dynamic-with-child.child', 'Dynamic Child');
      return this.visit('/').then(function () {
        _this2.routerService.recognize('/dynamic-with-child/123/1?a=b');

        _this2.assertText('Parent', 'Did not transition and cause render');

        assert.equal(_this2.routerService.currentURL, '/', 'Did not transition');
      });
    };

    _proto['@test respects the usage of a different rootURL'] = function testRespectsTheUsageOfADifferentRootURL(assert) {
      var _this3 = this;

      this.router.reopen({
        rootURL: '/app/'
      });
      return this.visit('/app').then(function () {
        var routeInfo = _this3.routerService.recognize('/app/child/');

        assert.ok(routeInfo);
        var name = routeInfo.name,
            localName = routeInfo.localName,
            parent = routeInfo.parent;
        assert.equal(name, 'parent.child');
        assert.equal(localName, 'child');
        assert.equal(parent.name, 'parent');
      });
    };

    _proto['@test must include rootURL'] = function testMustIncludeRootURL() {
      var _this4 = this;

      this.addTemplate('parent', 'Parent');
      this.addTemplate('dynamic-with-child.child', 'Dynamic Child');
      this.router.reopen({
        rootURL: '/app/'
      });
      return this.visit('/app').then(function () {
        expectAssertion(function () {
          _this4.routerService.recognize('/dynamic-with-child/123/1?a=b');
        }, 'You must pass a url that begins with the application\'s rootURL "/app/"');
      });
    };

    _proto['@test returns `null` if URL is not recognized'] = function testReturnsNullIfURLIsNotRecognized(assert) {
      var _this5 = this;

      return this.visit('/').then(function () {
        var routeInfo = _this5.routerService.recognize('/foo');

        assert.equal(routeInfo, null);
      });
    };

    return _class;
  }(_internalTestHelpers.RouterTestCase));
  (0, _internalTestHelpers.moduleFor)('Router Service - recognizeAndLoad',
  /*#__PURE__*/
  function (_RouterTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _RouterTestCase2);

    function _class2() {
      return _RouterTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test returns a RouteInfoWithAttributes for recognized URL'] = function testReturnsARouteInfoWithAttributesForRecognizedURL(assert) {
      var _this6 = this;

      this.add('route:dynamicWithChild', _routing.Route.extend({
        model: function (params) {
          return {
            name: 'dynamicWithChild',
            data: params.dynamic_id
          };
        }
      }));
      this.add('route:dynamicWithChild.child', _routing.Route.extend({
        model: function (params) {
          return {
            name: 'dynamicWithChild.child',
            data: params.child_id
          };
        }
      }));
      return this.visit('/').then(function () {
        return _this6.routerService.recognizeAndLoad('/dynamic-with-child/123/1?a=b');
      }).then(function (routeInfoWithAttributes) {
        assert.ok(routeInfoWithAttributes);
        var name = routeInfoWithAttributes.name,
            localName = routeInfoWithAttributes.localName,
            parent = routeInfoWithAttributes.parent,
            attributes = routeInfoWithAttributes.attributes,
            paramNames = routeInfoWithAttributes.paramNames,
            params = routeInfoWithAttributes.params,
            queryParams = routeInfoWithAttributes.queryParams;
        assert.equal(name, 'dynamicWithChild.child');
        assert.equal(localName, 'child');
        assert.equal(parent.name, 'dynamicWithChild');
        assert.deepEqual(params, {
          child_id: '1'
        });
        assert.deepEqual(queryParams, {
          a: 'b'
        });
        assert.deepEqual(paramNames, ['child_id']);
        assert.deepEqual(attributes, {
          name: 'dynamicWithChild.child',
          data: '1'
        });
        assert.deepEqual(parent.attributes, {
          name: 'dynamicWithChild',
          data: '123'
        });
        assert.deepEqual(parent.paramNames, ['dynamic_id']);
        assert.deepEqual(parent.params, {
          dynamic_id: '123'
        });
      });
    };

    _proto2['@test does not transition'] = function testDoesNotTransition(assert) {
      var _this7 = this;

      this.addTemplate('parent', 'Parent{{outlet}}');
      this.addTemplate('parent.child', 'Child');
      this.add('route:parent.child', _routing.Route.extend({
        model: function () {
          return {
            name: 'child',
            data: ['stuff']
          };
        }
      }));
      return this.visit('/').then(function () {
        _this7.routerService.on('routeWillChange', function () {
          return assert.ok(false);
        });

        _this7.routerService.on('routeDidChange', function () {
          return assert.ok(false);
        });

        return _this7.routerService.recognizeAndLoad('/child');
      }).then(function () {
        assert.equal(_this7.routerService.currentURL, '/');

        _this7.assertText('Parent');
      });
    };

    _proto2['@test respects the usage of a different rootURL'] = function testRespectsTheUsageOfADifferentRootURL(assert) {
      var _this8 = this;

      this.router.reopen({
        rootURL: '/app/'
      });
      return this.visit('/app').then(function () {
        return _this8.routerService.recognizeAndLoad('/app/child/');
      }).then(function (routeInfoWithAttributes) {
        assert.ok(routeInfoWithAttributes);
        var name = routeInfoWithAttributes.name,
            localName = routeInfoWithAttributes.localName,
            parent = routeInfoWithAttributes.parent;
        assert.equal(name, 'parent.child');
        assert.equal(localName, 'child');
        assert.equal(parent.name, 'parent');
      });
    };

    _proto2['@test must include rootURL'] = function testMustIncludeRootURL() {
      var _this9 = this;

      this.router.reopen({
        rootURL: '/app/'
      });
      return this.visit('/app').then(function () {
        expectAssertion(function () {
          _this9.routerService.recognizeAndLoad('/dynamic-with-child/123/1?a=b');
        }, 'You must pass a url that begins with the application\'s rootURL "/app/"');
      });
    };

    _proto2['@test rejects if url is not recognized'] = function testRejectsIfUrlIsNotRecognized(assert) {
      var _this10 = this;

      this.addTemplate('parent', 'Parent{{outlet}}');
      this.addTemplate('parent.child', 'Child');
      this.add('route:parent.child', _routing.Route.extend({
        model: function () {
          return {
            name: 'child',
            data: ['stuff']
          };
        }
      }));
      return this.visit('/').then(function () {
        return _this10.routerService.recognizeAndLoad('/foo');
      }).then(function () {
        assert.ok(false, 'never');
      }, function (reason) {
        assert.equal(reason, 'URL /foo was not recognized');
      });
    };

    _proto2['@test rejects if there is an unhandled error'] = function testRejectsIfThereIsAnUnhandledError(assert) {
      var _this11 = this;

      this.addTemplate('parent', 'Parent{{outlet}}');
      this.addTemplate('parent.child', 'Child');
      this.add('route:parent.child', _routing.Route.extend({
        model: function () {
          throw Error('Unhandled');
        }
      }));
      return this.visit('/').then(function () {
        return _this11.routerService.recognizeAndLoad('/child');
      }).then(function () {
        assert.ok(false, 'never');
      }, function (err) {
        assert.equal(err.message, 'Unhandled');
      });
    };

    return _class2;
  }(_internalTestHelpers.RouterTestCase));
});
enifed("ember/tests/routing/router_service_test/replaceWith_test", ["ember-babel", "@ember/-internals/routing", "internal-test-helpers", "router_js", "@ember/controller"], function (_emberBabel, _routing, _internalTestHelpers, _router_js, _controller) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router Service - replaceWith',
  /*#__PURE__*/
  function (_RouterTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

    function _class() {
      var _this;

      _this = _RouterTestCase.apply(this, arguments) || this;
      var testCase = (0, _emberBabel.assertThisInitialized)(_this);
      testCase.state = [];

      _this.add('location:test', _routing.NoneLocation.extend({
        setURL: function (path) {
          testCase.state.push(path);
          this.set('path', path);
        },
        replaceURL: function (path) {
          testCase.state.splice(testCase.state.length - 1, 1, path);
          this.set('path', path);
        }
      }));

      return _this;
    }

    var _proto = _class.prototype;

    _proto['@test RouterService#replaceWith returns a Transition'] = function testRouterServiceReplaceWithReturnsATransition(assert) {
      var _this2 = this;

      assert.expect(1);
      var transition;
      return this.visit('/').then(function () {
        transition = _this2.routerService.replaceWith('parent.child');
        assert.ok(transition instanceof _router_js.InternalTransition);
        return transition;
      });
    };

    _proto['@test RouterService#replaceWith with basic route replaces location'] = function testRouterServiceReplaceWithWithBasicRouteReplacesLocation(assert) {
      var _this3 = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        return _this3.routerService.transitionTo('parent.child');
      }).then(function () {
        return _this3.routerService.transitionTo('parent.sister');
      }).then(function () {
        return _this3.routerService.replaceWith('parent.brother');
      }).then(function () {
        assert.deepEqual(_this3.state, ['/', '/child', '/brother']);
      });
    };

    _proto['@test RouterService#replaceWith with basic route using URLs replaces location'] = function testRouterServiceReplaceWithWithBasicRouteUsingURLsReplacesLocation(assert) {
      var _this4 = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        return _this4.routerService.transitionTo('/child');
      }).then(function () {
        return _this4.routerService.transitionTo('/sister');
      }).then(function () {
        return _this4.routerService.replaceWith('/brother');
      }).then(function () {
        assert.deepEqual(_this4.state, ['/', '/child', '/brother']);
      });
    };

    _proto['@test RouterService#replaceWith transitioning back to previously visited route replaces location'] = function testRouterServiceReplaceWithTransitioningBackToPreviouslyVisitedRouteReplacesLocation(assert) {
      var _this5 = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        return _this5.routerService.transitionTo('parent.child');
      }).then(function () {
        return _this5.routerService.transitionTo('parent.sister');
      }).then(function () {
        return _this5.routerService.transitionTo('parent.brother');
      }).then(function () {
        return _this5.routerService.replaceWith('parent.sister');
      }).then(function () {
        assert.deepEqual(_this5.state, ['/', '/child', '/sister', '/sister']);
      });
    };

    _proto['@test RouterService#replaceWith with basic query params does not remove query param defaults'] = function testRouterServiceReplaceWithWithBasicQueryParamsDoesNotRemoveQueryParamDefaults(assert) {
      var _this6 = this;

      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort'],
        sort: 'ASC'
      }));
      var queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      return this.visit('/').then(function () {
        return _this6.routerService.transitionTo('parent.brother');
      }).then(function () {
        return _this6.routerService.replaceWith('parent.sister');
      }).then(function () {
        return _this6.routerService.replaceWith('parent.child', queryParams);
      }).then(function () {
        assert.deepEqual(_this6.state, ['/', '/child?sort=ASC']);
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "routerOptions",
      get: function () {
        return {
          location: 'test'
        };
      }
    }]);
    return _class;
  }(_internalTestHelpers.RouterTestCase));
});
enifed("ember/tests/routing/router_service_test/transitionTo_test", ["ember-babel", "@ember/service", "@ember/-internals/glimmer", "@ember/-internals/routing", "@ember/controller", "@ember/runloop", "@ember/-internals/metal", "internal-test-helpers", "router_js"], function (_emberBabel, _service, _glimmer, _routing, _controller, _runloop, _metal, _internalTestHelpers, _router_js) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Router Service - transitionTo',
  /*#__PURE__*/
  function (_RouterTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

    function _class() {
      var _this;

      _this = _RouterTestCase.apply(this, arguments) || this;
      var testCase = (0, _emberBabel.assertThisInitialized)(_this);
      testCase.state = [];

      _this.add('location:test', _routing.NoneLocation.extend({
        setURL: function (path) {
          testCase.state.push(path);
          this.set('path', path);
        },
        replaceURL: function (path) {
          testCase.state.splice(testCase.state.length - 1, 1, path);
          this.set('path', path);
        }
      }));

      return _this;
    }

    var _proto = _class.prototype;

    _proto['@test RouterService#transitionTo returns a Transition'] = function testRouterServiceTransitionToReturnsATransition(assert) {
      var _this2 = this;

      assert.expect(1);
      var transition;
      return this.visit('/').then(function () {
        transition = _this2.routerService.transitionTo('parent.child');
        assert.ok(transition instanceof _router_js.InternalTransition);
        return transition;
      });
    };

    _proto['@test RouterService#transitionTo with basic route updates location'] = function testRouterServiceTransitionToWithBasicRouteUpdatesLocation(assert) {
      var _this3 = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        return _this3.routerService.transitionTo('parent.child');
      }).then(function () {
        return _this3.routerService.transitionTo('parent.sister');
      }).then(function () {
        return _this3.routerService.transitionTo('parent.brother');
      }).then(function () {
        assert.deepEqual(_this3.state, ['/', '/child', '/sister', '/brother']);
      });
    };

    _proto['@test RouterService#transitionTo transitioning back to previously visited route updates location'] = function testRouterServiceTransitionToTransitioningBackToPreviouslyVisitedRouteUpdatesLocation(assert) {
      var _this4 = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        return _this4.routerService.transitionTo('parent.child');
      }).then(function () {
        return _this4.routerService.transitionTo('parent.sister');
      }).then(function () {
        return _this4.routerService.transitionTo('parent.brother');
      }).then(function () {
        return _this4.routerService.transitionTo('parent.sister');
      }).then(function () {
        assert.deepEqual(_this4.state, ['/', '/child', '/sister', '/brother', '/sister']);
      });
    };

    _proto['@test RouterService#transitionTo with basic route'] = function testRouterServiceTransitionToWithBasicRoute(assert) {
      var _this5 = this;

      assert.expect(1);
      var componentInstance;
      this.addTemplate('parent.index', '{{foo-bar}}');
      this.addComponent('foo-bar', {
        ComponentClass: _glimmer.Component.extend({
          routerService: (0, _service.inject)('router'),
          init: function () {
            this._super();

            componentInstance = this;
          },
          actions: {
            transitionToSister: function () {
              (0, _metal.get)(this, 'routerService').transitionTo('parent.sister');
            }
          }
        }),
        template: "foo-bar"
      });
      return this.visit('/').then(function () {
        (0, _runloop.run)(function () {
          componentInstance.send('transitionToSister');
        });
        assert.equal(_this5.routerService.get('currentRouteName'), 'parent.sister');
      });
    };

    _proto['@test RouterService#transitionTo with basic route using URL'] = function testRouterServiceTransitionToWithBasicRouteUsingURL(assert) {
      var _this6 = this;

      assert.expect(1);
      var componentInstance;
      this.addTemplate('parent.index', '{{foo-bar}}');
      this.addComponent('foo-bar', {
        ComponentClass: _glimmer.Component.extend({
          routerService: (0, _service.inject)('router'),
          init: function () {
            this._super();

            componentInstance = this;
          },
          actions: {
            transitionToSister: function () {
              (0, _metal.get)(this, 'routerService').transitionTo('/sister');
            }
          }
        }),
        template: "foo-bar"
      });
      return this.visit('/').then(function () {
        (0, _runloop.run)(function () {
          componentInstance.send('transitionToSister');
        });
        assert.equal(_this6.routerService.get('currentRouteName'), 'parent.sister');
      });
    };

    _proto['@test RouterService#transitionTo with dynamic segment'] = function testRouterServiceTransitionToWithDynamicSegment(assert) {
      var _this7 = this;

      assert.expect(3);
      var componentInstance;
      var dynamicModel = {
        id: 1,
        contents: 'much dynamicism'
      };
      this.addTemplate('parent.index', '{{foo-bar}}');
      this.addTemplate('dynamic', '{{model.contents}}');
      this.addComponent('foo-bar', {
        ComponentClass: _glimmer.Component.extend({
          routerService: (0, _service.inject)('router'),
          init: function () {
            this._super();

            componentInstance = this;
          },
          actions: {
            transitionToDynamic: function () {
              (0, _metal.get)(this, 'routerService').transitionTo('dynamic', dynamicModel);
            }
          }
        }),
        template: "foo-bar"
      });
      return this.visit('/').then(function () {
        (0, _runloop.run)(function () {
          componentInstance.send('transitionToDynamic');
        });
        assert.equal(_this7.routerService.get('currentRouteName'), 'dynamic');
        assert.equal(_this7.routerService.get('currentURL'), '/dynamic/1');

        _this7.assertText('much dynamicism');
      });
    };

    _proto['@test RouterService#transitionTo with dynamic segment and model hook'] = function testRouterServiceTransitionToWithDynamicSegmentAndModelHook(assert) {
      var _this8 = this;

      assert.expect(3);
      var componentInstance;
      var dynamicModel = {
        id: 1,
        contents: 'much dynamicism'
      };
      this.add('route:dynamic', _routing.Route.extend({
        model: function () {
          return dynamicModel;
        }
      }));
      this.addTemplate('parent.index', '{{foo-bar}}');
      this.addTemplate('dynamic', '{{model.contents}}');
      this.addComponent('foo-bar', {
        ComponentClass: _glimmer.Component.extend({
          routerService: (0, _service.inject)('router'),
          init: function () {
            this._super();

            componentInstance = this;
          },
          actions: {
            transitionToDynamic: function () {
              (0, _metal.get)(this, 'routerService').transitionTo('dynamic', 1);
            }
          }
        }),
        template: "foo-bar"
      });
      return this.visit('/').then(function () {
        (0, _runloop.run)(function () {
          componentInstance.send('transitionToDynamic');
        });
        assert.equal(_this8.routerService.get('currentRouteName'), 'dynamic');
        assert.equal(_this8.routerService.get('currentURL'), '/dynamic/1');

        _this8.assertText('much dynamicism');
      });
    };

    _proto['@test RouterService#transitionTo with basic query params does not remove query param defaults'] = function testRouterServiceTransitionToWithBasicQueryParamsDoesNotRemoveQueryParamDefaults(assert) {
      var _this9 = this;

      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort'],
        sort: 'ASC'
      }));
      var queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      return this.visit('/').then(function () {
        return _this9.routerService.transitionTo('parent.child', queryParams);
      }).then(function () {
        assert.equal(_this9.routerService.get('currentURL'), '/child?sort=ASC');
      });
    };

    _proto['@test RouterService#transitionTo passing only queryParams works'] = function testRouterServiceTransitionToPassingOnlyQueryParamsWorks(assert) {
      var _this10 = this;

      assert.expect(2);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort']
      }));
      var queryParams = this.buildQueryParams({
        sort: 'DESC'
      });
      return this.visit('/').then(function () {
        return _this10.routerService.transitionTo('parent.child');
      }).then(function () {
        assert.equal(_this10.routerService.get('currentURL'), '/child');
      }).then(function () {
        return _this10.routerService.transitionTo(queryParams);
      }).then(function () {
        assert.equal(_this10.routerService.get('currentURL'), '/child?sort=DESC');
      });
    };

    _proto['@test RouterService#transitionTo with unspecified query params'] = function testRouterServiceTransitionToWithUnspecifiedQueryParams(assert) {
      var _this11 = this;

      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort', 'page', 'category', 'extra'],
        sort: 'ASC',
        page: null,
        category: undefined
      }));
      var queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      return this.visit('/').then(function () {
        return _this11.routerService.transitionTo('parent.child', queryParams);
      }).then(function () {
        assert.equal(_this11.routerService.get('currentURL'), '/child?sort=ASC');
      });
    };

    _proto['@test RouterService#transitionTo with aliased query params uses the original provided key'] = function testRouterServiceTransitionToWithAliasedQueryParamsUsesTheOriginalProvidedKey(assert) {
      var _this12 = this;

      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: {
          cont_sort: 'url_sort'
        },
        cont_sort: 'ASC'
      }));
      var queryParams = this.buildQueryParams({
        url_sort: 'ASC'
      });
      return this.visit('/').then(function () {
        return _this12.routerService.transitionTo('parent.child', queryParams);
      }).then(function () {
        assert.equal(_this12.routerService.get('currentURL'), '/child?url_sort=ASC');
      });
    };

    _proto['@test RouterService#transitionTo with aliased query params uses the original provided key when controller property name'] = function testRouterServiceTransitionToWithAliasedQueryParamsUsesTheOriginalProvidedKeyWhenControllerPropertyName(assert) {
      var _this13 = this;

      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: {
          cont_sort: 'url_sort'
        },
        cont_sort: 'ASC'
      }));
      var queryParams = this.buildQueryParams({
        cont_sort: 'ASC'
      });
      return this.visit('/').then(function () {
        expectAssertion(function () {
          return _this13.routerService.transitionTo('parent.child', queryParams);
        }, 'You passed the `cont_sort` query parameter during a transition into parent.child, please update to url_sort');
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "routerOptions",
      get: function () {
        return {
          location: 'test'
        };
      }
    }]);
    return _class;
  }(_internalTestHelpers.RouterTestCase));
});
enifed("ember/tests/routing/router_service_test/urlFor_test", ["ember-babel", "@ember/controller", "@ember/string", "@ember/-internals/routing", "@ember/-internals/metal", "internal-test-helpers"], function (_emberBabel, _controller, _string, _routing, _metal, _internalTestHelpers) {
  "use strict";

  function setupController(app, name) {
    var controllerName = (0, _string.capitalize)(name) + "Controller";
    Object.defineProperty(app, controllerName, {
      get: function () {
        throw new Error("Generating a URL should not require instantiation of a " + controllerName + ".");
      }
    });
  }

  (0, _internalTestHelpers.moduleFor)('Router Service - urlFor',
  /*#__PURE__*/
  function (_RouterTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _RouterTestCase);

    function _class() {
      return _RouterTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test RouterService#urlFor returns URL for simple route'] = function testRouterServiceUrlForReturnsURLForSimpleRoute(assert) {
      var _this = this;

      assert.expect(1);
      return this.visit('/').then(function () {
        var expectedURL = _this.routerService.urlFor('parent.child');

        assert.equal('/child', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with dynamic segments'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithDynamicSegments(assert) {
      var _this2 = this;

      assert.expect(1);
      setupController(this.application, 'dynamic');
      var dynamicModel = {
        id: 1,
        contents: 'much dynamicism'
      };
      return this.visit('/').then(function () {
        var expectedURL = _this2.routerService.urlFor('dynamic', dynamicModel);

        assert.equal('/dynamic/1', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with basic query params'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithBasicQueryParams(assert) {
      var _this3 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        foo: 'bar'
      });
      return this.visit('/').then(function () {
        var expectedURL = _this3.routerService.urlFor('parent.child', queryParams);

        assert.equal('/child?foo=bar', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with basic query params and default value'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithBasicQueryParamsAndDefaultValue(assert) {
      var _this4 = this;

      assert.expect(1);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort'],
        sort: 'ASC'
      }));
      var queryParams = this.buildQueryParams({
        sort: 'ASC'
      });
      return this.visit('/').then(function () {
        var expectedURL = _this4.routerService.urlFor('parent.child', queryParams);

        assert.equal('/child?sort=ASC', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with basic query params and default value with stickyness'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithBasicQueryParamsAndDefaultValueWithStickyness(assert) {
      var _this5 = this;

      assert.expect(2);
      this.add('controller:parent.child', _controller.default.extend({
        queryParams: ['sort', 'foo'],
        sort: 'ASC'
      }));
      return this.visit('/child/?sort=DESC').then(function () {
        var controller = _this5.applicationInstance.lookup('controller:parent.child');

        assert.equal((0, _metal.get)(controller, 'sort'), 'DESC', 'sticky is set');

        var queryParams = _this5.buildQueryParams({
          foo: 'derp'
        });

        var actual = _this5.routerService.urlFor('parent.child', queryParams);

        assert.equal(actual, '/child?foo=derp', 'does not use "stickiness"');
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with array as query params'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithArrayAsQueryParams(assert) {
      var _this6 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        selectedItems: ['a', 'b', 'c']
      });
      return this.visit('/').then(function () {
        var expectedURL = _this6.routerService.urlFor('parent.child', queryParams);

        assert.equal('/child?selectedItems[]=a&selectedItems[]=b&selectedItems[]=c', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with null query params'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithNullQueryParams(assert) {
      var _this7 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        foo: null
      });
      return this.visit('/').then(function () {
        var expectedURL = _this7.routerService.urlFor('parent.child', queryParams);

        assert.equal('/child', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with undefined query params'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithUndefinedQueryParams(assert) {
      var _this8 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        foo: undefined
      });
      return this.visit('/').then(function () {
        var expectedURL = _this8.routerService.urlFor('parent.child', queryParams);

        assert.equal('/child', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with dynamic segments and basic query params'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithDynamicSegmentsAndBasicQueryParams(assert) {
      var _this9 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        foo: 'bar'
      });
      return this.visit('/').then(function () {
        var expectedURL = _this9.routerService.urlFor('dynamic', {
          id: 1
        }, queryParams);

        assert.equal('/dynamic/1?foo=bar', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with dynamic segments and array as query params'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithDynamicSegmentsAndArrayAsQueryParams(assert) {
      var _this10 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        selectedItems: ['a', 'b', 'c']
      });
      return this.visit('/').then(function () {
        var expectedURL = _this10.routerService.urlFor('dynamic', {
          id: 1
        }, queryParams);

        assert.equal('/dynamic/1?selectedItems[]=a&selectedItems[]=b&selectedItems[]=c', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with dynamic segments and null query params'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithDynamicSegmentsAndNullQueryParams(assert) {
      var _this11 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        foo: null
      });
      return this.visit('/').then(function () {
        var expectedURL = _this11.routerService.urlFor('dynamic', {
          id: 1
        }, queryParams);

        assert.equal('/dynamic/1', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor returns URL for simple route with dynamic segments and undefined query params'] = function testRouterServiceUrlForReturnsURLForSimpleRouteWithDynamicSegmentsAndUndefinedQueryParams(assert) {
      var _this12 = this;

      assert.expect(1);
      var queryParams = this.buildQueryParams({
        foo: undefined
      });
      return this.visit('/').then(function () {
        var expectedURL = _this12.routerService.urlFor('dynamic', {
          id: 1
        }, queryParams);

        assert.equal('/dynamic/1', expectedURL);
      });
    };

    _proto['@test RouterService#urlFor correctly transitions to route via generated path'] = function testRouterServiceUrlForCorrectlyTransitionsToRouteViaGeneratedPath(assert) {
      var _this13 = this;

      assert.expect(1);
      var expectedURL;
      return this.visit('/').then(function () {
        expectedURL = _this13.routerService.urlFor('parent.child');
        return _this13.routerService.transitionTo(expectedURL);
      }).then(function () {
        assert.equal(expectedURL, _this13.routerService.get('currentURL'));
      });
    };

    _proto['@test RouterService#urlFor correctly transitions to route via generated path with dynamic segments'] = function testRouterServiceUrlForCorrectlyTransitionsToRouteViaGeneratedPathWithDynamicSegments(assert) {
      var _this14 = this;

      assert.expect(1);
      var expectedURL;
      var dynamicModel = {
        id: 1
      };
      this.add('route:dynamic', _routing.Route.extend({
        model: function () {
          return dynamicModel;
        }
      }));
      return this.visit('/').then(function () {
        expectedURL = _this14.routerService.urlFor('dynamic', dynamicModel);
        return _this14.routerService.transitionTo(expectedURL);
      }).then(function () {
        assert.equal(expectedURL, _this14.routerService.get('currentURL'));
      });
    };

    _proto['@test RouterService#urlFor correctly transitions to route via generated path with query params'] = function testRouterServiceUrlForCorrectlyTransitionsToRouteViaGeneratedPathWithQueryParams(assert) {
      var _this15 = this;

      assert.expect(1);
      var expectedURL;
      var actualURL;
      var queryParams = this.buildQueryParams({
        foo: 'bar'
      });
      return this.visit('/').then(function () {
        expectedURL = _this15.routerService.urlFor('parent.child', queryParams);
        return _this15.routerService.transitionTo(expectedURL);
      }).then(function () {
        actualURL = _this15.routerService.get('currentURL') + "?foo=bar";
        assert.equal(expectedURL, actualURL);
      });
    };

    _proto['@test RouterService#urlFor correctly transitions to route via generated path with dynamic segments and query params'] = function testRouterServiceUrlForCorrectlyTransitionsToRouteViaGeneratedPathWithDynamicSegmentsAndQueryParams(assert) {
      var _this16 = this;

      assert.expect(1);
      var expectedURL;
      var actualURL;
      var queryParams = this.buildQueryParams({
        foo: 'bar'
      });
      var dynamicModel = {
        id: 1
      };
      this.add('route:dynamic', _routing.Route.extend({
        model: function () {
          return dynamicModel;
        }
      }));
      return this.visit('/').then(function () {
        expectedURL = _this16.routerService.urlFor('dynamic', dynamicModel, queryParams);
        return _this16.routerService.transitionTo(expectedURL);
      }).then(function () {
        actualURL = _this16.routerService.get('currentURL') + "?foo=bar";
        assert.equal(expectedURL, actualURL);
      });
    };

    return _class;
  }(_internalTestHelpers.RouterTestCase));
});
enifed("ember/tests/routing/substates_test", ["ember-babel", "@ember/-internals/runtime", "@ember/-internals/routing", "internal-test-helpers"], function (_emberBabel, _runtime, _routing, _internalTestHelpers) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var counter;

  function step(assert, expectedValue, description) {
    assert.equal(counter, expectedValue, 'Step ' + expectedValue + ': ' + description);
    counter++;
  }

  (0, _internalTestHelpers.moduleFor)('Loading/Error Substates',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.apply(this, arguments) || this;
      counter = 1;

      _this.addTemplate('application', "<div id=\"app\">{{outlet}}</div>");

      _this.addTemplate('index', 'INDEX');

      return _this;
    }

    var _proto = _class.prototype;

    _proto.visit = function visit() {
      var _this2 = this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (0, _internalTestHelpers.runTask)(function () {
        var _ApplicationTestCase$;

        return (_ApplicationTestCase$ = _ApplicationTestCase.prototype.visit).call.apply(_ApplicationTestCase$, [_this2].concat(args));
      });
    };

    _proto.getController = function getController(name) {
      return this.applicationInstance.lookup("controller:" + name);
    };

    _proto['@test Slow promise from a child route of application enters nested loading state'] = function testSlowPromiseFromAChildRouteOfApplicationEntersNestedLoadingState(assert) {
      var _this3 = this;

      var turtleDeferred = _runtime.RSVP.defer();

      this.router.map(function () {
        this.route('turtle');
      });
      this.add('route:application', _routing.Route.extend({
        setupController: function () {
          step(assert, 2, 'ApplicationRoute#setupController');
        }
      }));
      this.add('route:turtle', _routing.Route.extend({
        model: function () {
          step(assert, 1, 'TurtleRoute#model');
          return turtleDeferred.promise;
        }
      }));
      this.addTemplate('turtle', 'TURTLE');
      this.addTemplate('loading', 'LOADING');
      var promise = this.visit('/turtle').then(function () {
        text = _this3.$('#app').text();
        assert.equal(text, 'TURTLE', "turtle template has loaded and replaced the loading template");
      });
      var text = this.$('#app').text();
      assert.equal(text, 'LOADING', "The Loading template is nested in application template's outlet");
      turtleDeferred.resolve();
      return promise;
    };

    _proto["@test Slow promises returned from ApplicationRoute#model don't enter LoadingRoute"] = function (assert) {
      var _this4 = this;

      var appDeferred = _runtime.RSVP.defer();

      this.add('route:application', _routing.Route.extend({
        model: function () {
          return appDeferred.promise;
        }
      }));
      this.add('route:loading', _routing.Route.extend({
        setupController: function () {
          assert.ok(false, "shouldn't get here");
        }
      }));
      var promise = this.visit('/').then(function () {
        var text = _this4.$('#app').text();

        assert.equal(text, 'INDEX', "index template has been rendered");
      });

      if (this.element) {
        assert.equal(this.element.textContent, '');
      }

      appDeferred.resolve();
      return promise;
    };

    _proto["@test Don't enter loading route unless either route or template defined"] = function (assert) {
      var _this5 = this;

      var deferred = _runtime.RSVP.defer();

      this.router.map(function () {
        this.route('dummy');
      });
      this.add('route:dummy', _routing.Route.extend({
        model: function () {
          return deferred.promise;
        }
      }));
      this.addTemplate('dummy', 'DUMMY');
      return this.visit('/').then(function () {
        var promise = _this5.visit('/dummy').then(function () {
          var text = _this5.$('#app').text();

          assert.equal(text, 'DUMMY', "dummy template has been rendered");
        });

        assert.ok(_this5.currentPath !== 'loading', "\n        loading state not entered\n      ");
        deferred.resolve();
        return promise;
      });
    };

    _proto['@test Enter loading route only if loadingRoute is defined'] = function testEnterLoadingRouteOnlyIfLoadingRouteIsDefined(assert) {
      var _this6 = this;

      var deferred = _runtime.RSVP.defer();

      this.router.map(function () {
        this.route('dummy');
      });
      this.add('route:dummy', _routing.Route.extend({
        model: function () {
          step(assert, 1, 'DummyRoute#model');
          return deferred.promise;
        }
      }));
      this.add('route:loading', _routing.Route.extend({
        setupController: function () {
          step(assert, 2, 'LoadingRoute#setupController');
        }
      }));
      this.addTemplate('dummy', 'DUMMY');
      return this.visit('/').then(function () {
        var promise = _this6.visit('/dummy').then(function () {
          var text = _this6.$('#app').text();

          assert.equal(text, 'DUMMY', "dummy template has been rendered");
        });

        assert.equal(_this6.currentPath, 'loading', "loading state entered");
        deferred.resolve();
        return promise;
      });
    };

    _proto['@test Slow promises returned from ApplicationRoute#model enter ApplicationLoadingRoute if present'] = function testSlowPromisesReturnedFromApplicationRouteModelEnterApplicationLoadingRouteIfPresent(assert) {
      var _this7 = this;

      var appDeferred = _runtime.RSVP.defer();

      this.add('route:application', _routing.Route.extend({
        model: function () {
          return appDeferred.promise;
        }
      }));
      var loadingRouteEntered = false;
      this.add('route:application_loading', _routing.Route.extend({
        setupController: function () {
          loadingRouteEntered = true;
        }
      }));
      var promise = this.visit('/').then(function () {
        assert.equal(_this7.$('#app').text(), 'INDEX', 'index route loaded');
      });
      assert.ok(loadingRouteEntered, 'ApplicationLoadingRoute was entered');
      appDeferred.resolve();
      return promise;
    };

    _proto['@test Slow promises returned from ApplicationRoute#model enter application_loading if template present'] = function testSlowPromisesReturnedFromApplicationRouteModelEnterApplication_loadingIfTemplatePresent(assert) {
      var _this8 = this;

      var appDeferred = _runtime.RSVP.defer();

      this.addTemplate('application_loading', "\n      <div id=\"toplevel-loading\">TOPLEVEL LOADING</div>\n    ");
      this.add('route:application', _routing.Route.extend({
        model: function () {
          return appDeferred.promise;
        }
      }));
      var promise = this.visit('/').then(function () {
        var length = _this8.$('#toplevel-loading').length;

        text = _this8.$('#app').text();
        assert.equal(length, 0, "top-level loading view has been entirely removed from the DOM");
        assert.equal(text, 'INDEX', 'index has fully rendered');
      });
      var text = this.$('#toplevel-loading').text();
      assert.equal(text, 'TOPLEVEL LOADING', 'still loading the top level');
      appDeferred.resolve();
      return promise;
    };

    _proto['@test Prioritized substate entry works with preserved-namespace nested routes'] = function testPrioritizedSubstateEntryWorksWithPreservedNamespaceNestedRoutes(assert) {
      var _this9 = this;

      var deferred = _runtime.RSVP.defer();

      this.addTemplate('foo.bar_loading', 'FOOBAR LOADING');
      this.addTemplate('foo.bar.index', 'YAY');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar', {
            path: '/bar'
          }, function () {});
        });
      });
      this.add('route:foo.bar', _routing.Route.extend({
        model: function () {
          return deferred.promise;
        }
      }));
      return this.visit('/').then(function () {
        var promise = _this9.visit('/foo/bar').then(function () {
          text = _this9.$('#app').text();
          assert.equal(text, 'YAY', 'foo.bar.index fully loaded');
        });

        var text = _this9.$('#app').text();

        assert.equal(text, 'FOOBAR LOADING', "foo.bar_loading was entered (as opposed to something like foo/foo/bar_loading)");
        deferred.resolve();
        return promise;
      });
    };

    _proto['@test Prioritized substate entry works with reset-namespace nested routes'] = function testPrioritizedSubstateEntryWorksWithResetNamespaceNestedRoutes(assert) {
      var _this10 = this;

      var deferred = _runtime.RSVP.defer();

      this.addTemplate('bar_loading', 'BAR LOADING');
      this.addTemplate('bar.index', 'YAY');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar', {
            path: '/bar',
            resetNamespace: true
          }, function () {});
        });
      });
      this.add('route:bar', _routing.Route.extend({
        model: function () {
          return deferred.promise;
        }
      }));
      return this.visit('/').then(function () {
        var promise = _this10.visit('/foo/bar').then(function () {
          text = _this10.$('#app').text();
          assert.equal(text, 'YAY', 'bar.index fully loaded');
        });

        var text = _this10.$('#app').text();

        assert.equal(text, 'BAR LOADING', "foo.bar_loading was entered (as opposed to something likefoo/foo/bar_loading)");
        deferred.resolve();
        return promise;
      });
    };

    _proto['@test Prioritized loading substate entry works with preserved-namespace nested routes'] = function testPrioritizedLoadingSubstateEntryWorksWithPreservedNamespaceNestedRoutes(assert) {
      var _this11 = this;

      var deferred = _runtime.RSVP.defer();

      this.addTemplate('foo.bar_loading', 'FOOBAR LOADING');
      this.addTemplate('foo.bar', 'YAY');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar');
        });
      });
      this.add('route:foo.bar', _routing.Route.extend({
        model: function () {
          return deferred.promise;
        }
      }));
      var promise = this.visit('/foo/bar').then(function () {
        text = _this11.$('#app').text();
        assert.equal(text, 'YAY', 'foo.bar has rendered');
      });
      var text = this.$('#app').text();
      assert.equal(text, 'FOOBAR LOADING', "foo.bar_loading was entered (as opposed to something like foo/foo/bar_loading)");
      deferred.resolve();
      return promise;
    };

    _proto['@test Prioritized error substate entry works with preserved-namespaec nested routes'] = function testPrioritizedErrorSubstateEntryWorksWithPreservedNamespaecNestedRoutes(assert) {
      var _this12 = this;

      this.addTemplate('foo.bar_error', 'FOOBAR ERROR: {{model.msg}}');
      this.addTemplate('foo.bar', 'YAY');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar');
        });
      });
      this.add('route:foo.bar', _routing.Route.extend({
        model: function () {
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        }
      }));
      return this.visit('/').then(function () {
        return _this12.visit('/foo/bar').then(function () {
          var text = _this12.$('#app').text();

          assert.equal(text, 'FOOBAR ERROR: did it broke?', "foo.bar_error was entered (as opposed to something like foo/foo/bar_error)");
        });
      });
    };

    _proto['@test Prioritized loading substate entry works with auto-generated index routes'] = function testPrioritizedLoadingSubstateEntryWorksWithAutoGeneratedIndexRoutes(assert) {
      var _this13 = this;

      var deferred = _runtime.RSVP.defer();

      this.addTemplate('foo.index_loading', 'FOO LOADING');
      this.addTemplate('foo.index', 'YAY');
      this.addTemplate('foo', '{{outlet}}');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar');
        });
      });
      this.add('route:foo.index', _routing.Route.extend({
        model: function () {
          return deferred.promise;
        }
      }));
      this.add('route:foo', _routing.Route.extend({
        model: function () {
          return true;
        }
      }));
      var promise = this.visit('/foo').then(function () {
        text = _this13.$('#app').text();
        assert.equal(text, 'YAY', 'foo.index was rendered');
      });
      var text = this.$('#app').text();
      assert.equal(text, 'FOO LOADING', 'foo.index_loading was entered');
      deferred.resolve();
      return promise;
    };

    _proto['@test Prioritized error substate entry works with auto-generated index routes'] = function testPrioritizedErrorSubstateEntryWorksWithAutoGeneratedIndexRoutes(assert) {
      var _this14 = this;

      this.addTemplate('foo.index_error', 'FOO ERROR: {{model.msg}}');
      this.addTemplate('foo.index', 'YAY');
      this.addTemplate('foo', '{{outlet}}');
      this.router.map(function () {
        this.route('foo', function () {
          this.route('bar');
        });
      });
      this.add('route:foo.index', _routing.Route.extend({
        model: function () {
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        }
      }));
      this.add('route:foo', _routing.Route.extend({
        model: function () {
          return true;
        }
      }));
      return this.visit('/').then(function () {
        return _this14.visit('/foo').then(function () {
          var text = _this14.$('#app').text();

          assert.equal(text, 'FOO ERROR: did it broke?', 'foo.index_error was entered');
        });
      });
    };

    _proto['@test Rejected promises returned from ApplicationRoute transition into top-level application_error'] = function testRejectedPromisesReturnedFromApplicationRouteTransitionIntoTopLevelApplication_error(assert) {
      var _this15 = this;

      var reject = true;
      this.addTemplate('index', '<div id="index">INDEX</div>');
      this.add('route:application', _routing.Route.extend({
        init: function () {
          this._super.apply(this, arguments);
        },
        model: function () {
          if (reject) {
            return _runtime.RSVP.reject({
              msg: 'BAD NEWS BEARS'
            });
          } else {
            return {};
          }
        }
      }));
      this.addTemplate('application_error', "\n      <p id=\"toplevel-error\">TOPLEVEL ERROR: {{model.msg}}</p>\n    ");
      return this.visit('/').then(function () {
        var text = _this15.$('#toplevel-error').text();

        assert.equal(text, 'TOPLEVEL ERROR: BAD NEWS BEARS', 'toplevel error rendered');
        reject = false;
      }).then(function () {
        return _this15.visit('/');
      }).then(function () {
        var text = _this15.$('#index').text();

        assert.equal(text, 'INDEX', 'the index route resolved');
      });
    };

    (0, _emberBabel.createClass)(_class, [{
      key: "currentPath",
      get: function () {
        var _this16 = this;

        var currentPath;
        expectDeprecation(function () {
          currentPath = _this16.getController('application').get('currentPath');
        }, 'Accessing `currentPath` on `controller:application` is deprecated, use the `currentPath` property on `service:router` instead.');
        return currentPath;
      }
    }]);
    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Loading/Error Substates - nested routes',
  /*#__PURE__*/
  function (_ApplicationTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase2);

    function _class2() {
      var _this17;

      _this17 = _ApplicationTestCase2.apply(this, arguments) || this;
      counter = 1;

      _this17.addTemplate('application', "<div id=\"app\">{{outlet}}</div>");

      _this17.addTemplate('index', 'INDEX');

      _this17.addTemplate('grandma', 'GRANDMA {{outlet}}');

      _this17.addTemplate('mom', 'MOM');

      _this17.router.map(function () {
        this.route('grandma', function () {
          this.route('mom', {
            resetNamespace: true
          }, function () {
            this.route('sally');
            this.route('this-route-throws');
          });
          this.route('puppies');
        });
        this.route('memere', {
          path: '/memere/:seg'
        }, function () {});
      });

      return _this17;
    }

    var _proto2 = _class2.prototype;

    _proto2.getController = function getController(name) {
      return this.applicationInstance.lookup("controller:" + name);
    };

    _proto2['@test ApplicationRoute#currentPath reflects loading state path'] =
    /*#__PURE__*/
    function () {
      var _testApplicationRouteCurrentPathReflectsLoadingStatePath = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var _this18, momDeferred, promise, text;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _this18 = this;
              _context.next = 3;
              return this.visit('/');

            case 3:
              momDeferred = _runtime.RSVP.defer();
              this.addTemplate('grandma.loading', 'GRANDMALOADING');
              this.add('route:mom', _routing.Route.extend({
                model: function () {
                  return momDeferred.promise;
                }
              }));
              promise = (0, _internalTestHelpers.runTask)(function () {
                return _this18.visit('/grandma/mom');
              }).then(function () {
                text = _this18.$('#app').text();
                assert.equal(text, 'GRANDMA MOM', "Grandma.mom loaded text is displayed");
                assert.equal(_this18.currentPath, 'grandma.mom.index', "currentPath reflects final state");
              });
              text = this.$('#app').text();
              assert.equal(text, 'GRANDMA GRANDMALOADING', "Grandma.mom loading text displayed");
              assert.equal(this.currentPath, 'grandma.loading', "currentPath reflects loading state");
              momDeferred.resolve();
              return _context.abrupt("return", promise);

            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testApplicationRouteCurrentPathReflectsLoadingStatePath(_x) {
        return _testApplicationRouteCurrentPathReflectsLoadingStatePath.apply(this, arguments);
      }

      return testApplicationRouteCurrentPathReflectsLoadingStatePath;
    }();

    _proto2["@test Loading actions bubble to root but don't enter substates above pivot "] =
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        var _this19, sallyDeferred, puppiesDeferred, promise;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _this19 = this;
              _context2.next = 3;
              return this.visit('/');

            case 3:
              sallyDeferred = _runtime.RSVP.defer();
              puppiesDeferred = _runtime.RSVP.defer();
              this.add('route:application', _routing.Route.extend({
                actions: {
                  loading: function () {
                    assert.ok(true, 'loading action received on ApplicationRoute');
                  }
                }
              }));
              this.add('route:mom.sally', _routing.Route.extend({
                model: function () {
                  return sallyDeferred.promise;
                }
              }));
              this.add('route:grandma.puppies', _routing.Route.extend({
                model: function () {
                  return puppiesDeferred.promise;
                }
              }));
              promise = this.visit('/grandma/mom/sally');
              assert.equal(this.currentPath, 'index', 'Initial route fully loaded');
              sallyDeferred.resolve();
              promise.then(function () {
                assert.equal(_this19.currentPath, 'grandma.mom.sally', 'transition completed');

                var visit = _this19.visit('/grandma/puppies');

                assert.equal(_this19.currentPath, 'grandma.mom.sally', 'still in initial state because the only loading state is above the pivot route');
                return visit;
              }).then(function () {
                (0, _internalTestHelpers.runTask)(function () {
                  return puppiesDeferred.resolve();
                });
                assert.equal(_this19.currentPath, 'grandma.puppies', 'Finished transition');
              });
              return _context2.abrupt("return", promise);

            case 13:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      return function (_x2) {
        return _ref.apply(this, arguments);
      };
    }();

    _proto2['@test Default error event moves into nested route'] =
    /*#__PURE__*/
    function () {
      var _testDefaultErrorEventMovesIntoNestedRoute = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(assert) {
        var _this20;

        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _this20 = this;
              _context3.next = 3;
              return this.visit('/');

            case 3:
              this.addTemplate('grandma.error', 'ERROR: {{model.msg}}');
              this.add('route:mom.sally', _routing.Route.extend({
                model: function () {
                  step(assert, 1, 'MomSallyRoute#model');
                  return _runtime.RSVP.reject({
                    msg: 'did it broke?'
                  });
                },
                actions: {
                  error: function () {
                    step(assert, 2, 'MomSallyRoute#actions.error');
                    return true;
                  }
                }
              }));
              return _context3.abrupt("return", this.visit('/grandma/mom/sally').then(function () {
                step(assert, 3, 'App finished loading');

                var text = _this20.$('#app').text();

                assert.equal(text, 'GRANDMA ERROR: did it broke?', 'error bubbles');
                assert.equal(_this20.currentPath, 'grandma.error', 'Initial route fully loaded');
              }));

            case 6:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function testDefaultErrorEventMovesIntoNestedRoute(_x3) {
        return _testDefaultErrorEventMovesIntoNestedRoute.apply(this, arguments);
      }

      return testDefaultErrorEventMovesIntoNestedRoute;
    }();

    _proto2["@test Non-bubbled errors that re-throw aren't swallowed"] =
    /*#__PURE__*/
    function () {
      var _ref2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee4(assert) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.visit('/');

            case 2:
              this.add('route:mom.sally', _routing.Route.extend({
                model: function () {
                  return _runtime.RSVP.reject({
                    msg: 'did it broke?'
                  });
                },
                actions: {
                  error: function (err) {
                    // returns undefined which is falsey
                    throw err;
                  }
                }
              }));
              _context4.next = 5;
              return assert.rejects(this.visit('/grandma/mom/sally'), function (err) {
                return err.msg === 'did it broke?';
              }, 'it broke');

            case 5:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));

      return function (_x4) {
        return _ref2.apply(this, arguments);
      };
    }();

    _proto2["@test Handled errors that re-throw aren't swallowed"] =
    /*#__PURE__*/
    function () {
      var _ref3 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(assert) {
        var handledError;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.visit('/');

            case 2:
              this.add('route:mom.sally', _routing.Route.extend({
                model: function () {
                  step(assert, 1, 'MomSallyRoute#model');
                  return _runtime.RSVP.reject({
                    msg: 'did it broke?'
                  });
                },
                actions: {
                  error: function (err) {
                    step(assert, 2, 'MomSallyRoute#actions.error');
                    handledError = err;
                    this.transitionTo('mom.this-route-throws');
                    return false;
                  }
                }
              }));
              this.add('route:mom.this-route-throws', _routing.Route.extend({
                model: function () {
                  step(assert, 3, 'MomThisRouteThrows#model');
                  throw handledError;
                }
              }));
              _context5.next = 6;
              return assert.rejects(this.visit('/grandma/mom/sally'), function (err) {
                return err.msg === 'did it broke?';
              }, "it broke");

            case 6:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));

      return function (_x5) {
        return _ref3.apply(this, arguments);
      };
    }();

    _proto2['@test errors that are bubbled are thrown at a higher level if not handled'] =
    /*#__PURE__*/
    function () {
      var _testErrorsThatAreBubbledAreThrownAtAHigherLevelIfNotHandled = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee6(assert) {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.visit('/');

            case 2:
              this.add('route:mom.sally', _routing.Route.extend({
                model: function () {
                  step(assert, 1, 'MomSallyRoute#model');
                  return _runtime.RSVP.reject({
                    msg: 'did it broke?'
                  });
                },
                actions: {
                  error: function () {
                    step(assert, 2, 'MomSallyRoute#actions.error');
                    return true;
                  }
                }
              }));
              _context6.next = 5;
              return assert.rejects(this.visit('/grandma/mom/sally'), function (err) {
                return err.msg == 'did it broke?';
              }, 'Correct error was thrown');

            case 5:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));

      function testErrorsThatAreBubbledAreThrownAtAHigherLevelIfNotHandled(_x6) {
        return _testErrorsThatAreBubbledAreThrownAtAHigherLevelIfNotHandled.apply(this, arguments);
      }

      return testErrorsThatAreBubbledAreThrownAtAHigherLevelIfNotHandled;
    }();

    _proto2["@test Handled errors that are thrown through rejection aren't swallowed"] =
    /*#__PURE__*/
    function () {
      var _ref4 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee7(assert) {
        var handledError;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this.visit('/');

            case 2:
              this.add('route:mom.sally', _routing.Route.extend({
                model: function () {
                  step(assert, 1, 'MomSallyRoute#model');
                  return _runtime.RSVP.reject({
                    msg: 'did it broke?'
                  });
                },
                actions: {
                  error: function (err) {
                    step(assert, 2, 'MomSallyRoute#actions.error');
                    handledError = err;
                    this.transitionTo('mom.this-route-throws');
                    return false;
                  }
                }
              }));
              this.add('route:mom.this-route-throws', _routing.Route.extend({
                model: function () {
                  step(assert, 3, 'MomThisRouteThrows#model');
                  return _runtime.RSVP.reject(handledError);
                }
              }));
              _context7.next = 6;
              return assert.rejects(this.visit('/grandma/mom/sally'), function (err) {
                return err.msg === 'did it broke?';
              }, 'it broke');

            case 6:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));

      return function (_x7) {
        return _ref4.apply(this, arguments);
      };
    }();

    _proto2['@test Default error events move into nested route, prioritizing more specifically named error routes - NEW'] =
    /*#__PURE__*/
    function () {
      var _testDefaultErrorEventsMoveIntoNestedRoutePrioritizingMoreSpecificallyNamedErrorRoutesNEW = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee8(assert) {
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.visit('/');

            case 2:
              this.addTemplate('grandma.error', 'ERROR: {{model.msg}}');
              this.addTemplate('mom_error', 'MOM ERROR: {{model.msg}}');
              this.add('route:mom.sally', _routing.Route.extend({
                model: function () {
                  step(assert, 1, 'MomSallyRoute#model');
                  return _runtime.RSVP.reject({
                    msg: 'did it broke?'
                  });
                },
                actions: {
                  error: function () {
                    step(assert, 2, 'MomSallyRoute#actions.error');
                    return true;
                  }
                }
              }));
              _context8.next = 7;
              return this.visit('/grandma/mom/sally');

            case 7:
              step(assert, 3, 'Application finished booting');
              assert.equal(this.$('#app').text(), 'GRANDMA MOM ERROR: did it broke?', 'the more specifically named mome error substate was entered over the other error route');
              assert.equal(this.currentPath, 'grandma.mom_error', 'Initial route fully loaded');

            case 10:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));

      function testDefaultErrorEventsMoveIntoNestedRoutePrioritizingMoreSpecificallyNamedErrorRoutesNEW(_x8) {
        return _testDefaultErrorEventsMoveIntoNestedRoutePrioritizingMoreSpecificallyNamedErrorRoutesNEW.apply(this, arguments);
      }

      return testDefaultErrorEventsMoveIntoNestedRoutePrioritizingMoreSpecificallyNamedErrorRoutesNEW;
    }();

    _proto2['@test Slow promises waterfall on startup'] =
    /*#__PURE__*/
    function () {
      var _testSlowPromisesWaterfallOnStartup = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee9(assert) {
        var _this21, grandmaDeferred, sallyDeferred, promise, text;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _this21 = this;
              _context9.next = 3;
              return this.visit('/');

            case 3:
              grandmaDeferred = _runtime.RSVP.defer();
              sallyDeferred = _runtime.RSVP.defer();
              this.addTemplate('loading', 'LOADING');
              this.addTemplate('mom', 'MOM {{outlet}}');
              this.addTemplate('mom.loading', 'MOMLOADING');
              this.addTemplate('mom.sally', 'SALLY');
              this.add('route:grandma', _routing.Route.extend({
                model: function () {
                  step(assert, 1, 'GrandmaRoute#model');
                  return grandmaDeferred.promise;
                }
              }));
              this.add('route:mom', _routing.Route.extend({
                model: function () {
                  step(assert, 2, 'MomRoute#model');
                  return {};
                }
              }));
              this.add('route:mom.sally', _routing.Route.extend({
                model: function () {
                  step(assert, 3, 'SallyRoute#model');
                  return sallyDeferred.promise;
                },
                setupController: function () {
                  step(assert, 4, 'SallyRoute#setupController');
                }
              }));
              promise = (0, _internalTestHelpers.runTask)(function () {
                return _this21.visit('/grandma/mom/sally');
              }).then(function () {
                text = _this21.$('#app').text();
                assert.equal(text, 'GRANDMA MOM SALLY', "Sally template displayed");
              });
              text = this.$('#app').text();
              assert.equal(text, 'LOADING', "The loading template is nested in application template's outlet");
              (0, _internalTestHelpers.runTask)(function () {
                return grandmaDeferred.resolve();
              });
              text = this.$('#app').text();
              assert.equal(text, 'GRANDMA MOM MOMLOADING', "Mom's child loading route is displayed due to sally's slow promise");
              sallyDeferred.resolve();
              return _context9.abrupt("return", promise);

            case 20:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));

      function testSlowPromisesWaterfallOnStartup(_x9) {
        return _testSlowPromisesWaterfallOnStartup.apply(this, arguments);
      }

      return testSlowPromisesWaterfallOnStartup;
    }();

    _proto2['@test Enter child loading state of pivot route'] =
    /*#__PURE__*/
    function () {
      var _testEnterChildLoadingStateOfPivotRoute = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee10(assert) {
        var _this22, deferred, promise;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _this22 = this;
              _context10.next = 3;
              return this.visit('/');

            case 3:
              deferred = _runtime.RSVP.defer();
              this.addTemplate('grandma.loading', 'GMONEYLOADING');
              this.add('route:mom.sally', _routing.Route.extend({
                setupController: function () {
                  step(assert, 1, 'SallyRoute#setupController');
                }
              }));
              this.add('route:grandma.puppies', _routing.Route.extend({
                model: function () {
                  return deferred.promise;
                }
              }));
              _context10.next = 9;
              return this.visit('/grandma/mom/sally');

            case 9:
              assert.equal(this.currentPath, 'grandma.mom.sally', 'Initial route fully loaded');
              promise = (0, _internalTestHelpers.runTask)(function () {
                return _this22.visit('/grandma/puppies');
              }).then(function () {
                assert.equal(_this22.currentPath, 'grandma.puppies', 'Finished transition');
              });
              assert.equal(this.currentPath, 'grandma.loading', "in pivot route's child loading state");
              deferred.resolve();
              return _context10.abrupt("return", promise);

            case 14:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));

      function testEnterChildLoadingStateOfPivotRoute(_x10) {
        return _testEnterChildLoadingStateOfPivotRoute.apply(this, arguments);
      }

      return testEnterChildLoadingStateOfPivotRoute;
    }();

    _proto2["@test Error events that aren't bubbled don't throw application assertions"] =
    /*#__PURE__*/
    function () {
      var _ref5 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee11(assert) {
        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              _context11.next = 2;
              return this.visit('/');

            case 2:
              this.add('route:mom.sally', _routing.Route.extend({
                model: function () {
                  step(assert, 1, 'MomSallyRoute#model');
                  return _runtime.RSVP.reject({
                    msg: 'did it broke?'
                  });
                },
                actions: {
                  error: function (err) {
                    step(assert, 2, 'MomSallyRoute#actions.error');
                    assert.equal(err.msg, 'did it broke?', "it didn't break");
                    return false;
                  }
                }
              }));
              return _context11.abrupt("return", this.visit('/grandma/mom/sally'));

            case 4:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));

      return function (_x11) {
        return _ref5.apply(this, arguments);
      };
    }();

    _proto2['@test Handled errors that bubble can be handled at a higher level'] = function testHandledErrorsThatBubbleCanBeHandledAtAHigherLevel(assert) {
      var handledError;
      this.add('route:mom', _routing.Route.extend({
        actions: {
          error: function (err) {
            step(assert, 3, 'MomRoute#actions.error');
            assert.equal(err, handledError, "error handled and rebubbled is handleable at higher route");
          }
        }
      }));
      this.add('route:mom.sally', _routing.Route.extend({
        model: function () {
          step(assert, 1, 'MomSallyRoute#model');
          return _runtime.RSVP.reject({
            msg: 'did it broke?'
          });
        },
        actions: {
          error: function (err) {
            step(assert, 2, 'MomSallyRoute#actions.error');
            handledError = err;
            return true;
          }
        }
      }));
      return this.visit('/grandma/mom/sally');
    };

    _proto2['@test Setting a query param during a slow transition should work'] =
    /*#__PURE__*/
    function () {
      var _testSettingAQueryParamDuringASlowTransitionShouldWork = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee12(assert) {
        var _this23, deferred, promise, memereController;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              _this23 = this;
              _context12.next = 3;
              return this.visit('/');

            case 3:
              deferred = _runtime.RSVP.defer();
              this.addTemplate('memere.loading', 'MMONEYLOADING');
              this.add('route:grandma', _routing.Route.extend({
                beforeModel: function () {
                  this.transitionTo('memere', 1);
                }
              }));
              this.add('route:memere', _routing.Route.extend({
                queryParams: {
                  test: {
                    defaultValue: 1
                  }
                }
              }));
              this.add('route:memere.index', _routing.Route.extend({
                model: function () {
                  return deferred.promise;
                }
              }));
              promise = (0, _internalTestHelpers.runTask)(function () {
                return _this23.visit('/grandma');
              }).then(function () {
                assert.equal(_this23.currentPath, 'memere.index', 'Transition should be complete');
              });
              memereController = this.getController('memere');
              assert.equal(this.currentPath, 'memere.loading', 'Initial route should be loading');
              memereController.set('test', 3);
              assert.equal(this.currentPath, 'memere.loading', 'Initial route should still be loading');
              assert.equal(memereController.get('test'), 3, 'Controller query param value should have changed');
              deferred.resolve();
              return _context12.abrupt("return", promise);

            case 16:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));

      function testSettingAQueryParamDuringASlowTransitionShouldWork(_x12) {
        return _testSettingAQueryParamDuringASlowTransitionShouldWork.apply(this, arguments);
      }

      return testSettingAQueryParamDuringASlowTransitionShouldWork;
    }();

    (0, _emberBabel.createClass)(_class2, [{
      key: "currentPath",
      get: function () {
        var _this24 = this;

        var currentPath;
        expectDeprecation(function () {
          currentPath = _this24.getController('application').get('currentPath');
        }, 'Accessing `currentPath` on `controller:application` is deprecated, use the `currentPath` property on `service:router` instead.');
        return currentPath;
      }
    }]);
    return _class2;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/routing/toplevel_dom_test", ["ember-babel", "@ember/-internals/environment", "internal-test-helpers"], function (_emberBabel, _environment, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('Top Level DOM Structure',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.apply(this, arguments) || this;
      _this._APPLICATION_TEMPLATE_WRAPPER = _environment.ENV._APPLICATION_TEMPLATE_WRAPPER;
      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      _ApplicationTestCase.prototype.teardown.call(this);

      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = this._APPLICATION_TEMPLATE_WRAPPER;
    };

    _proto['@test topmost template with wrapper'] = function testTopmostTemplateWithWrapper() {
      var _this2 = this;

      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = true;
      this.addTemplate('application', 'hello world');
      return this.visit('/').then(function () {
        _this2.assertComponentElement(_this2.element, {
          content: 'hello world'
        });
      });
    };

    _proto['@test topmost template without wrapper'] = function testTopmostTemplateWithoutWrapper() {
      var _this3 = this;

      _environment.ENV._APPLICATION_TEMPLATE_WRAPPER = false;
      this.addTemplate('application', 'hello world');
      return this.visit('/').then(function () {
        _this3.assertInnerHTML('hello world');
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("ember/tests/service_injection_test", ["ember-babel", "@ember/-internals/owner", "@ember/controller", "@ember/service", "@ember/-internals/runtime", "internal-test-helpers", "@ember/-internals/metal"], function (_emberBabel, _owner, _controller, _service, _runtime, _internalTestHelpers, _metal) {
  "use strict";

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  (0, _internalTestHelpers.moduleFor)('Service Injection',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      return _ApplicationTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test Service can be injected and is resolved'] =
    /*#__PURE__*/
    function () {
      var _testServiceCanBeInjectedAndIsResolved = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(assert) {
        var MyService, controller;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.add('controller:application', _controller.default.extend({
                myService: (0, _service.inject)('my-service')
              }));
              MyService = _service.default.extend();
              this.add('service:my-service', MyService);
              this.addTemplate('application', '');
              _context.next = 6;
              return this.visit('/');

            case 6:
              controller = this.applicationInstance.lookup('controller:application');
              assert.ok(controller.get('myService') instanceof MyService);

            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function testServiceCanBeInjectedAndIsResolved(_x) {
        return _testServiceCanBeInjectedAndIsResolved.apply(this, arguments);
      }

      return testServiceCanBeInjectedAndIsResolved;
    }();

    _proto['@test Service can be an object proxy and access owner in init GH#16484'] =
    /*#__PURE__*/
    function () {
      var _testServiceCanBeAnObjectProxyAndAccessOwnerInInitGH = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(assert) {
        var serviceOwner, MyService, instance, controller;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              this.add('controller:application', _controller.default.extend({
                myService: (0, _service.inject)('my-service')
              }));
              MyService = _service.default.extend(_runtime._ProxyMixin, {
                init: function () {
                  this._super.apply(this, arguments);

                  serviceOwner = (0, _owner.getOwner)(this);
                }
              });
              this.add('service:my-service', MyService);
              this.addTemplate('application', '');
              _context2.next = 6;
              return this.visit('/');

            case 6:
              instance = _context2.sent;
              controller = this.applicationInstance.lookup('controller:application');
              assert.ok(controller.get('myService') instanceof MyService);
              assert.equal(serviceOwner, instance, 'should be able to `getOwner` in init');

            case 10:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));

      function testServiceCanBeAnObjectProxyAndAccessOwnerInInitGH16484(_x2) {
        return _testServiceCanBeAnObjectProxyAndAccessOwnerInInitGH.apply(this, arguments);
      }

      return testServiceCanBeAnObjectProxyAndAccessOwnerInInitGH16484;
    }();

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
  (0, _internalTestHelpers.moduleFor)('Service Injection with ES5 Getters',
  /*#__PURE__*/
  function (_ApplicationTestCase2) {
    (0, _emberBabel.inheritsLoose)(_class2, _ApplicationTestCase2);

    function _class2() {
      return _ApplicationTestCase2.apply(this, arguments) || this;
    }

    var _proto2 = _class2.prototype;

    _proto2['@test Service can be injected and is resolved without calling `get`'] =
    /*#__PURE__*/
    function () {
      var _testServiceCanBeInjectedAndIsResolvedWithoutCallingGet = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(assert) {
        var MyService, controller;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              this.add('controller:application', _controller.default.extend({
                myService: (0, _service.inject)('my-service')
              }));
              MyService = _service.default.extend({
                name: (0, _metal.computed)(function () {
                  return 'The service name';
                })
              });
              this.add('service:my-service', MyService);
              this.addTemplate('application', '');
              _context3.next = 6;
              return this.visit('/');

            case 6:
              controller = this.applicationInstance.lookup('controller:application');
              assert.ok(controller.myService instanceof MyService);
              assert.equal(controller.myService.name, 'The service name', 'service property accessible');

            case 9:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));

      function testServiceCanBeInjectedAndIsResolvedWithoutCallingGet(_x3) {
        return _testServiceCanBeInjectedAndIsResolvedWithoutCallingGet.apply(this, arguments);
      }

      return testServiceCanBeInjectedAndIsResolvedWithoutCallingGet;
    }();

    return _class2;
  }(_internalTestHelpers.ApplicationTestCase));

  if (false
  /* EMBER_MODULE_UNIFICATION */
  ) {
      (0, _internalTestHelpers.moduleFor)('Service Injection (MU)',
      /*#__PURE__*/
      function (_ApplicationTestCase3) {
        (0, _emberBabel.inheritsLoose)(_class3, _ApplicationTestCase3);

        function _class3() {
          return _ApplicationTestCase3.apply(this, arguments) || this;
        }

        var _proto3 = _class3.prototype;

        _proto3['@test Service can be injected with source and is resolved'] = function testServiceCanBeInjectedWithSourceAndIsResolved(assert) {
          var _this = this;

          var source = 'controller:src/ui/routes/application/controller';
          this.add('controller:application', _controller.default.extend({
            myService: (0, _service.inject)('my-service', {
              source: source
            })
          }));

          var MyService = _service.default.extend();

          this.add({
            specifier: 'service:my-service',
            source: source
          }, MyService);
          return this.visit('/').then(function () {
            var controller = _this.applicationInstance.lookup('controller:application');

            assert.ok(controller.get('myService') instanceof MyService);
          });
        };

        _proto3['@test Services can be injected with same name, different source, and resolve different instances'] = function testServicesCanBeInjectedWithSameNameDifferentSourceAndResolveDifferentInstances(assert) {
          var _this2 = this; // This test implies that there is a file src/ui/routes/route-a/-services/my-service


          var routeASource = 'controller:src/ui/routes/route-a/controller'; // This test implies that there is a file src/ui/routes/route-b/-services/my-service

          var routeBSource = 'controller:src/ui/routes/route-b/controller';
          this.add('controller:route-a', _controller.default.extend({
            myService: (0, _service.inject)('my-service', {
              source: routeASource
            })
          }));
          this.add('controller:route-b', _controller.default.extend({
            myService: (0, _service.inject)('my-service', {
              source: routeBSource
            })
          }));

          var LocalLookupService = _service.default.extend();

          this.add({
            specifier: 'service:my-service',
            source: routeASource
          }, LocalLookupService);

          var MyService = _service.default.extend();

          this.add({
            specifier: 'service:my-service',
            source: routeBSource
          }, MyService);
          return this.visit('/').then(function () {
            var controllerA = _this2.applicationInstance.lookup('controller:route-a');

            var serviceFromControllerA = controllerA.get('myService');
            assert.ok(serviceFromControllerA instanceof LocalLookupService, 'local lookup service is returned');

            var controllerB = _this2.applicationInstance.lookup('controller:route-b');

            var serviceFromControllerB = controllerB.get('myService');
            assert.ok(serviceFromControllerB instanceof MyService, 'global service is returned');
            assert.notStrictEqual(serviceFromControllerA, serviceFromControllerB);
          });
        };

        _proto3['@test Services can be injected with same name, different source, but same resolution result, and share an instance'] = function testServicesCanBeInjectedWithSameNameDifferentSourceButSameResolutionResultAndShareAnInstance(assert) {
          var _this3 = this;

          var routeASource = 'controller:src/ui/routes/route-a/controller';
          var routeBSource = 'controller:src/ui/routes/route-b/controller';
          this.add('controller:route-a', _controller.default.extend({
            myService: (0, _service.inject)('my-service', {
              source: routeASource
            })
          }));
          this.add('controller:route-b', _controller.default.extend({
            myService: (0, _service.inject)('my-service', {
              source: routeBSource
            })
          }));

          var MyService = _service.default.extend();

          this.add({
            specifier: 'service:my-service'
          }, MyService);
          return this.visit('/').then(function () {
            var controllerA = _this3.applicationInstance.lookup('controller:route-a');

            var serviceFromControllerA = controllerA.get('myService');
            assert.ok(serviceFromControllerA instanceof MyService);

            var controllerB = _this3.applicationInstance.lookup('controller:route-b');

            assert.strictEqual(serviceFromControllerA, controllerB.get('myService'));
          });
        }
        /*
         * This test demonstrates a failure in the caching system of ember's
         * container around singletons and and local lookup. The local lookup
         * is cached and the global injection is then looked up incorrectly.
         *
         * The paractical rules of Ember's module unification config are such
         * that services cannot be locally looked up, thus this case is really
         * just a demonstration of what could go wrong if we permit arbitrary
         * configuration (such as a singleton type that has local lookup).
         */
        ;

        _proto3['@test Services can be injected with same name, one with source one without, and share an instance'] = function testServicesCanBeInjectedWithSameNameOneWithSourceOneWithoutAndShareAnInstance(assert) {
          var _this4 = this;

          var routeASource = 'controller:src/ui/routes/route-a/controller';
          this.add('controller:route-a', _controller.default.extend({
            myService: (0, _service.inject)('my-service', {
              source: routeASource
            })
          }));
          this.add('controller:route-b', _controller.default.extend({
            myService: (0, _service.inject)('my-service')
          }));

          var MyService = _service.default.extend();

          this.add({
            specifier: 'service:my-service'
          }, MyService);
          return this.visit('/').then(function () {
            var controllerA = _this4.applicationInstance.lookup('controller:route-a');

            var serviceFromControllerA = controllerA.get('myService');
            assert.ok(serviceFromControllerA instanceof MyService, 'global service is returned');

            var controllerB = _this4.applicationInstance.lookup('controller:route-b');

            var serviceFromControllerB = controllerB.get('myService');
            assert.ok(serviceFromControllerB instanceof MyService, 'global service is returned');
            assert.strictEqual(serviceFromControllerA, serviceFromControllerB);
          });
        };

        _proto3['@test Service with namespace can be injected and is resolved'] =
        /*#__PURE__*/
        function () {
          var _testServiceWithNamespaceCanBeInjectedAndIsResolved = _asyncToGenerator(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee4(assert) {
            var MyService, controller;
            return regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  this.add('controller:application', _controller.default.extend({
                    myService: (0, _service.inject)('my-namespace::my-service')
                  }));
                  MyService = _service.default.extend();
                  this.add({
                    specifier: 'service:my-service',
                    namespace: 'my-namespace'
                  }, MyService);
                  _context4.next = 5;
                  return this.visit('/');

                case 5:
                  controller = this.applicationInstance.lookup('controller:application');
                  assert.ok(controller.get('myService') instanceof MyService);

                case 7:
                case "end":
                  return _context4.stop();
              }
            }, _callee4, this);
          }));

          function testServiceWithNamespaceCanBeInjectedAndIsResolved(_x4) {
            return _testServiceWithNamespaceCanBeInjectedAndIsResolved.apply(this, arguments);
          }

          return testServiceWithNamespaceCanBeInjectedAndIsResolved;
        }();

        return _class3;
      }(_internalTestHelpers.ApplicationTestCase));
    }
});
enifed("ember/tests/view_instrumentation_test", ["ember-babel", "@ember/instrumentation", "internal-test-helpers"], function (_emberBabel, _instrumentation, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('View Instrumentation',
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _ApplicationTestCase);

    function _class() {
      var _this;

      _this = _ApplicationTestCase.call(this) || this;

      _this.addTemplate('application', "{{outlet}}");

      _this.addTemplate('index', "<h1>Index</h1>");

      _this.addTemplate('posts', "<h1>Posts</h1>");

      _this.router.map(function () {
        this.route('posts');
      });

      return _this;
    }

    var _proto = _class.prototype;

    _proto.teardown = function teardown() {
      (0, _instrumentation.reset)();

      _ApplicationTestCase.prototype.teardown.call(this);
    };

    _proto['@test Nodes without view instances are instrumented'] = function testNodesWithoutViewInstancesAreInstrumented(assert) {
      var _this2 = this;

      var called = false;
      (0, _instrumentation.subscribe)('render', {
        before: function () {
          called = true;
        },
        after: function () {}
      });
      return this.visit('/').then(function () {
        assert.equal(_this2.textValue(), 'Index', 'It rendered the correct template');
        assert.ok(called, 'Instrumentation called on first render');
        called = false;
        return _this2.visit('/posts');
      }).then(function () {
        assert.equal(_this2.textValue(), 'Posts', 'It rendered the correct template');
        assert.ok(called, 'Instrumentation called on transition to non-view backed route');
      });
    };

    return _class;
  }(_internalTestHelpers.ApplicationTestCase));
});
enifed("internal-test-helpers/index", ["exports", "internal-test-helpers/lib/factory", "internal-test-helpers/lib/build-owner", "internal-test-helpers/lib/confirm-export", "internal-test-helpers/lib/equal-inner-html", "internal-test-helpers/lib/equal-tokens", "internal-test-helpers/lib/module-for", "internal-test-helpers/lib/strip", "internal-test-helpers/lib/apply-mixins", "internal-test-helpers/lib/get-text-of", "internal-test-helpers/lib/matchers", "internal-test-helpers/lib/run", "internal-test-helpers/lib/test-context", "internal-test-helpers/lib/test-cases/abstract", "internal-test-helpers/lib/test-cases/abstract-application", "internal-test-helpers/lib/test-cases/application", "internal-test-helpers/lib/test-cases/query-param", "internal-test-helpers/lib/test-cases/abstract-rendering", "internal-test-helpers/lib/test-cases/rendering", "internal-test-helpers/lib/test-cases/router", "internal-test-helpers/lib/test-cases/autoboot-application", "internal-test-helpers/lib/test-cases/default-resolver-application", "internal-test-helpers/lib/test-resolver", "internal-test-helpers/lib/browser-detect", "internal-test-helpers/lib/registry-check"], function (_exports, _factory, _buildOwner, _confirmExport, _equalInnerHtml, _equalTokens, _moduleFor, _strip, _applyMixins, _getTextOf, _matchers, _run, _testContext, _abstract, _abstractApplication, _application, _queryParam, _abstractRendering, _rendering, _router, _autobootApplication, _defaultResolverApplication, _testResolver, _browserDetect, _registryCheck) {
  "use strict";

  Object.defineProperty(_exports, "factory", {
    enumerable: true,
    get: function () {
      return _factory.default;
    }
  });
  Object.defineProperty(_exports, "buildOwner", {
    enumerable: true,
    get: function () {
      return _buildOwner.default;
    }
  });
  Object.defineProperty(_exports, "confirmExport", {
    enumerable: true,
    get: function () {
      return _confirmExport.default;
    }
  });
  Object.defineProperty(_exports, "equalInnerHTML", {
    enumerable: true,
    get: function () {
      return _equalInnerHtml.default;
    }
  });
  Object.defineProperty(_exports, "equalTokens", {
    enumerable: true,
    get: function () {
      return _equalTokens.default;
    }
  });
  Object.defineProperty(_exports, "moduleFor", {
    enumerable: true,
    get: function () {
      return _moduleFor.default;
    }
  });
  Object.defineProperty(_exports, "setupTestClass", {
    enumerable: true,
    get: function () {
      return _moduleFor.setupTestClass;
    }
  });
  Object.defineProperty(_exports, "strip", {
    enumerable: true,
    get: function () {
      return _strip.default;
    }
  });
  Object.defineProperty(_exports, "applyMixins", {
    enumerable: true,
    get: function () {
      return _applyMixins.default;
    }
  });
  Object.defineProperty(_exports, "getTextOf", {
    enumerable: true,
    get: function () {
      return _getTextOf.default;
    }
  });
  Object.defineProperty(_exports, "equalsElement", {
    enumerable: true,
    get: function () {
      return _matchers.equalsElement;
    }
  });
  Object.defineProperty(_exports, "classes", {
    enumerable: true,
    get: function () {
      return _matchers.classes;
    }
  });
  Object.defineProperty(_exports, "styles", {
    enumerable: true,
    get: function () {
      return _matchers.styles;
    }
  });
  Object.defineProperty(_exports, "regex", {
    enumerable: true,
    get: function () {
      return _matchers.regex;
    }
  });
  Object.defineProperty(_exports, "runAppend", {
    enumerable: true,
    get: function () {
      return _run.runAppend;
    }
  });
  Object.defineProperty(_exports, "runDestroy", {
    enumerable: true,
    get: function () {
      return _run.runDestroy;
    }
  });
  Object.defineProperty(_exports, "runTask", {
    enumerable: true,
    get: function () {
      return _run.runTask;
    }
  });
  Object.defineProperty(_exports, "runTaskNext", {
    enumerable: true,
    get: function () {
      return _run.runTaskNext;
    }
  });
  Object.defineProperty(_exports, "runLoopSettled", {
    enumerable: true,
    get: function () {
      return _run.runLoopSettled;
    }
  });
  Object.defineProperty(_exports, "getContext", {
    enumerable: true,
    get: function () {
      return _testContext.getContext;
    }
  });
  Object.defineProperty(_exports, "setContext", {
    enumerable: true,
    get: function () {
      return _testContext.setContext;
    }
  });
  Object.defineProperty(_exports, "unsetContext", {
    enumerable: true,
    get: function () {
      return _testContext.unsetContext;
    }
  });
  Object.defineProperty(_exports, "AbstractTestCase", {
    enumerable: true,
    get: function () {
      return _abstract.default;
    }
  });
  Object.defineProperty(_exports, "AbstractApplicationTestCase", {
    enumerable: true,
    get: function () {
      return _abstractApplication.default;
    }
  });
  Object.defineProperty(_exports, "ApplicationTestCase", {
    enumerable: true,
    get: function () {
      return _application.default;
    }
  });
  Object.defineProperty(_exports, "QueryParamTestCase", {
    enumerable: true,
    get: function () {
      return _queryParam.default;
    }
  });
  Object.defineProperty(_exports, "AbstractRenderingTestCase", {
    enumerable: true,
    get: function () {
      return _abstractRendering.default;
    }
  });
  Object.defineProperty(_exports, "RenderingTestCase", {
    enumerable: true,
    get: function () {
      return _rendering.default;
    }
  });
  Object.defineProperty(_exports, "RouterTestCase", {
    enumerable: true,
    get: function () {
      return _router.default;
    }
  });
  Object.defineProperty(_exports, "AutobootApplicationTestCase", {
    enumerable: true,
    get: function () {
      return _autobootApplication.default;
    }
  });
  Object.defineProperty(_exports, "DefaultResolverApplicationTestCase", {
    enumerable: true,
    get: function () {
      return _defaultResolverApplication.default;
    }
  });
  Object.defineProperty(_exports, "TestResolver", {
    enumerable: true,
    get: function () {
      return _testResolver.default;
    }
  });
  Object.defineProperty(_exports, "ModuleBasedTestResolver", {
    enumerable: true,
    get: function () {
      return _testResolver.ModuleBasedResolver;
    }
  });
  Object.defineProperty(_exports, "isIE11", {
    enumerable: true,
    get: function () {
      return _browserDetect.isIE11;
    }
  });
  Object.defineProperty(_exports, "isEdge", {
    enumerable: true,
    get: function () {
      return _browserDetect.isEdge;
    }
  });
  Object.defineProperty(_exports, "verifyInjection", {
    enumerable: true,
    get: function () {
      return _registryCheck.verifyInjection;
    }
  });
  Object.defineProperty(_exports, "verifyRegistration", {
    enumerable: true,
    get: function () {
      return _registryCheck.verifyRegistration;
    }
  });
});
enifed("internal-test-helpers/lib/apply-mixins", ["exports", "@ember/polyfills", "internal-test-helpers/lib/get-all-property-names"], function (_exports, _polyfills, _getAllPropertyNames) {
  "use strict";

  _exports.default = applyMixins;

  function isGenerator(mixin) {
    return Array.isArray(mixin.cases) && typeof mixin.generate === 'function';
  }

  function applyMixins(TestClass) {
    for (var _len = arguments.length, mixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      mixins[_key - 1] = arguments[_key];
    }

    mixins.forEach(function (mixinOrGenerator) {
      var mixin;

      if (isGenerator(mixinOrGenerator)) {
        var generator = mixinOrGenerator;
        mixin = {};
        generator.cases.forEach(function (value, idx) {
          (0, _polyfills.assign)(mixin, generator.generate(value, idx));
        });
        (0, _polyfills.assign)(TestClass.prototype, mixin);
      } else if (typeof mixinOrGenerator === 'function') {
        var properties = (0, _getAllPropertyNames.default)(mixinOrGenerator);
        mixin = new mixinOrGenerator();
        properties.forEach(function (name) {
          TestClass.prototype[name] = function () {
            return mixin[name].apply(mixin, arguments);
          };
        });
      } else {
        mixin = mixinOrGenerator;
        (0, _polyfills.assign)(TestClass.prototype, mixin);
      }
    });
    return TestClass;
  }
});
enifed("internal-test-helpers/lib/browser-detect", ["exports"], function (_exports) {
  "use strict";

  _exports.isEdge = _exports.isIE11 = void 0;
  // `window.ActiveXObject` is "falsey" in IE11 (but not `undefined` or `false`)
  // `"ActiveXObject" in window` returns `true` in all IE versions
  // only IE11 will pass _both_ of these conditions
  var isIE11 = !window.ActiveXObject && 'ActiveXObject' in window;
  _exports.isIE11 = isIE11;
  var isEdge = /Edge/.test(navigator.userAgent);
  _exports.isEdge = isEdge;
});
enifed("internal-test-helpers/lib/build-owner", ["exports", "@ember/-internals/container", "@ember/-internals/routing", "@ember/application/instance", "@ember/application", "@ember/-internals/runtime"], function (_exports, _container, _routing, _instance, _application, _runtime) {
  "use strict";

  _exports.default = buildOwner;

  var ResolverWrapper =
  /*#__PURE__*/
  function () {
    function ResolverWrapper(resolver) {
      this.resolver = resolver;
    }

    var _proto = ResolverWrapper.prototype;

    _proto.create = function create() {
      return this.resolver;
    };

    return ResolverWrapper;
  }();

  function buildOwner() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var ownerOptions = options.ownerOptions || {};
    var resolver = options.resolver;
    var bootOptions = options.bootOptions || {};

    var Owner = _runtime.Object.extend(_runtime.RegistryProxyMixin, _runtime.ContainerProxyMixin);

    var namespace = _runtime.Object.create({
      Resolver: new ResolverWrapper(resolver)
    });

    var fallbackRegistry = _application.default.buildRegistry(namespace);

    fallbackRegistry.register('router:main', _routing.Router);
    var registry = new _container.Registry({
      fallback: fallbackRegistry
    });

    _instance.default.setupRegistry(registry, bootOptions);

    var owner = Owner.create({
      __registry__: registry,
      __container__: null
    }, ownerOptions);
    var container = registry.container({
      owner: owner
    });
    owner.__container__ = container;
    return owner;
  }
});
enifed("internal-test-helpers/lib/confirm-export", ["exports", "require"], function (_exports, _require) {
  "use strict";

  _exports.default = confirmExport;

  function getDescriptor(obj, path) {
    var parts = path.split('.');
    var value = obj;

    for (var i = 0; i < parts.length - 1; i++) {
      var part = parts[i];
      value = value[part];

      if (!value) {
        return undefined;
      }
    }

    var last = parts[parts.length - 1];
    return Object.getOwnPropertyDescriptor(value, last);
  }

  function confirmExport(Ember, assert, path, moduleId, exportName) {
    try {
      var desc = getDescriptor(Ember, path);
      assert.ok(desc, "the " + path + " property exists on the Ember global");

      if (typeof exportName === 'string') {
        var mod = (0, _require.default)(moduleId);
        assert.equal(desc.value, mod[exportName], "Ember." + path + " is exported correctly");
        assert.notEqual(mod[exportName], undefined, "Ember." + path + " is not `undefined`");
      } else if ('value' in desc) {
        assert.equal(desc.value, exportName.value, "Ember." + path + " is exported correctly");
      } else {
        var _mod = (0, _require.default)(moduleId);

        assert.equal(desc.get, _mod[exportName.get], "Ember." + path + " getter is exported correctly");
        assert.notEqual(desc.get, undefined, "Ember." + path + " getter is not undefined");

        if (exportName.set) {
          assert.equal(desc.set, _mod[exportName.set], "Ember." + path + " setter is exported correctly");
          assert.notEqual(desc.set, undefined, "Ember." + path + " setter is not undefined");
        }
      }
    } catch (error) {
      assert.pushResult({
        result: false,
        message: "An error occured while testing " + path + " is exported from " + moduleId + ".",
        source: error
      });
    }
  }
});
enifed("internal-test-helpers/lib/element-helpers", ["exports", "internal-test-helpers/lib/test-context"], function (_exports, _testContext) {
  "use strict";

  _exports.getElement = getElement;

  function getElement() {
    var context = (0, _testContext.getContext)();

    if (!context) {
      throw new Error('Test context is not set up.');
    }

    var element = context.element;

    if (!element) {
      throw new Error('`element` property on test context is not set up.');
    }

    return element;
  }
});
enifed("internal-test-helpers/lib/ember-dev/assertion", ["exports", "internal-test-helpers/lib/ember-dev/utils"], function (_exports, _utils) {
  "use strict";

  _exports.setupAssertionHelpers = setupAssertionHelpers;
  var BREAK = {};
  /*
    This assertion helper is used to test assertions made using Ember.assert.
    It injects two helpers onto `window`:
  
    - expectAssertion(func: Function, [expectedMessage: String | RegExp])
  
    This function calls `func` and asserts that `Ember.assert` is invoked during
    the execution. Moreover, it takes a String or a RegExp as a second optional
    argument that can be used to test if a specific assertion message was
    generated.
  
    - ignoreAssertion(func: Function)
  
    This function calls `func` and disables `Ember.assert` during the execution.
    In particular, this prevents `Ember.assert` from throw errors that would
    disrupt the control flow.
  */

  function setupAssertionHelpers(hooks, env) {
    hooks.beforeEach(function (assert) {
      var expectAssertion = function (func, expectedMessage) {
        if (env.runningProdBuild) {
          assert.ok(true, 'Assertions disabled in production builds.');
          return;
        }

        var sawCall = false;
        var actualMessage = undefined; // The try-catch statement is used to "exit" `func` as soon as
        // the first useful assertion has been produced.

        try {
          (0, _utils.callWithStub)(env, 'assert', func, function (message, test) {
            sawCall = true;

            if ((0, _utils.checkTest)(test)) {
              return;
            }

            actualMessage = message;
            throw BREAK;
          });
        } catch (e) {
          if (e !== BREAK) {
            throw e;
          }
        }

        check(assert, sawCall, actualMessage, expectedMessage);
      };

      var ignoreAssertion = function (func) {
        (0, _utils.callWithStub)(env, 'assert', func);
      };

      window.expectAssertion = expectAssertion;
      window.ignoreAssertion = ignoreAssertion;
    });
    hooks.afterEach(function () {
      window.expectAssertion = null;
      window.ignoreAssertion = null;
    });
  }

  function check(assert, sawCall, actualMessage, expectedMessage) {
    // Run assertions in an order that is useful when debugging a test failure.
    if (!sawCall) {
      assert.ok(false, "Expected Ember.assert to be called (Not called with any value).");
    } else if (!actualMessage) {
      assert.ok(false, "Expected a failing Ember.assert (Ember.assert called, but without a failing test).");
    } else {
      if (expectedMessage) {
        if (expectedMessage instanceof RegExp) {
          assert.ok(expectedMessage.test(actualMessage), "Expected failing Ember.assert: '" + expectedMessage + "', but got '" + actualMessage + "'.");
        } else {
          assert.equal(actualMessage, expectedMessage, "Expected failing Ember.assert: '" + expectedMessage + "', but got '" + actualMessage + "'.");
        }
      } else {
        // Positive assertion that assert was called
        assert.ok(true, 'Expected a failing Ember.assert.');
      }
    }
  }
});
enifed("internal-test-helpers/lib/ember-dev/containers", ["exports", "@ember/-internals/container"], function (_exports, _container) {
  "use strict";

  _exports.setupContainersCheck = setupContainersCheck;
  var containerLeakTracking = _container.Container._leakTracking;

  function setupContainersCheck(hooks) {
    hooks.afterEach(function () {
      if (containerLeakTracking === undefined) return;
      var _QUnit = QUnit,
          config = _QUnit.config;
      var _config$current = config.current,
          testName = _config$current.testName,
          testId = _config$current.testId,
          moduleName = _config$current.module.name,
          originalFinish = _config$current.finish;

      config.current.finish = function () {
        originalFinish.call(this);
        originalFinish = undefined;
        config.queue.unshift(function () {
          if (containerLeakTracking.hasContainers()) {
            containerLeakTracking.reset(); // eslint-disable-next-line no-console

            console.assert(false, "Leaked container after test " + moduleName + ": " + testName + " testId=" + testId);
          }
        });
      };
    });
  }
});
enifed("internal-test-helpers/lib/ember-dev/debug", ["exports", "internal-test-helpers/lib/ember-dev/method-call-tracker"], function (_exports, _methodCallTracker) {
  "use strict";

  _exports.default = void 0;

  var DebugAssert =
  /*#__PURE__*/
  function () {
    function DebugAssert(methodName, env) {
      this.methodName = methodName;
      this.env = env;
      this.tracker = null;
    }

    var _proto = DebugAssert.prototype;

    _proto.inject = function inject() {};

    _proto.restore = function restore() {
      this.reset();
    };

    _proto.reset = function reset() {
      if (this.tracker) {
        this.tracker.restoreMethod();
      }

      this.tracker = null;
    };

    _proto.assert = function assert() {
      if (this.tracker) {
        this.tracker.assert();
      }
    } // Run an expectation callback within the context of a new tracker, optionally
    // accepting a function to run, which asserts immediately
    ;

    _proto.runExpectation = function runExpectation(func, callback) {
      var _this = this;

      var async = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var originalTracker = null; // When helpers are passed a callback, they get a new tracker context

      if (func) {
        originalTracker = this.tracker;
        this.tracker = null;
      }

      if (!this.tracker) {
        this.tracker = new _methodCallTracker.default(this.env, this.methodName);
      } // Yield to caller with tracker instance


      callback(this.tracker); // Once the given callback is invoked, the pending assertions should be
      // flushed immediately

      if (func) {
        var maybePromise = func();

        if (async && typeof maybePromise.then === 'function') {
          return maybePromise.then(function () {
            _this.assert();

            _this.reset();

            _this.tracker = originalTracker;
          });
        } else {
          this.assert();
          this.reset();
          this.tracker = originalTracker;
        }
      }
    };

    return DebugAssert;
  }();

  var _default = DebugAssert;
  _exports.default = _default;
});
enifed("internal-test-helpers/lib/ember-dev/deprecation", ["exports", "ember-babel", "internal-test-helpers/lib/ember-dev/debug", "internal-test-helpers/lib/ember-dev/utils"], function (_exports, _emberBabel, _debug, _utils) {
  "use strict";

  _exports.setupDeprecationHelpers = setupDeprecationHelpers;
  _exports.default = void 0;

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function setupDeprecationHelpers(hooks, env) {
    var assertion = new DeprecationAssert(env);
    hooks.beforeEach(function () {
      assertion.reset();
      assertion.inject();
    });
    hooks.afterEach(function () {
      assertion.assert();
      assertion.restore();
    });
  }

  var DeprecationAssert =
  /*#__PURE__*/
  function (_DebugAssert) {
    (0, _emberBabel.inheritsLoose)(DeprecationAssert, _DebugAssert);

    function DeprecationAssert(env) {
      return _DebugAssert.call(this, 'deprecate', env) || this;
    }

    var _proto = DeprecationAssert.prototype;

    _proto.inject = function inject() {
      var _this = this; // Expects no deprecation to happen within a function, or if no function is
      // passed, from the time of calling until the end of the test.
      //
      // expectNoDeprecation(function() {
      //   fancyNewThing();
      // });
      //
      // expectNoDeprecation();
      // Ember.deprecate("Old And Busted");
      //


      var expectNoDeprecation = function (func) {
        if (typeof func !== 'function') {
          func = undefined;
        }

        _this.runExpectation(func, function (tracker) {
          if (tracker.isExpectingCalls()) {
            throw new Error('expectNoDeprecation was called after expectDeprecation was called!');
          }

          tracker.expectNoCalls();
        });
      }; // Expect a deprecation to happen within a function, or if no function
      // is pass, from the time of calling until the end of the test. Can be called
      // multiple times to assert deprecations with different specific messages
      // were fired.
      //
      // expectDeprecation(function() {
      //   Ember.deprecate("Old And Busted");
      // }, /* optionalStringOrRegex */);
      //
      // expectDeprecation(/* optionalStringOrRegex */);
      // Ember.deprecate("Old And Busted");
      //


      var expectDeprecation = function (func, message) {
        var actualFunc;

        if (typeof func !== 'function') {
          message = func;
          actualFunc = undefined;
        } else {
          actualFunc = func;
        }

        _this.runExpectation(actualFunc, function (tracker) {
          if (tracker.isExpectingNoCalls()) {
            throw new Error('expectDeprecation was called after expectNoDeprecation was called!');
          }

          tracker.expectCall(message, ['id', 'until']);
        });
      };

      var expectDeprecationAsync =
      /*#__PURE__*/
      function () {
        var _ref = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee(func, message) {
          var actualFunc;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (typeof func !== 'function') {
                  message = func;
                  actualFunc = undefined;
                } else {
                  actualFunc = func;
                }

                _context.next = 3;
                return _this.runExpectation(actualFunc, function (tracker) {
                  if (tracker.isExpectingNoCalls()) {
                    throw new Error('expectDeprecation was called after expectNoDeprecation was called!');
                  }

                  tracker.expectCall(message, ['id', 'until']);
                }, true);

              case 3:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));

        return function expectDeprecationAsync(_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }();

      var ignoreDeprecation = function (func) {
        (0, _utils.callWithStub)(_this.env, 'deprecate', func);
      };

      window.expectNoDeprecation = expectNoDeprecation;
      window.expectDeprecation = expectDeprecation;
      window.expectDeprecationAsync = expectDeprecationAsync;
      window.ignoreDeprecation = ignoreDeprecation;
    };

    _proto.restore = function restore() {
      _DebugAssert.prototype.restore.call(this);

      window.expectDeprecation = null;
      window.expectDeprecationAsync = null;
      window.expectNoDeprecation = null;
      window.ignoreDeprecation = null;
    };

    return DeprecationAssert;
  }(_debug.default);

  var _default = DeprecationAssert;
  _exports.default = _default;
});
enifed("internal-test-helpers/lib/ember-dev/method-call-tracker", ["exports", "internal-test-helpers/lib/ember-dev/utils"], function (_exports, _utils) {
  "use strict";

  _exports.default = void 0;

  var MethodCallTracker =
  /*#__PURE__*/
  function () {
    function MethodCallTracker(env, methodName) {
      this._env = env;
      this._methodName = methodName;
      this._isExpectingNoCalls = false;
      this._expectedMessages = [];
      this._expectedOptionLists = [];
      this._actuals = [];
      this._originalMethod = undefined;
    }

    var _proto = MethodCallTracker.prototype;

    _proto.stubMethod = function stubMethod() {
      var _this = this;

      if (this._originalMethod) {
        // Method is already stubbed
        return;
      }

      var env = this._env;
      var methodName = this._methodName;
      this._originalMethod = env.getDebugFunction(methodName);
      env.setDebugFunction(methodName, function (message, test, options) {
        var resultOfTest = (0, _utils.checkTest)(test);

        _this._actuals.push([message, resultOfTest, options]);
      });
    };

    _proto.restoreMethod = function restoreMethod() {
      if (this._originalMethod) {
        this._env.setDebugFunction(this._methodName, this._originalMethod);
      }
    };

    _proto.expectCall = function expectCall(message, options) {
      this.stubMethod();

      this._expectedMessages.push(message || /.*/);

      this._expectedOptionLists.push(options);
    };

    _proto.expectNoCalls = function expectNoCalls() {
      this.stubMethod();
      this._isExpectingNoCalls = true;
    };

    _proto.isExpectingNoCalls = function isExpectingNoCalls() {
      return this._isExpectingNoCalls;
    };

    _proto.isExpectingCalls = function isExpectingCalls() {
      return !this._isExpectingNoCalls && this._expectedMessages.length;
    };

    _proto.assert = function assert() {
      var assert = QUnit.config.current.assert;
      var env = this._env;
      var methodName = this._methodName;
      var isExpectingNoCalls = this._isExpectingNoCalls;
      var expectedMessages = this._expectedMessages;
      var expectedOptionLists = this._expectedOptionLists;
      var actuals = this._actuals;
      var o, i, j;

      if (!isExpectingNoCalls && expectedMessages.length === 0 && actuals.length === 0) {
        return;
      }

      if (env.runningProdBuild) {
        assert.ok(true, "calls to Ember." + methodName + " disabled in production builds.");
        return;
      }

      if (isExpectingNoCalls) {
        var actualMessages = [];

        for (i = 0; i < actuals.length; i++) {
          if (!actuals[i][1]) {
            actualMessages.push(actuals[i][0]);
          }
        }

        assert.ok(actualMessages.length === 0, "Expected no Ember." + methodName + " calls, got " + actuals.length + ": " + actualMessages.join(', '));
        return;
      }

      var actual;
      var match = undefined;

      for (o = 0; o < expectedMessages.length; o++) {
        var expectedMessage = expectedMessages[o];
        var expectedOptionList = expectedOptionLists[o];

        for (i = 0; i < actuals.length; i++) {
          var matchesMessage = false;
          var matchesOptionList = false;
          actual = actuals[i];

          if (actual[1] === true) {
            continue;
          }

          if (expectedMessage instanceof RegExp && expectedMessage.test(actual[0])) {
            matchesMessage = true;
          } else if (expectedMessage === actual[0]) {
            matchesMessage = true;
          }

          if (expectedOptionList === undefined) {
            matchesOptionList = true;
          } else if (actual[2]) {
            matchesOptionList = true;

            for (j = 0; j < expectedOptionList.length; j++) {
              matchesOptionList = matchesOptionList && actual[2].hasOwnProperty(expectedOptionList[j]);
            }
          }

          if (matchesMessage && matchesOptionList) {
            match = actual;
            break;
          }
        }

        var expectedOptionsMessage = expectedOptionList ? "and options: { " + expectedOptionList.join(', ') + " }" : 'and no options';
        var actualOptionsMessage = actual && actual[2] ? "and options: { " + Object.keys(actual[2]).join(', ') + " }" : 'and no options';

        if (!actual) {
          assert.ok(false, "Received no Ember." + methodName + " calls at all, expecting: " + expectedMessage);
        } else if (match && !match[1]) {
          assert.ok(true, "Received failing Ember." + methodName + " call with message: " + match[0]);
        } else if (match && match[1]) {
          assert.ok(false, "Expected failing Ember." + methodName + " call, got succeeding with message: " + match[0]);
        } else if (actual[1]) {
          assert.ok(false, "Did not receive failing Ember." + methodName + " call matching '" + expectedMessage + "' " + expectedOptionsMessage + ", last was success with '" + actual[0] + "' " + actualOptionsMessage);
        } else if (!actual[1]) {
          assert.ok(false, "Did not receive failing Ember." + methodName + " call matching '" + expectedMessage + "' " + expectedOptionsMessage + ", last was failure with '" + actual[0] + "' " + actualOptionsMessage);
        }
      }
    };

    return MethodCallTracker;
  }();

  _exports.default = MethodCallTracker;
});
enifed("internal-test-helpers/lib/ember-dev/namespaces", ["exports", "@ember/-internals/metal", "@ember/runloop"], function (_exports, _metal, _runloop) {
  "use strict";

  _exports.setupNamespacesCheck = setupNamespacesCheck;

  function setupNamespacesCheck(hooks) {
    hooks.afterEach(function () {
      var assert = QUnit.config.current.assert;

      if (_metal.NAMESPACES.length > 0) {
        assert.ok(false, 'Should not have any NAMESPACES after tests');
        (0, _runloop.run)(function () {
          var namespaces = _metal.NAMESPACES.slice();

          for (var i = 0; i < namespaces.length; i++) {
            namespaces[i].destroy();
          }
        });
      }

      var keys = Object.keys(_metal.NAMESPACES_BY_ID);

      if (keys.length > 0) {
        assert.ok(false, 'Should not have any NAMESPACES_BY_ID after tests');

        for (var i = 0; i < keys.length; i++) {
          delete _metal.NAMESPACES_BY_ID[keys[i]];
        }
      }
    });
  }
});
enifed("internal-test-helpers/lib/ember-dev/run-loop", ["exports", "@ember/runloop"], function (_exports, _runloop) {
  "use strict";

  _exports.setupRunLoopCheck = setupRunLoopCheck;

  // @ts-ignore
  function setupRunLoopCheck(hooks) {
    hooks.afterEach(function (assert) {
      if ((0, _runloop.getCurrentRunLoop)() || (0, _runloop.hasScheduledTimers)()) {
        var done = assert.async(); // use a setTimeout to allow the current run loop to flush via autorun

        setTimeout(function () {
          // increment expected assertion count for the assertions just below
          if (assert['test'].expected !== null) {
            assert['test'].expected += 2;
          } // if it is _still_ not completed, we have a problem and the test should be fixed


          assert.ok(!(0, _runloop.hasScheduledTimers)(), 'Ember run should not have scheduled timers at end of test');
          assert.ok(!(0, _runloop.getCurrentRunLoop)(), 'Should not be in a run loop at end of test'); // attempt to recover so the rest of the tests can run

          while ((0, _runloop.getCurrentRunLoop)()) {
            (0, _runloop.end)();
          }

          (0, _runloop.cancelTimers)();
          done();
        }, 0);
      }
    });
  }
});
enifed("internal-test-helpers/lib/ember-dev/setup-qunit", ["exports", "@ember/debug", "internal-test-helpers/lib/ember-dev/assertion", "internal-test-helpers/lib/ember-dev/containers", "internal-test-helpers/lib/ember-dev/deprecation", "internal-test-helpers/lib/ember-dev/namespaces", "internal-test-helpers/lib/ember-dev/run-loop", "internal-test-helpers/lib/ember-dev/warning"], function (_exports, _debug, _assertion, _containers, _deprecation, _namespaces, _runLoop, _warning) {
  "use strict";

  _exports.default = setupQUnit;

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function setupQUnit(_ref) {
    var runningProdBuild = _ref.runningProdBuild;
    var env = {
      runningProdBuild: runningProdBuild,
      getDebugFunction: _debug.getDebugFunction,
      setDebugFunction: _debug.setDebugFunction
    };
    var originalModule = QUnit.module;

    QUnit.module = function (name, callback) {
      return originalModule(name, function (hooks) {
        (0, _containers.setupContainersCheck)(hooks);
        (0, _namespaces.setupNamespacesCheck)(hooks);
        (0, _runLoop.setupRunLoopCheck)(hooks);
        (0, _assertion.setupAssertionHelpers)(hooks, env);
        (0, _deprecation.setupDeprecationHelpers)(hooks, env);
        (0, _warning.setupWarningHelpers)(hooks, env);
        callback(hooks);
      });
    };

    QUnit.assert.rejects =
    /*#__PURE__*/
    function () {
      var _ref2 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(promise, expected, message) {
        var error, prevOnError;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              prevOnError = Ember.onerror;

              Ember.onerror = function (e) {
                error = e;
              };

              _context.prev = 2;
              _context.next = 5;
              return promise;

            case 5:
              _context.next = 10;
              break;

            case 7:
              _context.prev = 7;
              _context.t0 = _context["catch"](2);
              error = _context.t0;

            case 10:
              QUnit.assert.throws(function () {
                if (error) {
                  throw error;
                }
              }, expected, message);
              Ember.onerror = prevOnError;

            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[2, 7]]);
      }));

      return function (_x, _x2, _x3) {
        return _ref2.apply(this, arguments);
      };
    }();

    QUnit.assert.throwsAssertion = function (block, expected, message) {
      if (!true
      /* DEBUG */
      ) {
          QUnit.assert.ok(true, 'Assertions disabled in production builds.');
          return;
        }

      return QUnit.assert.throws(block, expected, message);
    };

    QUnit.assert.rejectsAssertion =
    /*#__PURE__*/
    function () {
      var _ref3 = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(promise, expected, message) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (true) {
                _context2.next = 3;
                break;
              }

              QUnit.assert.ok(true, 'Assertions disabled in production builds.');
              return _context2.abrupt("return", promise);

            case 3:
              _context2.next = 5;
              return QUnit.assert.rejects(promise, expected, message);

            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));

      return function (_x4, _x5, _x6) {
        return _ref3.apply(this, arguments);
      };
    }();
  }
});
enifed("internal-test-helpers/lib/ember-dev/utils", ["exports"], function (_exports) {
  "use strict";

  _exports.callWithStub = callWithStub;
  _exports.checkTest = checkTest;

  function noop() {}

  function callWithStub(env, name, func) {
    var debugStub = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;
    var originalFunc = env.getDebugFunction(name);

    try {
      env.setDebugFunction(name, debugStub);
      func();
    } finally {
      env.setDebugFunction(name, originalFunc);
    }
  }

  function checkTest(test) {
    return typeof test === 'function' ? test() : test;
  }
});
enifed("internal-test-helpers/lib/ember-dev/warning", ["exports", "ember-babel", "internal-test-helpers/lib/ember-dev/debug", "internal-test-helpers/lib/ember-dev/utils"], function (_exports, _emberBabel, _debug, _utils) {
  "use strict";

  _exports.setupWarningHelpers = setupWarningHelpers;
  _exports.default = void 0;

  function setupWarningHelpers(hooks, env) {
    var assertion = new WarningAssert(env);
    hooks.beforeEach(function () {
      assertion.reset();
      assertion.inject();
    });
    hooks.afterEach(function () {
      assertion.assert();
      assertion.restore();
    });
  }

  var WarningAssert =
  /*#__PURE__*/
  function (_DebugAssert) {
    (0, _emberBabel.inheritsLoose)(WarningAssert, _DebugAssert);

    function WarningAssert(env) {
      return _DebugAssert.call(this, 'warn', env) || this;
    }

    var _proto = WarningAssert.prototype;

    _proto.inject = function inject() {
      var _this = this; // Expects no warning to happen within a function, or if no function is
      // passed, from the time of calling until the end of the test.
      //
      // expectNoWarning(function() {
      //   fancyNewThing();
      // });
      //
      // expectNoWarning();
      // Ember.warn("Oh snap, didn't expect that");
      //


      var expectNoWarning = function (func) {
        if (typeof func !== 'function') {
          func = undefined;
        }

        _this.runExpectation(func, function (tracker) {
          if (tracker.isExpectingCalls()) {
            throw new Error('expectNoWarning was called after expectWarning was called!');
          }

          tracker.expectNoCalls();
        });
      }; // Expect a warning to happen within a function, or if no function is
      // passed, from the time of calling until the end of the test. Can be called
      // multiple times to assert warnings with different specific messages
      // happened.
      //
      // expectWarning(function() {
      //   Ember.warn("Times they are a-changin'");
      // }, /* optionalStringOrRegex */);
      //
      // expectWarning(/* optionalStringOrRegex */);
      // Ember.warn("Times definitely be changin'");
      //


      var expectWarning = function (func, message) {
        var actualFunc;

        if (typeof func !== 'function') {
          message = func;
          actualFunc = undefined;
        } else {
          actualFunc = func;
        }

        _this.runExpectation(actualFunc, function (tracker) {
          if (tracker.isExpectingNoCalls()) {
            throw new Error('expectWarning was called after expectNoWarning was called!');
          }

          tracker.expectCall(message);
        });
      };

      var ignoreWarning = function (func) {
        (0, _utils.callWithStub)(_this.env, 'warn', func);
      };

      window.expectNoWarning = expectNoWarning;
      window.expectWarning = expectWarning;
      window.ignoreWarning = ignoreWarning;
    };

    _proto.restore = function restore() {
      _DebugAssert.prototype.restore.call(this);

      window.expectWarning = null;
      window.expectNoWarning = null;
      window.ignoreWarning = null;
    };

    return WarningAssert;
  }(_debug.default);

  var _default = WarningAssert;
  _exports.default = _default;
});
enifed("internal-test-helpers/lib/equal-inner-html", ["exports"], function (_exports) {
  "use strict";

  _exports.default = equalInnerHTML;

  // detect side-effects of cloning svg elements in IE9-11
  var ieSVGInnerHTML = function () {
    if (!document.createElementNS) {
      return false;
    }

    var div = document.createElement('div');
    var node = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    div.appendChild(node);
    var clone = div.cloneNode(true);
    return clone.innerHTML === '<svg xmlns="http://www.w3.org/2000/svg" />';
  }();

  function normalizeInnerHTML(actualHTML) {
    if (ieSVGInnerHTML) {
      // Replace `<svg xmlns="http://www.w3.org/2000/svg" height="50%" />` with `<svg height="50%"></svg>`, etc.
      // drop namespace attribute
      // replace self-closing elements
      actualHTML = actualHTML.replace(/ xmlns="[^"]+"/, '').replace(/<([^ >]+) [^\/>]*\/>/gi, function (tag, tagName) {
        return tag.slice(0, tag.length - 3) + "></" + tagName + ">";
      });
    }

    return actualHTML;
  }

  function equalInnerHTML(assert, fragment, html) {
    var actualHTML = normalizeInnerHTML(fragment.innerHTML);
    assert.pushResult({
      result: actualHTML === html,
      actual: actualHTML,
      expected: html
    });
  }
});
enifed("internal-test-helpers/lib/equal-tokens", ["exports", "simple-html-tokenizer"], function (_exports, _simpleHtmlTokenizer) {
  "use strict";

  _exports.default = equalTokens;

  function generateTokens(containerOrHTML) {
    if (typeof containerOrHTML === 'string') {
      return {
        tokens: (0, _simpleHtmlTokenizer.tokenize)(containerOrHTML),
        html: containerOrHTML
      };
    } else {
      return {
        tokens: (0, _simpleHtmlTokenizer.tokenize)(containerOrHTML.innerHTML),
        html: containerOrHTML.innerHTML
      };
    }
  }

  function normalizeTokens(tokens) {
    tokens.forEach(function (token) {
      if (token.type === 'StartTag') {
        token.attributes = token.attributes.sort(function (a, b) {
          if (a[0] > b[0]) {
            return 1;
          }

          if (a[0] < b[0]) {
            return -1;
          }

          return 0;
        });
      }
    });
  }

  function equalTokens(actualContainer, expectedHTML) {
    var message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var actual = generateTokens(actualContainer);
    var expected = generateTokens(expectedHTML);
    normalizeTokens(actual.tokens);
    normalizeTokens(expected.tokens);
    var assert = QUnit.config.current.assert;
    var equiv = QUnit.equiv(actual.tokens, expected.tokens);

    if (equiv && expected.html !== actual.html) {
      assert.deepEqual(actual.tokens, expected.tokens, message);
    } else {
      assert.pushResult({
        result: QUnit.equiv(actual.tokens, expected.tokens),
        actual: actual.html,
        expected: expected.html,
        message: message
      });
    }
  }
});
enifed("internal-test-helpers/lib/factory", ["exports"], function (_exports) {
  "use strict";

  _exports.default = factory;

  function setProperties(object, properties) {
    for (var key in properties) {
      if (properties.hasOwnProperty(key)) {
        object[key] = properties[key];
      }
    }
  }

  var guids = 0;

  function factory() {
    function Klass(options) {
      setProperties(this, options);
      this._guid = guids++;
      this.isDestroyed = false;
    }

    Klass.prototype.constructor = Klass;

    Klass.prototype.destroy = function () {
      this.isDestroyed = true;
    };

    Klass.prototype.toString = function () {
      return '<Factory:' + this._guid + '>';
    };

    Klass.create = create;
    Klass.extend = extend;
    Klass.reopen = extend;
    Klass.reopenClass = reopenClass;
    return Klass;

    function create(options) {
      return new this.prototype.constructor(options);
    }

    function reopenClass(options) {
      setProperties(this, options);
    }

    function extend(options) {
      function Child(options) {
        Klass.call(this, options);
      }

      var Parent = this;
      Child.prototype = new Parent();
      Child.prototype.constructor = Child;
      setProperties(Child, Klass);
      setProperties(Child.prototype, options);
      Child.create = create;
      Child.extend = extend;
      Child.reopen = extend;
      Child.reopenClass = reopenClass;
      return Child;
    }
  }
});
enifed("internal-test-helpers/lib/get-all-property-names", ["exports"], function (_exports) {
  "use strict";

  _exports.default = getAllPropertyNames;

  function getAllPropertyNames(Klass) {
    var proto = Klass.prototype;
    var properties = new Set();

    while (proto !== Object.prototype) {
      var names = Object.getOwnPropertyNames(proto);
      names.forEach(function (name) {
        return properties.add(name);
      });
      proto = Object.getPrototypeOf(proto);
    }

    return properties;
  }
});
enifed("internal-test-helpers/lib/get-text-of", ["exports"], function (_exports) {
  "use strict";

  _exports.default = getTextOf;

  function getTextOf(elem) {
    return elem.textContent.trim();
  }
});
enifed("internal-test-helpers/lib/matchers", ["exports"], function (_exports) {
  "use strict";

  _exports.regex = regex;
  _exports.classes = classes;
  _exports.styles = styles;
  _exports.equalsElement = equalsElement;
  var HTMLElement = window.HTMLElement;
  var MATCHER_BRAND = '3d4ef194-13be-4ccf-8dc7-862eea02c93e';

  function isMatcher(obj) {
    return typeof obj === 'object' && obj !== null && MATCHER_BRAND in obj;
  }

  function equalsAttr(expected) {
    var _ref;

    return _ref = {}, _ref[MATCHER_BRAND] = true, _ref.match = function (actual) {
      return expected === actual;
    }, _ref.expected = function () {
      return expected;
    }, _ref.message = function () {
      return "should equal " + this.expected();
    }, _ref;
  }

  function regex(r) {
    var _ref2;

    return _ref2 = {}, _ref2[MATCHER_BRAND] = true, _ref2.match = function (v) {
      return r.test(v);
    }, _ref2.expected = function () {
      return r.toString();
    }, _ref2.message = function () {
      return "should match " + this.expected();
    }, _ref2;
  }

  function classes(expected) {
    var _ref3;

    return _ref3 = {}, _ref3[MATCHER_BRAND] = true, _ref3.match = function (actual) {
      actual = actual.trim();
      return actual && expected.split(/\s+/).sort().join(' ') === actual.trim().split(/\s+/).sort().join(' ');
    }, _ref3.expected = function () {
      return expected;
    }, _ref3.message = function () {
      return "should match " + this.expected();
    }, _ref3;
  }

  function styles(expected) {
    var _ref4;

    return _ref4 = {}, _ref4[MATCHER_BRAND] = true, _ref4.match = function (actual) {
      // coerce `null` or `undefined` to an empty string
      // needed for matching empty styles on IE9 - IE11
      actual = actual || '';
      actual = actual.trim();
      return expected.split(';').map(function (s) {
        return s.trim();
      }).filter(function (s) {
        return s;
      }).sort().join('; ') === actual.split(';').map(function (s) {
        return s.trim();
      }).filter(function (s) {
        return s;
      }).sort().join('; ');
    }, _ref4.expected = function () {
      return expected;
    }, _ref4.message = function () {
      return "should match " + this.expected();
    }, _ref4;
  }

  function equalsElement(assert, element, tagName, attributes, content) {
    assert.pushResult({
      result: element.tagName === tagName.toUpperCase(),
      actual: element.tagName.toLowerCase(),
      expected: tagName,
      message: "expect tagName to be " + tagName
    });
    var expectedAttrs = {};
    var expectedCount = 0;

    for (var name in attributes) {
      var expected = attributes[name];

      if (expected !== null) {
        expectedCount++;
      }

      var matcher = isMatcher(expected) ? expected : equalsAttr(expected);
      expectedAttrs[name] = matcher;
      assert.pushResult({
        result: expectedAttrs[name].match(element.getAttribute(name)),
        actual: element.getAttribute(name),
        expected: matcher.expected(),
        message: "Element's " + name + " attribute " + matcher.message()
      });
    }

    var actualAttributes = {};

    for (var i = 0, l = element.attributes.length; i < l; i++) {
      actualAttributes[element.attributes[i].name] = element.attributes[i].value;
    }

    if (!(element instanceof HTMLElement)) {
      assert.pushResult({
        result: element instanceof HTMLElement,
        message: 'Element must be an HTML Element, not an SVG Element'
      });
    } else {
      assert.pushResult({
        result: element.attributes.length === expectedCount || !attributes,
        actual: element.attributes.length,
        expected: expectedCount,
        message: "Expected " + expectedCount + " attributes; got " + element.outerHTML
      });

      if (content !== null) {
        assert.pushResult({
          result: element.innerHTML === content,
          actual: element.innerHTML,
          expected: content,
          message: "The element had '" + content + "' as its content"
        });
      }
    }
  }
});
enifed("internal-test-helpers/lib/module-for", ["exports", "@ember/canary-features", "internal-test-helpers/lib/apply-mixins", "internal-test-helpers/lib/get-all-property-names", "internal-test-helpers/lib/test-context", "rsvp"], function (_exports, _canaryFeatures, _applyMixins, _getAllPropertyNames, _testContext, _rsvp) {
  "use strict";

  _exports.default = moduleFor;
  _exports.setupTestClass = setupTestClass;

  function moduleFor(description, TestClass) {
    for (var _len = arguments.length, mixins = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      mixins[_key - 2] = arguments[_key];
    }

    QUnit.module(description, function (hooks) {
      setupTestClass.apply(void 0, [hooks, TestClass].concat(mixins));
    });
  }

  function setupTestClass(hooks, TestClass) {
    hooks.beforeEach(function (assert) {
      var instance = new TestClass(assert);
      this.instance = instance;
      (0, _testContext.setContext)(instance);

      if (instance.beforeEach) {
        return instance.beforeEach(assert);
      }
    });
    hooks.afterEach(function () {
      var promises = [];
      var instance = this.instance;
      this.instance = null;

      if (instance.teardown) {
        promises.push(instance.teardown());
      }

      if (instance.afterEach) {
        promises.push(instance.afterEach());
      } // this seems odd, but actually saves significant time
      // in the test suite
      //
      // returning a promise from a QUnit test always adds a 13ms
      // delay to the test, this filtering prevents returning a
      // promise when it is not needed


      var filteredPromises = promises.filter(Boolean);

      if (filteredPromises.length > 0) {
        return (0, _rsvp.all)(filteredPromises).finally(function () {
          return (0, _testContext.unsetContext)();
        });
      }

      (0, _testContext.unsetContext)();
    });

    for (var _len2 = arguments.length, mixins = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      mixins[_key2 - 2] = arguments[_key2];
    }

    if (mixins.length > 0) {
      _applyMixins.default.apply(void 0, [TestClass].concat(mixins));
    }

    var properties = (0, _getAllPropertyNames.default)(TestClass);
    properties.forEach(generateTest);

    function shouldTest(features) {
      return features.every(function (feature) {
        if (feature[0] === '!' && (0, _canaryFeatures.isEnabled)(feature.slice(1))) {
          return false;
        } else if (!(0, _canaryFeatures.isEnabled)(feature)) {
          return false;
        } else {
          return true;
        }
      });
    }

    function generateTest(name) {
      if (name.indexOf('@test ') === 0) {
        QUnit.test(name.slice(5), function (assert) {
          return this.instance[name](assert);
        });
      } else if (name.indexOf('@only ') === 0) {
        // eslint-disable-next-line qunit/no-only
        QUnit.only(name.slice(5), function (assert) {
          return this.instance[name](assert);
        });
      } else if (name.indexOf('@skip ') === 0) {
        QUnit.skip(name.slice(5), function (assert) {
          return this.instance[name](assert);
        });
      } else {
        var match = /^@feature\(([A-Z_a-z-!]+)\) /.exec(name);

        if (match) {
          var features = match[1].replace(/ /g, '').split(',');

          if (shouldTest(features)) {
            QUnit.test(name.slice(match[0].length), function (assert) {
              return this.instance[name](assert);
            });
          }
        }
      }
    }
  }
});
enifed("internal-test-helpers/lib/node-query", ["exports", "@ember/debug", "internal-test-helpers/lib/system/synthetic-events"], function (_exports, _debug, _syntheticEvents) {
  "use strict";

  _exports.default = void 0;

  /* global Node */
  var NodeQuery =
  /*#__PURE__*/
  function () {
    NodeQuery.query = function query(selector) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
      true && !(context && context instanceof Node) && (0, _debug.assert)("Invalid second parameter to NodeQuery.query", context && context instanceof Node);
      return new NodeQuery(toArray(context.querySelectorAll(selector)));
    };

    NodeQuery.element = function element(_element) {
      return new NodeQuery([_element]);
    };

    function NodeQuery(nodes) {
      true && !Array.isArray(nodes) && (0, _debug.assert)('NodeQuery must be initialized with a literal array', Array.isArray(nodes));
      this.nodes = nodes;

      for (var i = 0; i < nodes.length; i++) {
        this[i] = nodes[i];
      }

      this.length = nodes.length;
      Object.freeze(this);
    }

    var _proto = NodeQuery.prototype;

    _proto.find = function find(selector) {
      assertSingle(this);
      return this[0].querySelector(selector);
    };

    _proto.findAll = function findAll(selector) {
      var nodes = [];
      this.nodes.forEach(function (node) {
        nodes.push.apply(nodes, node.querySelectorAll(selector));
      });
      return new NodeQuery(nodes);
    };

    _proto.trigger = function trigger(eventName, options) {
      return this.nodes.map(function (node) {
        return (0, _syntheticEvents.fireEvent)(node, eventName, options);
      });
    };

    _proto.click = function click() {
      return this.trigger('click');
    };

    _proto.focus = function focus() {
      this.nodes.forEach(_syntheticEvents.focus);
    };

    _proto.text = function text() {
      return this.nodes.map(function (node) {
        return node.textContent;
      }).join('');
    };

    _proto.attr = function attr(name) {
      if (arguments.length !== 1) {
        throw new Error('not implemented');
      }

      assertSingle(this);
      return this.nodes[0].getAttribute(name);
    };

    _proto.prop = function prop(name, value) {
      if (arguments.length > 1) {
        return this.setProp(name, value);
      }

      assertSingle(this);
      return this.nodes[0][name];
    };

    _proto.setProp = function setProp(name, value) {
      this.nodes.forEach(function (node) {
        return node[name] = value;
      });
      return this;
    };

    _proto.val = function val(value) {
      if (arguments.length === 1) {
        return this.setProp('value', value);
      }

      return this.prop('value');
    };

    _proto.is = function is(selector) {
      return this.nodes.every(function (node) {
        return (0, _syntheticEvents.matches)(node, selector);
      });
    };

    _proto.hasClass = function hasClass(className) {
      return this.is("." + className);
    };

    return NodeQuery;
  }();

  _exports.default = NodeQuery;

  function assertSingle(nodeQuery) {
    if (nodeQuery.length !== 1) {
      throw new Error("attr(name) called on a NodeQuery with " + this.nodes.length + " elements. Expected one element.");
    }
  }

  function toArray(nodes) {
    var out = [];

    for (var i = 0; i < nodes.length; i++) {
      out.push(nodes[i]);
    }

    return out;
  }
});
enifed("internal-test-helpers/lib/registry-check", ["exports"], function (_exports) {
  "use strict";

  _exports.verifyRegistration = verifyRegistration;
  _exports.verifyInjection = verifyInjection;

  function verifyRegistration(assert, owner, fullName) {
    assert.ok(owner.resolveRegistration(fullName), "has registration: " + fullName);
  }

  function verifyInjection(assert, owner, fullName, property, injectionName) {
    var registry = owner.__registry__;
    var injections;

    if (fullName.indexOf(':') === -1) {
      injections = registry.getTypeInjections(fullName);
    } else {
      injections = registry.getInjections(registry.normalize(fullName));
    }

    var normalizedName = registry.normalize(injectionName);
    var hasInjection = false;
    var injection;

    for (var i = 0, l = injections.length; i < l; i++) {
      injection = injections[i];

      if (injection.property === property && injection.specifier === normalizedName) {
        hasInjection = true;
        break;
      }
    }

    assert.ok(hasInjection, "has injection: " + fullName + "." + property + " = " + injectionName);
  }
});
enifed("internal-test-helpers/lib/run", ["exports", "@ember/runloop", "rsvp"], function (_exports, _runloop, _rsvp) {
  "use strict";

  _exports.runAppend = runAppend;
  _exports.runDestroy = runDestroy;
  _exports.runTask = runTask;
  _exports.runTaskNext = runTaskNext;
  _exports.runLoopSettled = runLoopSettled;

  function runAppend(view) {
    (0, _runloop.run)(view, 'appendTo', document.getElementById('qunit-fixture'));
  }

  function runDestroy(toDestroy) {
    if (toDestroy) {
      (0, _runloop.run)(toDestroy, 'destroy');
    }
  }

  function runTask(callback) {
    return (0, _runloop.run)(callback);
  }

  function runTaskNext() {
    return new _rsvp.Promise(function (resolve) {
      return (0, _runloop.next)(resolve);
    });
  } // TODO: Find a better name 


  function runLoopSettled(event) {
    return new _rsvp.Promise(function (resolve) {
      // Every 5ms, poll for the async thing to have finished
      var watcher = setInterval(function () {
        // If there are scheduled timers or we are inside of a run loop, keep polling
        if ((0, _runloop.hasScheduledTimers)() || (0, _runloop.getCurrentRunLoop)()) {
          return;
        } // Stop polling


        clearInterval(watcher); // Synchronously resolve the promise

        resolve(event);
      }, 5);
    });
  }
});
enifed("internal-test-helpers/lib/strip", ["exports"], function (_exports) {
  "use strict";

  _exports.default = strip;

  function strip(_ref) {
    var strings = _ref.slice(0);

    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }

    var str = strings.map(function (string, index) {
      var interpolated = values[index];
      return string + (interpolated !== undefined ? interpolated : '');
    }).join('');
    return str.split('\n').map(function (s) {
      return s.trim();
    }).join('');
  }
});
enifed("internal-test-helpers/lib/system/synthetic-events", ["exports", "@ember/runloop", "@ember/polyfills"], function (_exports, _runloop, _polyfills) {
  "use strict";

  _exports.matches = matches;
  _exports.click = click;
  _exports.focus = focus;
  _exports.blur = blur;
  _exports.fireEvent = fireEvent;
  _exports.elMatches = void 0;

  /* globals Element */
  var DEFAULT_EVENT_OPTIONS = {
    canBubble: true,
    cancelable: true
  };
  var KEYBOARD_EVENT_TYPES = ['keydown', 'keypress', 'keyup'];
  var MOUSE_EVENT_TYPES = ['click', 'mousedown', 'mouseup', 'dblclick', 'mouseenter', 'mouseleave', 'mousemove', 'mouseout', 'mouseover'];
  var elMatches = typeof Element !== 'undefined' && (Element.prototype.matches || Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector);
  _exports.elMatches = elMatches;

  function matches(el, selector) {
    return elMatches.call(el, selector);
  }

  function isFocusable(el) {
    var focusableTags = ['INPUT', 'BUTTON', 'LINK', 'SELECT', 'A', 'TEXTAREA'];
    var tagName = el.tagName,
        type = el.type;

    if (type === 'hidden') {
      return false;
    }

    return focusableTags.indexOf(tagName) > -1 || el.contentEditable === 'true';
  }

  function click(el) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _runloop.run)(function () {
      return fireEvent(el, 'mousedown', options);
    });
    focus(el);
    (0, _runloop.run)(function () {
      return fireEvent(el, 'mouseup', options);
    });
    (0, _runloop.run)(function () {
      return fireEvent(el, 'click', options);
    });
  }

  function focus(el) {
    if (!el) {
      return;
    }

    if (isFocusable(el)) {
      (0, _runloop.run)(null, function () {
        var browserIsNotFocused = document.hasFocus && !document.hasFocus(); // Firefox does not trigger the `focusin` event if the window
        // does not have focus. If the document doesn't have focus just
        // use trigger('focusin') instead.

        if (browserIsNotFocused) {
          fireEvent(el, 'focusin');
        } // makes `document.activeElement` be `el`. If the browser is focused, it also fires a focus event


        el.focus(); // if the browser is not focused the previous `el.focus()` didn't fire an event, so we simulate it

        if (browserIsNotFocused) {
          fireEvent(el, 'focus');
        }
      });
    }
  }

  function blur(el) {
    if (isFocusable(el)) {
      (0, _runloop.run)(null, function () {
        var browserIsNotFocused = document.hasFocus && !document.hasFocus();
        fireEvent(el, 'focusout'); // makes `document.activeElement` be `body`.
        // If the browser is focused, it also fires a blur event

        el.blur(); // Chrome/Firefox does not trigger the `blur` event if the window
        // does not have focus. If the document does not have focus then
        // fire `blur` event via native event.

        if (browserIsNotFocused) {
          fireEvent(el, 'blur');
        }
      });
    }
  }

  function fireEvent(element, type) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (!element) {
      return;
    }

    var event;

    if (KEYBOARD_EVENT_TYPES.indexOf(type) > -1) {
      event = buildKeyboardEvent(type, options);
    } else if (MOUSE_EVENT_TYPES.indexOf(type) > -1) {
      var rect = element.getBoundingClientRect();
      var x = rect.left + 1;
      var y = rect.top + 1;
      var simulatedCoordinates = {
        screenX: x + 5,
        screenY: y + 95,
        clientX: x,
        clientY: y
      };
      event = buildMouseEvent(type, (0, _polyfills.assign)(simulatedCoordinates, options));
    } else {
      event = buildBasicEvent(type, options);
    }

    element.dispatchEvent(event);
    return event;
  }

  function buildBasicEvent(type) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var event = document.createEvent('Events');
    event.initEvent(type, true, true);
    (0, _polyfills.assign)(event, options);
    return event;
  }

  function buildMouseEvent(type) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var event;

    try {
      event = document.createEvent('MouseEvents');
      var eventOpts = (0, _polyfills.assign)({}, DEFAULT_EVENT_OPTIONS, options);
      event.initMouseEvent(type, eventOpts.canBubble, eventOpts.cancelable, window, eventOpts.detail, eventOpts.screenX, eventOpts.screenY, eventOpts.clientX, eventOpts.clientY, eventOpts.ctrlKey, eventOpts.altKey, eventOpts.shiftKey, eventOpts.metaKey, eventOpts.button, eventOpts.relatedTarget);
    } catch (e) {
      event = buildBasicEvent(type, options);
    }

    return event;
  }

  function buildKeyboardEvent(type) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var event;

    try {
      event = document.createEvent('KeyEvents');
      var eventOpts = (0, _polyfills.assign)({}, DEFAULT_EVENT_OPTIONS, options);
      event.initKeyEvent(type, eventOpts.canBubble, eventOpts.cancelable, window, eventOpts.ctrlKey, eventOpts.altKey, eventOpts.shiftKey, eventOpts.metaKey, eventOpts.keyCode, eventOpts.charCode);
    } catch (e) {
      event = buildBasicEvent(type, options);
    }

    return event;
  }
});
enifed("internal-test-helpers/lib/test-cases/abstract-application", ["exports", "ember-babel", "ember-template-compiler", "@ember/-internals/environment", "internal-test-helpers/lib/test-cases/abstract", "internal-test-helpers/lib/run"], function (_exports, _emberBabel, _emberTemplateCompiler, _environment, _abstract, _run) {
  "use strict";

  _exports.default = void 0;

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var AbstractApplicationTestCase =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(AbstractApplicationTestCase, _AbstractTestCase);

    function AbstractApplicationTestCase() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = AbstractApplicationTestCase.prototype;

    _proto._ensureInstance = function _ensureInstance(bootOptions) {
      var _this = this;

      if (this._applicationInstancePromise) {
        return this._applicationInstancePromise;
      }

      return this._applicationInstancePromise = (0, _run.runTask)(function () {
        return _this.application.boot();
      }).then(function (app) {
        _this.applicationInstance = app.buildInstance();
        return _this.applicationInstance.boot(bootOptions);
      });
    };

    _proto.visit =
    /*#__PURE__*/
    function () {
      var _visit = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(url, options) {
        var instance;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this._ensureInstance(options).then(function (instance) {
                return instance.visit(url);
              });

            case 2:
              instance = _context.sent;
              _context.next = 5;
              return (0, _run.runLoopSettled)();

            case 5:
              return _context.abrupt("return", instance);

            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function visit(_x, _x2) {
        return _visit.apply(this, arguments);
      }

      return visit;
    }();

    _proto.afterEach = function afterEach() {
      (0, _run.runDestroy)(this.applicationInstance);
      (0, _run.runDestroy)(this.application);

      _AbstractTestCase.prototype.teardown.call(this);
    };

    _proto.compile = function compile()
    /* string, options */
    {
      return _emberTemplateCompiler.compile.apply(void 0, arguments);
    };

    (0, _emberBabel.createClass)(AbstractApplicationTestCase, [{
      key: "element",
      get: function () {
        if (this._element) {
          return this._element;
        } else if (_environment.ENV._APPLICATION_TEMPLATE_WRAPPER) {
          return this._element = document.querySelector('#qunit-fixture > div.ember-view');
        } else {
          return this._element = document.querySelector('#qunit-fixture');
        }
      },
      set: function (element) {
        this._element = element;
      }
    }, {
      key: "applicationOptions",
      get: function () {
        return {
          rootElement: '#qunit-fixture'
        };
      }
    }, {
      key: "routerOptions",
      get: function () {
        return {
          location: 'none'
        };
      }
    }, {
      key: "router",
      get: function () {
        return this.application.resolveRegistration('router:main');
      }
    }]);
    return AbstractApplicationTestCase;
  }(_abstract.default);

  _exports.default = AbstractApplicationTestCase;
});
enifed("internal-test-helpers/lib/test-cases/abstract-rendering", ["exports", "ember-babel", "@ember/polyfills", "ember-template-compiler", "@ember/-internals/views", "@ember/-internals/glimmer", "internal-test-helpers/lib/test-resolver", "internal-test-helpers/lib/test-cases/abstract", "internal-test-helpers/lib/build-owner", "internal-test-helpers/lib/run"], function (_exports, _emberBabel, _polyfills, _emberTemplateCompiler, _views, _glimmer, _testResolver, _abstract, _buildOwner, _run) {
  "use strict";

  _exports.default = void 0;
  var TextNode = window.Text;

  var AbstractRenderingTestCase =
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(AbstractRenderingTestCase, _AbstractTestCase);

    function AbstractRenderingTestCase() {
      var _this;

      _this = _AbstractTestCase.apply(this, arguments) || this;

      var bootOptions = _this.getBootOptions();

      var owner = _this.owner = (0, _buildOwner.default)({
        ownerOptions: _this.getOwnerOptions(),
        resolver: _this.getResolver(),
        bootOptions: bootOptions
      });
      owner.register('-view-registry:main', Object.create(null), {
        instantiate: false
      });
      owner.register('event_dispatcher:main', _views.EventDispatcher); // TODO: why didn't buildOwner do this for us?

      owner.inject('view', '_viewRegistry', '-view-registry:main');
      owner.inject('renderer', '_viewRegistry', '-view-registry:main');
      _this.renderer = _this.owner.lookup('renderer:-dom');
      _this.element = document.querySelector('#qunit-fixture');
      _this.component = null;

      if (!bootOptions || bootOptions.isInteractive !== false) {
        owner.lookup('event_dispatcher:main').setup(_this.getCustomDispatcherEvents(), _this.element);
      }

      return _this;
    }

    var _proto = AbstractRenderingTestCase.prototype;

    _proto.compile = function compile() {
      return _emberTemplateCompiler.compile.apply(void 0, arguments);
    };

    _proto.getCustomDispatcherEvents = function getCustomDispatcherEvents() {
      return {};
    };

    _proto.getOwnerOptions = function getOwnerOptions() {};

    _proto.getBootOptions = function getBootOptions() {};

    _proto.getResolver = function getResolver() {
      return new _testResolver.ModuleBasedResolver();
    };

    _proto.add = function add(specifier, factory) {
      this.resolver.add(specifier, factory);
    };

    _proto.addTemplate = function addTemplate(templateName, templateString) {
      if (typeof templateName === 'string') {
        this.resolver.add("template:" + templateName, this.compile(templateString, {
          moduleName: templateName
        }));
      } else {
        this.resolver.add(templateName, this.compile(templateString, {
          moduleName: templateName.moduleName
        }));
      }
    };

    _proto.addComponent = function addComponent(name, _ref) {
      var _ref$ComponentClass = _ref.ComponentClass,
          ComponentClass = _ref$ComponentClass === void 0 ? null : _ref$ComponentClass,
          _ref$template = _ref.template,
          template = _ref$template === void 0 ? null : _ref$template;

      if (ComponentClass) {
        this.resolver.add("component:" + name, ComponentClass);
      }

      if (typeof template === 'string') {
        this.resolver.add("template:components/" + name, this.compile(template, {
          moduleName: "components/" + name
        }));
      }
    };

    _proto.afterEach = function afterEach() {
      try {
        if (this.component) {
          (0, _run.runDestroy)(this.component);
        }

        if (this.owner) {
          (0, _run.runDestroy)(this.owner);
        }
      } finally {
        (0, _glimmer._resetRenderers)();
      }
    };

    _proto.render = function render(templateStr) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var owner = this.owner;
      owner.register('template:-top-level', this.compile(templateStr, {
        moduleName: '-top-level'
      }));
      var attrs = (0, _polyfills.assign)({}, context, {
        tagName: '',
        layoutName: '-top-level'
      });
      owner.register('component:-top-level', _glimmer.Component.extend(attrs));
      this.component = owner.lookup('component:-top-level');
      (0, _run.runAppend)(this.component);
    };

    _proto.rerender = function rerender() {
      this.component.rerender();
    };

    _proto.registerHelper = function registerHelper(name, funcOrClassBody) {
      var type = typeof funcOrClassBody;

      if (type === 'function') {
        this.owner.register("helper:" + name, (0, _glimmer.helper)(funcOrClassBody));
      } else if (type === 'object' && type !== null) {
        this.owner.register("helper:" + name, _glimmer.Helper.extend(funcOrClassBody));
      } else {
        throw new Error("Cannot register " + funcOrClassBody + " as a helper");
      }
    };

    _proto.registerPartial = function registerPartial(name, template) {
      var owner = this.env.owner || this.owner;

      if (typeof template === 'string') {
        owner.register("template:" + name, this.compile(template, {
          moduleName: "my-app/templates/-" + name + ".hbs"
        }));
      }
    };

    _proto.registerComponent = function registerComponent(name, _ref2) {
      var _ref2$ComponentClass = _ref2.ComponentClass,
          ComponentClass = _ref2$ComponentClass === void 0 ? _glimmer.Component : _ref2$ComponentClass,
          _ref2$template = _ref2.template,
          template = _ref2$template === void 0 ? null : _ref2$template;
      var owner = this.owner;

      if (ComponentClass) {
        owner.register("component:" + name, ComponentClass);
      }

      if (typeof template === 'string') {
        owner.register("template:components/" + name, this.compile(template, {
          moduleName: "my-app/templates/components/" + name + ".hbs"
        }));
      }
    };

    _proto.registerModifier = function registerModifier(name, ModifierClass) {
      var owner = this.owner;
      owner.register("modifier:" + name, ModifierClass);
    };

    _proto.registerComponentManager = function registerComponentManager(name, manager) {
      var owner = this.env.owner || this.owner;
      owner.register("component-manager:" + name, manager);
    };

    _proto.registerTemplate = function registerTemplate(name, template) {
      var owner = this.owner;

      if (typeof template === 'string') {
        owner.register("template:" + name, this.compile(template, {
          moduleName: "my-app/templates/" + name + ".hbs"
        }));
      } else {
        throw new Error("Registered template \"" + name + "\" must be a string");
      }
    };

    _proto.registerService = function registerService(name, klass) {
      this.owner.register("service:" + name, klass);
    };

    _proto.assertTextNode = function assertTextNode(node, text) {
      if (!(node instanceof TextNode)) {
        throw new Error("Expecting a text node, but got " + node);
      }

      this.assert.strictEqual(node.textContent, text, 'node.textContent');
    };

    (0, _emberBabel.createClass)(AbstractRenderingTestCase, [{
      key: "resolver",
      get: function () {
        return this.owner.__registry__.fallback.resolver;
      }
    }, {
      key: "context",
      get: function () {
        return this.component;
      }
    }]);
    return AbstractRenderingTestCase;
  }(_abstract.default);

  _exports.default = AbstractRenderingTestCase;
});
enifed("internal-test-helpers/lib/test-cases/abstract", ["exports", "ember-babel", "@ember/polyfills", "internal-test-helpers/lib/node-query", "internal-test-helpers/lib/equal-inner-html", "internal-test-helpers/lib/equal-tokens", "internal-test-helpers/lib/element-helpers", "internal-test-helpers/lib/matchers", "internal-test-helpers/lib/run"], function (_exports, _emberBabel, _polyfills, _nodeQuery, _equalInnerHtml, _equalTokens, _elementHelpers, _matchers, _run) {
  "use strict";

  _exports.default = void 0;

  /* global Element */
  var TextNode = window.Text;
  var HTMLElement = window.HTMLElement;
  var Comment = window.Comment;

  function isMarker(node) {
    if (node instanceof Comment && node.textContent === '') {
      return true;
    }

    if (node instanceof TextNode && node.textContent === '') {
      return true;
    }

    return false;
  }

  var AbstractTestCase =
  /*#__PURE__*/
  function () {
    function AbstractTestCase(assert) {
      this.element = null;
      this.snapshot = null;
      this.assert = assert;
      var fixture = this.fixture;

      if (fixture) {
        this.setupFixture(fixture);
      }
    }

    var _proto = AbstractTestCase.prototype;

    _proto.teardown = function teardown() {};

    _proto.afterEach = function afterEach() {};

    _proto.setupFixture = function setupFixture(innerHTML) {
      var fixture = document.getElementById('qunit-fixture');
      fixture.innerHTML = innerHTML;
    } // The following methods require `this.element` to work
    ;

    _proto.nthChild = function nthChild(n) {
      var i = 0;
      var node = (0, _elementHelpers.getElement)().firstChild;

      while (node) {
        if (!isMarker(node)) {
          i++;
        }

        if (i > n) {
          break;
        } else {
          node = node.nextSibling;
        }
      }

      return node;
    };

    _proto.$ = function $(sel) {
      if (sel instanceof Element) {
        return _nodeQuery.default.element(sel);
      } else if (typeof sel === 'string') {
        return _nodeQuery.default.query(sel, (0, _elementHelpers.getElement)());
      } else if (sel !== undefined) {
        throw new Error("Invalid this.$(" + sel + ")");
      } else {
        return _nodeQuery.default.element((0, _elementHelpers.getElement)());
      }
    };

    _proto.wrap = function wrap(element) {
      return _nodeQuery.default.element(element);
    };

    _proto.click = function click(selector) {
      var element;

      if (typeof selector === 'string') {
        element = (0, _elementHelpers.getElement)().querySelector(selector);
      } else {
        element = selector;
      }

      var event = element.click();
      return (0, _run.runLoopSettled)(event);
    };

    _proto.textValue = function textValue() {
      return (0, _elementHelpers.getElement)().textContent;
    };

    _proto.takeSnapshot = function takeSnapshot() {
      var snapshot = this.snapshot = [];
      var node = (0, _elementHelpers.getElement)().firstChild;

      while (node) {
        if (!isMarker(node)) {
          snapshot.push(node);
        }

        node = node.nextSibling;
      }

      return snapshot;
    };

    _proto.assertText = function assertText(text) {
      this.assert.strictEqual(this.textValue(), text, "#qunit-fixture content should be: `" + text + "`");
    };

    _proto.assertInnerHTML = function assertInnerHTML(html) {
      (0, _equalInnerHtml.default)(this.assert, (0, _elementHelpers.getElement)(), html);
    };

    _proto.assertHTML = function assertHTML(html) {
      (0, _equalTokens.default)((0, _elementHelpers.getElement)(), html, "#qunit-fixture content should be: `" + html + "`");
    };

    _proto.assertElement = function assertElement(node, _ref) {
      var _ref$ElementType = _ref.ElementType,
          ElementType = _ref$ElementType === void 0 ? HTMLElement : _ref$ElementType,
          tagName = _ref.tagName,
          _ref$attrs = _ref.attrs,
          attrs = _ref$attrs === void 0 ? null : _ref$attrs,
          _ref$content = _ref.content,
          content = _ref$content === void 0 ? null : _ref$content;

      if (!(node instanceof ElementType)) {
        throw new Error("Expecting a " + ElementType.name + ", but got " + node);
      }

      (0, _matchers.equalsElement)(this.assert, node, tagName, attrs, content);
    };

    _proto.assertComponentElement = function assertComponentElement(node, _ref2) {
      var _ref2$ElementType = _ref2.ElementType,
          ElementType = _ref2$ElementType === void 0 ? HTMLElement : _ref2$ElementType,
          _ref2$tagName = _ref2.tagName,
          tagName = _ref2$tagName === void 0 ? 'div' : _ref2$tagName,
          _ref2$attrs = _ref2.attrs,
          attrs = _ref2$attrs === void 0 ? null : _ref2$attrs,
          _ref2$content = _ref2.content,
          content = _ref2$content === void 0 ? null : _ref2$content;
      attrs = (0, _polyfills.assign)({}, {
        id: (0, _matchers.regex)(/^ember\d*$/),
        class: (0, _matchers.classes)('ember-view')
      }, attrs || {});
      this.assertElement(node, {
        ElementType: ElementType,
        tagName: tagName,
        attrs: attrs,
        content: content
      });
    };

    _proto.assertSameNode = function assertSameNode(actual, expected) {
      this.assert.strictEqual(actual, expected, 'DOM node stability');
    };

    _proto.assertInvariants = function assertInvariants(oldSnapshot, newSnapshot) {
      oldSnapshot = oldSnapshot || this.snapshot;
      newSnapshot = newSnapshot || this.takeSnapshot();
      this.assert.strictEqual(newSnapshot.length, oldSnapshot.length, 'Same number of nodes');

      for (var i = 0; i < oldSnapshot.length; i++) {
        this.assertSameNode(newSnapshot[i], oldSnapshot[i]);
      }
    };

    _proto.assertPartialInvariants = function assertPartialInvariants(start, end) {
      this.assertInvariants(this.snapshot, this.takeSnapshot().slice(start, end));
    };

    _proto.assertStableRerender = function assertStableRerender() {
      var _this = this;

      this.takeSnapshot();
      (0, _run.runTask)(function () {
        return _this.rerender();
      });
      this.assertInvariants();
    };

    (0, _emberBabel.createClass)(AbstractTestCase, [{
      key: "firstChild",
      get: function () {
        return this.nthChild(0);
      }
    }, {
      key: "nodesCount",
      get: function () {
        var count = 0;
        var node = (0, _elementHelpers.getElement)().firstChild;

        while (node) {
          if (!isMarker(node)) {
            count++;
          }

          node = node.nextSibling;
        }

        return count;
      }
    }]);
    return AbstractTestCase;
  }();

  _exports.default = AbstractTestCase;
});
enifed("internal-test-helpers/lib/test-cases/application", ["exports", "ember-babel", "internal-test-helpers/lib/test-cases/test-resolver-application", "@ember/application", "@ember/-internals/routing", "@ember/polyfills", "internal-test-helpers/lib/run"], function (_exports, _emberBabel, _testResolverApplication, _application, _routing, _polyfills, _run) {
  "use strict";

  _exports.default = void 0;

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var ApplicationTestCase =
  /*#__PURE__*/
  function (_TestResolverApplicat) {
    (0, _emberBabel.inheritsLoose)(ApplicationTestCase, _TestResolverApplicat);

    function ApplicationTestCase() {
      var _this;

      _this = _TestResolverApplicat.apply(this, arguments) || this;

      var _assertThisInitialize = (0, _emberBabel.assertThisInitialized)(_this),
          applicationOptions = _assertThisInitialize.applicationOptions;

      _this.application = (0, _run.runTask)(_this.createApplication.bind((0, _emberBabel.assertThisInitialized)(_this), applicationOptions));
      _this.resolver = _this.application.__registry__.resolver;

      if (_this.resolver) {
        _this.resolver.add('router:main', _routing.Router.extend(_this.routerOptions));
      }

      return _this;
    }

    var _proto = ApplicationTestCase.prototype;

    _proto.createApplication = function createApplication() {
      var myOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var MyApplication = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _application.default;
      return MyApplication.create(myOptions);
    };

    _proto.transitionTo =
    /*#__PURE__*/
    function () {
      var _transitionTo = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var _this$appRouter,
            _args = arguments;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return (_this$appRouter = this.appRouter).transitionTo.apply(_this$appRouter, _args);

            case 2:
              _context.next = 4;
              return (0, _run.runLoopSettled)();

            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));

      function transitionTo() {
        return _transitionTo.apply(this, arguments);
      }

      return transitionTo;
    }();

    (0, _emberBabel.createClass)(ApplicationTestCase, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_TestResolverApplicat.prototype.applicationOptions, {
          autoboot: false
        });
      }
    }, {
      key: "appRouter",
      get: function () {
        return this.applicationInstance.lookup('router:main');
      }
    }]);
    return ApplicationTestCase;
  }(_testResolverApplication.default);

  _exports.default = ApplicationTestCase;
});
enifed("internal-test-helpers/lib/test-cases/autoboot-application", ["exports", "ember-babel", "internal-test-helpers/lib/test-cases/test-resolver-application", "@ember/application", "@ember/polyfills", "@ember/-internals/routing"], function (_exports, _emberBabel, _testResolverApplication, _application, _polyfills, _routing) {
  "use strict";

  _exports.default = void 0;

  var AutobootApplicationTestCase =
  /*#__PURE__*/
  function (_TestResolverApplicat) {
    (0, _emberBabel.inheritsLoose)(AutobootApplicationTestCase, _TestResolverApplicat);

    function AutobootApplicationTestCase() {
      return _TestResolverApplicat.apply(this, arguments) || this;
    }

    var _proto = AutobootApplicationTestCase.prototype;

    _proto.createApplication = function createApplication(options) {
      var MyApplication = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _application.default;
      var myOptions = (0, _polyfills.assign)(this.applicationOptions, options);
      var application = this.application = MyApplication.create(myOptions);
      this.resolver = application.__registry__.resolver;

      if (this.resolver) {
        this.resolver.add('router:main', _routing.Router.extend(this.routerOptions));
      }

      return application;
    };

    _proto.visit = function visit(url) {
      var _this = this;

      return this.application.boot().then(function () {
        return _this.applicationInstance.visit(url);
      });
    };

    (0, _emberBabel.createClass)(AutobootApplicationTestCase, [{
      key: "applicationInstance",
      get: function () {
        var application = this.application;

        if (!application) {
          return undefined;
        }

        return application.__deprecatedInstance__;
      }
    }]);
    return AutobootApplicationTestCase;
  }(_testResolverApplication.default);

  _exports.default = AutobootApplicationTestCase;
});
enifed("internal-test-helpers/lib/test-cases/default-resolver-application", ["exports", "ember-babel", "internal-test-helpers/lib/test-cases/abstract-application", "@ember/application/globals-resolver", "@ember/application", "@ember/-internals/glimmer", "@ember/polyfills", "@ember/-internals/routing", "internal-test-helpers/lib/run"], function (_exports, _emberBabel, _abstractApplication, _globalsResolver, _application, _glimmer, _polyfills, _routing, _run) {
  "use strict";

  _exports.default = void 0;

  var DefaultResolverApplicationTestCase =
  /*#__PURE__*/
  function (_AbstractApplicationT) {
    (0, _emberBabel.inheritsLoose)(DefaultResolverApplicationTestCase, _AbstractApplicationT);

    function DefaultResolverApplicationTestCase() {
      return _AbstractApplicationT.apply(this, arguments) || this;
    }

    var _proto = DefaultResolverApplicationTestCase.prototype;

    _proto.createApplication = function createApplication() {
      var application = this.application = _application.default.create(this.applicationOptions);

      application.Router = _routing.Router.extend(this.routerOptions);
      return application;
    };

    _proto.afterEach = function afterEach() {
      (0, _glimmer.setTemplates)({});
      return _AbstractApplicationT.prototype.afterEach.call(this);
    };

    _proto.transitionTo = function transitionTo() {
      var _this = this,
          _arguments = arguments;

      return (0, _run.runTask)(function () {
        var _this$appRouter;

        return (_this$appRouter = _this.appRouter).transitionTo.apply(_this$appRouter, _arguments);
      });
    };

    _proto.addTemplate = function addTemplate(name, templateString) {
      var compiled = this.compile(templateString);
      (0, _glimmer.setTemplate)(name, compiled);
      return compiled;
    };

    (0, _emberBabel.createClass)(DefaultResolverApplicationTestCase, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_AbstractApplicationT.prototype.applicationOptions, {
          name: 'TestApp',
          autoboot: false,
          Resolver: _globalsResolver.default
        });
      }
    }, {
      key: "appRouter",
      get: function () {
        return this.applicationInstance.lookup('router:main');
      }
    }]);
    return DefaultResolverApplicationTestCase;
  }(_abstractApplication.default);

  _exports.default = DefaultResolverApplicationTestCase;
});
enifed("internal-test-helpers/lib/test-cases/query-param", ["exports", "ember-babel", "@ember/controller", "@ember/-internals/routing", "internal-test-helpers/lib/test-cases/application", "internal-test-helpers/lib/run"], function (_exports, _emberBabel, _controller, _routing, _application, _run) {
  "use strict";

  _exports.default = void 0;

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  var QueryParamTestCase =
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(QueryParamTestCase, _ApplicationTestCase);

    function QueryParamTestCase() {
      var _this;

      _this = _ApplicationTestCase.apply(this, arguments) || this;
      var testCase = (0, _emberBabel.assertThisInitialized)(_this);
      testCase.expectedPushURL = null;
      testCase.expectedReplaceURL = null;

      _this.add('location:test', _routing.NoneLocation.extend({
        setURL: function (path) {
          if (testCase.expectedReplaceURL) {
            testCase.assert.ok(false, 'pushState occurred but a replaceState was expected');
          }

          if (testCase.expectedPushURL) {
            testCase.assert.equal(path, testCase.expectedPushURL, 'an expected pushState occurred');
            testCase.expectedPushURL = null;
          }

          this.set('path', path);
        },
        replaceURL: function (path) {
          if (testCase.expectedPushURL) {
            testCase.assert.ok(false, 'replaceState occurred but a pushState was expected');
          }

          if (testCase.expectedReplaceURL) {
            testCase.assert.equal(path, testCase.expectedReplaceURL, 'an expected replaceState occurred');
            testCase.expectedReplaceURL = null;
          }

          this.set('path', path);
        }
      }));

      return _this;
    }

    var _proto = QueryParamTestCase.prototype;

    _proto.visitAndAssert = function visitAndAssert(path) {
      var _this2 = this;

      return this.visit.apply(this, arguments).then(function () {
        _this2.assertCurrentPath(path);
      });
    };

    _proto.getController = function getController(name) {
      return this.applicationInstance.lookup("controller:" + name);
    };

    _proto.getRoute = function getRoute(name) {
      return this.applicationInstance.lookup("route:" + name);
    };

    _proto.setAndFlush =
    /*#__PURE__*/
    function () {
      var _setAndFlush = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(obj, prop, value) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (typeof prop === 'object') {
                obj.setProperties(prop);
              } else {
                obj.set(prop, value);
              }

              _context.next = 3;
              return (0, _run.runLoopSettled)();

            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));

      function setAndFlush(_x, _x2, _x3) {
        return _setAndFlush.apply(this, arguments);
      }

      return setAndFlush;
    }();

    _proto.assertCurrentPath = function assertCurrentPath(path) {
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "current path equals '" + path + "'";
      this.assert.equal(this.appRouter.get('location.path'), path, message);
    }
    /**
      Sets up a Controller for a given route with a single query param and default
      value. Can optionally extend the controller with an object.
       @public
      @method setSingleQPController
    */
    ;

    _proto.setSingleQPController = function setSingleQPController(routeName) {
      var _Controller$extend;

      var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'foo';
      var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'bar';
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      this.add("controller:" + routeName, _controller.default.extend((_Controller$extend = {
        queryParams: [param]
      }, _Controller$extend[param] = defaultValue, _Controller$extend), options));
    }
    /**
      Sets up a Controller for a given route with a custom property/url key mapping.
       @public
      @method setMappedQPController
    */
    ;

    _proto.setMappedQPController = function setMappedQPController(routeName) {
      var _queryParams, _Controller$extend2;

      var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'page';
      var urlKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'parentPage';
      var defaultValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      this.add("controller:" + routeName, _controller.default.extend((_Controller$extend2 = {
        queryParams: (_queryParams = {}, _queryParams[prop] = urlKey, _queryParams)
      }, _Controller$extend2[prop] = defaultValue, _Controller$extend2), options));
    };

    (0, _emberBabel.createClass)(QueryParamTestCase, [{
      key: "routerOptions",
      get: function () {
        return {
          location: 'test'
        };
      }
    }]);
    return QueryParamTestCase;
  }(_application.default);

  _exports.default = QueryParamTestCase;
});
enifed("internal-test-helpers/lib/test-cases/rendering", ["exports", "ember-babel", "internal-test-helpers/lib/test-cases/abstract-rendering", "@ember/-internals/container"], function (_exports, _emberBabel, _abstractRendering, _container) {
  "use strict";

  _exports.default = void 0;

  function _templateObject() {
    const data = _taggedTemplateLiteralLoose(["template-compiler:main"]);

    _templateObject = function () {
      return data;
    };

    return data;
  }

  function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

  var RenderingTestCase =
  /*#__PURE__*/
  function (_AbstractRenderingTes) {
    (0, _emberBabel.inheritsLoose)(RenderingTestCase, _AbstractRenderingTes);

    function RenderingTestCase() {
      var _this;

      _this = _AbstractRenderingTes.apply(this, arguments) || this;

      var _assertThisInitialize = (0, _emberBabel.assertThisInitialized)(_this),
          owner = _assertThisInitialize.owner;

      _this.env = owner.lookup('service:-glimmer-environment');
      _this.templateOptions = owner.lookup((0, _container.privatize)(_templateObject()));
      _this.compileTimeLookup = _this.templateOptions.resolver;
      _this.runtimeResolver = _this.compileTimeLookup.resolver;
      return _this;
    }

    return RenderingTestCase;
  }(_abstractRendering.default);

  _exports.default = RenderingTestCase;
});
enifed("internal-test-helpers/lib/test-cases/router", ["exports", "ember-babel", "internal-test-helpers/lib/test-cases/application"], function (_exports, _emberBabel, _application) {
  "use strict";

  _exports.default = void 0;

  var RouterTestCase =
  /*#__PURE__*/
  function (_ApplicationTestCase) {
    (0, _emberBabel.inheritsLoose)(RouterTestCase, _ApplicationTestCase);

    function RouterTestCase() {
      var _this;

      _this = _ApplicationTestCase.apply(this, arguments) || this;

      _this.router.map(function () {
        this.route('parent', {
          path: '/'
        }, function () {
          this.route('child');
          this.route('sister');
          this.route('brother');
        });
        this.route('dynamic', {
          path: '/dynamic/:dynamic_id'
        });
        this.route('dynamicWithChild', {
          path: '/dynamic-with-child/:dynamic_id'
        }, function () {
          this.route('child', {
            path: '/:child_id'
          });
        });
      });

      return _this;
    }

    var _proto = RouterTestCase.prototype;

    _proto.buildQueryParams = function buildQueryParams(queryParams) {
      return {
        queryParams: queryParams
      };
    };

    (0, _emberBabel.createClass)(RouterTestCase, [{
      key: "routerService",
      get: function () {
        return this.applicationInstance.lookup('service:router');
      }
    }]);
    return RouterTestCase;
  }(_application.default);

  _exports.default = RouterTestCase;
});
enifed("internal-test-helpers/lib/test-cases/test-resolver-application", ["exports", "ember-babel", "internal-test-helpers/lib/test-cases/abstract-application", "internal-test-helpers/lib/test-resolver", "@ember/-internals/glimmer", "@ember/polyfills"], function (_exports, _emberBabel, _abstractApplication, _testResolver, _glimmer, _polyfills) {
  "use strict";

  _exports.default = void 0;

  var TestResolverApplicationTestCase =
  /*#__PURE__*/
  function (_AbstractApplicationT) {
    (0, _emberBabel.inheritsLoose)(TestResolverApplicationTestCase, _AbstractApplicationT);

    function TestResolverApplicationTestCase() {
      return _AbstractApplicationT.apply(this, arguments) || this;
    }

    var _proto = TestResolverApplicationTestCase.prototype;

    _proto.add = function add(specifier, factory) {
      this.resolver.add(specifier, factory);
    };

    _proto.addTemplate = function addTemplate(templateName, templateString) {
      this.resolver.add("template:" + templateName, this.compile(templateString, {
        moduleName: "my-app/templates/" + templateName + ".hbs"
      }));
    };

    _proto.addComponent = function addComponent(name, _ref) {
      var _ref$ComponentClass = _ref.ComponentClass,
          ComponentClass = _ref$ComponentClass === void 0 ? _glimmer.Component : _ref$ComponentClass,
          _ref$template = _ref.template,
          template = _ref$template === void 0 ? null : _ref$template;

      if (ComponentClass) {
        this.resolver.add("component:" + name, ComponentClass);
      }

      if (typeof template === 'string') {
        this.resolver.add("template:components/" + name, this.compile(template, {
          moduleName: "my-app/templates/components/" + name + ".hbs"
        }));
      }
    };

    (0, _emberBabel.createClass)(TestResolverApplicationTestCase, [{
      key: "applicationOptions",
      get: function () {
        return (0, _polyfills.assign)(_AbstractApplicationT.prototype.applicationOptions, {
          Resolver: _testResolver.ModuleBasedResolver
        });
      }
    }]);
    return TestResolverApplicationTestCase;
  }(_abstractApplication.default);

  _exports.default = TestResolverApplicationTestCase;
});
enifed("internal-test-helpers/lib/test-context", ["exports"], function (_exports) {
  "use strict";

  _exports.setContext = setContext;
  _exports.getContext = getContext;
  _exports.unsetContext = unsetContext;

  var __test_context__;
  /**
   * Stores the provided context as the "global testing context".
   *
   * @param {Object} context the context to use
   */


  function setContext(context) {
    __test_context__ = context;
  }
  /**
   * Retrive the "global testing context" as stored by `setContext`.
   *
   * @returns {Object} the previously stored testing context
   */


  function getContext() {
    return __test_context__;
  }
  /**
   * Clear the "global testing context".
   */


  function unsetContext() {
    __test_context__ = undefined;
  }
});
enifed("internal-test-helpers/lib/test-resolver", ["exports", "ember-babel", "ember-template-compiler"], function (_exports, _emberBabel, _emberTemplateCompiler) {
  "use strict";

  _exports.ModuleBasedResolver = _exports.default = void 0;
  var DELIMITER = '%';

  function serializeKey(specifier, source, namespace) {
    var _specifier$split = specifier.split(':'),
        type = _specifier$split[0],
        name = _specifier$split[1];

    return type + "://" + [name, namespace ? '[source invalid due to namespace]' : source, namespace].join(DELIMITER);
  }

  var Resolver =
  /*#__PURE__*/
  function () {
    function Resolver() {
      this._registered = {};
    }

    var _proto = Resolver.prototype;

    _proto.resolve = function resolve(specifier) {
      return this._registered[specifier] || this._registered[serializeKey(specifier)];
    };

    _proto.expandLocalLookup = function expandLocalLookup(specifier, source, namespace) {
      if (specifier.indexOf('://') !== -1) {
        return specifier; // an already expanded specifier
      }

      if (source || namespace) {
        var key = serializeKey(specifier, source, namespace);

        if (this._registered[key]) {
          return key; // like local lookup
        }

        key = serializeKey(specifier);

        if (this._registered[key]) {
          return specifier; // top level resolution despite source/namespace
        }
      }

      return specifier; // didn't know how to expand it
    };

    _proto.add = function add(lookup, factory) {
      var key;

      switch (typeof lookup) {
        case 'string':
          if (lookup.indexOf(':') === -1) {
            throw new Error('Specifiers added to the resolver must be in the format of type:name');
          }

          key = serializeKey(lookup);
          break;

        case 'object':
          key = serializeKey(lookup.specifier, lookup.source, lookup.namespace);
          break;

        default:
          throw new Error('Specifier string has an unknown type');
      }

      return this._registered[key] = factory;
    };

    _proto.addTemplate = function addTemplate(templateName, template) {
      var templateType = typeof template;

      if (templateType !== 'string') {
        throw new Error("You called addTemplate for \"" + templateName + "\" with a template argument of type of '" + templateType + "'. addTemplate expects an argument of an uncompiled template as a string.");
      }

      return this._registered[serializeKey("template:" + templateName)] = (0, _emberTemplateCompiler.compile)(template, {
        moduleName: "my-app/templates/" + templateName + ".hbs"
      });
    };

    Resolver.create = function create() {
      return new this();
    };

    return Resolver;
  }();

  var _default = Resolver;
  /*
   * A resolver with moduleBasedResolver = true handles error and loading
   * substates differently than a standard resolver.
   */

  _exports.default = _default;

  var ModuleBasedResolver =
  /*#__PURE__*/
  function (_Resolver) {
    (0, _emberBabel.inheritsLoose)(ModuleBasedResolver, _Resolver);

    function ModuleBasedResolver() {
      return _Resolver.apply(this, arguments) || this;
    }

    (0, _emberBabel.createClass)(ModuleBasedResolver, [{
      key: "moduleBasedResolver",
      get: function () {
        return true;
      }
    }]);
    return ModuleBasedResolver;
  }(Resolver);

  _exports.ModuleBasedResolver = ModuleBasedResolver;
});
enifed("internal-test-helpers/tests/index-test", ["ember-babel", "internal-test-helpers"], function (_emberBabel, _internalTestHelpers) {
  "use strict";

  (0, _internalTestHelpers.moduleFor)('internal-test-helpers',
  /*#__PURE__*/
  function (_AbstractTestCase) {
    (0, _emberBabel.inheritsLoose)(_class, _AbstractTestCase);

    function _class() {
      return _AbstractTestCase.apply(this, arguments) || this;
    }

    var _proto = _class.prototype;

    _proto['@test module present'] = function testModulePresent(assert) {
      assert.ok(true, 'each package needs at least one test to be able to run through `npm test`');
    };

    return _class;
  }(_internalTestHelpers.AbstractTestCase));
});
/*global enifed, module */
enifed('node-module', ['exports'], function(_exports) {
  var IS_NODE = typeof module === 'object' && typeof module.require === 'function';
  if (IS_NODE) {
    _exports.require = module.require;
    _exports.module = module;
    _exports.IS_NODE = IS_NODE;
  } else {
    _exports.require = null;
    _exports.module = null;
    _exports.IS_NODE = IS_NODE;
  }
});



}());
//# sourceMappingURL=ember-tests.map
